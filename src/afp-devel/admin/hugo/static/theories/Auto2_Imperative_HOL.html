<div id="Mapping_Str">
<div class="head"><h1>Theory Mapping_Str</h1>
<span class="command">theory</span> <span class="name">Mapping_Str</span><br/>
<span class="keyword">imports</span> <a href="../Auto2_HOL/Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Mapping_Str.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Mapping_Str</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auto2_HOL.Auto2_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Basic definitions of a mapping. Here, we enclose the mapping inside
  a structure, to make evaluation a first-order concept.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>map</span><span> </span><span class="delimiter">=</span><span> </span><span>Map</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>meval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map ⇒ 'a ⇒ 'b option"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_⟨_⟩"</span></span></span><span> </span><span class="delimiter">[</span><span>90</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Map f) ⟨h⟩ = f h"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm meval.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meval_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. M⟨x⟩ = N⟨x⟩ ⟹ M = N"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>N</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond @{thm meval_ext} [with_filt (order_filter "M" "N")]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"empty_map = Map (λx. None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm empty_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map ⇒ 'a ⇒ 'b ⇒ ('a ,'b) map"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">" _ { _ → _ }"</span></span></span><span> </span><span class="delimiter">[</span><span>89</span><span class="delimiter">,</span><span>90</span><span class="delimiter">,</span><span>90</span><span class="delimiter">]</span><span> </span><span>90</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"M {k → v} = Map (λx. if x = k then Some v else M⟨x⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm update_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>delete_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a, 'b) map ⇒ ('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_map k M = Map (λx. if x = k then None else M⟨x⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm delete_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Map from an AList›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>map_of_alist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) list ⇒ ('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_of_alist [] = empty_map"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of_alist (x # xs) = (map_of_alist xs) {fst x → snd x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms map_of_alist.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_key_alist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) list ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_key_alist xs a ⟷ (∃p∈set xs. fst p = a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_nil</span><span> </span><span class="delimiter">[</span><span>rewrite_back</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_key_alist ys x ⟷ (map_of_alist ys)⟨x⟩ ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm map_of_alist_nil} [with_term "(map_of_alist ?ys)⟨?x⟩"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_some</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(map_of_alist xs)⟨k⟩ = Some v ⟹ (k, v) ∈ set xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_nil'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ set (map fst ys) ⟷ (map_of_alist ys)⟨x⟩ ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm map_of_alist_nil'} [with_term "(map_of_alist ?ys)⟨?x⟩"]›</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping defined by a set of key-value pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unique_keys_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S = (∀i x y. (i, x) ∈ S ⟶ (i, y) ∈ S ⟶ x = y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_keys_setD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S ⟹ (i, x) ∈ S ⟹ (i, y) ∈ S ⟹ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm unique_keys_set_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_of_aset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) set ⇒ ('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_of_aset S = Map (λa. if ∃b. (a, b) ∈ S then Some (THE b. (a, b) ∈ S) else None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm map_of_aset_def}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("map_of_aset S", "unique_keys_set S")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_asetI1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S ⟹ (a, b) ∈ S ⟹ (map_of_aset S)⟨a⟩ = Some b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃b. (a, b) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!b. (a, b) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_asetI2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀b. (a, b) ∉ S ⟹ (map_of_aset S)⟨a⟩ = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_asetD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(map_of_aset S)⟨a⟩ = None ⟹ ∀b. (a, b) ∉ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_asetD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S ⟹ (map_of_aset S)⟨a⟩ = Some b ⟹ (a, b) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm map_of_aset_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_aset_insert</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set (S ∪ {(k, v)}) ⟹ map_of_aset (S ∪ {(k, v)}) = (map_of_aset S) {k → v}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = map_of_aset S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = map_of_aset (S ∪ {(k, v)})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. N⟨x⟩ = (M {k → v}) ⟨x⟩"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M⟨x⟩ = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_to_aset</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set (set xs) ⟹ map_of_aset (set xs) = map_of_alist xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = x # xs'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (x # xs') = set xs' ∪ {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_aset_delete</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S ⟹ (k, v) ∈ S ⟹ map_of_aset (S - {(k, v)}) = delete_map k (map_of_aset S)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T = S - {(k, v)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = map_of_aset S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = map_of_aset T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. N⟨x⟩ = (delete_map k M) ⟨x⟩"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M⟨x⟩ = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M⟨x⟩ = Some y"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_aset_update</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unique_keys_set S ⟹ (k, v) ∈ S ⟹
   map_of_aset (S - {(k, v)} ∪ {(k, v')}) = (map_of_aset S) {k → v'}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_delete</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set xs' = set xs - {x} ⟹ unique_keys_set (set xs) ⟹ x ∈ set xs ⟹
   map_of_alist xs' = delete_map (fst x) (map_of_alist xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of_alist xs' = map_of_aset (set xs')"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_insert</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set xs' = set xs ∪ {x} ⟹ unique_keys_set (set xs') ⟹
   map_of_alist xs' = (map_of_alist xs) {fst x → snd x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of_alist xs' = map_of_aset (set xs')"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_update</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set xs' = set xs - {(k, v)} ∪ {(k, v')} ⟹ unique_keys_set (set xs) ⟹ (k, v) ∈ set xs ⟹
   map_of_alist xs' = (map_of_alist xs) {k → v'}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of_alist xs' = map_of_aset (set xs')"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set of keys of a mapping›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>keys_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keys_of M = {x. M⟨x⟩ ≠ None}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keys_of_iff</span><span> </span><span class="delimiter">[</span><span>rewrite_bidir</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ keys_of M ⟷ M⟨x⟩ ≠ None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm keys_of_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keys_of_empty</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keys_of empty_map = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keys_of_delete</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keys_of (delete_map x M) = keys_of M - {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Minimum of a mapping, relevant for heaps (priority queues)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_heap_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a, 'b::linorder) map ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap_min x M ⟷ x ∈ keys_of M ∧ (∀k∈keys_of M. the (M⟨x⟩) ≤ the (M⟨k⟩))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹General construction and update of maps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>map_constr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ bool) ⇒ (nat ⇒ 'a) ⇒ nat ⇒ (nat, 'a) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_constr S f 0 = empty_map"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_constr S f (Suc k) = (let M = map_constr S f k in if S k then M {k → f k} else M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms map_constr.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_constr_eval</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_constr S f n = Map (λi. if i &lt; n then if S i then Some (f i) else None else None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keys_of_map_constr</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ∈ keys_of (map_constr S f n) ⟷ (S i ∧ i &lt; n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_update_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ 'a) ⇒ (nat, 'a) map ⇒ (nat, 'a) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_update_all f M = Map (λi. if i ∈ keys_of M then Some (f i) else M⟨i⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>map_update_all_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ 'a) ⇒ (nat, 'a) map ⇒ nat ⇒ (nat, 'a) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_update_all_impl f M 0 = M"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_update_all_impl f M (Suc k) =
   (let M' = map_update_all_impl f M k in if k ∈ keys_of M then M' {k → f k} else M')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms map_update_all_impl.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_update_all_impl_ind</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_update_all_impl f M n = Map (λi. if i &lt; n then if i ∈ keys_of M then Some (f i) else None else M⟨i⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_update_all_impl_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀i∈keys_of M. i &lt; n ⟹ map_update_all_impl f M n = map_update_all f M"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keys_of_map_update_all</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keys_of (map_update_all f M) = keys_of M"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lists_Ex">
<div class="head"><h1>Theory Lists_Ex</h1>
<span class="command">theory</span> <span class="name">Lists_Ex</span><br/>
<span class="keyword">imports</span> <a href="Mapping_Str.html"><span class="name">Mapping_Str</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Lists_Ex.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lists_Ex</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Mapping_Str</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Examples on lists. The itrev example comes from
  \cite[Section 2.4]{prog-prove}.

  The development here of insertion and deletion on lists is
  essential for verifying functional binary search trees and
  red-black trees. The idea, following Nipkow~\cite{nipkow16},
  is that showing sorted-ness and preservation of multisets for trees
  should be done on the in-order traversal of the tree.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Linear time version of rev›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>itrev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"itrev []       ys = ys"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrev (x # xs) ys = itrev xs (x # ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms itrev.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrev_eq_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrev x [] = rev x"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. itrev x y = rev x @ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>y</span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strict sorted›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>strict_sorted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted [] = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (x # ys) = ((∀y∈set ys. x &lt; y) ∧ strict_sorted ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms strict_sorted.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_sorted_appendI</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted xs ∧ strict_sorted ys ∧ (∀x∈set xs. ∀y∈set ys. x &lt; y) ⟹ strict_sorted (xs @ ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_sorted_appendE1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (xs @ ys) ⟹ strict_sorted xs ∧ strict_sorted ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_sorted_appendE2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (xs @ ys) ⟹ x ∈ set xs ⟹ ∀y∈set ys. x &lt; y"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_sorted_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_sorted l ⟹ distinct l"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered insert›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ordered_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ordered_insert x [] = [x]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ordered_insert x (y # ys) = (
    if x = y then (y # ys)
    else if x &lt; y then x # (y # ys)
    else y # ordered_insert x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms ordered_insert.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (ordered_insert x ys) = {x} ∪ set ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted ys ⟹ strict_sorted (ordered_insert x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_binary</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (xs @ a # ys) ⟹ ordered_insert x (xs @ a # ys) =
    (if x &lt; a then ordered_insert x xs @ a # ys
     else if x &gt; a then xs @ a # ordered_insert x ys
     else xs @ a # ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deleting an element›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove_elt_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove_elt_list x [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove_elt_list x (y # ys) = (if y = x then remove_elt_list x ys else y # remove_elt_list x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms remove_elt_list.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_list_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (remove_elt_list x ys) = set ys - {x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_list_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted ys ⟹ strict_sorted (remove_elt_list x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_idem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∉ set ys ⟹ remove_elt_list x ys = ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_list_binary</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (xs @ a # ys) ⟹ remove_elt_list x (xs @ a # ys) =
    (if x &lt; a then remove_elt_list x xs @ a # ys
     else if x &gt; a then xs @ a # remove_elt_list x ys else xs @ ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; a"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set ys"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered insertion into list of pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ordered_insert_pairs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ 'b ⇒ ('a × 'b) list ⇒ ('a × 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ordered_insert_pairs x v [] = [(x, v)]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ordered_insert_pairs x v (y # ys) = (
    if x = fst y then ((x, v) # ys)
    else if x &lt; fst y then (x, v) # (y # ys)
    else y # ordered_insert_pairs x v ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms ordered_insert_pairs.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_pairs_map</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_of_alist (ordered_insert_pairs x v ys) = update_map (map_of_alist ys) x v"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_pairs_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (map fst (ordered_insert_pairs x v ys)) = {x} ∪ set (map fst ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_pairs_sorted</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst ys) ⟹ strict_sorted (map fst (ordered_insert_pairs x v ys))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_insert_pairs_binary</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst (xs @ a # ys)) ⟹ ordered_insert_pairs x v (xs @ a # ys) =
    (if x &lt; fst a then ordered_insert_pairs x v xs @ a # ys
     else if x &gt; fst a then xs @ a # ordered_insert_pairs x v ys
     else xs @ (x, v) # ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deleting from a list of pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove_elt_pairs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a × 'b) list ⇒ ('a × 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove_elt_pairs x [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove_elt_pairs x (y # ys) = (if fst y = x then ys else y # remove_elt_pairs x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms remove_elt_pairs.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_pairs_map</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst ys) ⟹ map_of_alist (remove_elt_pairs x ys) = delete_map x (map_of_alist ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys = y # ys'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst y = x"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set (map fst ys')"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_pairs_on_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst ys) ⟹ set (map fst (remove_elt_pairs x ys)) = set (map fst ys) - {x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_pairs_sorted</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst ys) ⟹ strict_sorted (map fst (remove_elt_pairs x ys))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_pairs_idem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∉ set (map fst ys) ⟹ remove_elt_pairs x ys = ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_elt_pairs_binary</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst (xs @ a # ys)) ⟹ remove_elt_pairs x (xs @ a # ys) =
    (if x &lt; fst a then remove_elt_pairs x xs @ a # ys
     else if x &gt; fst a then xs @ a # remove_elt_pairs x ys else xs @ ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; fst a"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set (map fst ys)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search in a list of pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_alist_binary</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strict_sorted (map fst (xs @ a # ys)) ⟹ (map_of_alist (xs @ a # ys))⟨x⟩ =
   (if x &lt; fst a then (map_of_alist xs)⟨x⟩
    else if x &gt; fst a then (map_of_alist ys)⟨x⟩ else Some (snd a))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set (map fst ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BST">
<div class="head"><h1>Theory BST</h1>
<span class="command">theory</span> <span class="name">BST</span><br/>
<span class="keyword">imports</span> <a href="Lists_Ex.html"><span class="name">Lists_Ex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: BST.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binary search tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BST</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lists_Ex</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verification of functional programs on binary search trees. For
  basic technique, see comments in Lists\_Ex.thy.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition and setup for trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>tree</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>Tip</span><span> </span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>key</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>nval</span><span class="delimiter">:</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm tree.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm tree.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_var_induct_rule @{thm tree.induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inorder traversal, and set of elements of a tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>in_traverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_traverse Tip = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_traverse (Node l k v r) = in_traverse l @ k # in_traverse r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms in_traverse.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_set Tip = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_set (Node l k v r) = {k} ∪ tree_set l ∪ tree_set r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_set.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>in_traverse_pairs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a × 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_traverse_pairs Tip = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_traverse_pairs (Node l k v r) = in_traverse_pairs l @ (k, v) # in_traverse_pairs r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms in_traverse_pairs.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_traverse_fst</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map fst (in_traverse_pairs t) = in_traverse t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_map t = map_of_alist (in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm tree_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sortedness on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_sorted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder, 'b) tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted Tip = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l k v r) = ((∀x∈tree_set l. x &lt; k) ∧ (∀x∈tree_set r. k &lt; x)
                              ∧ tree_sorted l ∧ tree_sorted r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_sorted.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_sorted_lr</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l k v r) ⟹ tree_sorted l ∧ tree_sorted r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inorder_preserve_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_set t = set (in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inorder_pairs_sorted</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟷ strict_sorted (map fst (in_traverse_pairs t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Use definition in terms of in\_traverse from now on.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm (@{thms tree_set.simps} @ @{thms tree_sorted.simps})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rotation on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rotateL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rotateL t = (if t = Tip then t else if rsub t = Tip then t else
    (let rt = rsub t in
     Node (Node (lsub t) (key t) (nval t) (lsub rt)) (key rt) (nval rt) (rsub rt)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rotateR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rotateR t = (if t = Tip then t else if lsub t = Tip then t else
    (let lt = lsub t in
     Node (lsub lt) (key lt) (nval lt) (Node (rsub lt) (key t) (nval t) (rsub t))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rotateL_in_trav</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_traverse (rotateL t) = in_traverse t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rotateR_in_trav</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_traverse (rotateR t) = in_traverse t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rotateL_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_sorted (rotateL t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rotateR_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_sorted (rotateR t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ 'b ⇒ ('a, 'b) tree ⇒ ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_insert x v Tip = Node Tip x v Tip"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_insert x v (Node l y w r) =
    (if x = y then Node l x v r
     else if x &lt; y then Node (tree_insert x v l) y w r
     else Node l y w (tree_insert x v r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_insert.simps}›</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ in_traverse_pairs (tree_insert x v t) = ordered_insert_pairs x v (in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness results for insertion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_sorted (tree_insert x v t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_on_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_map (tree_insert x v t) = (tree_map t) {x → v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletion on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>del_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a × 'b) × ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"del_min Tip = undefined"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"del_min (Node lt x v rt) =
   (if lt = Tip then ((x, v), rt) else
    (fst (del_min lt), Node (snd (del_min lt)) x v rt))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm del_min.simps(2)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_del_hd_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≠ Tip ⟹ fst (del_min t) # in_traverse_pairs (snd (del_min t)) = in_traverse_pairs t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>delete_elt_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) tree ⇒ ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_elt_tree Tip = undefined"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_elt_tree (Node lt x v rt) =
    (if lt = Tip then rt else if rt = Tip then lt else
     Node lt (fst (fst (del_min rt))) (snd (fst (del_min rt))) (snd (del_min rt)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm delete_elt_tree.simps(2)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_traverse_pairs (delete_elt_tree (Node lt x v rt)) = in_traverse_pairs lt @ in_traverse_pairs rt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_delete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ ('a, 'b) tree ⇒ ('a, 'b) tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_delete x Tip = Tip"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_delete x (Node l y w r) =
    (if x = y then delete_elt_tree (Node l y w r)
     else if x &lt; y then Node (tree_delete x l) y w r
     else Node l y w (tree_delete x r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_delete.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_delete_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ in_traverse_pairs (tree_delete x t) = remove_elt_pairs x (in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness results for deletion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_delete_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_sorted (tree_delete x t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_delete_map</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_map (tree_delete x t) = delete_map x (tree_map t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search on sorted trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_search</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ord, 'b) tree ⇒ 'a ⇒ 'b option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_search Tip x = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_search (Node l k v r) x =
  (if x = k then Some v
   else if x &lt; k then tree_search l x
   else tree_search r x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_search.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of search.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_search_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_search t x = (tree_map t)⟨x⟩"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Partial_Equiv_Rel">
<div class="head"><h1>Theory Partial_Equiv_Rel</h1>
<span class="command">theory</span> <span class="name">Partial_Equiv_Rel</span><br/>
<span class="keyword">imports</span> <a href="../Auto2_HOL/Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Partial_Equiv_Rel.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partial equivalence relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Partial_Equiv_Rel</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auto2_HOL.Auto2_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Partial equivalence relations, following theory
  Lib/Partial\_Equivalence\_Relation in \cite{Collections-AFP}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>part_equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"part_equiv R ⟷ sym R ∧ trans R"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_equivI</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sym R ⟹ trans R ⟹ part_equiv R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_equivD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_equiv R ⟹ sym R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_equivD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_equiv R ⟹ trans R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm part_equiv_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combining two elements in a partial equivalence relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>per_union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ 'a ⇒ 'a ⇒ ('a × 'a) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"per_union R a b = R ∪ { (x,y). (x,a)∈R ∧ (b,y)∈R } ∪ { (x,y). (x,b)∈R ∧ (a,y)∈R }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_memI1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ R ⟹ (x, y) ∈ per_union R a b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>per_union_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm per_union_memI1} [with_term "per_union ?R ?a ?b"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_memI2</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, a) ∈ R ⟹ (b, y) ∈ R ⟹ (x, y) ∈ per_union R a b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>per_union_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_memI3</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, b) ∈ R ⟹ (a, y) ∈ R ⟹ (x, y) ∈ per_union R a b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>per_union_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_memD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ per_union R a b ⟹ (x, y) ∈ R ∨ ((x, a) ∈ R ∧ (b, y) ∈ R) ∨ ((x, b) ∈ R ∧ (a, y) ∈ R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>per_union_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm per_union_memD} [with_cond "?x ≠ ?y", with_filt (order_filter "x" "y")]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm per_union_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_is_trans</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans R ⟹ trans (per_union R a b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>per_union_is_part_equiv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"part_equiv R ⟹ part_equiv (per_union R a b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Union_Find">
<div class="head"><h1>Theory Union_Find</h1>
<span class="command">theory</span> <span class="name">Union_Find</span><br/>
<span class="keyword">imports</span> <a href="Partial_Equiv_Rel.html"><span class="name">Partial_Equiv_Rel</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Union_Find.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Union find›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Union_Find</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Partial_Equiv_Rel</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Development follows theory Union\_Find in \cite{Separation_Logic_Imperative_HOL-AFP}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representing a partial equivalence relation using rep\_of array›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span class="delimiter">(</span><span>domintros</span><span class="delimiter">)</span><span> </span><span>rep_of</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rep_of l i = (if l ! i = i then i else rep_of l (l ! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("rep_of l i", ["i &lt; length l"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm rep_of.domintros}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm rep_of.psimps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prop_induct_rule @{thm rep_of.pinduct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ufa_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l = (∀i&lt;length l. rep_of_dom (l, i) ∧ l ! i &lt; length l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_invarD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ rep_of_dom (l, i) ∧ l ! i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm ufa_invarD} [with_term "?l ! ?i"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm ufa_invar_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_id</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ l ! i = i ⟹ rep_of l i = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_iff</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ rep_of l i = (if l ! i = i then i else rep_of l (l ! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm rep_of.psimps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_min</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ l ! (rep_of l i) = rep_of l i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep_of_dom (l, i)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l ⟹
   ∀i&lt;length l. l ! i = i ⟶ P l i ⟹
   ∀i&lt;length l. l ! i ≠ i ⟶ P l (l ! i) ⟶ P l i ⟹ P l i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep_of_dom (l, i)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prop_induct_rule @{thm rep_of_induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_bound</span><span> </span><span class="delimiter">[</span><span>forward_arg1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ rep_of l i &lt; length l"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_idem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ rep_of l (rep_of l i) = rep_of l i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rep_of_idx</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹ rep_of l (l ! i) = rep_of l i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ufa_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ (nat × nat) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_α l = {(x, y). x &lt; length l ∧ y &lt; length l ∧ rep_of l x = rep_of l y}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_α_memI</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">,</span><span> </span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x &lt; length l ⟹ y &lt; length l ⟹ rep_of l x = rep_of l y ⟹ (x, y) ∈ ufa_α l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ufa_α_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_α_memD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ ufa_α l ⟹ x &lt; length l ∧ y &lt; length l ∧ rep_of l x = rep_of l y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ufa_α_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm ufa_α_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_α_equiv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"part_equiv (ufa_α l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_α_refl</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i, i) ∈ ufa_α l ⟷ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations on rep\_of array›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uf_init_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_init_rel n = ufa_α [0..&lt;n]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_init_invar</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar [0..&lt;n]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_init_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ uf_init_rel n ⟷ (x = y ∧ x &lt; n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar [0..&lt;n]"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ufa_union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ nat ⇒ nat ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_union l x y ≡ l[rep_of l x := rep_of l y]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_union_invar</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ y &lt; length l ⟹ l' = ufa_union l x y ⟹ ufa_invar l'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length l'. rep_of_dom (l', i) ∧ l' ! i &lt; length l'"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_union_aux</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ y &lt; length l ⟹ l' = ufa_union l x y ⟹
   i &lt; length l' ⟹ rep_of l' i = (if rep_of l i = rep_of l x then rep_of l y else rep_of l i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of union operation.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ufa_union_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ y &lt; length l ⟹ l' = ufa_union l x y ⟹
   ufa_α l' = per_union (ufa_α l) x y"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. (a,b) ∈ ufa_α l' ⟷ (a,b) ∈ per_union (ufa_α l) x y"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ ufa_α l'"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep_of l a = rep_of l x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep_of l a = rep_of l y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ufa_compress</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ nat ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_compress l x ≡ l[x := rep_of l x]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_compress_invar</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ l' = ufa_compress l x ⟹ ufa_invar l'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length l'. rep_of_dom (l', i) ∧ l' ! i &lt; length l'"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ufa_compress_aux</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ l' = ufa_compress l x ⟹ i &lt; length l' ⟹
   rep_of l' i = rep_of l i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of compress operation.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ufa_compress_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ x &lt; length l ⟹ ufa_α (ufa_compress l x) = ufa_α l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm rep_of_iff}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Connectivity">
<div class="head"><h1>Theory Connectivity</h1>
<span class="command">theory</span> <span class="name">Connectivity</span><br/>
<span class="keyword">imports</span> <a href="Union_Find.html"><span class="name">Union_Find</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Connectivity.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Connectedness for a set of undirected edges.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Connectivity</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Union_Find</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A simple application of union-find for graph connectivity.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) set ⇒ nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_path n S [] = False"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S (x # xs) =
   (if xs = [] then x &lt; n else ((x, hd xs) ∈ S ∨ (hd xs, x) ∈ S) ∧ is_path n S xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms is_path.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) set ⇒ nat ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_path n S i j ⟷ (∃p. is_path n S p ∧ hd p = i ∧ last p = j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_nonempty</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S p ⟹ p ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonempty_is_not_path</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬is_path n S []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_extend</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_path n S p ⟹ S ⊆ T ⟹ is_path n T p"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_path_extend</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_path n S i j ⟹ S ⊆ T ⟹ has_path n T i j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>joinable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable p q ⟷ (last p = hd q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>path_join</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ nat list ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"path_join p q = p @ tl q"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("path_join p q", ["joinable p q"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("path_join p q", "joinable p q")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_join_hd</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ [] ⟹ hd (path_join p q) = hd p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_join_last</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable p q ⟹ q ≠ [] ⟹ last (path_join p q) = last q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = hd q # tl q"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl q = []"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_join_is_path</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable p q ⟹ is_path n S p ⟹ is_path n S q ⟹ is_path n S (path_join p q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_path_trans</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_path n S i j ⟹ has_path n S j k ⟹ has_path n S i k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p = i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last p = j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd q = j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last q = k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S (path_join p q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_valid_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S ⟷ (∀p∈S. fst p &lt; n ∧ snd p &lt; n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_path_single1</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S ⟹ (a, b) ∈ S ⟹ has_path n S a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S [a, b]"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_path_single2</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S ⟹ (a, b) ∈ S ⟹ has_path n S b a"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S [b, a]"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_path_refl</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S ⟹ a &lt; n ⟹ has_path n S a a"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>connected_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) set ⇒ (nat × nat) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"connected_rel n S = {(a,b). has_path n S a b}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_iff</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a, b) ∈ connected_rel n S ⟷ has_path n S a b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>connected_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_trans</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans (connected_rel n S)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_refl</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S ⟹ a &lt; n ⟹ (a, a) ∈ connected_rel n S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_per_union</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (S ∪ {(a, b)}) ⟹
   has_path n (S ∪ {(a, b)}) i j ⟷ (i, j) ∈ per_union (connected_rel n S) a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R = connected_rel n S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' = S ∪ {(a, b)}"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ S'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i, j) ∈ per_union R a b"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i, a) ∈ R ∧ (b, j) ∈ R"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' i a"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' a b"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' b j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i, b) ∈ R ∧ (a, j) ∈ R"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' i b"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' b a"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' a j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n S' i j"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. is_path n S' p ⟶ (hd p, last p) ∈ per_union R a b"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>p</span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = x # xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, hd xs) ∈ per_union R a b"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>          </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n S"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, hd xs) ∈ S'"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, hd xs) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(hd xs, x) ∈ S'"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(hd xs, x) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n S' p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p = i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last p = j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_union</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (S ∪ {(a, b)}) ⟹
   connected_rel n (S ∪ {(a, b)}) = per_union (connected_rel n S) a b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_init</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"connected_rel n {} = uf_init_rel n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i j. has_path n {} i j ⟷ (i, j) ∈ uf_init_rel n"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_path n {} i j"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path n {} p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p = i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last p = j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = hd p # tl p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>connected_rel_ind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) list ⇒ nat ⇒ (nat × nat) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"connected_rel_ind n es 0 = uf_init_rel n"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected_rel_ind n es (Suc k) =
   (let R = connected_rel_ind n es k; p = es ! k in
      per_union R (fst p) (snd p))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms connected_rel_ind.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_ind_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (set es) ⟹ k ≤ length es ⟹
   connected_rel_ind n es k = connected_rel n (set (take k es))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = Suc m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (set (take (Suc m) es))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of the functional algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>connected_rel_ind_compute</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (set es) ⟹
   connected_rel_ind n es (length es) = connected_rel n (set es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Arrays_Ex">
<div class="head"><h1>Theory Arrays_Ex</h1>
<span class="command">theory</span> <span class="name">Arrays_Ex</span><br/>
<span class="keyword">imports</span> <a href="../Auto2_HOL/Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Arrays_Ex.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Arrays›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Arrays_Ex</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auto2_HOL.Auto2_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic examples for arrays.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List swap›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_swap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_swap xs i j = xs[i := xs ! j, j := xs ! i]"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("list_swap xs i j", ["i &lt; length xs", "j &lt; length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("list_swap xs i j", "i &lt; length xs ∧ j &lt; length xs")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_swap_eval</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹
   (list_swap xs i j) ! k = (if k = i then xs ! j else if k = j then xs ! i else xs ! k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm list_swap_eval} [with_cond "?k ≠ ?i", with_cond "?k ≠ ?j"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_swap_eval_triv</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ (list_swap xs i j) ! i = xs ! j"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ (list_swap xs i j) ! j = xs ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_list_swap</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length (list_swap xs i j) = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_list_swap</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ mset (list_swap xs i j) = mset xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_list_swap</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ set (list_swap xs i j) = set xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm list_swap_def}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm list_swap_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reverse›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_nth</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length xs ⟹ rev xs ! n = xs ! (length xs - 1 - n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rev_swap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ nat ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j = (if i &lt; j then rev_swap (list_swap xs i j) (i + 1) (j - 1) else xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("rev_swap xs i j", ["j &lt; length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("rev_swap xs i j", "j &lt; length xs")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_swap_length</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j &lt; length xs ⟹ length (rev_swap xs i j) = length xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_swap_eval</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j &lt; length xs ⟹ (rev_swap xs i j) ! k =
    (if k &lt; i then xs ! k else if k &gt; j then xs ! k else xs ! (j - (k - i)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; i"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &gt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j - (k - i) = j - k + i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_swap_is_rev</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length xs ≥ 1 ⟹ rev_swap xs 0 (length xs - 1) = rev xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Copy one array to the beginning of another›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>array_copy</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_copy xs xs' 0 = xs'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"array_copy xs xs' (Suc n) = list_update (array_copy xs xs' n) n (xs ! n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms array_copy.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("array_copy xs xs' n", ["n ≤ length xs", "n ≤ length xs'"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("array_copy xs xs' n", "n ≤ length xs ∧ n ≤ length xs'")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_copy_length</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ n ≤ length xs' ⟹ length (array_copy xs xs' n) = length xs'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_copy_ind</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ n ≤ length xs' ⟹ k &lt; n ⟹ (array_copy xs xs' n) ! k = xs ! k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_copy_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ n ≤ length xs' ⟹ take n (array_copy xs xs' n) = take n xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sublist›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sublist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist l r xs = drop l (take r xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("sublist l r xs", ["l ≤ r", "r ≤ length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("sublist l r xs", "l ≤ r ∧ r ≤ length xs")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_sublist</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ≤ length xs ⟹ length (sublist l r xs) = r - l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_sublist</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ≤ length xs ⟹ xs' = sublist l r xs ⟹ i &lt; length xs' ⟹ xs' ! i = xs ! (i + l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_nil</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ≤ length xs ⟹ r ≤ l ⟹ sublist l r xs = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_0</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist 0 l xs = take l xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_drop</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sublist l r (drop n xs) = sublist (l + n) (r + n) xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm sublist_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_single</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l + 1 ≤ length xs ⟹ sublist l (l + 1) xs = [xs ! l]"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length [xs ! l] = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_append</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l ≤ m ⟹ m ≤ r ⟹ r ≤ length xs ⟹ sublist l m xs @ sublist m r xs = sublist l r xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs1 = sublist l r xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs2 = sublist l m xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs3 = sublist m r xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (xs2 @ xs3) = (r - m) + (m - l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length xs1. xs1 ! i = (xs2 @ xs3) ! i"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i - length xs2 &lt; length xs3"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_Cons</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ≤ length xs ⟹ l &lt; r ⟹ xs ! l # sublist (l + 1) r xs = sublist l r xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist l r xs = sublist l (l + 1) xs @ sublist (l + 1) r xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sublist_equalityI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≤ j ⟹ j ≤ length xs ⟹ length xs = length ys ⟹
   ∀k. i ≤ k ⟶ k &lt; j ⟶ xs ! k = ys ! k ⟹ sublist i j xs = sublist i j ys"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep_cond @{thm sublist_equalityI} [with_filt (order_filter "xs" "ys")]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_sublist</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j ≤ length xs ⟹ x ∈ set (sublist i j xs) ⟹ ∃k. k ≥ i ∧ k &lt; j ∧ x = xs ! k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = sublist i j xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; length xs'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' ! l = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_take_sublist_drop_eq</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l ≤ r ⟹ r ≤ length xs ⟹ take l xs @ sublist l r xs @ drop r xs = xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take l xs = sublist 0 l xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop r xs = sublist r (length xs) xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Updating a set of elements in an array›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_update_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ bool) ⇒ (nat ⇒ 'a) ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_update_set S f xs = list (λi. if S i then f i else xs ! i) (length xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_update_set_length</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length (list_update_set S f xs) = length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_update_set_nth</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs' = list_update_set S f xs ⟹ i &lt; length xs' ⟹ xs' ! i = (if S i then f i else xs ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm list_update_set_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>list_update_set_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ bool) ⇒ (nat ⇒ 'a) ⇒ 'a list ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_update_set_impl S f xs 0 = xs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_update_set_impl S f xs (Suc k) =
   (let xs' = list_update_set_impl S f xs k in
      if S k then xs' [k := f k] else xs')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms list_update_set_impl.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("list_update_set_impl S f xs n", ["n ≤ length xs"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_update_set_impl_ind</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ list_update_set_impl S f xs n =
   list (λi. if i &lt; n then if S i then f i else xs ! i else xs ! i) (length xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_update_set_impl_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_update_set_impl S f xs (length xs) = list_update_set S f xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra">
<div class="head"><h1>Theory Dijkstra</h1>
<span class="command">theory</span> <span class="name">Dijkstra</span><br/>
<span class="keyword">imports</span> <a href="Mapping_Str.html"><span class="name">Mapping_Str</span></a> <a href="Arrays_Ex.html"><span class="name">Arrays_Ex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Dijkstra.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Dijkstra's algorithm for shortest paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Mapping_Str</span><span> </span><span>Arrays_Ex</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verification of Dijkstra's algorithm: function part.

  The algorithm is also verified by Nordhoff and Lammich in
  \cite{Dijkstra_Shortest_Path-AFP}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graphs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>graph</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>size</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size (Graph G) = length G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weight (Graph G) m n = (G ! m) ! n"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>valid_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_graph (Graph G) ⟷ (∀i&lt;length G. length (G ! i) = length G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm valid_graph.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paths on graphs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The set of vertices less than n.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>verts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"verts G = {i. i &lt; size G}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>verts_mem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ verts G ⟷ i &lt; size G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>verts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_verts</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (verts G) = size G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>verts_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_verts</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (verts G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>verts_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_path G p ⟷ p ≠ [] ∧ set p ⊆ verts G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_to_in_verts</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path G p ⟹ hd p ∈ verts G ∧ last p ∈ verts G"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last p ∈ set p"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>joinable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat list ⇒ nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟷ (is_path G p ∧ is_path G q ∧ last p = hd q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>path_join</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat list ⇒ nat list ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"path_join G p q = p @ tl q"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("path_join G p q", ["joinable G p q"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("path_join G p q", "joinable G p q")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_join_is_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟹ is_path G (path_join G p q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = hd q # tl q"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm path_join_is_path} [with_term "path_join ?G ?p ?q"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>path_weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat list ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"path_weight G [] = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G (x # xs) = (if xs = [] then 0 else weight G x (hd xs) + path_weight G xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms path_weight.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_singleton</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G [x] = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_doubleton</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G [m, n] = weight G m n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_sum</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟹ path_weight G (path_join G p q) = path_weight G p + path_weight G q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>path_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat list set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"path_set G m n = {p. is_path G p ∧ hd p = m ∧ last p = n}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_set_mem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set G m n ⟷ is_path G p ∧ hd p = m ∧ last p = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_join_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟹ path_join G p q ∈ path_set G (hd p) (last q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = hd q # tl q"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl q = []"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm path_join_set} [with_term "path_join ?G ?p ?q"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shortest paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_shortest_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G m n p ⟷
     (p ∈ path_set G m n ∧ (∀p'∈path_set G m n. path_weight G p' ≥ path_weight G p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_shortest_pathD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G m n p ⟹ p ∈ path_set G m n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_shortest_pathD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G m n p ⟹ p' ∈ path_set G m n ⟹ path_weight G p' ≥ path_weight G p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm is_shortest_path_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist G m n ⟷ (∃p. is_shortest_path G m n p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_distI</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G m n p ⟹ has_dist G m n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_distD</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist G m n ⟹ ∃p. is_shortest_path G m n p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_dist_to_in_verts</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist G u v ⟹ u ∈ verts G ∧ v ∈ verts G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm has_dist_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dist G m n = path_weight G (SOME p. is_shortest_path G m n p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("dist G m n", ["has_dist G m n"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_eq</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G m n p ⟹ dist G m n = path_weight G p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist G m n ⟹ p ∈ path_set G m n ⟹ path_weight G p ≥ dist G m n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm dist_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shortest_init</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ verts G ⟹ is_shortest_path G n n [n]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interior points›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List of interior points›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_pts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_pts p = set (butlast p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_pts_singleton</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_pts [x] = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_pts_doubleton</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_pts [x, y] = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>path_set_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat set ⇒ nat list set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"path_set_on G m n V = {p. p ∈ path_set G m n ∧ int_pts p ⊆ V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_set_on_mem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set_on G m n V ⟷ p ∈ path_set G m n ∧ int_pts p ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>path_set_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Version of shortest path on a set of points›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_shortest_path_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat list ⇒ nat set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V ⟷
    (p ∈ path_set_on G m n V ∧ (∀p'∈path_set_on G m n V. path_weight G p' ≥ path_weight G p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_shortest_path_onD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V ⟹ p ∈ path_set_on G m n V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_shortest_path_onD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V ⟹ p' ∈ path_set_on G m n V ⟹ path_weight G p' ≥ path_weight G p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm is_shortest_path_on_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_dist_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G m n V ⟷ (∃p. is_shortest_path_on G m n p V)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_dist_onI</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V ⟹ has_dist_on G m n V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_dist_onD</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G m n V ⟹ ∃p. is_shortest_path_on G m n p V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm has_dist_on_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dist_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat set ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dist_on G m n V = path_weight G (SOME p. is_shortest_path_on G m n p V)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("dist_on G m n V", ["has_dist_on G m n V"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_on_eq</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V ⟹ dist_on G m n V = path_weight G p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_onD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G m n V ⟹ p ∈ path_set_on G m n V ⟹ path_weight G p ≥ dist_on G m n V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm dist_on_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two splitting lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_split1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path G p ⟹ hd p ∈ V ⟹ last p ∉ V ⟹
  ∃p1 p2. joinable G p1 p2 ∧ p = path_join G p1 p2 ∧ int_pts p1 ⊆ V ∧ hd p2 ∉ V"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>p</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = a # p'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = a # p'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p' ∉ V"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = path_join G [a, hd p'] p'"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G p1 p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = path_join G p1 p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"int_pts p1 ⊆ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p2 ∉ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = path_join G (a # p1) p2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_split2</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path G p ⟹ hd p ≠ last p ⟹
  ∃q n. joinable G q [n, last p] ∧ p = path_join G q [n, last p]"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = butlast p @ [last p]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast p ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = last (butlast p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = path_join G (butlast p) [n, last p]"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deriving has\_dist and has\_dist\_on›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>known_dists</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"known_dists G V ⟷ (V ⊆ verts G ∧ 0 ∈ V ∧
      (∀i∈verts G. has_dist_on G 0 i V) ∧
      (∀i∈V. has_dist G 0 i ∧ dist G 0 i = dist_on G 0 i V))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>derive_dist</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"known_dists G V ⟹
   m ∈ verts G - V ⟹
   ∀i∈verts G - V. dist_on G 0 i V ≥ dist_on G 0 m V ⟹
   has_dist G 0 m ∧ dist G 0 m = dist_on G 0 m V"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 m p V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G 0 m p"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set G 0 m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p'∈path_set G 0 m. path_weight G p' ≥ path_weight G p"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G p1 p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = path_join G p1 p2"</span></span></span><span>
</span><span>                          </span><span class="string"><span class="delete"><span class="delete">"int_pts p1 ⊆ V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd p2 ∉ V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = last p1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_on G 0 x V ≥ dist_on G 0 m V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p1 ∈ path_set_on G 0 x V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p1 ≥ dist_on G 0 x V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p' ≥ dist_on G 0 m V + path_weight G p2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>join_def'</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟹ path_join G p q = butlast p @ q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = butlast p @ [last p]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_join G p q = butlast p @ [last p] @ tl q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_pts_join</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinable G p q ⟹ int_pts (path_join G p q) = int_pts p ∪ int_pts q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_join G p q = butlast p @ q"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_on_triangle_ineq</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G k m V ⟹ has_dist_on G k n V ⟹ V ⊆ verts G ⟹ n ∈ verts G ⟹ m ∈ V ⟹
   dist_on G k m V + weight G m n ≥ dist_on G k n V"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G k m p V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pq = path_join G p [m, n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∪ {m} = V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pq ∈ path_set_on G k n V"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>derive_dist_on</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"known_dists G V ⟹
   m ∈ verts G - V ⟹
   ∀i∈verts G - V. dist_on G 0 i V ≥ dist_on G 0 m V ⟹
   V' = V ∪ {m} ⟹
   n ∈ verts G - V' ⟹
   has_dist_on G 0 n V' ∧ dist_on G 0 n V' = min (dist_on G 0 n V) (dist_on G 0 m V + weight G m n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist G 0 m ∧ dist G 0 m = dist_on G 0 m V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = min (dist_on G 0 n V) (dist_on G 0 m V + weight G m n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p∈path_set_on G 0 n V'. path_weight G p ≥ M"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>q</span><span> </span><span>n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G q [n', n]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = path_join G q [n', n]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈ path_set G 0 n'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ V'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ V"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_on G 0 n' V = dist G 0 n'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G q ≥ dist_on G 0 n' V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p ≥ dist_on G 0 n' V + weight G n' n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_on G 0 n' V + weight G n' n ≥ dist_on G 0 n V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G q ≥ dist G 0 m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p ≥ dist G 0 m + weight G m n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_on G 0 m V + weight G m n ≥ dist_on G 0 n V"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 n p V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 n p V'"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set_on G 0 n V'"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ V'"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = dist_on G 0 m V + weight G m n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>pm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 m pm V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G pm = dist G 0 m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = path_join G pm [m, n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G pm [m, n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p = path_weight G pm + weight G m n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 n p V'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant for the Dijkstra's algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The state consists of an array maintaining the best estimates,
  and a heap containing estimates for the unknown vertices.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>State</span><span> </span><span class="delimiter">(</span><span>est</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat, nat) map"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "state"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unknown_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unknown_set S = keys_of (heap S)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>known_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"known_set S = {..&lt;length (est S)} - unknown_set S"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant: for every vertex, the estimate is at least the shortest distance.
  Furthermore, for the known vertices the estimate is exact.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟷ (let V = known_set S; W = unknown_set S; M = heap S in
      (length (est S) = size G ∧ known_dists G V ∧
      keys_of M ⊆ verts G ∧
      (∀i∈W. M⟨i⟩ = Some (est S ! i)) ∧
      (∀i∈V. est S ! i = dist G 0 i) ∧
      (∀i∈verts G. est S ! i = dist_on G 0 i V)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invE1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ length (est S) = size G ∧ known_dists G (known_set S) ∧ unknown_set S ⊆ verts G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invE2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ i ∈ known_set S ⟹ est S ! i = dist G 0 i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invE3</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ i ∈ verts G ⟹ est S ! i = dist_on G 0 i (known_set S)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invE4</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ i ∈ unknown_set S ⟹ (heap S)⟨i⟩ = Some (est S ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_str "@eqforward" @{thm inv_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_unknown_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ unknown_set S = verts G - known_set S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_end_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ unknown_set S = {} ⟹ ∀i∈verts G. has_dist G 0 i ∧ est S ! i = dist G 0 i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Starting state›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dijkstra_start_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra_start_state G =
     State (list (λi. if i = 0 then 0 else weight G 0 i) (size G))
           (map_constr (λi. i &gt; 0) (λi. weight G 0 i) (size G))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("dijkstra_start_state G", ["size G &gt; 0"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_start_known_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size G &gt; 0 ⟹ known_set (dijkstra_start_state G) = {0}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_start_unknown_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size G &gt; 0 ⟹ unknown_set (dijkstra_start_state G) = verts G - {0}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_start_state</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size G &gt; 0 ⟹ card (unknown_set (dijkstra_start_state G)) = size G - 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∈ verts G"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Starting start of Dijkstra's algorithm satisfies the invariant.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dijkstra_start_inv</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size G &gt; 0 ⟹ inv G (dijkstra_start_state G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = {0::nat}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist G 0 0 ∧ dist G 0 0 = 0"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path G 0 0 [0]"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G 0 0 V ∧ dist_on G 0 0 V = 0"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 0 [0] V"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ verts G ∧ 0 ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈verts G. i ≠ 0 ⟶ has_dist_on G 0 i V ∧ dist_on G 0 i V = weight G 0 i"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = [0, i]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G 0 i p V"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set_on G 0 i V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p'∈path_set_on G 0 i V. path_weight G p' ≥ weight G 0 i"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>q</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable G q [n, last p']"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = path_join G q [n, last p']"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight G p' = path_weight G q + weight G 0 i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Step of Dijkstra's algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dijkstra_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ state ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra_step G m (State e M) =
    (let M' = delete_map m M;
         e' = list_update_set (λi. i ∈ keys_of M') (λi. min (e ! m + weight G m i) (e ! i)) e;
         M'' = map_update_all (λi. e' ! i) M'
     in State e' M'')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm dijkstra_step.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("dijkstra_step G m S", ["inv G S", "m ∈ unknown_set S"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_dist_on_larger</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_dist G m n ⟹ has_dist_on G m n V ⟹ dist_on G m n V = dist G m n ⟹
   has_dist_on G m n (V ∪ {x}) ∧ dist_on G m n (V ∪ {x}) = dist G m n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V' = V ∪ {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ path_set_on G m n V'"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ V'"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_on G m n p V'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_step_unknown_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ m ∈ unknown_set S ⟹ unknown_set (dijkstra_step G m S) = unknown_set S - {m}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_step_known_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ m ∈ unknown_set S ⟹ known_set (dijkstra_step G m S) = known_set S ∪ {m}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹One step of Dijkstra's algorithm preserves the invariant.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dijkstra_step_preserves_inv</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ is_heap_min m (heap S) ⟹ inv G (dijkstra_step G m S)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = known_set S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V' = V ∪ {m}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈V. has_dist G 0 i ∧ has_dist_on G 0 i V' ∧ dist_on G 0 i V' = dist G 0 i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist G 0 m ∧ dist G 0 m = dist_on G 0 m V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_dist_on G 0 m V' ∧ dist_on G 0 m V' = dist G 0 m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈verts G - V'. has_dist_on G 0 i V' ∧ dist_on G 0 i V' = min (dist_on G 0 i V) (dist_on G 0 m V + weight G m i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S' = dijkstra_step G m S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"known_dists G V'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈V'. est S' ! i = dist G 0 i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈verts G. est S' ! i = dist_on G 0 i V'"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ V'"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_dijkstra_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ state ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_dijkstra_step G S S' ⟷ (∃m. is_heap_min m (heap S) ∧ S' = dijkstra_step G m S)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_dijkstra_stepI</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap_min m (heap S) ⟹ dijkstra_step G m S = S' ⟹ is_dijkstra_step G S S'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_dijkstra_stepD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ is_dijkstra_step G S S' ⟹ inv G S'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_dijkstra_stepD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv G S ⟹ is_dijkstra_step G S S' ⟹ card (unknown_set S') = card (unknown_set S) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm is_dijkstra_step_def}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Interval">
<div class="head"><h1>Theory Interval</h1>
<span class="command">theory</span> <span class="name">Interval</span><br/>
<span class="keyword">imports</span> <a href="../Auto2_HOL/Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Interval.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Intervals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Interval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auto2_HOL.Auto2_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic definition of intervals.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of interval›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>interval</span><span> </span><span class="delimiter">=</span><span> </span><span>Interval</span><span> </span><span class="delimiter">(</span><span>low</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>high</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "interval"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>linorder</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a &lt; b) = (low a &lt; low b | (low a = low b ∧ high a &lt; high b))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_less_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ≤ b) = (low a &lt; low b | (low a = low b ∧ high a ≤ high b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x &lt; y) = (x ≤ y ∧ ¬ y ≤ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>int_less</span><span> </span><span>int_less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>int_less_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ z ⟹ x ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>int_less_eq</span><span> </span><span>dual_order.trans</span><span> </span><span>less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ x ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>int_less_eq</span><span> </span><span>a</span><span> </span><span>interval.expand</span><span> </span><span>int_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ∨ y ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>int_less_eq</span><span> </span><span>leI</span><span> </span><span>not_less_iff_gr_or_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) interval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval it ⟷ (low it ≤ high it)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of interval with an index›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>idx_interval</span><span> </span><span class="delimiter">=</span><span> </span><span>IdxInterval</span><span> </span><span class="delimiter">(</span><span>int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>idx</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "idx_interval"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>idx_interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>linorder</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iint_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a &lt; b) = (int a &lt; int b | (int a = int b ∧ idx a &lt; idx b))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iint_less_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ≤ b) = (int a &lt; int b | (int a = int b ∧ idx a ≤ idx b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a idx_interval"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x &lt; y) = (x ≤ y ∧ ¬ y ≤ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iint_less</span><span> </span><span>iint_less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iint_less_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ z ⟹ x ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>iint_less_eq</span><span> </span><span>dual_order.trans</span><span> </span><span>less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ x ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>idx_interval.expand</span><span> </span><span>iint_less</span><span> </span><span>iint_less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ∨ y ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>iint_less_eq</span><span> </span><span>leI</span><span> </span><span>not_less_iff_gr_or_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interval_less_to_le_low</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::('a::linorder idx_interval)) &lt; b ⟹ low (int a) ≤ low (int b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>iint_less</span><span> </span><span>int_less</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Overlapping intervals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_overlap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) interval ⇒ 'a interval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_overlap x y ⟷ (high x ≥ low y ∧ high y ≥ low x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_overlap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) idx_interval set ⇒ 'a interval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_overlap xs y ⟷ (∃x∈xs. is_overlap (int x) y)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Interval_Tree">
<div class="head"><h1>Theory Interval_Tree</h1>
<span class="command">theory</span> <span class="name">Interval_Tree</span><br/>
<span class="keyword">imports</span> <a href="Lists_Ex.html"><span class="name">Lists_Ex</span></a> <a href="Interval.html"><span class="name">Interval</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Interval_Tree.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interval tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Interval_Tree</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lists_Ex</span><span> </span><span>Interval</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Functional version of interval tree. This is an augmented data
  structure on top of regular binary search trees (see BST.thy).
  See \cite[Section 14.3]{cormen2009introduction} for a reference.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of an interval tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>interval_tree</span><span> </span><span class="delimiter">=</span><span>
</span><span>   </span><span>Tip</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span>interval_tree</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>tmax</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span>interval_tree</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tmax Tip = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm interval_tree.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms interval_tree.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm interval_tree.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_var_induct_rule @{thm interval_tree.induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inorder traversal, and set of elements of a tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>in_traverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ nat idx_interval list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_traverse Tip = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_traverse (Node l it m r) = in_traverse l @ it # in_traverse r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms in_traverse.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ nat idx_interval set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_set Tip = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_set (Node l it m r) = {it} ∪ tree_set l ∪ tree_set r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_set.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_sorted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted Tip = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l it m r) = ((∀x∈tree_set l. x &lt; it) ∧ (∀x∈tree_set r. it &lt; x)
                                   ∧ tree_sorted l ∧ tree_sorted r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_sorted.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_sorted_lr</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l it m r) ⟹ tree_sorted l ∧ tree_sorted r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_sortedD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l it m r) ⟹ x ∈ tree_set l ⟹ x &lt; it"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_sortedD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted (Node l it m r) ⟹ x ∈ tree_set r ⟹ x &gt; it"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inorder_preserve_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_set t = set (in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inorder_sorted</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟷ strict_sorted (in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Use definition in terms of in\_traverse from now on.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm (@{thms tree_set.simps} @ @{thms tree_sorted.simps})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant on the maximum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ nat ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max3 it b c = max (high (int it)) (max b c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_max_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv Tip = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv (Node l it m r) ⟷ (tree_max_inv l ∧ tree_max_inv r ∧ m = max3 it (tmax l) (tmax r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms tree_max_inv.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_max_is_max</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ it ∈ tree_set t ⟹ high (int it) ≤ tmax t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tmax_exists</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ t ≠ Tip ⟹ ∃p∈tree_set t. high (int p) = tmax t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l it m r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = Tip"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = Tip"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = Tip"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For insertion›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max3_insert</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max3 it 0 0 = high (int it)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm max3_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Condition on the values›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_interval_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_interval_inv t ⟷ (∀p∈tree_set t. is_interval (int p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_interval_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟷ (tree_sorted t ∧ tree_max_inv t ∧ tree_interval_inv t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_interval_tree_lr</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree (Node l x m r) ⟹ is_interval_tree l ∧ is_interval_tree r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ interval_tree ⇒ interval_tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert x Tip = Node Tip x (high (int x)) Tip"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert x (Node l y m r) =
    (if x = y then Node l y m r
     else if x &lt; y then
       let l' = insert x l in
           Node l' y (max3 y (tmax l') (tmax r)) r
     else
       let r' = insert x r in
           Node l y (max3 y (tmax l) (tmax r')) r')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms insert.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_insert_in_traverse</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ in_traverse (insert x t) = ordered_insert x (in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_insert_max_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ tree_max_inv (insert x t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of insertion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_insert_all_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟹ is_interval (int it) ⟹ is_interval_tree (insert it t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_insert_on_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_set (insert it t) = {it} ∪ tree_set t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletion on trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>del_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ nat idx_interval × interval_tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"del_min Tip = undefined"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"del_min (Node lt v m rt) =
   (if lt = Tip then (v, rt) else
    let lt' = snd (del_min lt) in
    (fst (del_min lt), Node lt' v (max3 v (tmax lt') (tmax rt)) rt))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm del_min.simps(2)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("del_min t", ["t ≠ Tip"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_del_hd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≠ Tip ⟹ fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm delete_min_del_hd} [with_term "in_traverse (snd (del_min ?t))"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_max_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ t ≠ Tip ⟹ tree_max_inv (snd (del_min t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_on_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≠ Tip ⟹ {fst (del_min t)} ∪ tree_set (snd (del_min t)) = tree_set t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm delete_min_on_set} [with_term "tree_set (snd (del_min ?t))"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_interval_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_interval_inv t ⟹ t ≠ Tip ⟹ tree_interval_inv (snd (del_min t))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_all_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟹ t ≠ Tip ⟹ is_interval_tree (snd (del_min t))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>delete_elt_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ interval_tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_elt_tree Tip = undefined"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_elt_tree (Node lt x m rt) =
    (if lt = Tip then rt else if rt = Tip then lt else
     let x' = fst (del_min rt);
         rt' = snd (del_min rt);
         m' = max3 x' (tmax lt) (tmax rt') in
       Node lt (fst (del_min rt)) m' rt')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm delete_elt_tree.simps(2)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_in_traverse</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_traverse (delete_elt_tree (Node lt x m rt)) = in_traverse lt @ in_traverse rt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_max_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ t ≠ Tip ⟹ tree_max_inv (delete_elt_tree t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_on_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≠ Tip ⟹ tree_set (delete_elt_tree (Node lt x m rt)) = tree_set lt ∪ tree_set rt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_interval_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_interval_inv t ⟹ t ≠ Tip ⟹ tree_interval_inv (delete_elt_tree t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_elt_all_inv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟹ t ≠ Tip ⟹ is_interval_tree (delete_elt_tree t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>delete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ interval_tree ⇒ interval_tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete x Tip = Tip"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"delete x (Node l y m r) =
    (if x = y then delete_elt_tree (Node l y m r)
     else if x &lt; y then
       let l' = delete x l;
           m' = max3 y (tmax l') (tmax r) in Node l' y m' r
     else
       let r' = delete x r;
           m' = max3 y (tmax l) (tmax r') in Node l y m' r')"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms delete.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_delete_in_traverse</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ in_traverse (delete x t) = remove_elt_list x (in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_delete_max_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_max_inv t ⟹ tree_max_inv (delete x t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of deletion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_delete_all_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟹ is_interval_tree (delete x t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_set (delete x t) ⊆ tree_set t"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_delete_on_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_sorted t ⟹ tree_set (delete x t) = tree_set t - {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search on interval trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>search</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ nat interval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"search Tip x = False"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"search (Node l y m r) x =
   (if is_overlap (int y) x then True
    else if l ≠ Tip ∧ tmax l ≥ low x then search l x
    else search r x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms search.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of search›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>search_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_interval_tree t ⟹ is_interval x ⟹ search t x ⟷ has_overlap (tree_set t) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l y m r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l y m r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int y) x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ Tip ∧ tmax l ≥ low x"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p∈tree_set l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"high (int p) = tmax l"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int p) x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = Tip"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@endgoal</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Quicksort">
<div class="head"><h1>Theory Quicksort</h1>
<span class="command">theory</span> <span class="name">Quicksort</span><br/>
<span class="keyword">imports</span> <a href="Arrays_Ex.html"><span class="name">Arrays_Ex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Quicksort.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Quicksort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Quicksort</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Arrays_Ex</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Functional version of quicksort.

  Implementation of quicksort is largely based on theory
  Imperative\_Quicksort in HOL/Imperative\_HOL/ex in the Isabelle
  library.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer remains›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>outer_remains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ nat ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟷ (length xs = length xs' ∧ (∀i. i &lt; l ∨ r &lt; i ⟶ xs ! i = xs' ! i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outer_remains_length</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟹ length xs = length xs'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outer_remains_eq</span><span> </span><span class="delimiter">[</span><span>rewrite_back</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟹ i &lt; l ⟹ xs ! i = xs' ! i"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟹ r &lt; i ⟹ xs ! i = xs' ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outer_remains_sublist</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟹ i &lt; l ⟹ take i xs = take i xs'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"outer_remains xs xs' l r ⟹ r &lt; i ⟹ drop i xs = drop i xs'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≤ j ⟹ j ≤ length xs ⟹ outer_remains xs xs' l r ⟹ j ≤ l ⟹ sublist i j xs = sublist i j xs'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≤ j ⟹ j ≤ length xs ⟹ outer_remains xs xs' l r ⟹ i &gt; r ⟹ sublist i j xs = sublist i j xs'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm outer_remains_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹part1 function›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>part1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) list ⇒ nat ⇒ nat ⇒ 'a ⇒ (nat × 'a list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a = (
     if r ≤ l then (r, xs)
     else if xs ! l ≤ a then part1 xs (l + 1) r a
     else part1 (list_swap xs l r) l (r - 1) a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ(_,l,r,_). r - l)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("part1 xs l r a", ["r &lt; length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("part1 xs l r a", "r &lt; length xs")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part1_basic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ l ≤ r ⟹ (rs, xs') = part1 xs l r a ⟹
   outer_remains xs xs' l r ∧ mset xs' = mset xs ∧ l ≤ rs ∧ rs ≤ r"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm part1_basic} [with_term "part1 ?xs ?l ?r ?a"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part1_partitions1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ (rs, xs') = part1 xs l r a ⟹ l ≤ i ⟹ i &lt; rs ⟹ xs' ! i ≤ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part1_partitions2</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ (rs, xs') = part1 xs l r a ⟹ rs &lt; i ⟹ i ≤ r ⟹ xs' ! i ≥ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paritition function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder list) ⇒ nat ⇒ nat ⇒ (nat × 'a list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"partition xs l r = (
    let p = xs ! r;
      (m, xs') = part1 xs l (r - 1) p;
      m' = if xs' ! m ≤ p then m + 1 else m
    in
      (m', list_swap xs' m' r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("partition xs l r", ["l &lt; r", "r &lt; length xs"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partition_basic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l &lt; r ⟹ r &lt; length xs ⟹ (rs, xs') = partition xs l r ⟹
   outer_remains xs xs' l r ∧ mset xs' = mset xs ∧ l ≤ rs ∧ rs ≤ r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm partition_basic} [with_term "partition ?xs ?l ?r"]›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partition_partitions1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l &lt; r ⟹ r &lt; length xs ⟹ (rs, xs') = partition xs l r ⟹
   x ∈ set (sublist l rs xs') ⟹ x ≤ xs' ! rs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; rs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = xs' ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partition_partitions2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l &lt; r ⟹ r &lt; length xs ⟹ (rs, xs'') = partition xs l r ⟹
   x ∈ set (sublist (rs + 1) (r + 1) xs'') ⟹ x ≥ xs'' ! rs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ rs + 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; r + 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = xs'' ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = xs ! r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = fst (part1 xs l (r - 1) p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = snd (part1 xs l (r - 1) p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' ! m ≤ p"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm partition_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_term1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬r ≤ l ⟹ ¬ length xs ≤ r ⟹ x = partition xs l r ⟹ (p, xs1) = x ⟹ p - Suc l &lt; r - l"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (partition xs l r) - l - 1 &lt; r - l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_term2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬r ≤ l ⟹ ¬ length xs ≤ r ⟹ x = partition xs l r ⟹ (p, xs2) = x ⟹ r - Suc p &lt; r - l"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r - fst (partition xs l r) - 1 &lt; r - l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Quicksort function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>quicksort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) list ⇒ nat ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r = (
    if l ≥ r then xs
    else if r ≥ length xs then xs
    else let
      (p, xs1) = partition xs l r;
      xs2 = quicksort xs1 l (p - 1)
    in
      quicksort xs2 (p + 1) r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ(a, l, r). (r - l))"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quicksort_term1</span><span> </span><span>quicksort_term2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_basic</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset (quicksort xs l r) = mset xs ∧ outer_remains xs (quicksort xs l r) l r"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_trivial1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l ≥ r ⟹ quicksort xs l r = xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_trivial2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ≥ length xs ⟹ quicksort xs l r = xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_permutes</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs' = quicksort xs l r ⟹ set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≥ r"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≥ length xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = take l xs @ sublist l (r + 1) xs @ drop (r + 1) xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = take l xs' @ sublist l (r + 1) xs' @ drop (r + 1) xs'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take l xs = take l xs'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop (r + 1) xs = drop (r + 1) xs'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_sorts</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ sorted (sublist l (r + 1) (quicksort xs l r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≥ r"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = r"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≥ length xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = fst (partition xs l r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs1 = snd (partition xs l r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs2 = quicksort xs1 l (p - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs3 = quicksort xs2 (p + 1) r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (sublist l (r + 1) xs3)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≤ p"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p + 1 ≤ r + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r + 1 ≤ length xs3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist l p xs2 = sublist l p xs3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (sublist l p xs1) = set (sublist l p xs2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist (p + 1) (r + 1) xs1 = sublist (p + 1) (r + 1) xs2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (sublist (p + 1) (r + 1) xs2) = set (sublist (p + 1) (r + 1) xs3)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈set (sublist l p xs3). x ≤ xs3 ! p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈set (sublist (p + 1) (r + 1) xs3). x ≥ xs3 ! p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (sublist l p xs3)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (sublist (p + 1) (r + 1) xs3)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist l (r + 1) xs3 = sublist l p xs3 @ (xs3 ! p) # sublist (p + 1) (r + 1) xs3"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort xs l r"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main result: correctness of functional quicksort.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>quicksort_sorts_all</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ quicksort xs 0 (length xs - 1) = sort xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = quicksort xs 0 (length xs - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sublist 0 (length xs - 1 + 1) xs' = xs'"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Indexed_PQueue">
<div class="head"><h1>Theory Indexed_PQueue</h1>
<span class="command">theory</span> <span class="name">Indexed_PQueue</span><br/>
<span class="keyword">imports</span> <a href="Arrays_Ex.html"><span class="name">Arrays_Ex</span></a> <a href="Mapping_Str.html"><span class="name">Mapping_Str</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Indexed_PQueue.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Indexed priority queues›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Indexed_PQueue</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Arrays_Ex</span><span> </span><span>Mapping_Str</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verification of indexed priority queue: functional part. The data
  structure is also verified by Lammich in
  \cite{Refine_Imperative_HOL-AFP}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Successor functions, eq-pred predicate›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>s1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 m = 2 * m + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>s2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 m = 2 * m + 2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s_inj</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s1 m = s1 m' ⟹ m = m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 m = s2 m' ⟹ m = m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s_neq</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s1 m ≠ s2 m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 m &gt; m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 m &gt; m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 m &gt; s1 m"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1.simps</span><span> </span><span>s2.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm s_neq(2)} [with_term "s1 ?m"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm s_neq(3)} [with_term "s2 ?m"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm s_neq(4)} [with_term "s2 ?m", with_term "s1 ?m"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>eq_pred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_pred n n"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred n m ⟹ eq_pred n (s1 m)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred n m ⟹ eq_pred n (s2 m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_case_induct_rule @{thm eq_pred.cases}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prop_induct_rule @{thm eq_pred.induct}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm eq_pred.intros(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_backward_prfstep @{thms eq_pred.intros(2,3)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_pred_parent1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_pred i (s1 k) ⟹ i ≠ s1 k ⟹ eq_pred i k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = s1 k"</span></span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i v"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_pred_parent2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_pred i (s2 k) ⟹ i ≠ s2 k ⟹ eq_pred i k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = s2 k"</span></span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i v"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_pred_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_pred i j ⟹ eq_pred (s1 i) j ∨ eq_pred (s2 i) j ∨ j = i ∨ j = s1 i ∨ j = s2 i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm eq_pred_cases} [with_cond "?i ≠ s1 ?k", with_cond "?i ≠ s2 ?k"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_pred_le</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i j ⟹ i ≤ j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Heap property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The corresponding tree is a heap›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b::linorder) list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap xs = (∀i j. eq_pred i j ⟶ j &lt; length xs ⟶ snd (xs ! i) ≤ snd (xs ! j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_heapD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap xs ⟹ j &lt; length xs ⟹ eq_pred i j ⟹ snd (xs ! i) ≤ snd (xs ! j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm is_heapD} [with_term "?xs ! ?j"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm is_heap_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bubble-down›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The corresponding tree is a heap, except k is not necessarily smaller than its descendents.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_heap_partial1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b::linorder) list ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial1 xs k = (∀i j. eq_pred i j ⟶ i ≠ k ⟶ j &lt; length xs ⟶ snd (xs ! i) ≤ snd (xs ! j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two cases of switching with s1 k.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bubble_down1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s1 k &lt; length xs ⟹ is_heap_partial1 xs k ⟹ snd (xs ! k) &gt; snd (xs ! s1 k) ⟹
   snd (xs ! s1 k) ≤ snd (xs ! s2 k) ⟹ is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm bubble_down1} [with_term "list_swap ?xs ?k (s1 ?k)"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bubble_down2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s1 k &lt; length xs ⟹ is_heap_partial1 xs k ⟹ snd (xs ! k) &gt; snd (xs ! s1 k) ⟹
   s2 k ≥ length xs ⟹ is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm bubble_down2} [with_term "list_swap ?xs ?k (s1 ?k)"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹One case of switching with s2 k.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bubble_down3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s2 k &lt; length xs ⟹ is_heap_partial1 xs k ⟹ snd (xs ! s1 k) &gt; snd (xs ! s2 k) ⟹
   snd (xs ! k) &gt; snd (xs ! s2 k) ⟹ xs' = list_swap xs k (s2 k) ⟹ is_heap_partial1 xs' (s2 k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm bubble_down3} [with_term "?xs'"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bubble-up›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>par</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"par m = (m - 1) div 2"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("par m", ["m ≠ 0"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ps_inverse</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"par (s1 k) = k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"par (s2 k) = k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ 0 ⟹ par m &lt; m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm p_basic} [with_term "par ?m"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ 0 ⟹ m = s1 (par m) ∨ m = s2 (par m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm p_cases} [with_term "par ?m"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_pred_p_next</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≠ 0 ⟹ eq_pred i j ⟹ eq_pred (par i) j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm eq_pred_p_next} [with_term "par ?i"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_implies_hd_min</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap xs ⟹ i &lt; length xs ⟹ xs ≠ [] ⟹ snd (hd xs) ≤ snd (xs ! i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"par i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_pred (par i) i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The corresponding tree is a heap, except k is not necessarily greater than its ancestors.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_heap_partial2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b::linorder) list ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial2 xs k = (∀i j. eq_pred i j ⟶ j &lt; length xs ⟶ j ≠ k ⟶ snd (xs ! i) ≤ snd (xs ! j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bubble_up1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length xs ⟹ is_heap_partial2 xs k ⟹ snd (xs ! k) &lt; snd (xs ! par k) ⟹ k ≠ 0 ⟹
   is_heap_partial2 (list_swap xs k (par k)) (par k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bubble_up2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length xs ⟹ is_heap_partial2 xs k ⟹ snd (xs ! k) ≥ snd (xs ! par k) ⟹ k ≠ 0 ⟹
   is_heap xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm p_cases}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Indexed priority queue›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>idx_pqueue</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × 'a) list × nat option list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>index_of_pqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a idx_pqueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) = (
    (∀i&lt;length xs. fst (xs ! i) &lt; length m ∧ m ! (fst (xs ! i)) = Some i) ∧
    (∀i. ∀k&lt;length m. m ! k = Some i ⟶ i &lt; length xs ∧ fst (xs ! i) = k))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm index_of_pqueue.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_of_pqueueD1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ index_of_pqueue (xs, m) ⟹
   fst (xs ! i) &lt; length m ∧ m ! (fst (xs ! i)) = Some i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm index_of_pqueueD1} [with_term "?xs ! ?i"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_of_pqueueD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length m ⟹ index_of_pqueue (xs, m) ⟹
   m ! k = Some i ⟹ i &lt; length xs ∧ fst (xs ! i) = k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_of_pqueueD3</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ p ∈ set xs ⟹ fst p &lt; length m"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ! i = p"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm index_of_pqueue.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_index_unique_key</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ unique_keys_set (set xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a x y. (a, x) ∈ set xs ⟶ (a, y) ∈ set xs ⟶ x = y"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ! i = (a, x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ! j = (a, y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_index_keys_of</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ has_key_alist xs k ⟷ (k &lt; length m ∧ m ! k ≠ None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_key_alist xs k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>v'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(k, v') ∈ set xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ∧ xs ! i = (k, v')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_index_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ distinct xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length xs. ∀j&lt;length xs. i ≠ j ⟶ xs ! i ≠ xs ! j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations on indexed\_queue›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_pqueue_swap_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × 'a) list × nat option list ⇒ nat ⇒ nat ⇒ (nat × 'a) list × nat option list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap_fun (xs, m) i j = (
    list_swap xs i j, ((m [fst (xs ! i) := Some j]) [fst (xs ! j) := Some i]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_of_pqueue_swap</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ index_of_pqueue (xs, m) ⟹
   index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap_fun (xs, m) i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_idx_pqueue_swap</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap_fun (xs, m) i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_idx_pqueue_swap</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap_fun (xs, m) i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_pqueue_push_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a ⇒ 'a idx_pqueue ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_push_fun k v (xs, m) = (xs @ [(k, v)], list_update m k (Some (length xs)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_push_correct</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ k &lt; length m ⟹ ¬has_key_alist xs k ⟹
   r = idx_pqueue_push_fun k v (xs, m) ⟹
   index_of_pqueue r ∧ fst r = xs @ [(k, v)] ∧ length (snd r) = length m"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_push_fun k v (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_pqueue_pop_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a idx_pqueue ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_pop_fun (xs, m) = (butlast xs, list_update m (fst (last xs)) None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_pop_correct</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ xs ≠ [] ⟹ r = idx_pqueue_pop_fun (xs, m) ⟹
   index_of_pqueue r ∧ fst r = butlast xs ∧ length (snd r) = length m"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_pop_fun (xs, m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length (butlast xs) + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (xs ! length (butlast xs)) &lt; length m"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: remove? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bubble up and down›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>idx_bubble_down_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder idx_pqueue ⇒ nat ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun (xs, m) k = (
    if s2 k &lt; length xs then
      if snd (xs ! s1 k) ≤ snd (xs ! s2 k) then
        if snd (xs ! k) &gt; snd (xs ! s1 k) then
          idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s1 k)) (s1 k)
        else (xs, m)
      else
        if snd (xs ! k) &gt; snd (xs ! s2 k) then
          idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s2 k)) (s2 k)
        else (xs, m)
    else if s1 k &lt; length xs then
      if snd (xs ! k) &gt; snd (xs ! s1 k) then
        idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s1 k)) (s1 k)
      else (xs, m)
    else (xs, m))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ((xs,_),k). (length xs - k))"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto2</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_down_fun_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r = idx_bubble_down_fun x k ⟹ is_heap_partial1 (fst x) k ⟹
   is_heap (fst r) ∧ mset (fst r) = mset (fst x) ∧ length (snd r) = length (snd x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun (xs, m) k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 k &lt; length xs"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (xs ! s1 k) ≤ snd (xs ! s2 k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 k &lt; length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm idx_bubble_down_fun_correct} [with_term "?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_down_fun_correct2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue x ⟹ index_of_pqueue (idx_bubble_down_fun x k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun (xs, m) k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 k &lt; length xs"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (xs ! s1 k) ≤ snd (xs ! s2 k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 k &lt; length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_bubble_up_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder idx_pqueue ⇒ nat ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun (xs, m) k = (
    if k = 0 then (xs, m)
    else if k &lt; length xs then
      if snd (xs ! k) &lt; snd (xs ! par k) then
        idx_bubble_up_fun (idx_pqueue_swap_fun (xs, m) k (par k)) (par k)
      else (xs, m)
    else (xs, m))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_up_fun_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r = idx_bubble_up_fun x k ⟹ is_heap_partial2 (fst x) k ⟹
   is_heap (fst r) ∧ mset (fst r) = mset (fst x) ∧ length (snd r) = length (snd x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun (xs, m) k"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm idx_bubble_up_fun_correct} [with_term "?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_up_fun_correct2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue x ⟹ index_of_pqueue (idx_bubble_up_fun x k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun (xs, m) k"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>delete_min_idx_pqueue_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder idx_pqueue ⇒ (nat × 'a) × 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_min_idx_pqueue_fun (xs, m) = (
    let (xs', m') = idx_pqueue_swap_fun (xs, m) 0 (length xs - 1);
        a'' = idx_pqueue_pop_fun (xs', m')
     in (last xs', idx_bubble_down_fun a'' 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_idx_pqueue_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ xs ≠ [] ⟹ res = delete_min_idx_pqueue_fun (xs, m) ⟹
   index_of_pqueue (snd res)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_min_idx_pqueue_fun (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm delete_min_idx_pqueue_correct} [with_term "?res"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hd_last_swap_eval_last</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ last (list_swap xs 0 (length xs - 1)) = hd xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = list_swap xs 0 (length xs - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last xs' = xs' ! (length xs - 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of delete-min.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>delete_min_idx_pqueue_correct2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap xs ⟹ xs ≠ [] ⟹ res = delete_min_idx_pqueue_fun (xs, m) ⟹ index_of_pqueue (xs, m) ⟹
   is_heap (fst (snd res)) ∧ fst res = hd xs ∧ length (snd (snd res)) = length m ∧
   map_of_alist (fst (snd res)) = delete_map (fst (fst res)) (map_of_alist xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_min_idx_pqueue_fun (xs, m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = list_swap xs 0 (length xs - 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial1 (butlast xs') 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm delete_min_idx_pqueue_correct2} [with_term "?res"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert_idx_pqueue_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::linorder ⇒ 'a idx_pqueue ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert_idx_pqueue_fun k v x = (
    let x' = idx_pqueue_push_fun k v x in
      idx_bubble_up_fun x' (length (fst x') - 1))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_idx_pqueue_correct</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ k &lt; length m ⟹ ¬has_key_alist xs k ⟹
   index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert_idx_pqueue_fun k v (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of insertion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_idx_pqueue_correct2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ is_heap xs ⟹ k &lt; length m ⟹ ¬has_key_alist xs k ⟹
   r = insert_idx_pqueue_fun k v (xs, m) ⟹
   is_heap (fst r) ∧ length (snd r) = length m ∧
   map_of_alist (fst r) = map_of_alist xs { k → v }"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert_idx_pqueue_fun k v (xs, m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial2 (xs @ [(k, v)]) (length xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm insert_idx_pqueue_correct2} [with_term "?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>update_idx_pqueue_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::linorder ⇒ 'a idx_pqueue ⇒ 'a idx_pqueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"update_idx_pqueue_fun k v (xs, m) = (
    if m ! k = None then
      insert_idx_pqueue_fun k v (xs, m)
    else let
      i = the (m ! k);
      xs' = list_update xs i (k, v)
    in
      if snd (xs ! i) ≤ v then idx_bubble_down_fun (xs', m) i
      else idx_bubble_up_fun (xs', m) i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>update_idx_pqueue_correct</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ k &lt; length m ⟹
   index_of_pqueue (update_idx_pqueue_fun k v (xs, m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_idx_pqueue_fun k v (xs, m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = the (m ! k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = list_update xs i (k, v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ! k = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs', m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of update.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>update_idx_pqueue_correct2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue (xs, m) ⟹ is_heap xs ⟹ k &lt; length m ⟹
   r = update_idx_pqueue_fun k v (xs, m) ⟹
   is_heap (fst r) ∧ length (snd r) = length m ∧
   map_of_alist (fst r) = map_of_alist xs { k → v }"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_idx_pqueue_fun k v (xs, m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = the (m ! k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = list_update xs i (k, v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = fst (xs', m)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: remove *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ! k = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (xs ! the (m ! k)) ≤ v"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial1 xs' i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_heap_partial2 xs' i"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm update_idx_pqueue_correct2} [with_term "?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RBTree">
<div class="head"><h1>Theory RBTree</h1>
<span class="command">theory</span> <span class="name">RBTree</span><br/>
<span class="keyword">imports</span> <a href="Lists_Ex.html"><span class="name">Lists_Ex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: RBTree.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Red-black trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RBTree</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lists_Ex</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verification of functional red-black trees. For general technique,
  see Lists\_Ex.thy.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of RBT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>color</span><span> </span><span class="delimiter">=</span><span> </span><span>R</span><span> </span><span class="delimiter">|</span><span> </span><span>B</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>rbt</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>Leaf</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cl</span><span class="delimiter">:</span><span> </span><span>color</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>key</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl Leaf = B"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm color.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm rbt.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm rbt.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_var_induct_rule @{thm rbt.induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_R</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ R ⟹ c = B"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>color.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_B</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ B ⟹ c = R"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>color.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_not_leaf</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl t = R ⟹ t ≠ Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹RBT invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>black_depth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_depth Leaf = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"black_depth (Node l R k v r) = black_depth l"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"black_depth (Node l B k v r) = black_depth l + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms black_depth.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cl_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv Leaf = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv (Node l R k v r) = (cl_inv l ∧ cl_inv r ∧ cl l = B ∧ cl r = B)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv (Node l B k v r) = (cl_inv l ∧ cl_inv r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms cl_inv.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bd_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv Leaf = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"bd_inv (Node l c k v r) = (bd_inv l ∧ bd_inv r ∧ black_depth l = black_depth r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms bd_inv.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_rbt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rbt t = (cl_inv t ∧ bd_inv t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_invI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv l ⟹ cl_inv r ⟹ cl_inv (Node l B k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm cl_invI} [with_term "Node ?l B ?k ?v ?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bd_invI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ black_depth l = black_depth r ⟹ bd_inv (Node l c k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm bd_invI} [with_term "Node ?l ?c ?k ?v ?r"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_rbt_rec</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rbt (Node l c k v r) ⟹ is_rbt l ∧ is_rbt r"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = R"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Balancedness of RBT›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: remove after having general normalization procedure for nats. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_distrib</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat) * (a + 1) = 2 * a + 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>min_depth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_depth Leaf = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_depth (Node l c k v r) = min (min_depth l) (min_depth r) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms min_depth.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>max_depth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_depth Leaf = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth (Node l c k v r) = max (max_depth l) (max_depth r) + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms max_depth.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Balancedness of red-black trees.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_balanced</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rbt t ⟹ max_depth t ≤ 2 * min_depth t + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rbt t ⟶ black_depth t ≤ min_depth t"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l c k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = R"</span></span></span><span> </span><span class="keyword1"><span class="command">@endgoal</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rbt t ⟶ (if cl t = R then max_depth t ≤ 2 * black_depth t + 1
                               else max_depth t ≤ 2 * black_depth t)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l c k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = R"</span></span></span><span> </span><span class="keyword1"><span class="command">@endgoal</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_depth t ≤ 2 * black_depth t + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition and basic properties of cl\_inv'›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cl_inv'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' Leaf = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv' (Node l c k v r) = (cl_inv l ∧ cl_inv r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms cl_inv'.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_inv'B</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">,</span><span> </span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' t ⟹ cl t = B ⟹ cl_inv t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_inv'R</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' (Node l R k v r) ⟹ cl l = B ⟹ cl r = B ⟹ cl_inv (Node l R k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_inv_to_cl_inv'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv t ⟹ cl_inv' t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl t = R"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_inv'I</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv l ⟹ cl_inv r ⟹ cl_inv' (Node l c k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set of keys, sortedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_in_traverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse Leaf = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse (Node l c k v r) = rbt_in_traverse l @ k # rbt_in_traverse r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_in_traverse.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_set Leaf = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_set (Node l c k v r) = {k} ∪ rbt_set l ∪ rbt_set r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_set.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_in_traverse_pairs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ ('a × 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs Leaf = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (Node l c k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_in_traverse_pairs.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_in_traverse_fst</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ ('a, 'b) map"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_map t = map_of_alist (rbt_in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm rbt_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_sorted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder, 'b) rbt ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted Leaf = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted (Node l c k v r) = ((∀x∈rbt_set l. x &lt; k) ∧ (∀x∈rbt_set r. k &lt; x) ∧ rbt_sorted l ∧ rbt_sorted r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_sorted.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_sorted_lr</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted (Node l c k v r) ⟹ rbt_sorted l ∧ rbt_sorted r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_inorder_preserve_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_set t = set (rbt_in_traverse t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_inorder_sorted</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟷ strict_sorted (map fst (rbt_in_traverse_pairs t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm (@{thms rbt_set.simps} @ @{thms rbt_sorted.simps})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Balance function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>balanceR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"balanceR l k v r =
   (if cl r = R then
      let lr = lsub r; rr = rsub r in
      if cl lr = R then Node (Node l B k v (lsub lr)) R (key lr) (val lr) (Node (rsub lr) B (key r) (val r) rr)
      else if cl rr = R then Node (Node l B k v lr) R (key r) (val r) (Node (lsub rr) B (key rr) (val rr) (rsub rr))
      else Node l B k v r
    else Node l B k v r)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>balance</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"balance l k v r =
   (if cl l = R then
      let ll = lsub l; rl = rsub l in
      if cl ll = R then Node (Node (lsub ll) B (key ll) (val ll) (rsub ll)) R (key l) (val l) (Node (rsub l) B k v r)
      else if cl rl = R then Node (Node (lsub l) B (key l) (val l) (lsub rl)) R (key rl) (val rl) (Node (rsub rl) B k v r)
      else balanceR l k v r
    else balanceR l k v r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("balance l k v r", ["black_depth l = black_depth r"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("balance l k v r", "black_depth l = black_depth r")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_non_Leaf</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"balance l k v r ≠ Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_bdinv</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ black_depth l = black_depth r ⟹ bd_inv (balance l k v r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bd_inv (balanceR l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_bd</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ black_depth l = black_depth r ⟹
   black_depth (balance l k v r) = black_depth l + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"black_depth (balanceR l k v r) = black_depth l + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_cl1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' l ⟹ cl_inv r ⟹ cl_inv (balance l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_cl2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv l ⟹ cl_inv' r ⟹ cl_inv (balance l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balanceR_inorder_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (balanceR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_inorder_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (balance l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm [@{thm balanceR_def}, @{thm balance_def}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ins function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::order ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins x v Leaf = Node Leaf R x v Leaf"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ins x v (Node l c y w r) =
   (if c = B then
     (if x = y then Node l B x v r
      else if x &lt; y then balance (ins x v l) y w r
      else balance l y w (ins x v r))
    else
     (if x = y then Node l R x v r
      else if x &lt; y then Node (ins x v l) R y w r
      else Node l R y w (ins x v r)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms ins.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_non_Leaf</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ins x v t ≠ Leaf"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_inv_ins</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv t ⟹ cl_inv' (ins x v t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv t ⟶ (if cl t = B then cl_inv (ins x v t) else cl_inv' (ins x v t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bd_inv_ins</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv t ⟹ bd_inv (ins x v t) ∧ black_depth t = black_depth (ins x v t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond (conj_left_th @{thm bd_inv_ins}) [with_term "ins ?x ?v ?t"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_inorder_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_in_traverse_pairs (ins x v t) = ordered_insert_pairs x v (rbt_in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paint function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>paint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"color ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"paint c Leaf = Leaf"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"paint c (Node l c' x v r) = Node l c x v r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms paint.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("paint c t", ["t ≠ Leaf"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("paint c t", "t ≠ Leaf")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>paint_cl_inv'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cl_inv' t ⟹ cl_inv' (paint c t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>paint_bd_inv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bd_inv t ⟹ bd_inv (paint c t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>paint_bd</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv t ⟹ t ≠ Leaf ⟹ cl t = B ⟹ black_depth (paint R t) = black_depth t - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>paint_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (paint c t) = rbt_in_traverse_pairs t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insert function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::order ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_insert x v t = paint B (ins x v t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness results for insertion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_is_rbt</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rbt t ⟹ is_rbt (rbt_insert x v t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_sorted (rbt_insert x v t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_rbt_map</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_map (rbt_insert x v t) = (rbt_map t) {x → v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search on sorted trees and its correctness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_search</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ord, 'b) rbt ⇒ 'a ⇒ 'b option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_search Leaf x = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_search (Node l c y w r) x =
  (if x = y then Some w
   else if x &lt; y then rbt_search l x
   else rbt_search r x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_search.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of search›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_search_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_search t x = (rbt_map t)⟨x⟩"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹balL and balR›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>balL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"balL l k v r = (let lr = lsub r in
   if cl l = R then Node (Node (lsub l) B (key l) (val l) (rsub l)) R k v r
   else if r = Leaf then Node l R k v r
   else if cl r = B then balance l k v (Node (lsub r) R (key r) (val r) (rsub r))
   else if lr = Leaf then Node l R k v r
   else if cl lr = B then
     Node (Node l B k v (lsub lr)) R (key lr) (val lr) (balance (rsub lr) (key r) (val r) (paint R (rsub r)))
   else Node l R k v r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("balL l k v r", ["black_depth l + 1 = black_depth r"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("balL l k v r", "black_depth l + 1 = black_depth r")›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>balR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"balR l k v r = (let rl = rsub l in
   if cl r = R then Node l R k v (Node (lsub r) B (key r) (val r) (rsub r))
   else if l = Leaf then Node l R k v r
   else if cl l = B then balance (Node (lsub l) R (key l) (val l) (rsub l)) k v r
   else if rl = Leaf then Node l R k v r
   else if cl rl = B then
     Node (balance (paint R (lsub l)) (key l) (val l) (lsub rl)) R (key rl) (val rl) (Node (rsub rl) B k v r)
   else Node l R k v r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("balR l k v r", ["black_depth l = black_depth r + 1"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("balR l k v r", "black_depth l = black_depth r + 1")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_bd</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ cl r = B ⟹ black_depth l + 1 = black_depth r ⟹
   bd_inv (balL l k v r) ∧ black_depth (balL l k v r) = black_depth l + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_bd'</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ cl_inv r ⟹ black_depth l + 1 = black_depth r ⟹
   bd_inv (balL l k v r) ∧ black_depth (balL l k v r) = black_depth l + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_cl</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' l ⟹ cl_inv r ⟹ cl r = B ⟹ cl_inv (balL l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_cl'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv' l ⟹ cl_inv r ⟹ cl_inv' (balL l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balR_bd</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv l ⟹ bd_inv r ⟹ cl_inv l ⟹ black_depth l = black_depth r + 1 ⟹
   bd_inv (balR l k v r) ∧ black_depth (balR l k v r) = black_depth l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balR_cl</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv l ⟹ cl_inv' r ⟹ cl l = B ⟹ cl_inv (balR l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balR_cl'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv l ⟹ cl_inv' r ⟹ cl_inv' (balR l k v r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (balL l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balR_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (balR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm [@{thm balL_def}, @{thm balR_def}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combine›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>combine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"combine Leaf t = t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"combine t Leaf = t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2) = (
   if c1 = R then
     if c2 = R then
       let tm = combine r1 l2 in
         if cl tm = R then
           Node (Node l1 R k1 v1 (lsub tm)) R (key tm) (val tm) (Node (rsub tm) R k2 v2 r2)
         else
           Node l1 R k1 v1 (Node tm R k2 v2 r2)
     else
       Node l1 R k1 v1 (combine r1 (Node l2 c2 k2 v2 r2))
   else
     if c2 = B then
       let tm = combine r1 l2 in
         if cl tm = R then
           Node (Node l1 B k1 v1 (lsub tm)) R (key tm) (val tm) (Node (rsub tm) B k2 v2 r2)
         else
           balL l1 k1 v1 (Node tm B k2 v2 r2)
     else
       Node (combine (Node l1 c1 k1 v1 r1) l2) R k2 v2 r2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms combine.simps(1,2)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>combine_bd</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv lt ⟹ bd_inv rt ⟹ black_depth lt = black_depth rt ⟹
   bd_inv (combine lt rt) ∧ black_depth (combine lt rt) = black_depth lt"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine lt rt"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c2 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (combine r1 l2) = B"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (Node (combine r1 l2) B k2 v2 r2) = B"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>combine_cl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv lt ⟹ cl_inv rt ⟹
   (cl lt = B ⟶ cl rt = B ⟶ cl_inv (combine lt rt)) ∧ cl_inv' (combine lt rt)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine lt rt"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c2 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (combine r1 l2) = B"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (Node (combine r1 l2) B k2 v2 r2) = B"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm combine_cl} [with_term "combine ?lt ?rt"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>combine_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (combine lt rt) = rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine lt rt"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 = R"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c2 = R"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (combine r1 l2) = R"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)) =
             rbt_in_traverse_pairs l1 @ (k1, v1) # rbt_in_traverse_pairs (combine r1 l2) @ (k2, v2) # rbt_in_traverse_pairs r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c2 = B"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl (combine r1 l2) = R"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_in_traverse_pairs (combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)) =
             rbt_in_traverse_pairs l1 @ (k1, v1) # rbt_in_traverse_pairs (combine r1 l2) @ (k2, v2) # rbt_in_traverse_pairs r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>del</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"del x Leaf = Leaf"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"del x (Node l _ k v r) =
    (if x = k then combine l r
     else if x &lt; k then
       if l = Leaf then Node Leaf R k v r
       else if cl l = B then balL (del x l) k v r
       else Node (del x l) R k v r
     else
       if r = Leaf then Node l R k v Leaf
       else if cl r = B then balR l k v (del x r)
       else Node l R k v (del x r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm del.simps(1)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>del_bd</span><span> </span><span class="delimiter">[</span><span>forward_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bd_inv t ⟹ cl_inv t ⟹ bd_inv (del x t) ∧ (
    if cl t = R then black_depth (del x t) = black_depth t
    else black_depth (del x t) = black_depth t - 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l c k v r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"del x (Node l c k v r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = k"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl l = B"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &gt; k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cl r = B"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>del_cl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cl_inv t ⟹ if cl t = R then cl_inv (del x t) else cl_inv' (del x t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l c k v r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"del x (Node l c k v r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = k"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm del_cl} [with_term "del ?x ?t"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>del_in_traverse_pairs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_in_traverse_pairs (del x t) = remove_elt_pairs x (rbt_in_traverse_pairs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Node l c k v r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"del x (Node l c k v r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>delete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete x t = paint B (del x t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness results for deletion.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>delete_is_rbt</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rbt t ⟹ is_rbt (delete x t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>delete_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_sorted (delete x t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>delete_rbt_map</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_sorted t ⟹ rbt_map (delete x t) = delete_map x (rbt_map t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep "RBTree.balance_case"›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep "RBTree.balL_case"›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep "RBTree.balR_case"›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep "RBTree.paint_case"›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Rect_Intersect">
<div class="head"><h1>Theory Rect_Intersect</h1>
<span class="command">theory</span> <span class="name">Rect_Intersect</span><br/>
<span class="keyword">imports</span> <a href="Interval_Tree.html"><span class="name">Interval_Tree</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Rect_Intersect.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rectangle intersection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Rect_Intersect</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Interval_Tree</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Functional version of algorithm for detecting rectangle intersection.
  See \cite[Exercise 14.3-7]{cormen2009introduction} for a reference.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of rectangles›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>rectangle</span><span> </span><span class="delimiter">=</span><span> </span><span>Rectangle</span><span> </span><span class="delimiter">(</span><span>xint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>yint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "rectangle"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_rect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect rect ⟷ is_interval (xint rect) ∧ is_interval (yint rect)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_rect_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟷ (∀i&lt;length rects. is_rect (rects ! i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_rect_listD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ i &lt; length rects ⟹ is_rect (rects ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm is_rect_listD} [with_term "?rects ! ?i"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm is_rect_list_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_rect_overlap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle ⇒ ('a::linorder) rectangle ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_overlap A B ⟷ (is_overlap (xint A) (xint B) ∧ is_overlap (yint A) (yint B))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_rect_overlap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_rect_overlap As ⟷ (∃i&lt;length As. ∃j&lt;length As. i ≠ j ∧ is_rect_overlap (As ! i) (As ! j))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹INS / DEL operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>operation</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>INS</span><span> </span><span class="delimiter">(</span><span>pos</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>op_idx</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>op_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>DEL</span><span> </span><span class="delimiter">(</span><span>pos</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>op_idx</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>op_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a interval"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule_back @{thms operation.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms operation.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms operation.case}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm operation.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm operation.disc(1)} [with_term "INS ?x11.0 ?x12.0 ?x13.0"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm operation.disc(2)} [with_term "DEL ?x21.0 ?x22.0 ?x23.0"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>operation</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>linorder</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a &lt; b) = (if pos a ≠ pos b then pos a &lt; pos b else
                             if is_INS a ≠ is_INS b then is_INS a ∧ ¬is_INS b
                             else if op_idx a ≠ op_idx b then op_idx a &lt; op_idx b else op_int a &lt; op_int b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ≤ b) = (if pos a ≠ pos b then pos a &lt; pos b else
                              if is_INS a ≠ is_INS b then is_INS a ∧ ¬is_INS b
                              else if op_idx a ≠ op_idx b then op_idx a &lt; op_idx b else op_int a ≤ op_int b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a operation"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x &lt; y) = (x ≤ y ∧ ¬ y ≤ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Rect_Intersect.less</span><span> </span><span>Rect_Intersect.less_eq</span><span> </span><span>leD</span><span> </span><span>le_cases3</span><span> </span><span>not_less_iff_gr_or_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.less_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ z ⟹ x ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Rect_Intersect.less</span><span> </span><span>Rect_Intersect.less_eq</span><span> </span><span>a</span><span> </span><span>dual_order.trans</span><span> </span><span>less_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ y ≤ x ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rect_Intersect.less</span><span> </span><span>Rect_Intersect.less_eq</span><span> </span><span>a</span><span> </span><span>le_imp_less_or_eq</span><span> </span><span>operation.expand</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ∨ y ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule [@{thm less_eq}, @{thm less}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>operation_leD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::('a::linorder operation)) ≤ b ⟹ pos a ≤ pos b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>operation_lessI</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p1 ≤ p2 ⟹ INS p1 n1 i1 &lt; DEL p2 n2 i2"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (INS p1 n1 i1) = True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (DEL p2 n2 i2) = False"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm [@{thm less_eq}, @{thm less}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set of operations corresponding to a list of rectangles›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ins_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ nat ⇒ ('a::linorder) operation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins_op rects i = INS (low (yint (rects ! i))) i (xint (rects ! i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm ins_op.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>del_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ nat ⇒ ('a::linorder) operation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"del_op rects i = DEL (high (yint (rects ! i))) i (xint (rects ! i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm del_op.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ins_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ ('a::linorder) operation list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins_ops rects = list (λi. ins_op rects i) (length rects)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>del_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ ('a::linorder) operation list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"del_ops rects = list (λi. del_op rects i) (length rects)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_ops_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (ins_ops rects)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = ins_ops rects"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length xs. ∀j&lt;length xs. i ≠ j ⟶ xs ! i ≠ xs ! j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>del_ops_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (del_ops rects)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = del_ops rects"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length xs. ∀j&lt;length xs. i ≠ j ⟶ xs ! i ≠ xs ! j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_ins_ops</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oper ∈ set (ins_ops rects) ⟷ op_idx oper &lt; length rects ∧ oper = ins_op rects (op_idx oper)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oper ∈ set (ins_ops rects)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length rects"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ins_ops rects ! i = oper"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"op_idx oper &lt; length rects ∧ oper = ins_op rects (op_idx oper)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oper = (ins_ops rects) ! (op_idx oper)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_del_ops</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oper ∈ set (del_ops rects) ⟷ op_idx oper &lt; length rects ∧ oper = del_op rects (op_idx oper)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oper ∈ set (del_ops rects)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length rects"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"del_ops rects ! i = oper"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"op_idx oper &lt; length rects ∧ oper = del_op rects (op_idx oper)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oper = (del_ops rects) ! (op_idx oper)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ ('a::linorder) operation list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"all_ops rects = sort (ins_ops rects @ del_ops rects)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_ops_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (all_ops rects)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (ins_ops rects @ del_ops rects)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_all_ops_idx</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oper ∈ set (all_ops rects) ⟹ op_idx oper &lt; length rects"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_all_ops_ins</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"INS p n i ∈ set (all_ops rects) ⟹ INS p n i = ins_op rects n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_all_ops_del</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"DEL p n i ∈ set (all_ops rects) ⟹ DEL p n i = del_op rects n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_in_set_all_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length rects ⟹ ins_op rects i ∈ set (all_ops rects)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm ins_in_set_all_ops} [with_term "ins_op ?rects ?i"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>del_in_set_all_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length rects ⟹ del_op rects i ∈ set (all_ops rects)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm del_in_set_all_ops} [with_term "del_op ?rects ?i"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_ops_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (all_ops rects)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_ops_nonempty</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rects ≠ [] ⟹ all_ops rects ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (all_ops rects) &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm all_ops_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Applying a set of operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>apply_ops_k</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ nat ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"apply_ops_k rects k = (let ops = all_ops rects in
     {i. i &lt; length rects ∧ (∃j&lt;k. ins_op rects i = ops ! j) ∧ ¬(∃j&lt;k. del_op rects i = ops ! j)})"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("apply_ops_k rects k", ["k &lt; length (all_ops rects)"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_ops_set_mem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ops = all_ops rects ⟹
   i ∈ apply_ops_k rects k ⟷ (i &lt; length rects ∧ (∃j&lt;k. ins_op rects i = ops ! j) ∧ ¬(∃j&lt;k. del_op rects i = ops ! j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm apply_ops_k_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>xints_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rectangle list ⇒ nat set ⇒ (('a::linorder) idx_interval) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xints_of rect is = (λi. IdxInterval (xint (rect ! i)) i) ` is"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>xints_of_mem</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IdxInterval it i ∈ xints_of rect is ⟷ (i ∈ is ∧ xint (rect ! i) = it)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xints_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>xints_diff</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xints_of rects (A - B) = xints_of rects A - xints_of rects B"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj (λi. IdxInterval (xint (rects ! i)) i)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_overlap_at_k</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_overlap_at_k rects k ⟷ (
    let S = apply_ops_k rects k; ops = all_ops rects in
      is_INS (ops ! k) ∧ has_overlap (xints_of rects S) (op_int (ops ! k)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("has_overlap_at_k rects k", ["k &lt; length (all_ops rects)"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_overlap_at_k_equiv</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ k &lt; length ops ⟹
   has_overlap_at_k rects k ⟹ has_rect_overlap rects"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = apply_ops_k rects k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_overlap (xints_of rects S) (op_int (ops ! k))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' ∈ xints_of rects S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int xs') (op_int (ops ! k))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = int xs'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = idx xs'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j = op_idx (ops ! k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k = ins_op rects j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≠ j"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@contradiction</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>k'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k' &lt; k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k' = ins_op rects i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k = ops ! k'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"low (yint (rects ! i)) ≤ pos (ops ! k)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>k'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k' &lt; k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k' = ins_op rects i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k' ≤ ops ! k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"high (yint (rects ! i)) ≥ pos (ops ! k)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>k'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k' &lt; length ops"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k' = del_op rects i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k' ≥ ops ! k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rect_overlap (rects ! i) (rects ! j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_overlap_at_k_equiv2</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ has_rect_overlap rects ⟹
   ∃k&lt;length ops. has_overlap_at_k rects k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length rects"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length rects"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≠ j"</span></span></span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"is_rect_overlap (rects ! i) (rects ! j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rect_overlap (rects ! j) (rects ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; length ops"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! i1 = ins_op rects i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>j1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j1 &lt; length ops"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! j1 = ins_op rects j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; length ops"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! i2 = del_op rects i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>j2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j2 &lt; length ops"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! j2 = del_op rects j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ins_op rects i &lt; ins_op rects j"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; j1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j1 &lt; i2"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! j1 &lt; ops ! i2"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int (IdxInterval (xint (rects ! i)) i)) (xint (rects ! j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_overlap_at_k rects j1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ins_op rects j &lt; ins_op rects i"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j1 &lt; i1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; j2"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! i1 &lt; ops ! j2"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int (IdxInterval (xint (rects ! j)) j)) (xint (rects ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_overlap_at_k rects i1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_overlap_lst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_overlap_lst rects = (let ops = all_ops rects in (∃k&lt;length ops. has_overlap_at_k rects k))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_overlap_equiv</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ has_overlap_lst rects ⟷ has_rect_overlap rects"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of apply\_ops\_k›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_ops_k_next1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ n &lt; length ops ⟹ is_INS (ops ! n) ⟹
   apply_ops_k rects (n + 1) = apply_ops_k rects n ∪ {op_idx (ops ! n)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. i∈apply_ops_k rects (n + 1) ⟷ i∈apply_ops_k rects n ∪ {op_idx (ops ! n)}"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ apply_ops_k rects n ∪ {op_idx (ops ! n)}"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = op_idx (ops ! n)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>        </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ins_op rects i &lt; del_op rects i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_ops_k_next2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ n &lt; length ops ⟹ ¬is_INS (ops ! n) ⟹
   apply_ops_k rects (n + 1) = apply_ops_k rects n - {op_idx (ops ! n)}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>apply_ops_k_next</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::linorder) rectangle list ⇒ 'a idx_interval set ⇒ nat ⇒ 'a idx_interval set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"apply_ops_k_next rects S k = (let ops = all_ops rects in
   (case ops ! k of
      INS p n i ⇒ S ∪ {IdxInterval i n}
    | DEL p n i ⇒ S - {IdxInterval i n}))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm apply_ops_k_next_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_ops_k_next_is_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ n &lt; length ops ⟹
   S = xints_of rects (apply_ops_k rects n) ⟹
   xints_of rects (apply_ops_k rects (n + 1)) = apply_ops_k_next rects S n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (ops ! n)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>rect_inter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat rectangle list ⇒ nat idx_interval set ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects S k = (let ops = all_ops rects in
    if k ≥ length ops then False
    else if is_INS (ops ! k) then
      if has_overlap S (op_int (ops ! k)) then True
      else if k = length ops - 1 then False
      else rect_inter rects (apply_ops_k_next rects S k) (k + 1)
    else if k = length ops - 1 then False
      else rect_inter rects (apply_ops_k_next rects S k) (k + 1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ(rects,S,k). length (all_ops rects) - k)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rect_inter_correct_ind</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ n &lt; length ops ⟹
   rect_inter rects (xints_of rects (apply_ops_k rects n)) n ⟷
   (∃k&lt;length ops. k ≥ n ∧ has_overlap_at_k rects k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ints = xints_of rects (apply_ops_k rects n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects ints n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects ints n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ length ops"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (ops ! n) ∧ has_overlap ints (op_int (ops ! n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = length ops - 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of functional algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rect_inter_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ rect_inter rects {} 0 ⟷ has_rect_overlap rects"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{} = xints_of rects (apply_ops_k rects 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects {} 0 = has_overlap_lst rects"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects {} 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SepLogic_Base">
<div class="head"><h1>Theory SepLogic_Base</h1>
<span class="command">theory</span> <span class="name">SepLogic_Base</span><br/>
<span class="keyword">imports</span> <a href="../Auto2_HOL/Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: SepLogic_Base.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SepLogic_Base</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auto2_HOL.Auto2_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  General auto2 setup for separation logic. The automation defined
  here can be instantiated for different variants of separation logic.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sep_util_base.ML"</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assn_matcher.ML"</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sep_steps.ML"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SepAuto">
<div class="head"><h1>Theory SepAuto</h1>
<span class="command">theory</span> <span class="name">SepAuto</span><br/>
<span class="keyword">imports</span> <a href="SepLogic_Base.html"><span class="name">SepLogic_Base</span></a> <a href="Imperative_HOL.html"><span class="name">Imperative_HOL</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: SepAuto.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Separation logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SepAuto</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepLogic_Base</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Imperative_HOL.Imperative_HOL"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Separation logic for Imperative\_HOL, and setup of auto2. The development of
  separation logic here follows \cite{Separation_Logic_Imperative_HOL-AFP} by Lammich and Meis.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partial Heaps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>pheap</span><span> </span><span class="delimiter">=</span><span> </span><span>pHeap</span><span> </span><span class="delimiter">(</span><span>heapOf</span><span class="delimiter">:</span><span> </span><span>heap</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>addrOf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"addr set"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "pheap"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>in_range</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(heap × addr set) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_range (h,as) ⟷ (∀a∈as. a &lt; lim h)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm in_range.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two heaps agree on a set of addresses.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>relH</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"addr set ⇒ heap ⇒ heap ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' = (in_range (h, as) ∧ in_range (h', as) ∧
     (∀t. ∀a∈as. refs h t a = refs h' t a ∧ arrays h t a = arrays h' t a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_D</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ in_range (h, as) ∧ in_range (h', as)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_D2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ a ∈ as ⟹ refs h t a = refs h' t a"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ a ∈ as ⟹ arrays h t a = arrays h' t a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm relH_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_dist_union</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH (as ∪ as') h h' ⟹ relH as h h' ∧ relH as' h h'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_ref</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ addr_of_ref r ∈ as ⟹ Ref.get h r = Ref.get h' r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ref.get_def</span><span> </span><span>relH_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_array</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ addr_of_array r ∈ as ⟹ Array.get h r = Array.get h' r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Array.get_def</span><span> </span><span>relH_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_set_ref</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH {a. a &lt; lim h ∧ a ∉ {addr_of_ref r}} h (Ref.set r x h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ref.set_def</span><span> </span><span>relH_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relH_set_array</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relH {a. a &lt; lim h ∧ a ∉ {addr_of_array r}} h (Array.set r x h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Array.set_def</span><span> </span><span>relH_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assertions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>assn_raw</span><span> </span><span class="delimiter">=</span><span> </span><span>Assn</span><span> </span><span class="delimiter">(</span><span>assn_fn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pheap ⇒ bool"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>aseval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"assn_raw ⇒ pheap ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"aseval (Assn f) h = f h"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm aseval.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>proper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"assn_raw ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proper P = (
    (∀h as. aseval P (pHeap h as) ⟶ in_range (h,as)) ∧
    (∀h h' as. aseval P (pHeap h as) ⟶ relH as h h' ⟶ in_range (h',as) ⟶ aseval P (pHeap h' as)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>in_range_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pheap ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_range_assn (pHeap h as) ⟷ (∀a∈as. a &lt; lim h)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm in_range_assn.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect proper"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Assn in_range_assn ∈ Collect proper"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Rep_assn_inject}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("Abs_assn P", ["proper P"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("Abs_assn P", "proper P")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_assn_inverse'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"proper y ⟹ Rep_assn (Abs_assn y) = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_assn_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proper_Rep_assn</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"proper (Rep_assn P)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_assn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>models</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pheap ⇒ assn ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite_bidir</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"h ⊨ P ⟷ aseval (Rep_assn P) h"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>models_in_range</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ P ⟹ in_range (h,as)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_relH</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"relH as h h' ⟹ pHeap h as ⊨ P ⟹ pHeap h' as ⊨ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>assn</span><span> </span><span class="delimiter">::</span><span> </span><span>one</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>one_assn</span><span> </span><span class="delimiter">::</span><span> </span><span>assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"1 ≡ Abs_assn (Assn (λh. addrOf h = {}))"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>one_assn</span><span> </span><span class="delimiter">::</span><span> </span><span>assn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"emp"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"one_assn ≡ 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_assn_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ⊨ emp ⟷ addrOf h = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm one_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>assn</span><span> </span><span class="delimiter">::</span><span> </span><span>times</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>times_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P * Q = Abs_assn (Assn (
    λh. (∃as1 as2. addrOf h = as1 ∪ as2 ∧ as1 ∩ as2 = {} ∧
                   aseval (Rep_assn P) (pHeap (heapOf h) as1) ∧ aseval (Rep_assn Q) (pHeap (heapOf h) as2))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_star_conv</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ A * B ⟷ (∃as1 as2. as = as1 ∪ as2 ∧ as1 ∩ as2 = {} ∧ pHeap h as1 ⊨ A ∧ pHeap h as2 ⊨ B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm times_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aseval_ext</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h. aseval P h = aseval P' h ⟹ P = P'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assn_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as. pHeap h as ⊨ P ⟷ pHeap h as ⊨ Q ⟹ P = Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_assn P = Rep_assn Q"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond @{thm assn_ext} [with_filt (order_filter "P" "Q")]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm aseval_ext}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assn_one_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 * P = (P::assn)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as. pHeap h as ⊨ P ⟷ pHeap h as ⊨ 1 * P"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = {} ∪ as"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assn_times_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P * Q = Q * (P::assn)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as. pHeap h as ⊨ P * Q ⟷ pHeap h as ⊨ Q * P"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ P * Q"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as2 ⊨ Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as2 ∪ as1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ Q * P"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ Q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as2 ⊨ P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as2 ∪ as1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assn_times_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P * Q) * R = P * (Q * (R::assn))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as. pHeap h as ⊨ (P * Q) * R ⟷ pHeap h as ⊨ P * (Q * R)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ (P * Q) * R"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ P * Q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as2 ⊨ R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as11</span><span> </span><span>as12</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 = as11 ∪ as12"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as11 ∩ as12 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as11 ⊨ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as12 ⊨ Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as11 ∪ (as12 ∪ as2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ P * (Q * R)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as2 ⊨ Q * R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as21</span><span> </span><span>as22</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as2 = as21 ∪ as22"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as21 ∩ as22 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as21 ⊨ Q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as22 ⊨ R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = (as1 ∪ as21) ∪ as22"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>assn</span><span> </span><span class="delimiter">::</span><span> </span><span>comm_monoid_mult</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assn_times_assoc</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assn_times_comm</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assn_one_left</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Existential Quantification›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ex_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ assn) ⇒ assn"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃<span class="hidden">⇩</span><sub>A</sub>"</span></span></span><span> </span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃<span class="hidden">⇩</span><sub>A</sub>x. P x) = Abs_assn (Assn (λh. ∃x. h ⊨ P x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_ex_dist</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(h ⊨ (∃<span class="hidden">⇩</span><sub>A</sub>x. P x)) ⟷ (∃x. h ⊨ P x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm ex_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_distrib_star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃<span class="hidden">⇩</span><sub>A</sub>x. P x * Q) = (∃<span class="hidden">⇩</span><sub>A</sub>x. P x) * Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as. pHeap h as ⊨ (∃<span class="hidden">⇩</span><sub>A</sub>x. P x) * Q ⟷ pHeap h as ⊨ (∃<span class="hidden">⇩</span><sub>A</sub>x. P x * Q)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ (∃<span class="hidden">⇩</span><sub>A</sub>x. P x) * Q"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ (∃<span class="hidden">⇩</span><sub>A</sub>x. P x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as2 ⊨ Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ P x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ P x * Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pointers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sngr_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap ref ⇒ 'a ⇒ assn"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↦<span class="hidden">⇩</span><sub>r</sub>"</span></span></span><span> </span><span>82</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ↦<span class="hidden">⇩</span><sub>r</sub> x = Abs_assn (Assn (
    λh. Ref.get (heapOf h) r = x ∧ addrOf h = {addr_of_ref r} ∧ addr_of_ref r &lt; lim (heapOf h)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sngr_assn_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ r ↦<span class="hidden">⇩</span><sub>r</sub> x ⟷ (Ref.get h r = x ∧ as = {addr_of_ref r} ∧ addr_of_ref r &lt; lim h)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm sngr_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snga_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap array ⇒ 'a list ⇒ assn"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↦<span class="hidden">⇩</span><sub>a</sub>"</span></span></span><span> </span><span>82</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ↦<span class="hidden">⇩</span><sub>a</sub> x = Abs_assn (Assn (
    λh. Array.get (heapOf h) r = x ∧ addrOf h = {addr_of_array r} ∧ addr_of_array r &lt; lim (heapOf h)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snga_assn_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ r ↦<span class="hidden">⇩</span><sub>a</sub> x ⟷ (Array.get h r = x ∧ as = {addr_of_array r} ∧ addr_of_array r &lt; lim h)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm snga_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pure Assertions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pure_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ assn"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"↑"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"↑b = Abs_assn (Assn (λh. addrOf h = {} ∧ b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_assn_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ⊨ ↑b ⟷ (addrOf h = {} ∧ b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm pure_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>top_assn</span><span> </span><span class="delimiter">::</span><span> </span><span>assn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"true"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"top_assn = Abs_assn (Assn in_range_assn)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>top_assn_rule</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as ⊨ true ⟷ in_range (h, as)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm top_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm models_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of assertions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>bot_assn</span><span> </span><span class="delimiter">::</span><span> </span><span>assn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"false"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bot_assn ≡ ↑False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>top_assn_reduce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"true * true = true"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h. h ⊨ true ⟷ h ⊨ true * true"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"addrOf h = addrOf h ∪ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_pure_star_dist</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"h ⊨ P * ↑b ⟷ (h ⊨ P ∧ b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ⊨ P ∧ b"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"addrOf h = addrOf h ∪ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"↑(P ∧ Q) = ↑P * ↑Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Entailment and its properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>entails</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"assn ⇒ assn ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟹<span class="hidden">⇩</span><sub>A</sub>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(P ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ⟷ (∀h. h ⊨ P ⟶ h ⊨ Q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟹<span class="hidden">⇩</span><sub>A</sub> A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_true</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟹<span class="hidden">⇩</span><sub>A</sub> true"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_frame</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⟹<span class="hidden">⇩</span><sub>A</sub> Q ⟹ P * R ⟹<span class="hidden">⇩</span><sub>A</sub> Q * R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_frame'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (A * F ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ⟹ A ⟹<span class="hidden">⇩</span><sub>A</sub> B ⟹ ¬ (B * F ⟹<span class="hidden">⇩</span><sub>A</sub> Q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_frame''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (P ⟹<span class="hidden">⇩</span><sub>A</sub> B * F) ⟹ A ⟹<span class="hidden">⇩</span><sub>A</sub> B ⟹ ¬ (P ⟹<span class="hidden">⇩</span><sub>A</sub> A * F)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_equiv_forward</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = Q ⟹ P ⟹<span class="hidden">⇩</span><sub>A</sub> Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_equiv_backward</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = Q ⟹ Q ⟹<span class="hidden">⇩</span><sub>A</sub> P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entailsD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⟹<span class="hidden">⇩</span><sub>A</sub> Q ⟹ h ⊨ P ⟹ h ⊨ Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_trans2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟹<span class="hidden">⇩</span><sub>A</sub> D * B ⟹ B ⟹<span class="hidden">⇩</span><sub>A</sub> C ⟹ A ⟹<span class="hidden">⇩</span><sub>A</sub> D * C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_pure'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(↑b ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ⟷ (¬(emp ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ∧ b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(P * ↑b ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ⟷ (¬(P ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ∧ b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_ex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬((∃<span class="hidden">⇩</span><sub>A</sub>x. P x) ⟹<span class="hidden">⇩</span><sub>A</sub> Q) ⟷ (∃x. ¬(P x ⟹<span class="hidden">⇩</span><sub>A</sub> Q))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_ex_post</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(P ⟹<span class="hidden">⇩</span><sub>A</sub> (∃<span class="hidden">⇩</span><sub>A</sub>x. Q x)) ⟹ ∀x. ¬(P ⟹<span class="hidden">⇩</span><sub>A</sub> Q x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_pure_post</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(P ⟹<span class="hidden">⇩</span><sub>A</sub> Q * ↑b) ⟹ P ⟹<span class="hidden">⇩</span><sub>A</sub> Q ⟹ ¬b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm entails_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of the run predicate›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>run</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a Heap ⇒ heap option ⇒ heap option ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"run c None None r"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"execute c h = None ⟹ run c (Some h) None r"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"execute c h = Some (r, h') ⟹ run c (Some h) (Some h') r"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_case_induct_rule @{thm run.cases}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_resolve_prfstep @{thms run.intros(1,2)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm run.intros(3)}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>run_complete</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃σ' r. run c σ σ' (r::'a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r::'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = None"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run c None None r"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute c (the σ) = None"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run c σ None r"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>run_to_execute</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"run c (Some h) σ' r ⟹ if σ' = None then execute c h = None else execute c h = Some (r, the σ')"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run c (Some h) σ' r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_bind(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>runE</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"run f (Some h) (Some h') r' ⟹ run (f ⤜ g) (Some h) σ r ⟹ run (g r') (Some h') σ r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Array.get_alloc}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Ref.get_alloc}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_bidir @{thm Array.length_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of hoare triple, and the frame rule.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>new_addrs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"heap ⇒ addr set ⇒ heap ⇒ addr set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"new_addrs h as h' = as ∪ {a. lim h ≤ a ∧ a &lt; lim h'}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hoare_triple</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"assn ⇒ 'a Heap ⇒ ('a ⇒ assn) ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;_&gt;/ _/ &lt;_&gt;"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; c &lt;Q&gt; ⟷ (∀h as σ r. pHeap h as ⊨ P ⟶ run c (Some h) σ r ⟶
    (σ ≠ None ∧ pHeap (the σ) (new_addrs h as (the σ)) ⊨ Q r ∧ relH {a . a &lt; lim h ∧ a ∉ as} h (the σ) ∧
     lim h ≤ lim (the σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_tripleD</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; c &lt;Q&gt; ⟹ run c (Some h) σ r ⟹ ∀as. pHeap h as ⊨ P ⟶
     (σ ≠ None ∧ pHeap (the σ) (new_addrs h as (the σ)) ⊨ Q r ∧ relH {a . a &lt; lim h ∧ a ∉ as} h (the σ) ∧
     lim h ≤ lim (the σ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm hoare_triple_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hoare_triple'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"assn ⇒ 'r Heap ⇒ ('r ⇒ assn) ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;_&gt; _ &lt;_&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; c &lt;Q&gt;<span class="hidden">⇩</span><sub>t</sub> ≡ &lt;P&gt; c &lt;λr. Q r * true&gt;"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>frame_rule</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; c &lt;Q&gt; ⟹ &lt;P * R&gt; c &lt;λx. Q x * R&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as σ r. pHeap h as ⊨ P * R ⟶ run c (Some h) σ r ⟶
                    (σ ≠ None ∧ pHeap (the σ) (new_addrs h as (the σ)) ⊨ Q r * R ∧
                     relH {a . a &lt; lim h ∧ a ∉ as} h (the σ) ∧ lim h ≤ lim (the σ))"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as1 ∪ as2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as1 ∩ as2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h as1 ⊨ P ∧ pHeap h as2 ⊨ R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"relH as2 h (the σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"new_addrs h as (the σ) = new_addrs h as1 (the σ) ∪ as2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is the last use of the definition of separating conjunction.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm mod_star_conv}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bind_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; f &lt;Q&gt; ⟹ ∀x. &lt;Q x&gt; g x &lt;R&gt; ⟹ &lt;P&gt; f ⤜ g &lt;R&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀h as σ r. pHeap h as ⊨ P ⟶ run (f ⤜ g) (Some h) σ r ⟶
                    (σ ≠ None ∧ pHeap (the σ) (new_addrs h as (the σ)) ⊨ R r ∧
                     relH {a . a &lt; lim h ∧ a ∉ as} h (the σ) ∧ lim h ≤ lim (the σ))"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="comment">― ‹First step from h to h'›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>σ'</span><span> </span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run f (Some h) σ' r'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>h'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' = Some h'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = new_addrs h as h'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h' as' ⊨ Q r'"</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment">― ‹Second step from h' to h''›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"run (g r') (Some h') σ r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>h''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = Some h''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as'' = new_addrs h' as' h''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pHeap h'' as'' ⊨ R r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as'' = new_addrs h as h''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Actual statement used:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_rule'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; f &lt;Q&gt; ⟹ ¬ &lt;P&gt; f ⤜ g &lt;R&gt; ⟹ ∃x. ¬ &lt;Q x&gt; g x &lt;R&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bind_rule</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_rule'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ &lt;P * R&gt; f &lt;Q&gt; ⟹ P ⟹<span class="hidden">⇩</span><sub>A</sub> P' ⟹ ¬ &lt;P' * R&gt; f &lt;Q&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P * R ⟹<span class="hidden">⇩</span><sub>A</sub> P' * R"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_rule''</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; f &lt;Q&gt; ⟹ P' ⟹<span class="hidden">⇩</span><sub>A</sub> P * R ⟹ &lt;P'&gt; f &lt;λx. Q x * R&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;P * R&gt; f &lt;λx. Q x * R&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_ex_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ &lt;∃<span class="hidden">⇩</span><sub>A</sub>x. P x&gt; f &lt;Q&gt; ⟷ (∃x. ¬ &lt;P x&gt; f &lt;Q&gt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_pure_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ &lt;P * ↑b&gt; f &lt;Q&gt; ⟷ ¬ &lt;P&gt; f &lt;Q&gt; ∧ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_pure_rule'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ &lt;↑b&gt; f &lt;Q&gt; ⟷ ¬ &lt;emp&gt; f &lt;Q&gt; ∧ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>post_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; f &lt;Q&gt; ⟹ ∀x. Q x ⟹<span class="hidden">⇩</span><sub>A</sub> R x ⟹ &lt;P&gt; f &lt;R&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm [@{thm entailsD}, @{thm entails_frame}, @{thm frame_rule}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Actual statement used:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>post_rule'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;P&gt; f &lt;Q&gt; ⟹ ¬ &lt;P&gt; f &lt;R&gt; ⟹ ∃x. ¬ (Q x ⟹<span class="hidden">⇩</span><sub>A</sub> R x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>post_rule</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_pre_pure_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;P * ↑b&gt; c &lt;Q&gt; ⟷ (b ⟶ &lt;P&gt; c &lt;Q&gt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_pre_pure_iff2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;↑b&gt; c &lt;Q&gt; ⟷ (b ⟶ &lt;emp&gt; c &lt;Q&gt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Hoare triples for atomic commands›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First, those that do not modify the heap.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_assert(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;↑(R x)&gt; assert R x &lt;λr. ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>execute_return'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execute (return x) h = Some (x, h)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_eq_dest_lhs</span><span> </span><span>execute_return</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; return x &lt;λr. ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_nth(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(i &lt; length xs)&gt; Array.nth a i &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(r = xs ! i)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_len}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt; Array.len a &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(r = length xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_lookup}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;p ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; !p &lt;λr. p ↦<span class="hidden">⇩</span><sub>r</sub> x * ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_freeze}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freeze_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt; Array.freeze a &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(r = xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, the update rules.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Ref.lim_set}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Array_lim_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lim (Array.set p xs h) = lim h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Array.set_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule [@{thm Ref.get_set_eq}, @{thm Array.get_set_eq}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Array.update_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_upd(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>upd_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(i &lt; length xs)&gt; Array.upd i x a &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> list_update xs i x * ↑(r = a)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_update}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>update_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;p ↦<span class="hidden">⇩</span><sub>r</sub> y&gt; p := x &lt;λr. p ↦<span class="hidden">⇩</span><sub>r</sub> x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, the allocation rules.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lim_set_gen</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lim (h⦇lim := l⦈) = l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Array_alloc_def'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Array.alloc xs h = (let l = lim h; r = Array l in (r, (Array.set r xs (h⦇lim := l + 1⦈))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Array.alloc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule [
  @{thm addr_of_array.simps}, @{thm addr_of_ref.simps}, @{thm Ref.alloc_def}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refs_on_Array_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refs (Array.set p xs h) t i = refs h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Array.set_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arrays_on_Ref_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arrays (Ref.set p x h) t i = arrays h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ref.set_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refs_on_Array_alloc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refs (snd (Array.alloc xs h)) t i = refs h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Array.alloc_def</span><span> </span><span>refs_on_Array_set</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>surjective</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arrays_on_Ref_alloc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arrays (snd (Ref.alloc x h)) t i = arrays h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Ref.alloc_def</span><span> </span><span>arrays_on_Ref_set</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sndI</span><span> </span><span>surjective</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arrays_on_Array_alloc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; lim h ⟹ arrays (snd (Array.alloc xs h)) t i = arrays h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Array.alloc_def</span><span> </span><span>Array.set_def</span><span> </span><span>addr_of_array.simps</span><span> </span><span>fun_upd_apply</span><span> </span><span>less_or_eq_imp_le</span><span>
</span><span>          </span><span>linorder_not_less</span><span> </span><span>simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>surjective</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refs_on_Ref_alloc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; lim h ⟹ refs (snd (Ref.alloc x h)) t i = refs h t i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Ref.alloc_def</span><span> </span><span>Ref.set_def</span><span> </span><span>addr_of_ref.simps</span><span> </span><span>fun_upd_apply</span><span> </span><span>less_or_eq_imp_le</span><span>
</span><span>          </span><span>linorder_not_less</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>surjective</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_new}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>new_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; Array.new n x &lt;λr. r ↦<span class="hidden">⇩</span><sub>a</sub> replicate n x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_of_list}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; Array.of_list xs &lt;λr. r ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm execute_ref}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ref_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; ref x &lt;λr. r ↦<span class="hidden">⇩</span><sub>r</sub> x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm [
  @{thm sngr_assn_rule}, @{thm snga_assn_rule}, @{thm pure_assn_rule}, @{thm top_assn_rule},
  @{thm mod_pure_star_dist}, @{thm one_assn_rule}, @{thm hoare_triple_def}, @{thm mod_ex_dist}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_simple_datatype "pheap"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of procedures›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ASCII abbreviations for ML files.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>ex_assn_ascii</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ assn) ⇒ assn"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EXA"</span></span></span><span> </span><span>11</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_assn_ascii ≡ ex_assn"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>models_ascii</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pheap ⇒ assn ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|="</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h |= P ≡ h ⊨ P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sep_util.ML"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure AssnMatcher = AssnMatcher(SepUtil)
structure SepLogic = SepLogic(SepUtil)
val add_assn_matcher = AssnMatcher.add_assn_matcher
val add_entail_matcher = AssnMatcher.add_entail_matcher
val add_forward_ent_prfstep = SepLogic.add_forward_ent_prfstep
val add_rewrite_ent_rule = SepLogic.add_rewrite_ent_rule
val add_hoare_triple_prfstep = SepLogic.add_hoare_triple_prfstep
›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹AssnMatcher.add_assn_matcher_proofsteps›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹SepLogic.add_sep_logic_proofsteps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sep_steps_test.ML"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>forward_ent</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_forward_ent_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>rewrite_ent</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_rewrite_ent_rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>hoare_triple</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_hoare_triple_prfstep›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_hoare_triple_prfstep [
  @{thm assert_rule}, @{thm update_rule}, @{thm nth_rule}, @{thm upd_rule},
  @{thm return_rule}, @{thm ref_rule}, @{thm lookup_rule}, @{thm new_rule},
  @{thm of_list_rule}, @{thm length_rule}, @{thm freeze_rule}]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some simple tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; ref x &lt;λr. r ↦<span class="hidden">⇩</span><sub>r</sub> x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; ref x &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> x * r ↦<span class="hidden">⇩</span><sub>r</sub> x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; (!a) &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> x * ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x * b ↦<span class="hidden">⇩</span><sub>r</sub> y&gt; (!a) &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> x * b ↦<span class="hidden">⇩</span><sub>r</sub> y * ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x * b ↦<span class="hidden">⇩</span><sub>r</sub> y&gt; (!b) &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> x * b ↦<span class="hidden">⇩</span><sub>r</sub> y * ↑(r = y)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; do { a := y; !a } &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> y * ↑(r = y)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; do { a := y; a := z; !a } &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> z * ↑(r = z)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>r</sub> x&gt; do { y ← !a; ref y} &lt;λr. a ↦<span class="hidden">⇩</span><sub>r</sub> x * r ↦<span class="hidden">⇩</span><sub>r</sub> x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; return x &lt;λr. ↑(r = x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="GCD_Impl">
<div class="head"><h1>Theory GCD_Impl</h1>
<span class="command">theory</span> <span class="name">GCD_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: GCD_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GCD_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A tutorial example for computation of GCD.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Turn on auto2's trace›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>print_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Property of gcd that justifies the recursive computation. Add as a
  right-to-left rewrite rule.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm gcd_red_nat}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Functional version of gcd.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>gcd_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gcd_fun a b = (if b = 0 then a else gcd_fun b (a mod b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The fun package automatically generates induction rule upon showing
  termination. This adds the induction rule for the @fun\_induct command.›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_fun_induct_rule (@{term gcd_fun}, @{thm gcd_fun.induct})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gcd_fun_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gcd_fun a b = gcd a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gcd_fun a b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gcd_fun a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative version of gcd.›</span></span></span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>gcd_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gcd_impl a b = (
    if b = 0 then return a
    else do {
      c ← return (a mod b);
      r ← gcd_impl b c;
      return r
    })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The program is sufficiently simple that we can prove the Hoare triple
  directly (without going through the functional program).›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gcd_impl_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; gcd_impl a b &lt;λr. ↑(r = gcd a b)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gcd_fun a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Turn off trace.›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>print_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="LinkedList">
<div class="head"><h1>Theory LinkedList</h1>
<span class="command">theory</span> <span class="name">LinkedList</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: LinkedList.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of linked list›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LinkedList</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Examples in linked lists. Definitions and some of the examples are
  based on List\_Seg and Open\_List theories in \cite{Separation_Logic_Imperative_HOL-AFP}
  by Lammich and Meis.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List Assertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>node</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>nxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a node ref option"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms node.sel}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>node_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap node ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"node_encode (Node x r) = to_nat (x, r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>node</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"node_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap list ⇒ 'a node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_list [] p = ↑(p = None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"os_list (x # l) (Some p) = (∃<span class="hidden">⇩</span><sub>A</sub>q. p ↦<span class="hidden">⇩</span><sub>r</sub> Node x q * os_list l q)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"os_list (x # l) None = false"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_ent_rule @{thms os_list.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_list_empty</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_list [] p ⟹<span class="hidden">⇩</span><sub>A</sub> ↑(p = None)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_list_Cons</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_list (x # l) p ⟹<span class="hidden">⇩</span><sub>A</sub> (∃<span class="hidden">⇩</span><sub>A</sub>q. the p ↦<span class="hidden">⇩</span><sub>r</sub> Node x q * os_list l q * ↑(p ≠ None))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_list_none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emp ⟹<span class="hidden">⇩</span><sub>A</sub> os_list [] None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_list_constr_ent</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ↦<span class="hidden">⇩</span><sub>r</sub> Node x q * os_list l q ⟹<span class="hidden">⇩</span><sub>A</sub> os_list (x # l) (Some p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_entail_matcher [@{thm os_list_none}, @{thm os_list_constr_ent}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm @{thms os_list.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_matcher_test.ML"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>os_list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a node ref option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_empty = return None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; os_empty &lt;os_list []&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_is_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_is_empty b = return (b = None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_is_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; os_is_empty b &lt;λr. os_list xs b * ↑(r ⟷ xs = [])&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = hd xs # tl xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_prepend</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a::heap os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_prepend a n = do { p ← ref (Node a n); return (Some p) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_prepend_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs n&gt; os_prepend x n &lt;os_list (x # xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_pop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ ('a × 'a os_list) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_pop r = (case r of
    None ⇒ raise STR ''Empty Os_list'' |
    Some p ⇒ do {m ← !p; return (val m, nxt m)})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_pop_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs (Some p)&gt;
   os_pop (Some p)
   &lt;λ(x,r'). os_list (tl xs) r' * p ↦<span class="hidden">⇩</span><sub>r</sub> (Node x r') * ↑(x = hd xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = hd xs # tl xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reverse›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>os_reverse_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_reverse_aux q p = (case p of
    None ⇒ return q |
    Some r ⇒ do {
      v ← !r;
      r := Node (val v) q;
      os_reverse_aux p (nxt v) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_reverse_aux_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs p * os_list ys q&gt; 
    os_reverse_aux q p 
   &lt;os_list ((rev xs) @ ys)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>ys</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_reverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_reverse p = os_reverse_aux None p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_reverse_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs p&gt; os_reverse p &lt;os_list (rev xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remove›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms removeAll.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>os_rem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap ⇒ 'a node ref option ⇒ 'a node ref option Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_rem x b = (case b of 
     None ⇒ return None |
     Some p ⇒ do { 
       n ← !p;
       q ← os_rem x (nxt n);
       (if (val n = x) 
         then return q
         else do {
           p := Node (val n) q; 
           return (Some p) }) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_rem_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; os_rem x b &lt;λr. os_list (removeAll x xs) r&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extract list›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>extract_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ 'a list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extract_list p = (case p of
    None ⇒ return []
  | Some pp ⇒ do {
      v ← !pp;
      ls ← extract_list (nxt v);
      return (val v # ls)
    })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extract_list_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list l p&gt; extract_list p &lt;λr. os_list l p * ↑(r = l)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered insert›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>list_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_insert x [] = [x]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_insert x (y # ys) = (
    if x ≤ y then x # (y # ys) else y # list_insert x ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms list_insert.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_insert_length</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length (list_insert x xs) = length xs + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm list_insert_length} [with_term "list_insert ?x ?xs"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_insert_mset</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset (list_insert x xs) = {#x#} + mset xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_insert_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (list_insert x xs) = {x} ∪ set xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_insert_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted xs ⟹ sorted (list_insert x xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>os_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{ord,heap} ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_insert x b = (case b of
      None ⇒ os_prepend x None
    | Some p ⇒ do {
        v ← !p;
        (if x ≤ val v then os_prepend x b
         else do {
           q ← os_insert x (nxt v);
           p := Node (val v) q;
           return (Some p) }) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_insert_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; os_insert x b &lt;os_list (list_insert x xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion sort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert_sort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert_sort [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert_sort (x # xs) = list_insert x (insert_sort xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms insert_sort.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_sort_mset</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset (insert_sort xs) = mset xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_sort_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted (insert_sort xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_sort_is_sort</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert_sort xs = sort xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>os_insert_sort_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{ord,heap} list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_insert_sort_aux [] = (return None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"os_insert_sort_aux (x # xs) = do {
     b ← os_insert_sort_aux xs;
     b' ← os_insert x b;
     return b'
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>os_insert_sort_aux_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; os_insert_sort_aux xs &lt;os_list (insert_sort xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>os_insert_sort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{ord,heap} list ⇒ 'a list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"os_insert_sort xs = do {
    p ← os_insert_sort_aux xs;
    l ← extract_list p;
    return l
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_sort_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; os_insert_sort xs &lt;λys. ↑(ys = sort xs)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Merging two lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ord) list ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_list xs [] = xs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_list [] ys = ys"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_list (x # xs) (y # ys) = (
    if x ≤ y then x # (merge_list xs (y # ys))
    else y # (merge_list (x # xs) ys))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms merge_list.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_list_correct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (merge_list xs ys) = set xs ∪ set ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_list xs ys"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_list_sorted</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted xs ⟹ sorted ys ⟹ sorted (merge_list xs ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_list xs ys"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>merge_os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::{heap, ord}) os_list ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_os_list p q = (
    if p = None then return q
    else if q = None then return p
    else do {
      np ← !(the p); nq ← !(the q);
      if val np ≤ val nq then
        do { npq ← merge_os_list (nxt np) q;
             (the p) := Node (val np) npq;
             return p }
      else
        do { pnq ← merge_os_list p (nxt nq);
             (the q) := Node (val nq) pnq;
             return q } })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_os_list_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs p * os_list ys q&gt;
  merge_os_list p q
  &lt;λr. os_list (merge_list xs ys) r&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_list xs ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List copy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>copy_os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"copy_os_list b = (case b of
      None ⇒ return None
    | Some p ⇒ do {
        v ← !p;
        q ← copy_os_list (nxt v);
        os_prepend (val v) q })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>copy_os_list_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; copy_os_list b &lt;λr. os_list xs b * os_list xs r&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Higher-order functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>map_os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap ⇒ 'a) ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_os_list f b = (case b of
      None ⇒ return None
    | Some p ⇒ do {
        v ← !p;
        q ← map_os_list f (nxt v);
        p := Node (f (val v)) q;
        return (Some p) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_os_list_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; map_os_list f b &lt;os_list (map f xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>filter_os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap ⇒ bool) ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_os_list f b = (case b of
      None ⇒ return None
    | Some p ⇒ do {
        v ← !p;
        q ← filter_os_list f (nxt v);
        (if (f (val v)) then do {
           p := Node (val v) q;
           return (Some p) }
         else return q) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_os_list_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; filter_os_list f b &lt;λr. os_list (filter f xs) r * true&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>filter_os_list2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap ⇒ bool) ⇒ 'a os_list ⇒ 'a os_list Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_os_list2 f b = (case b of
      None ⇒ return None
    | Some p ⇒ do {
        v ← !p;
        q ← filter_os_list2 f (nxt v);
        (if (f (val v)) then os_prepend (val v) q
         else return q) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_os_list2_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; filter_os_list2 f b &lt;λr. os_list xs b * os_list (filter f xs) r&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms List.fold_simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>fold_os_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap ⇒ 'b ⇒ 'b) ⇒ 'a os_list ⇒ 'b ⇒ 'b Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fold_os_list f b x = (case b of
      None ⇒ return x
    | Some p ⇒ do {
       v ← !p;
       r ← fold_os_list f (nxt v) (f (val v) x);
       return r})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_os_list_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;os_list xs b&gt; fold_os_list f b x &lt;λr. os_list xs b * ↑(r = fold f xs x)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="BST_Impl">
<div class="head"><h1>Theory BST_Impl</h1>
<span class="command">theory</span> <span class="name">BST_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a> <a href="BST.html"><span class="name">BST</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: BST_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of binary search tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BST_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/BST"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative version of binary search trees.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree nodes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>node</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) node ref option"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>key</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) node ref option"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms node.sel}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>node_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) node ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"node_encode (Node l k v r) = to_nat (l, k, v, r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>node</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">,</span><span> </span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"node_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>btree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) tree ⇒ ('a, 'b) node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree Tip p = ↑(p = None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree (tree.Node lt k v rt) (Some p) = (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp k v rp * btree lt lp * btree rt rp)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree (tree.Node lt k v rt) None = false"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_ent_rule @{thms btree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_Tip</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree Tip p ⟹<span class="hidden">⇩</span><sub>A</sub> ↑(p = None)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_Node</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree (tree.Node lt k v rt) p ⟹<span class="hidden">⇩</span><sub>A</sub> (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. the p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp k v rp * btree lt lp * btree rt rp * ↑(p ≠ None))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emp ⟹<span class="hidden">⇩</span><sub>A</sub> btree tree.Tip None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_constr_ent</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp k v rp * btree lt lp * btree rt rp ⟹<span class="hidden">⇩</span><sub>A</sub> btree (tree.Node lt k v rt) (Some p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_entail_matcher [@{thm btree_none}, @{thm btree_constr_ent}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm @{thms btree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>btree</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) node ref option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_empty = return None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; tree_empty &lt;btree Tip&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_is_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) btree ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_is_empty b = return (b = None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_is_empty_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b&gt; tree_is_empty b &lt;λr. btree t b * ↑(r ⟷ t = Tip)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_constr</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ 'a ⇒ 'b ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_constr lp k v rp = do { p ← ref (Node lp k v rp); return (Some p) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_constr_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree lt lp * btree rt rp&gt; btree_constr lp k v rp &lt;btree (tree.Node lt k v rt)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>btree_insert</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ 'b::heap ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_insert k v b = (case b of
     None ⇒ btree_constr None k v None
   | Some p ⇒ do {
      t ← !p;
      (if k = key t then do {
         p := Node (lsub t) k v (rsub t);
         return (Some p) }
       else if k &lt; key t then do {
         q ← btree_insert k v (lsub t);
         p := Node q (key t) (val t) (rsub t);
         return (Some p) }
       else do {
         q ← btree_insert k v (rsub t);
         p := Node (lsub t) (key t) (val t) q;
         return (Some p)}) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_insert_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b&gt;
   btree_insert k v b
   &lt;btree (tree_insert k v t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>btree_del_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ (('a × 'b) × ('a, 'b) btree) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_del_min b = (case b of
     None ⇒ raise STR ''del_min: empty tree''
   | Some p ⇒ do {
      t ← !p;
      (if lsub t = None then
         return ((key t, val t), rsub t)
       else do {
         r ← btree_del_min (lsub t);
         p := Node (snd r) (key t) (val t) (rsub t);
         return (fst r, Some p) }) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_del_min_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b * ↑(b ≠ None)&gt;
   btree_del_min b
   &lt;λ(r,p). btree (snd (del_min t)) p * ↑(r = fst (del_min t))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_del_elt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_del_elt b = (case b of
     None ⇒ raise STR ''del_elt: empty tree''
   | Some p ⇒ do {
       t ← !p;
       (if lsub t = None then return (rsub t)
        else if rsub t = None then return (lsub t)
        else do {
          r ← btree_del_min (rsub t);
          p := Node (lsub t) (fst (fst r)) (snd (fst r)) (snd r);
          return (Some p) }) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_del_elt_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (tree.Node lt x v rt) b&gt;
   btree_del_elt b
   &lt;btree (delete_elt_tree (tree.Node lt x v rt))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>btree_delete</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ ('a, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_delete x b = (case b of
     None ⇒ return None
   | Some p ⇒ do {
      t ← !p;
      (if x = key t then do {
         r ← btree_del_elt b;
         return r }
       else if x &lt; key t then do {
         q ← btree_delete x (lsub t);
         p := Node q (key t) (val t) (rsub t);
         return (Some p) }
       else do {
         q ← btree_delete x (rsub t);
         p := Node (lsub t) (key t) (val t) q;
         return (Some p)}) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_delete_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b&gt;
   btree_delete x b
   &lt;btree (tree_delete x t)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>btree_search</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ ('a, 'b::heap) btree ⇒ 'b option Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_search x b = (case b of
     None ⇒ return None
   | Some p ⇒ do {
      t ← !p;
      (if x = key t then return (Some (val t))
       else if x &lt; key t then btree_search x (lsub t)
       else btree_search x (rsub t)) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_search_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b * ↑(tree_sorted t)&gt;
   btree_search x b
   &lt;λr. btree t b * ↑(r = tree_search t x)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer interface›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Express Hoare triples for operations on binary search tree in terms of
  the mapping represented by the tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map ⇒ ('a::{heap,linorder}, 'b::heap) node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_map M p = (∃<span class="hidden">⇩</span><sub>A</sub>t. btree t p * ↑(tree_sorted t) * ↑(M = tree_map t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm btree_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>btree_empty_rule_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; tree_empty &lt;btree_map empty_map&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>btree_insert_rule_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree_map M b&gt; btree_insert k v b &lt;btree_map (M {k → v})&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>btree_delete_rule_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree_map M b&gt; btree_delete x b &lt;btree_map (delete_map x M)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>btree_search_rule_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree_map M b&gt; btree_search x b &lt;λr. btree_map M b * ↑(r = M⟨x⟩)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RBTree_Impl">
<div class="head"><h1>Theory RBTree_Impl</h1>
<span class="command">theory</span> <span class="name">RBTree_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a> <a href="RBTree.html"><span class="name">RBTree</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: RBTree_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of red-black tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RBTree_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/RBTree"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verification of imperative red-black trees.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree nodes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>rbt_node</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt_node ref option"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cl</span><span class="delimiter">:</span><span> </span><span>color</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>key</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt_node ref option"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms rbt_node.sel}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>color_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"color ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"color_encode B = 0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"color_encode R = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>color</span><span> </span><span class="delimiter">::</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"color_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>color_encode.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>color_encode.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>not_B</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rbt_node_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) rbt_node ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_node_encode (Node l c k v r) = to_nat (l, c, k, v, r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>rbt_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">,</span><span> </span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_node_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>btree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) rbt ⇒ ('a, 'b) rbt_node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree Leaf p = ↑(p = None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree (rbt.Node lt c k v rt) (Some p) = (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp c k v rp * btree lt lp * btree rt rp)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree (rbt.Node lt c k v rt) None = false"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_ent_rule @{thms btree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_Leaf</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"btree Leaf p ⟹<span class="hidden">⇩</span><sub>A</sub> ↑(p = None)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_Node</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree (rbt.Node lt c k v rt) p ⟹<span class="hidden">⇩</span><sub>A</sub> (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. the p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp c k v rp * btree lt lp * btree rt rp * ↑(p ≠ None))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emp ⟹<span class="hidden">⇩</span><sub>A</sub> btree Leaf None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_constr_ent</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp c k v rp * btree lt lp * btree rt rp ⟹<span class="hidden">⇩</span><sub>A</sub> btree (rbt.Node lt c k v rt) (Some p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_entail_matcher [@{thm btree_none}, @{thm btree_constr_ent}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm @{thms btree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>btree</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt_node ref option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_empty = return None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; tree_empty &lt;btree Leaf&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tree_is_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) btree ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_is_empty b = return (b = None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_is_empty_rule</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b&gt; tree_is_empty b &lt;λr. btree t b * ↑(r ⟷ t = Leaf)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_constr</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ color ⇒ 'a ⇒ 'b ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_constr lp c k v rp = do { p ← ref (Node lp c k v rp); return (Some p) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_constr_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree lt lp * btree rt rp&gt;
   btree_constr lp c k v rp
   &lt;btree (rbt.Node lt c k v rt)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_color</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"color ⇒ ('a::heap, 'b::heap) btree ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_color c p = (case p of
    None ⇒ raise STR ''set_color''
  | Some pp ⇒ do {
      t ← !pp;
      pp := Node (lsub t) c (key t) (val t) (rsub t)
    })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_color_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node a c x v b) p&gt;
   set_color c' p
   &lt;λ_. btree (rbt.Node a c' x v b) p&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_color</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ color Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"get_color p = (case p of
     None ⇒ return B
   | Some pp ⇒ do {
       t ← !pp;
       return (cl t)
     })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_color_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt; get_color p &lt;λr. btree t p * ↑(r = rbt.cl t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>paint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"color ⇒ ('a::heap, 'b::heap) btree ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"paint c p = (case p of
    None ⇒ return ()
  | Some pp ⇒ do {
     t ← !pp;
     pp := Node (lsub t) c (key t) (val t) (rsub t)
   })"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>paint_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt;
   paint c p
   &lt;λ_. btree (RBTree.paint c t) p&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Leaf"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rotation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_rotate_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_rotate_l p = (case p of
    None ⇒ raise STR ''Empty btree''
  | Some pp ⇒ do {
     t ← !pp;
     (case rsub t of
        None ⇒ raise STR ''Empty rsub''
      | Some rp ⇒ do {
          rt ← !rp;
          pp := Node (lsub t) (cl t) (key t) (val t) (lsub rt);
          rp := Node p (cl rt) (key rt) (val rt) (rsub rt);
          return (rsub t) })})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_rotate_l_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node a c1 x v (rbt.Node b c2 y w c)) p&gt;
   btree_rotate_l p
   &lt;btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_rotate_r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_rotate_r p = (case p of
    None ⇒ raise STR ''Empty btree''
  | Some pp ⇒ do {
     t ← !pp;
     (case lsub t of
        None ⇒ raise STR ''Empty lsub''
      | Some lp ⇒ do {
          lt ← !lp;
          pp := Node (rsub lt) (cl t) (key t) (val t) (rsub t);
          lp := Node (lsub lt) (cl lt) (key lt) (val lt) p;
          return (lsub t) })})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_rotate_r_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c) p&gt;
   btree_rotate_r p
   &lt;btree (rbt.Node a c1 x v (rbt.Node b c2 y w c))&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Balance›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_balanceR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_balanceR p = (case p of None ⇒ return None | Some pp ⇒ do {
     t ← !pp;
     cl_r ← get_color (rsub t);
     if cl_r = R then do {
       rt ← !(the (rsub t));
       cl_lr ← get_color (lsub rt);
       cl_rr ← get_color (rsub rt);
       if cl_lr = R then do {
         rp' ← btree_rotate_r (rsub t);
         pp := Node (lsub t) (cl t) (key t) (val t) rp';
         p' ← btree_rotate_l p;
         t' ← !(the p');
         set_color B (rsub t');
         return p'
       } else if cl_rr = R then do {
         p' ← btree_rotate_l p;
         t' ← !(the p');
         set_color B (rsub t');
         return p'
        } else return p }
     else return p})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balanceR_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node l B k v r) p&gt;
   btree_balanceR p
   &lt;btree (balanceR l k v r)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"balanceR l k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_balance</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_balance p = (case p of None ⇒ return None | Some pp ⇒ do {
     t ← !pp;
     cl_l ← get_color (lsub t);
     if cl_l = R then do {
       lt ← !(the (lsub t));
       cl_rl ← get_color (rsub lt);
       cl_ll ← get_color (lsub lt);
       if cl_ll = R then do {
         p' ← btree_rotate_r p;
         t' ← !(the p');
         set_color B (lsub t');
         return p' }
       else if cl_rl = R then do {
         lp' ← btree_rotate_l (lsub t);
         pp := Node lp' (cl t) (key t) (val t) (rsub t);
         p' ← btree_rotate_r p;
         t' ← !(the p');
         set_color B (lsub t');
         return p'
       } else btree_balanceR p }
     else do {
       p' ← btree_balanceR p;
       return p'}})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balance_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node l B k v r) p&gt;
   btree_balance p
   &lt;btree (balance l k v r)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"balance l k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>rbt_ins</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,ord} ⇒ 'b::heap ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_ins k v p = (case p of
     None ⇒ btree_constr None R k v None
   | Some pp ⇒ do {
      t ← !pp;
      (if cl t = B then
        (if k = key t then do {
           pp := Node (lsub t) (cl t) k v (rsub t);
           return (Some pp) }
         else if k &lt; key t then do {
           q ← rbt_ins k v (lsub t);
           pp := Node q (cl t) (key t) (val t) (rsub t);
           btree_balance p }
         else do {
           q ← rbt_ins k v (rsub t);
           pp := Node (lsub t) (cl t) (key t) (val t) q;
           btree_balance p })
       else
        (if k = key t then do {
           pp := Node (lsub t) (cl t) k v (rsub t);
           return (Some pp) }
         else if k &lt; key t then do {
           q ← rbt_ins k v (lsub t);
           pp := Node q (cl t) (key t) (val t) (rsub t);
           return (Some pp) }
         else do {
           q ← rbt_ins k v (rsub t);
           pp := Node (lsub t) (cl t) (key t) (val t) q;
           return (Some pp) }))})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_ins_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt;
   rbt_ins k v p
   &lt;btree (ins k v t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_insert</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,ord} ⇒ 'b::heap ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_insert k v p = do {
    p' ← rbt_ins k v p;
    paint B p';
    return p' }"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_insert_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt;
   rbt_insert k v p
   &lt;btree (RBTree.rbt_insert k v t)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>rbt_search</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ ('a, 'b::heap) btree ⇒ 'b option Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_search x b = (case b of
     None ⇒ return None
   | Some p ⇒ do {
      t ← !p;
      (if x = key t then return (Some (val t))
       else if x &lt; key t then rbt_search x (lsub t)
       else rbt_search x (rsub t)) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>btree_search_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t b * ↑(rbt_sorted t)&gt;
   rbt_search x b
   &lt;λr. btree t b * ↑(r = RBTree.rbt_search t x)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Delete›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_balL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_balL p = (case p of
     None ⇒ return None
   | Some pp ⇒ do {
      t ← !pp;
      cl_l ← get_color (lsub t);
      if cl_l = R then do {
        set_color B (lsub t);  ― ‹Case 1›
        return p}
      else case rsub t of
        None ⇒ return p  ― ‹Case 2›
      | Some rp ⇒ do {  
         rt ← !rp;
         if cl rt = B then do {
           set_color R (rsub t);  ― ‹Case 3›
           set_color B p;
           btree_balance p}
         else case lsub rt of
           None ⇒ return p  ― ‹Case 4›
         | Some lrp ⇒ do {
            lrt ← !lrp;
            if cl lrt = B then do {
              set_color R (lsub rt);  ― ‹Case 5›
              paint R (rsub rt);
              set_color B (rsub t); 
              rp' ← btree_rotate_r (rsub t);
              pp := Node (lsub t) (cl t) (key t) (val t) rp';
              p' ← btree_rotate_l p;
              t' ← !(the p');
              set_color B (lsub t');
              rp'' ← btree_balance (rsub t');
              the p' := Node (lsub t') (cl t') (key t') (val t') rp'';
              return p'}
            else return p}}})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balL_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node l R k v r) p&gt;
   btree_balL p
   &lt;btree (balL l k v r)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"balL l k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>btree_balR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_balR p = (case p of
     None ⇒ return None
   | Some pp ⇒ do {
      t ← !pp;
      cl_r ← get_color (rsub t);
      if cl_r = R then do {
        set_color B (rsub t);  ― ‹Case 1›
        return p}
      else case lsub t of
        None ⇒ return p  ― ‹Case 2›
      | Some lp ⇒ do {  
         lt ← !lp;
         if cl lt = B then do {
           set_color R (lsub t);  ― ‹Case 3›
           set_color B p;
           btree_balance p}
         else case rsub lt of
           None ⇒ return p  ― ‹Case 4›
         | Some rlp ⇒ do {
            rlt ← !rlp;
            if cl rlt = B then do {
              set_color R (rsub lt);  ― ‹Case 5›
              paint R (lsub lt);
              set_color B (lsub t); 
              lp' ← btree_rotate_l (lsub t);
              pp := Node lp' (cl t) (key t) (val t) (rsub t);
              p' ← btree_rotate_r p;
              t' ← !(the p');
              set_color B (rsub t');
              lp'' ← btree_balance (lsub t');
              the p' := Node lp'' (cl t') (key t') (val t') (rsub t');
              return p'}
            else return p}}})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>balR_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree (rbt.Node l R k v r) p&gt;
   btree_balR p
   &lt;btree (balR l k v r)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"balR l k v r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>btree_combine</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('a::heap, 'b::heap) btree ⇒ ('a, 'b) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"btree_combine lp rp =
   (if lp = None then return rp
    else if rp = None then return lp
    else do {
      lt ← !(the lp);
      rt ← !(the rp);
      if cl lt = R then
        if cl rt = R then do {
          tmp ← btree_combine (rsub lt) (lsub rt);
          cl_tm ← get_color tmp;
          if cl_tm = R then do {
            tmt ← !(the tmp);
            the lp := Node (lsub lt) R (key lt) (val lt) (lsub tmt);
            the rp := Node (rsub tmt) R (key rt) (val rt) (rsub rt);
            the tmp := Node lp R (key tmt) (val tmt) rp;
            return tmp}
          else do {
            the rp := Node tmp R (key rt) (val rt) (rsub rt);
            the lp := Node (lsub lt) R (key lt) (val lt) rp;
            return lp}}
        else do {
          tmp ← btree_combine (rsub lt) rp;
          the lp := Node (lsub lt) R (key lt) (val lt) tmp;
          return lp}
      else if cl rt = B then do {
        tmp ← btree_combine (rsub lt) (lsub rt);
        cl_tm ← get_color tmp;
        if cl_tm = R then do {
          tmt ← !(the tmp);
          the lp := Node (lsub lt) B (key lt) (val lt) (lsub tmt);
          the rp := Node (rsub tmt) B (key rt) (val rt) (rsub rt);
          the tmp := Node lp R (key tmt) (val tmt) rp;
          return tmp}
        else do {
          the rp := Node tmp B (key rt) (val rt) (rsub rt);
          the lp := Node (lsub lt) R (key lt) (val lt) rp;
          btree_balL lp}}
      else do {
        tmp ← btree_combine lp (lsub rt);
        the rp := Node tmp R (key rt) (val rt) (rsub rt);
        return rp}})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>combine_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree lt lp * btree rt rp&gt;
   btree_combine lp rp
   &lt;btree (combine lt rt)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine lt rt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>lp</span><span> </span><span>rp</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lt = rbt.Node l1 c1 k1 v1 r1, rt = rbt.Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"combine (rbt.Node l1 c1 k1 v1 r1) (rbt.Node l2 c2 k2 v2 r2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>rbt_del</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ ('a, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_del x p = (case p of
     None ⇒ return None
   | Some pp ⇒ do {
      t ← !pp;
      (if x = key t then btree_combine (lsub t) (rsub t)
       else if x &lt; key t then case lsub t of
         None ⇒ do {
           set_color R p;
           return p}
       | Some lp ⇒ do {
           lt ← !lp;
           if cl lt = B then do {
             q ← rbt_del x (lsub t);
             pp := Node q R (key t) (val t) (rsub t);
             btree_balL p }
           else do {
             q ← rbt_del x (lsub t);
             pp := Node q R (key t) (val t) (rsub t);
             return p }}
       else case rsub t of
         None ⇒ do {
           set_color R p;
           return p}
       | Some rp ⇒ do {
           rt ← !rp;
           if cl rt = B then do {
             q ← rbt_del x (rsub t);
             pp := Node (lsub t) R (key t) (val t) q;
             btree_balR p }
           else do {
             q ← rbt_del x (rsub t);
             pp := Node (lsub t) R (key t) (val t) q;
             return p }})})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_del_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt;
   rbt_del x p
   &lt;btree (del x t)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>p</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = rbt.Node l c k v r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"del x (rbt.Node l c k v r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_delete</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} ⇒ ('a, 'b::heap) btree ⇒ ('a, 'b) btree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_delete k p = do {
    p' ← rbt_del k p;
    paint B p';
    return p'}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_delete_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;btree t p&gt;
   rbt_delete k p
   &lt;btree (RBTree.delete k t)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer interface›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Express Hoare triples for operations on red-black tree in terms of
  the mapping represented by the tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_map_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) map ⇒ ('a::{heap,linorder}, 'b::heap) rbt_node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_map_assn M p = (∃<span class="hidden">⇩</span><sub>A</sub>t. btree t p * ↑(is_rbt t) * ↑(rbt_sorted t) * ↑(M = rbt_map t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm rbt_map_assn_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; tree_empty &lt;rbt_map_assn empty_map&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_insert_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;rbt_map_assn M b&gt; rbt_insert k v b &lt;rbt_map_assn (M {k → v})&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_search</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;rbt_map_assn M b&gt; rbt_search x b &lt;λr. rbt_map_assn M b * ↑(r = M⟨x⟩)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rbt_delete_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;rbt_map_assn M b&gt; rbt_delete k b &lt;rbt_map_assn (delete_map k M)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Arrays_Impl">
<div class="head"><h1>Theory Arrays_Impl</h1>
<span class="command">theory</span> <span class="name">Arrays_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a> <a href="Arrays_Ex.html"><span class="name">Arrays_Ex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Arrays_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of arrays›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Arrays_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Arrays_Ex"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Imperative implementations of common array operations.

  Imperative reverse on arrays is also verified in theory Imperative\_Reverse
  in Imperative\_HOL/ex in the Isabelle library.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Array copy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>array_copy</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap array ⇒ 'a array ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_copy a b 0 = (return ())"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"array_copy a b (Suc n) = do {
      array_copy a b n;
      x ← Array.nth a n;
      Array.upd n x b;
      return () }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_copy_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length as ⟹ n ≤ length bs ⟹
   &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> as * b ↦<span class="hidden">⇩</span><sub>a</sub> bs&gt;
    array_copy a b n
   &lt;λ_. a ↦<span class="hidden">⇩</span><sub>a</sub> as * b ↦<span class="hidden">⇩</span><sub>a</sub> Arrays_Ex.array_copy as bs n&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Swap›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>swap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap array ⇒ nat ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"swap a i j = do {
     x ← Array.nth a i;
     y ← Array.nth a j;
     Array.upd i y a;
     Array.upd j x a;
     return ()
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   swap p i j
   &lt;λ_. p ↦<span class="hidden">⇩</span><sub>a</sub> list_swap xs i j&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reverse›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap array ⇒ nat ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rev a i j = (if i &lt; j then do {
     swap a i j;
     rev a (i + 1) (j - 1)
   }
   else return ())"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j &lt; length xs ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   rev p i j
   &lt;λ_. p ↦<span class="hidden">⇩</span><sub>a</sub> rev_swap xs i j&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_swap xs i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of imperative reverse.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rev_is_rev</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   rev p 0 (length xs - 1)
   &lt;λ_. p ↦<span class="hidden">⇩</span><sub>a</sub> List.rev xs&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Quicksort_Impl">
<div class="head"><h1>Theory Quicksort_Impl</h1>
<span class="command">theory</span> <span class="name">Quicksort_Impl</span><br/>
<span class="keyword">imports</span> <a href="Arrays_Impl.html"><span class="name">Arrays_Impl</span></a> <a href="Quicksort.html"><span class="name">Quicksort</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Quicksort_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of quicksort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Quicksort_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Arrays_Impl</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Quicksort"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Imperative implementation of quicksort. Also verified in
  theory Imperative\_Quicksort in HOL/Imperative\_HOL/ex
  in the Isabelle library.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>part1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} array ⇒ nat ⇒ nat ⇒ 'a ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"part1 a l r p = (
     if r ≤ l then return r
     else do {
       v ← Array.nth a l;
       if v ≤ p then
         part1 a (l + 1) r p
       else do {
         swap a l r;
         part1 a l (r - 1) p }})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part1_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   part1 p l r a
   &lt;λrs. p ↦<span class="hidden">⇩</span><sub>a</sub> snd (Quicksort.part1 xs l r a) * ↑(rs = fst (Quicksort.part1 xs l r a))&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Quicksort.part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Quicksort.part1 xs l r a"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partition function›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} array ⇒ nat ⇒ nat ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"partition a l r = do {
     p ← Array.nth a r;
     m ← part1 a l (r - 1) p;
     v ← Array.nth a m;
     m' ← return (if v ≤ p then m + 1 else m);
     swap a m' r;
     return m'
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partition_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l &lt; r ⟹ r &lt; length xs ⟹ &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   partition a l r
   &lt;λrs. a ↦<span class="hidden">⇩</span><sub>a</sub> snd (Quicksort.partition xs l r) * ↑(rs = fst (Quicksort.partition xs l r))&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Quicksort.partition xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Quicksort function›</span></span></span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>quicksort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} array ⇒ nat ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"quicksort a l r = do {
     len ← Array.len a;
     if l ≥ r then return ()
     else if r &lt; len then do {
       p ← partition a l r;
       quicksort a l (p - 1);
       quicksort a (p + 1) r
     }
     else return ()
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r &lt; length xs ⟹ &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   quicksort a l r
   &lt;λ_. a ↦<span class="hidden">⇩</span><sub>a</sub> Quicksort.quicksort xs l r&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Quicksort.quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Quicksort.quicksort xs l r"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::{heap,linorder}) array ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"quicksort_all a = do {
     n ← Array.len a;
     if n = 0 then return ()
     else quicksort a 0 (n - 1)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of quicksort.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>quicksort_sorts_basic</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;a ↦<span class="hidden">⇩</span><sub>a</sub> xs&gt;
   quicksort_all a
   &lt;λ_. a ↦<span class="hidden">⇩</span><sub>a</sub> sort xs&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Union_Find_Impl">
<div class="head"><h1>Theory Union_Find_Impl</h1>
<span class="command">theory</span> <span class="name">Union_Find_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a> <a href="Union_Find.html"><span class="name">Union_Find</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Union_Find_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of union find›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Union_Find_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Union_Find"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Development follows theory Union\_Find in
  \cite{Separation_Logic_Imperative_HOL-AFP} by Lammich and Meis.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>uf</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat array × nat array"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_uf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat×nat) set ⇒ uf ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_uf n R u = (∃<span class="hidden">⇩</span><sub>A</sub>l szl. snd u ↦<span class="hidden">⇩</span><sub>a</sub> l * fst u ↦<span class="hidden">⇩</span><sub>a</sub> szl *
        ↑(ufa_invar l) * ↑(ufa_α l = R) * ↑(length l = n) * ↑(length szl = n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uf_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ uf Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_init n = do {
     l ← Array.of_list [0..&lt;n];
     szl ← Array.new n (1::nat);
     return (szl, l)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of uf\_init.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>uf_init_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; uf_init n &lt;is_uf n (uf_init_rel n)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>uf_rep_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat array ⇒ nat ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_rep_of p i = do {
     n ← Array.nth p i;
     if n = i then return i else uf_rep_of p n
   }"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uf_rep_of_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> l&gt;
   uf_rep_of p i
   &lt;λr. p ↦<span class="hidden">⇩</span><sub>a</sub> l * ↑(r = rep_of l i)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>uf_compress</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat array ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_compress i ci p = (
    if i = ci then return ()
    else do {
      ni ← Array.nth p i;
      uf_compress ni ci p;
      Array.upd i ci p;
      return ()
    })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uf_compress_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> l&gt;
    uf_compress i (rep_of l i) p
   &lt;λ_. ∃<span class="hidden">⇩</span><sub>A</sub>l'. p ↦<span class="hidden">⇩</span><sub>a</sub> l' * ↑(ufa_invar l' ∧ length l' = length l ∧
              (∀i&lt;length l. rep_of l' i = rep_of l i))&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@prop_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ∧ i &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uf_rep_of_c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat array ⇒ nat ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_rep_of_c p i = do {
    ci ← uf_rep_of p i;
    uf_compress i ci p;
    return ci
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uf_rep_of_c_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ufa_invar l ⟹ i &lt; length l ⟹
   &lt;p ↦<span class="hidden">⇩</span><sub>a</sub> l&gt;
   uf_rep_of_c p i
   &lt;λr. ∃<span class="hidden">⇩</span><sub>A</sub>l'. p ↦<span class="hidden">⇩</span><sub>a</sub> l' * ↑(r = rep_of l i ∧ ufa_invar l' ∧ length l' = length l ∧
                          (∀i&lt;length l. rep_of l' i = rep_of l i))&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uf_cmp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"uf ⇒ nat ⇒ nat ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_cmp u i j = do {
    n ← Array.len (snd u);
    if (i≥n ∨ j≥n) then return False
    else do {
      ci ← uf_rep_of_c (snd u) i;
      cj ← uf_rep_of_c (snd u) j;
      return (ci = cj)
    }
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of compare.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>uf_cmp_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;is_uf n R u&gt;
   uf_cmp u i j
   &lt;λr. is_uf n R u * ↑(r ⟷ (i,j)∈R)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uf_union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"uf ⇒ nat ⇒ nat ⇒ uf Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uf_union u i j = do {
    ci ← uf_rep_of (snd u) i;
    cj ← uf_rep_of (snd u) j;
    if (ci = cj) then return u
    else do {
      si ← Array.nth (fst u) ci;
      sj ← Array.nth (fst u) cj;
      if si &lt; sj then do {
        Array.upd ci cj (snd u);
        Array.upd cj (si+sj) (fst u);
        return u
      } else do { 
        Array.upd cj ci (snd u);
        Array.upd ci (si+sj) (fst u);
        return u
      }
    }
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of union.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>uf_union_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ j &lt; n ⟹
   &lt;is_uf n R u&gt;
   uf_union u i j
   &lt;is_uf n (per_union R i j)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm is_uf_def}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Connectivity_Impl">
<div class="head"><h1>Theory Connectivity_Impl</h1>
<span class="command">theory</span> <span class="name">Connectivity_Impl</span><br/>
<span class="keyword">imports</span> <a href="Union_Find_Impl.html"><span class="name">Union_Find_Impl</span></a> <a href="Connectivity.html"><span class="name">Connectivity</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Connectivity_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of connectivity on graphs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Connectivity_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Union_Find_Impl</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Connectivity"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative version of graph-connectivity example.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Constructing the connected relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>connected_rel_imp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (nat × nat) list ⇒ nat ⇒ uf Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"connected_rel_imp n es 0 = do { p ← uf_init n; return p }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected_rel_imp n es (Suc k) = do {
    p ← connected_rel_imp n es k;
    p' ← uf_union p (fst (es ! k)) (snd (es ! k));
    return p' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_imp_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (set es) ⟹ k ≤ length es ⟹
   &lt;emp&gt;
   connected_rel_imp n es k
   &lt;is_uf n (connected_rel_ind n es k)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_rel_imp_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_valid_graph n (set es) ⟹
   &lt;emp&gt;
   connected_rel_imp n es (length es)
   &lt;is_uf n (connected_rel n (set es))&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Connectedness tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of the algorithm for detecting connectivity.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>uf_cmp_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;is_uf n (connected_rel n S) p&gt;
   uf_cmp p i j
   &lt;λr. is_uf n (connected_rel n S) p * ↑(r ⟷ has_path n S i j)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DynamicArray">
<div class="head"><h1>Theory DynamicArray</h1>
<span class="command">theory</span> <span class="name">DynamicArray</span><br/>
<span class="keyword">imports</span> <a href="Arrays_Impl.html"><span class="name">Arrays_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: DynamicArray.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of dynamic arrays›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DynamicArray</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Arrays_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Dynamically allocated arrays.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>dynamic_array</span><span> </span><span class="delimiter">=</span><span> </span><span>Dyn_Array</span><span> </span><span class="delimiter">(</span><span>alen</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a array"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "dynamic_array"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Raw assertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dyn_array_raw</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap list × nat ⇒ 'a dynamic_array ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dyn_array_raw (xs, n) (Dyn_Array m a) = (a ↦<span class="hidden">⇩</span><sub>a</sub> xs * ↑(m = n))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm dyn_array_raw.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dyn_array_new</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dyn_array_new = do {
     p ← Array.new 5 undefined;
     return (Dyn_Array 0 p)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dyn_array_new_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt;
   dyn_array_new
   &lt;dyn_array_raw (replicate 5 undefined, 0)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>double_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array ⇒ 'a dynamic_array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"double_length (Dyn_Array al ar) = do {
      am ← Array.len ar;
      p ← Array.new (2 * am + 1) undefined;
      array_copy ar p am;
      return (Dyn_Array am p)
    }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>double_length_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap list × nat ⇒ 'a list × nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"double_length_fun (xs, n) =
    (Arrays_Ex.array_copy xs (replicate (2 * n + 1) undefined) n, n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm double_length_fun.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>double_length_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length xs = n ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   double_length p
   &lt;dyn_array_raw (double_length_fun (xs, n))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>push_array_basic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a::heap dynamic_array ⇒ 'a dynamic_array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"push_array_basic x (Dyn_Array al ar) = do {
    Array.upd al x ar;
    return (Dyn_Array (al + 1) ar)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>push_array_basic_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a::heap list × nat ⇒ 'a list × nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"push_array_basic_fun x (xs, n) = (list_update xs n x, n + 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm push_array_basic_fun.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>push_array_basic_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length xs ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   push_array_basic x p
   &lt;dyn_array_raw (push_array_basic_fun x (xs, n))&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dynamic_array ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_length d = return (alen d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_length_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dyn_array_raw (xs, n) p&gt;
   array_length p
   &lt;λr. dyn_array_raw (xs, n) p * ↑(r = n)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_max</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_max d = Array.len (aref d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_max_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dyn_array_raw (xs, n) p&gt;
   array_max p
   &lt;λr. dyn_array_raw (xs, n) p * ↑(r = length xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array ⇒ nat ⇒ 'a Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_nth d i = Array.nth (aref d) i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ n ≤ length xs ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   array_nth p i
   &lt;λr. dyn_array_raw (xs, n) p * ↑(r = xs ! i)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a ⇒ 'a::heap dynamic_array ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_upd i x d = do { Array.upd i x (aref d); return () }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ n ≤ length xs ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   array_upd i x p
   &lt;λ_. dyn_array_raw (list_update xs i x, n) p&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>push_array</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a::heap dynamic_array ⇒ 'a dynamic_array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"push_array x p = do {
    m ← array_max p;
    l ← array_length p;
    if l &lt; m then push_array_basic x p
    else do {
      u ← double_length p;
      push_array_basic x u
    }
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pop_array</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array ⇒ ('a × 'a dynamic_array) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pop_array d = do {
    x ← Array.nth (aref d) (alen d - 1);
    return (x, Dyn_Array (alen d - 1) (aref d))
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pop_array_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟹ n ≤ length xs ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   pop_array p
   &lt;λ(x, r). dyn_array_raw (xs, n - 1) r * ↑(x = xs ! (n - 1))&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm dyn_array_raw.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_simple_datatype "dynamic_array"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>push_array_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a::heap list × nat ⇒ 'a list × nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"push_array_fun x (xs, n) = (
     if n &lt; length xs then push_array_basic_fun x (xs, n)
     else push_array_basic_fun x (double_length_fun (xs, n)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm push_array_fun.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>push_array_rule'</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹
   &lt;dyn_array_raw (xs, n) p&gt;
   push_array x p
   &lt;dyn_array_raw (push_array_fun x (xs, n))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract assertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>abs_array</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap list × nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"abs_array (xs, n) = take n xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm abs_array.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>double_length_abs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length xs = n ⟹ abs_array (double_length_fun (xs, n)) = abs_array (xs, n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>push_array_basic_abs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length xs ⟹ abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take n xs @ [x]) = n + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>push_array_fun_abs</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ abs_array (push_array_fun x (xs, n)) = abs_array (xs, n) @ [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dyn_array</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap list ⇒ 'a dynamic_array ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dyn_array xs a = (∃<span class="hidden">⇩</span><sub>A</sub>p. dyn_array_raw p a * ↑(xs = abs_array p) * ↑(snd p ≤ length (fst p)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dyn_array_new_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; dyn_array_new &lt;dyn_array []&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_length_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dyn_array xs p&gt;
   array_length p
   &lt;λr. dyn_array xs p * ↑(r = length xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹
   &lt;dyn_array xs p&gt;
    array_nth p i
   &lt;λr. dyn_array xs p * ↑(r = xs ! i)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹
   &lt;dyn_array xs p&gt;
    array_upd i x p
   &lt;λ_. dyn_array (list_update xs i x) p&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>push_array_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dyn_array xs p&gt;
    push_array x p
   &lt;dyn_array (xs @ [x])&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pop_array_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹
   &lt;dyn_array xs p&gt;
   pop_array p
   &lt;λ(x, r). dyn_array (butlast xs) r * ↑(x = last xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last xs = xs ! (length xs - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm dyn_array_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Derived operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>array_swap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap dynamic_array ⇒ nat ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"array_swap d i j = do {
    x ← array_nth d i;
    y ← array_nth d j;
    array_upd i y d;
    array_upd j x d;
    return ()
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_swap_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹
   &lt;dyn_array xs p&gt;
   array_swap p i j
   &lt;λ_. dyn_array (list_swap xs i j) p&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Indexed_PQueue_Impl">
<div class="head"><h1>Theory Indexed_PQueue_Impl</h1>
<span class="command">theory</span> <span class="name">Indexed_PQueue_Impl</span><br/>
<span class="keyword">imports</span> <a href="DynamicArray.html"><span class="name">DynamicArray</span></a> <a href="Indexed_PQueue.html"><span class="name">Indexed_PQueue</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Indexed_PQueue_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of the indexed priority queue›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Indexed_PQueue_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>DynamicArray</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Indexed_PQueue"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Imperative implementation of indexed priority queue. The data structure
  is also verified in \cite{Refine_Imperative_HOL-AFP} by Peter Lammich.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>indexed_pqueue</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Indexed_PQueue</span><span> </span><span class="delimiter">(</span><span>pqueue</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × 'a) dynamic_array"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>index</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat option array"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "indexed_pqueue"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_pqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap idx_pqueue ⇒ 'a indexed_pqueue ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue (xs, m) (Indexed_PQueue pq idx) = (dyn_array xs pq * idx ↦<span class="hidden">⇩</span><sub>a</sub> m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm idx_pqueue.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::heap indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_empty k = do {
    pq ← dyn_array_new;
    idx ← Array.new k None;
    return (Indexed_PQueue pq idx) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt;
   idx_pqueue_empty n
   &lt;idx_pqueue ([], replicate n None)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap indexed_pqueue ⇒ nat ⇒ (nat × 'a) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_nth p i = array_nth (pqueue p) i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_nth_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;idx_pqueue (xs, m) p * ↑(i &lt; length xs)&gt;
   idx_pqueue_nth p i
   &lt;λr. idx_pqueue (xs, m) p * ↑(r = xs ! i)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap indexed_pqueue ⇒ nat ⇒ nat option Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_nth p i = Array.nth (index p) i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_nth_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;idx_pqueue (xs, m) p * ↑(i &lt; length m)&gt;
   idx_nth p i
   &lt;λr. idx_pqueue (xs, m) p * ↑(r = m ! i)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a indexed_pqueue ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_length a = array_length (pqueue a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_length_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;idx_pqueue (xs, m) p&gt;
   idx_pqueue_length p
   &lt;λr. idx_pqueue (xs, m) p * ↑(r = length xs)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_swap</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} indexed_pqueue ⇒ nat ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap p i j = do {
     pr_i ← array_nth (pqueue p) i;
     pr_j ← array_nth (pqueue p) j;
     Array.upd (fst pr_i) (Some j) (index p);
     Array.upd (fst pr_j) (Some i) (index p);
     array_swap (pqueue p) i j
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_swap_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ j &lt; length xs ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   idx_pqueue_swap p i j
   &lt;λ_. idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_swap_fun (xs, m) i j"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_push</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::heap ⇒ 'a indexed_pqueue ⇒ 'a indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_push k v p = do {
     len ← array_length (pqueue p);
     d' ← push_array (k, v) (pqueue p);
     Array.upd k (Some len) (index p);
     return (Indexed_PQueue d' (index p))
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_push_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length m ⟹ ¬has_key_alist xs k ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   idx_pqueue_push k v p
   &lt;idx_pqueue (idx_pqueue_push_fun k v (xs, m))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_push_fun k v (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_pop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::heap indexed_pqueue ⇒ ((nat × 'a) × 'a indexed_pqueue) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_pop p = do {
     (x, d') ← pop_array (pqueue p);
     Array.upd (fst x) None (index p);
     return (x, Indexed_PQueue d' (index p))
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_pqueue_pop_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   idx_pqueue_pop p
   &lt;λ(x, r). idx_pqueue (idx_pqueue_pop_fun (xs, m)) r * ↑(x = last xs)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_pop_fun (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_array_upd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a ⇒ 'a::heap dynamic_array ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_array_upd i x d = array_upd i x d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_idx_pqueue_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ k = fst (xs ! i) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   idx_pqueue_array_upd i (k, v) (pqueue p)
   &lt;λ_. idx_pqueue (list_update xs i (k, v), m) p&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_key_idx_pqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::{heap,linorder} indexed_pqueue ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"has_key_idx_pqueue k p = do {
    i_opt ← Array.nth (index p) k;
    return (i_opt ≠ None) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_key_idx_pqueue_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length m ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   has_key_idx_pqueue k p
   &lt;λr. idx_pqueue (xs, m) p * ↑(r ⟷ has_key_alist xs k)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm idx_pqueue.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_simple_datatype "indexed_pqueue"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bubble up and down›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>idx_bubble_down</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} indexed_pqueue ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down a k = do {
    len ← idx_pqueue_length a;
    (if s2 k &lt; len then do {
      vk ← idx_pqueue_nth a k;
      vs1k ← idx_pqueue_nth a (s1 k);
      vs2k ← idx_pqueue_nth a (s2 k);
      (if snd vs1k ≤ snd vs2k then
         if snd vk &gt; snd vs1k then
           do { idx_pqueue_swap a k (s1 k); idx_bubble_down a (s1 k) }
         else return ()
       else
         if snd vk &gt; snd vs2k then
           do { idx_pqueue_swap a k (s2 k); idx_bubble_down a (s2 k) }
         else return ()) }
     else if s1 k &lt; len then do {
       vk ← idx_pqueue_nth a k;
       vs1k ← idx_pqueue_nth a (s1 k);
       (if snd vk &gt; snd vs1k then
          do { idx_pqueue_swap a k (s1 k); idx_bubble_down a (s1 k) }
        else return ()) }
     else return ()) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_down_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue x ⟹
   &lt;idx_pqueue x a&gt;
   idx_bubble_down a k
   &lt;λ_. idx_pqueue (idx_bubble_down_fun x k) a&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_down_fun (xs, m) k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 k &lt; length xs"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (xs ! s1 k) ≤ snd (xs ! s2 k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 k &lt; length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>idx_bubble_up</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} indexed_pqueue ⇒ nat ⇒ unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up a k =
    (if k = 0 then return () else do {
       len ← idx_pqueue_length a;
       (if k &lt; len then do {
          vk ← idx_pqueue_nth a k;
          vpk ← idx_pqueue_nth a (par k);
          (if snd vk &lt; snd vpk then
             do { idx_pqueue_swap a k (par k); idx_bubble_up a (par k) }
           else return ()) }
        else return ())})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_bubble_up_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_of_pqueue x ⟹
   &lt;idx_pqueue x a&gt;
   idx_bubble_up a k
   &lt;λ_. idx_pqueue (idx_bubble_up_fun x k) a&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@fun_induct</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun x k"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = (xs, m), k = k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_bubble_up_fun (xs, m) k"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>delete_min_idx_pqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::{heap,linorder} indexed_pqueue ⇒ ((nat × 'a) × 'a indexed_pqueue) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_min_idx_pqueue p = do {
     len ← idx_pqueue_length p;
     if len = 0 then raise STR ''delete_min''
     else do {
       idx_pqueue_swap p 0 (len - 1);
       (x', r) ← idx_pqueue_pop p;
       idx_bubble_down r 0;
       return (x', r)
     }
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_min_idx_pqueue_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   delete_min_idx_pqueue p
   &lt;λ(x, r). idx_pqueue (snd (delete_min_idx_pqueue_fun (xs, m))) r *
       ↑(x = fst (delete_min_idx_pqueue_fun (xs, m)))&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_min_idx_pqueue_fun (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insert_idx_pqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::{heap,linorder} ⇒ 'a indexed_pqueue ⇒ 'a indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert_idx_pqueue k v p = do {
     p' ← idx_pqueue_push k v p;
     len ← idx_pqueue_length p';
     idx_bubble_up p' (len - 1);
     return p'
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_idx_pqueue_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length m ⟹ ¬has_key_alist xs k ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   insert_idx_pqueue k v p
   &lt;idx_pqueue (insert_idx_pqueue_fun k v (xs, m))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert_idx_pqueue_fun k v (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_idx_pqueue</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::{heap,linorder} ⇒ 'a indexed_pqueue ⇒ 'a indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"update_idx_pqueue k v p = do {
    i_opt ← idx_nth p k;
    case i_opt of
      None ⇒ insert_idx_pqueue k v p
    | Some i ⇒ do {
      x ← idx_pqueue_nth p i;
      idx_pqueue_array_upd i (k, v) (pqueue p);
      (if snd x ≤ v then do {idx_bubble_down p i; return p}
       else do {idx_bubble_up p i; return p}) }}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>update_idx_pqueue_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; length m ⟹ index_of_pqueue (xs, m) ⟹
   &lt;idx_pqueue (xs, m) p&gt;
   update_idx_pqueue k v p
   &lt;idx_pqueue (update_idx_pqueue_fun k v (xs, m))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_idx_pqueue_fun k v (xs, m)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer interface›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Express Hoare triples for indexed priority queue operations in terms of
  the mapping represented by the queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>idx_pqueue_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat, 'a::{heap,linorder}) map ⇒ nat ⇒ 'a indexed_pqueue ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_pqueue_map M n p = (∃<span class="hidden">⇩</span><sub>A</sub>xs m. idx_pqueue (xs, m) p *
      ↑(index_of_pqueue (xs, m)) * ↑(is_heap xs) * ↑(M = map_of_alist xs) * ↑(n = length m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm idx_pqueue_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_implies_hd_min2</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_heap xs ⟹ xs ≠ [] ⟹ (map_of_alist xs)⟨k⟩ = Some v ⟹ snd (hd xs) ≤ v"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ! i = (k, v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (hd xs) ≤ snd (xs ! i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>idx_pqueue_empty_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt;
   idx_pqueue_empty n
   &lt;idx_pqueue_map empty_map n&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>delete_min_idx_pqueue_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;idx_pqueue_map M n p * ↑(M ≠ empty_map)&gt;
   delete_min_idx_pqueue p
   &lt;λ(x, r). idx_pqueue_map (delete_map (fst x) M) n r * ↑(fst x &lt; n) *
                ↑(is_heap_min (fst x) M) * ↑(M⟨fst x⟩ = Some (snd x))&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_idx_pqueue_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; n ⟹ k ∉ keys_of M ⟹
   &lt;idx_pqueue_map M n p&gt;
   insert_idx_pqueue k v p
   &lt;idx_pqueue_map (M {k → v}) n&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>has_key_idx_pqueue_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; n ⟹
   &lt;idx_pqueue_map M n p&gt;
   has_key_idx_pqueue k p
   &lt;λr. idx_pqueue_map M n p * ↑(r ⟷ k ∈ keys_of M)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>update_idx_pqueue_map</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k &lt; n ⟹
   &lt;idx_pqueue_map M n p&gt;
   update_idx_pqueue k v p
   &lt;idx_pqueue_map (M {k → v}) n&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm idx_pqueue_map_def}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra_Impl">
<div class="head"><h1>Theory Dijkstra_Impl</h1>
<span class="command">theory</span> <span class="name">Dijkstra_Impl</span><br/>
<span class="keyword">imports</span> <a href="Indexed_PQueue_Impl.html"><span class="name">Indexed_PQueue_Impl</span></a> <a href="Dijkstra.html"><span class="name">Dijkstra</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Dijkstra_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Dijkstra's algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Indexed_PQueue_Impl</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Dijkstra"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Imperative implementation of Dijkstra's shortest path algorithm. The
  algorithm is also verified by Nordhoff and Lammich in
  \cite{Dijkstra_Shortest_Path-AFP}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>dijkstra_state</span><span> </span><span class="delimiter">=</span><span> </span><span>Dijkstra_State</span><span> </span><span class="delimiter">(</span><span>est_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat array"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>heap_pq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat indexed_pqueue"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_simple_datatype "dijkstra_state"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ dijkstra_state ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dstate (State e M) (Dijkstra_State a pq) = a ↦<span class="hidden">⇩</span><sub>a</sub> e * idx_pqueue_map M (length e) pq"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm dstate.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dstate_pq_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dstate_pq_init G 0 = idx_pqueue_empty (size G)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"dstate_pq_init G (Suc k) = do {
    p ← dstate_pq_init G k;
    if k &gt; 0 then update_idx_pqueue k (weight G 0 k) p
    else return p }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_pq_init_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k ≤ size G ⟹
   &lt;emp&gt;
   dstate_pq_init G k
   &lt;idx_pqueue_map (map_constr (λi. i &gt; 0) (λi. weight G 0 i) k) (size G)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dstate_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ dijkstra_state Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dstate_init G = do {
     a ← Array.of_list (list (λi. if i = 0 then 0 else weight G 0 i) (size G));
     pq ← dstate_pq_init G (size G);
     return (Dijkstra_State a pq)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_init_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt;
   dstate_init G
   &lt;dstate (dijkstra_start_state G)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dstate_update_est</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat indexed_pqueue ⇒ nat array ⇒ nat array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dstate_update_est G m 0 pq a = (return a)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"dstate_update_est G m (Suc k) pq a = do {
     b ← has_key_idx_pqueue k pq;
     if b then do {
       ek ← Array.nth a k;
       em ← Array.nth a m;
       a' ← dstate_update_est G m k pq a;
       a'' ← Array.upd k (min (em + weight G m k) ek) a';
       return a'' }
     else dstate_update_est G m k pq a }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_update_est_ind</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k ≤ length e ⟹ m &lt; length e ⟹
   &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> e * idx_pqueue_map M (length e) pq&gt;
   dstate_update_est G m k pq a
   &lt;λr. dstate (State (list_update_set_impl (λi. i ∈ keys_of M)
                      (λi. min (e ! m + weight G m i) (e ! i)) e k) M) (Dijkstra_State r pq)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_update_est_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dstate (State e M) (Dijkstra_State a pq) * ↑(m &lt; length e)&gt;
   dstate_update_est G m (length e) pq a
   &lt;λr. dstate (State (list_update_set (λi. i ∈ keys_of M)
               (λi. min (e ! m + weight G m i) (e ! i)) e) M) (Dijkstra_State r pq)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dstate_update_heap</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ nat ⇒ nat array ⇒ nat indexed_pqueue ⇒ nat indexed_pqueue Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dstate_update_heap G m 0 a pq = return pq"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"dstate_update_heap G m (Suc k) a pq = do {
     b ← has_key_idx_pqueue k pq;
     if b then do {
       ek ← Array.nth a k;
       pq' ← dstate_update_heap G m k a pq;
       update_idx_pqueue k ek pq' }
     else dstate_update_heap G m k a pq }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_update_heap_ind</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k ≤ length e ⟹ m &lt; length e ⟹
   &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> e * idx_pqueue_map M (length e) pq&gt;
   dstate_update_heap G m k a pq
   &lt;λr. dstate (State e (map_update_all_impl (λi. e ! i) M k)) (Dijkstra_State a r)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dstate_update_heap_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m &lt; length e ⟹
   ∀i∈keys_of M. i &lt; length e ⟹
   &lt;dstate (State e M) (Dijkstra_State a pq)&gt;
   dstate_update_heap G m (length e) a pq
   &lt;λr. dstate (State e (map_update_all (λi. e ! i) M)) (Dijkstra_State a r)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dijkstra_extract_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dijkstra_state ⇒ (nat × dijkstra_state) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra_extract_min (Dijkstra_State a pq) = do {
     (x, pq') ← delete_min_idx_pqueue pq;
     return (fst x, Dijkstra_State a pq') }"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_extract_min_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"M ≠ empty_map ⟹
   &lt;dstate (State e M) (Dijkstra_State a pq)&gt;
   dijkstra_extract_min (Dijkstra_State a pq)
   &lt;λ(m, r). dstate (State e (delete_map m M)) r * ↑(m &lt; length e) * ↑(is_heap_min m M)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm dstate.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dijkstra_step_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ dijkstra_state ⇒ dijkstra_state Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra_step_impl G (Dijkstra_State a pq) = do {
     (x, S') ← dijkstra_extract_min (Dijkstra_State a pq);
     a' ← dstate_update_est G x (size G) (heap_pq S') (est_a S');
     pq'' ← dstate_update_heap G x (size G) a' (heap_pq S');
     return (Dijkstra_State a' pq'') }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_step_impl_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap S ≠ empty_map ⟹ inv G S ⟹
   &lt;dstate S (Dijkstra_State a pq)&gt;
   dijkstra_step_impl G (Dijkstra_State a pq)
   &lt;λr. ∃<span class="hidden">⇩</span><sub>A</sub>S'. dstate S' r * ↑(is_dijkstra_step G S S')&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_step_impl_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap S ≠ empty_map ⟹ inv G S ⟹
   &lt;dstate S p&gt;
   dijkstra_step_impl G p
   &lt;λr. ∃<span class="hidden">⇩</span><sub>A</sub>S'. dstate S' r * ↑(inv G S') * ↑(card (unknown_set S') = card (unknown_set S) - 1)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dijkstra_loop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ nat ⇒ dijkstra_state ⇒ dijkstra_state Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra_loop G 0 p = (return p)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"dijkstra_loop G (Suc k) p = do {
    p' ← dijkstra_step_impl G p;
    p'' ← dijkstra_loop G k p';
    return p'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra_loop_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;dstate S p * ↑(inv G S) * ↑(n ≤ card (unknown_set S))&gt;
   dijkstra_loop G n p
   &lt;λr. ∃<span class="hidden">⇩</span><sub>A</sub>S'. dstate S' r * ↑(inv G S') * ↑(card (unknown_set S') = card (unknown_set S) - n)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>S</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dijkstra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph ⇒ dijkstra_state Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dijkstra G = do {
    p ← dstate_init G;
    dijkstra_loop G (size G - 1) p }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of Dijkstra's algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dijkstra_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size G &gt; 0 ⟹
   &lt;emp&gt;
   dijkstra G
   &lt;λr. ∃<span class="hidden">⇩</span><sub>A</sub>S. dstate S r * ↑(inv G S) * ↑(unknown_set S = {}) *
        ↑(∀i∈verts G. has_dist G 0 i ∧ est S ! i = dist G 0 i)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IntervalTree_Impl">
<div class="head"><h1>Theory IntervalTree_Impl</h1>
<span class="command">theory</span> <span class="name">IntervalTree_Impl</span><br/>
<span class="keyword">imports</span> <a href="SepAuto.html"><span class="name">SepAuto</span></a> <a href="Interval_Tree.html"><span class="name">Interval_Tree</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: IntervalTree_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of interval tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IntervalTree_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SepAuto</span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Interval_Tree"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative version of interval tree.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interval and IdxInterval›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>interval_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap) interval ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interval_encode (Interval l h) = to_nat (l, h)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>idx_interval_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap) idx_interval ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"idx_interval_encode (IdxInterval it i) = to_nat (it, i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>idx_interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"idx_interval_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree nodes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>node</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Node</span><span> </span><span class="delimiter">(</span><span>lsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a node ref option"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a idx_interval"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>tmax</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a node ref option"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms node.sel}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>node_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap) node ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"node_encode (Node l v m r) = to_nat (l, v, m, r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>node</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"node_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>int_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_tree ⇒ nat node ref option ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree Tip p = ↑(p = None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree (interval_tree.Node lt v m rt) (Some p) = (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp v m rp * int_tree lt lp * int_tree rt rp)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree (interval_tree.Node lt v m rt) None = false"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_ent_rule @{thms int_tree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_Tip</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree Tip p ⟹<span class="hidden">⇩</span><sub>A</sub> ↑(p = None)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_Node</span><span> </span><span class="delimiter">[</span><span>forward_ent</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree (interval_tree.Node lt v m rt) p ⟹<span class="hidden">⇩</span><sub>A</sub> (∃<span class="hidden">⇩</span><sub>A</sub>lp rp. the p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp v m rp * int_tree lt lp * int_tree rt rp * ↑(p ≠ None))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = None"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"emp ⟹<span class="hidden">⇩</span><sub>A</sub> int_tree interval_tree.Tip None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_constr_ent</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ↦<span class="hidden">⇩</span><sub>r</sub> Node lp v m rp * int_tree lt lp * int_tree rt rp ⟹<span class="hidden">⇩</span><sub>A</sub> int_tree (interval_tree.Node lt v m rt) (Some p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_entail_matcher [@{thm int_tree_none}, @{thm int_tree_constr_ent}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold del_prfstep_thm @{thms int_tree.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>int_tree</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat node ref option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_tree_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_empty = return None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_empty_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; int_tree_empty &lt;int_tree Tip&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_tree_is_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_is_empty b = return (b = None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_is_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b&gt;
   int_tree_is_empty b
   &lt;λr. int_tree t b * ↑(r ⟷ t = Tip)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_tmax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"get_tmax b = (case b of
     None ⇒ return 0
   | Some p ⇒ do {
      t ← !p;
      return (tmax t) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_tmax_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b&gt; get_tmax b &lt;λr. int_tree t b * ↑(r = interval_tree.tmax t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Tip"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_tmax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ int_tree ⇒ int_tree ⇒ nat Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compute_tmax it l r = do {
    lm ← get_tmax l;
    rm ← get_tmax r;
    return (max3 it lm rm)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_tmax_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t1 b1 * int_tree t2 b2&gt;
   compute_tmax it b1 b2
   &lt;λr. int_tree t1 b1 * int_tree t2 b2 * ↑(r = max3 it (interval_tree.tmax t1) (interval_tree.tmax t2))&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_tree_constr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree ⇒ nat idx_interval ⇒ int_tree ⇒ int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_constr lp v rp = do {
    m ← compute_tmax v lp rp;
    p ← ref (Node lp v m rp);
    return (Some p) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_constr_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree lt lp * int_tree rt rp&gt;
   int_tree_constr lp v rp
   &lt;int_tree (interval_tree.Node lt v (max3 v (interval_tree.tmax lt) (interval_tree.tmax rt)) rt)&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insertion›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>insert_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ int_tree ⇒ int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert_impl v b = (case b of
    None ⇒ int_tree_constr None v None
  | Some p ⇒ do {
    t ← !p;
    (if v = val t then do {
       return (Some p) }
     else if v &lt; val t then do {
       q ← insert_impl v (lsub t);
       m ← compute_tmax (val t) q (rsub t);
       p := Node q (val t) m (rsub t);
       return (Some p) }
     else do {
       q ← insert_impl v (rsub t);
       m ← compute_tmax (val t) (lsub t) q;
       p := Node (lsub t) (val t) m q;
       return (Some p) })})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_insert_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b&gt;
    insert_impl v b
   &lt;int_tree (insert v t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>int_tree_del_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree ⇒ (nat idx_interval × int_tree) Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_del_min b = (case b of
     None ⇒ raise STR ''del_min: empty tree''
   | Some p ⇒ do {
      t ← !p;
      (if lsub t = None then
         return (val t, rsub t)
       else do {
         r ← int_tree_del_min (lsub t);
         m ← compute_tmax (val t) (snd r) (rsub t);
         p := Node (snd r) (val t) m (rsub t);
         return (fst r, Some p) })})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_del_min_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b * ↑(b ≠ None)&gt;
   int_tree_del_min b
   &lt;λr. int_tree (snd (del_min t)) (snd r) * ↑(fst(r) = fst (del_min t))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_tree_del_elt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_tree ⇒ int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_del_elt b = (case b of
     None ⇒ raise STR ''del_elt: empty tree''
   | Some p ⇒ do {
       t ← !p;
       (if lsub t = None then return (rsub t)
        else if rsub t = None then return (lsub t)
        else do {
          r ← int_tree_del_min (rsub t);
          m ← compute_tmax (fst r) (lsub t) (snd r);
          p := Node (lsub t) (fst r) m (snd r);
          return (Some p) }) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_del_elt_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree (interval_tree.Node lt v m rt) b&gt;
   int_tree_del_elt b
   &lt;int_tree (delete_elt_tree (interval_tree.Node lt v m rt))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>delete_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval ⇒ int_tree ⇒ int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delete_impl x b = (case b of
     None ⇒ return None
   | Some p ⇒ do {
      t ← !p;
      (if x = val t then do {
         r ← int_tree_del_elt b;
         return r }
       else if x &lt; val t then do {
         q ← delete_impl x (lsub t);
         m ← compute_tmax (val t) q (rsub t);
         p := Node q (val t) m (rsub t);
         return (Some p) }
       else do {
         q ← delete_impl x (rsub t);
         m ← compute_tmax (val t) (lsub t) q;
         p := Node (lsub t) (val t) m q;
         return (Some p) })})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_tree_delete_to_fun</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b&gt;
    delete_impl x b
   &lt;int_tree (delete x t)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Search›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>search_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat interval ⇒ int_tree ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"search_impl x b = (case b of
     None ⇒ return False
   | Some p ⇒ do {
      t ← !p;
      (if is_overlap (int (val t)) x then return True
       else case lsub t of
           None ⇒ do { b ← search_impl x (rsub t); return b }
         | Some lp ⇒ do {
            lt ← !lp;
            if tmax lt ≥ low x then
              do { b ← search_impl x (lsub t); return b }
            else
              do { b ← search_impl x (rsub t); return b }})})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>search_impl_correct</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree t b&gt;
    search_impl x b
   &lt;λr. int_tree t b * ↑(r ⟷ search t x)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>b</span><span> </span><span class="delimiter">@with</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = interval_tree.Node l v m r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_overlap (int v) x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ Tip ∧ interval_tree.tmax l ≥ low x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@endgoal</span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer interface›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Express Hoare triples for operations on interval tree in terms of
  the set of intervals represented by the tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_tree_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat idx_interval set ⇒ int_tree ⇒ assn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"int_tree_set S p = (∃<span class="hidden">⇩</span><sub>A</sub>t. int_tree t p * ↑(is_interval_tree t) * ↑(S = tree_set t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_ent_rule @{thm int_tree_set_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>int_tree_empty_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; int_tree_empty &lt;int_tree_set {}&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>int_tree_insert_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree_set S b * ↑(is_interval (int x))&gt;
   insert_impl x b
   &lt;int_tree_set (S ∪ {x})&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>int_tree_delete_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree_set S b * ↑(is_interval (int x))&gt;
   delete_impl x b
   &lt;int_tree_set (S - {x})&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>int_tree_search_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;int_tree_set S b * ↑(is_interval x)&gt;
   search_impl x b
   &lt;λr. int_tree_set S b * ↑(r ⟷ has_overlap S x)&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm int_tree_set_def}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Rect_Intersect_Impl">
<div class="head"><h1>Theory Rect_Intersect_Impl</h1>
<span class="command">theory</span> <span class="name">Rect_Intersect_Impl</span><br/>
<span class="keyword">imports</span> <a href="Rect_Intersect.html"><span class="name">Rect_Intersect</span></a> <a href="IntervalTree_Impl.html"><span class="name">IntervalTree_Impl</span></a> <a href="Quicksort_Impl.html"><span class="name">Quicksort_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Rect_Intersect_Impl.thy
  Author: Bohua Zhan
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of rectangle intersection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Rect_Intersect_Impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../Functional/Rect_Intersect"</span></span></span><span> </span><span>IntervalTree_Impl</span><span> </span><span>Quicksort_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative version of rectangle-intersection algorithm.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>operation_encode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::heap) operation ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"operation_encode oper =
   (case oper of INS p i n ⇒ to_nat (is_INS oper, p, i, n)
               | DEL p i n ⇒ to_nat (is_INS oper, p, i, n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>operation</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>heap</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heap_class.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>countable_classI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"operation_encode"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>operation.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Initial state›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rect_inter_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat rectangle list ⇒ nat operation array Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rect_inter_init rects = do {
     p ← Array.of_list (ins_ops rects @ del_ops rects);
     quicksort_all p;
     return p }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm all_ops_def}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rect_inter_init_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; rect_inter_init rects &lt;λp. p ↦<span class="hidden">⇩</span><sub>a</sub> all_ops rects&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm all_ops_def}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rect_inter_next</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat operation array ⇒ int_tree ⇒ nat ⇒ int_tree Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rect_inter_next a b k = do {
    oper ← Array.nth a k;
    if is_INS oper then
      IntervalTree_Impl.insert_impl (IdxInterval (op_int oper) (op_idx oper)) b
    else
      IntervalTree_Impl.delete_impl (IdxInterval (op_int oper) (op_idx oper)) b }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>op_int_is_interval</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ ops = all_ops rects ⟹ k &lt; length ops ⟹
   is_interval (op_int (ops ! k))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ops ! k ∈ set ops"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (ops ! k)"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm op_int_is_interval} [with_term "op_int (?ops ! ?k)"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rect_inter_next_rule</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ k &lt; length (all_ops rects) ⟹
   &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> all_ops rects * int_tree_set S b&gt;
   rect_inter_next a b k
   &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> all_ops rects * int_tree_set (apply_ops_k_next rects S k) r&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>heap</span><span class="delimiter">)</span><span> </span><span>rect_inter_impl</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat operation array ⇒ int_tree ⇒ nat ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rect_inter_impl a b k = do {
    n ← Array.len a;
    (if k ≥ n then return False
     else do {
       oper ← Array.nth a k;
       (if is_INS oper then do {
          overlap ← IntervalTree_Impl.search_impl (op_int oper) b;
          if overlap then return True
          else if k = n - 1 then return False
          else do {
            b' ← rect_inter_next a b k;
            rect_inter_impl a b' (k + 1)}}
        else
          if k = n - 1 then return False
          else do {
            b' ← rect_inter_next a b k;
            rect_inter_impl a b' (k + 1)})})}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rect_inter_to_fun_ind</span><span> </span><span class="delimiter">[</span><span>hoare_triple</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹ k &lt; length (all_ops rects) ⟹
   &lt;a ↦<span class="hidden">⇩</span><sub>a</sub> all_ops rects * int_tree_set S b&gt;
   rect_inter_impl a b k
   &lt;λr. a ↦<span class="hidden">⇩</span><sub>a</sub> all_ops rects * ↑(r ⟷ rect_inter rects S k)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@let</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d = length (all_ops rects) - k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>k</span><span> </span><span>S</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≥ length (all_ops rects)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@unfold</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rect_inter rects S k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_INS (all_ops rects ! k)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_overlap S (op_int (all_ops rects ! k))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = length (all_ops rects) - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (all_ops rects) - (k + 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (all_ops rects) - (k + 1) &lt; d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = length (all_ops rects) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (all_ops rects) - (k + 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (all_ops rects) - (k + 1) &lt; d"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rect_inter_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat rectangle list ⇒ bool Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rect_inter_all rects =
    (if rects = [] then return False
     else do {
       a ← rect_inter_init rects;
       b ← int_tree_empty;
       rect_inter_impl a b 0 })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of rectangle intersection algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rect_inter_all_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_rect_list rects ⟹
   &lt;emp&gt;
   rect_inter_all rects
   &lt;λr. ↑(r = has_rect_overlap rects)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Sep_Examples">
<div class="head"><h1>Theory Sep_Examples</h1>
<span class="command">theory</span> <span class="name">Sep_Examples</span><br/>
<span class="keyword">imports</span> <a href="GCD_Impl.html"><span class="name">GCD_Impl</span></a> <a href="LinkedList.html"><span class="name">LinkedList</span></a> <a href="BST_Impl.html"><span class="name">BST_Impl</span></a> <a href="RBTree_Impl.html"><span class="name">RBTree_Impl</span></a> <a href="Connectivity_Impl.html"><span class="name">Connectivity_Impl</span></a> <a href="Dijkstra_Impl.html"><span class="name">Dijkstra_Impl</span></a> <a href="Rect_Intersect_Impl.html"><span class="name">Rect_Intersect_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Sep_Examples.thy
  Author: Bohua Zhan

  Overall directory of examples in Imperative.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sep_Examples</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>
</span><span>  </span><span>GCD_Impl</span><span> </span><span class="comment">― ‹Tutorial›</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Inductive data structures›</span><span>
</span><span>
</span><span>  </span><span>LinkedList</span><span> </span><span class="comment">― ‹Linked lists›</span><span>
</span><span>  
</span><span>  </span><span>BST_Impl</span><span> </span><span class="comment">― ‹Binary search tree›</span><span>
</span><span>
</span><span>  </span><span>RBTree_Impl</span><span> </span><span class="comment">― ‹Red-black tree›</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Array algorithms›</span><span>
</span><span>
</span><span>  </span><span>Arrays_Impl</span><span> </span><span class="comment">― ‹Standard procedure on arrays›</span><span>
</span><span>
</span><span>  </span><span>DynamicArray</span><span> </span><span class="comment">― ‹Dynamic array›</span><span>
</span><span>  
</span><span>  </span><span>Quicksort_Impl</span><span> </span><span class="comment">― ‹Quicksort›</span><span>
</span><span>  
</span><span>  </span><span>Indexed_PQueue_Impl</span><span> </span><span class="comment">― ‹Indexed priority queue›</span><span>
</span><span>  
</span><span>  </span><span>Union_Find_Impl</span><span> </span><span class="comment">― ‹Union-find›</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Applications›</span><span>
</span><span>
</span><span>  </span><span>Connectivity_Impl</span><span> </span><span class="comment">― ‹Connectivity on graphs›</span><span>
</span><span>  
</span><span>  </span><span>Dijkstra_Impl</span><span> </span><span class="comment">― ‹Dijkstra's algorithm›</span><span>
</span><span>  
</span><span>  </span><span>Rect_Intersect_Impl</span><span> </span><span class="comment">― ‹Rectangular intersection›</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>