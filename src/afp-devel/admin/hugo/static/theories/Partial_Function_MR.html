<div id="Partial_Function_MR">
<div class="head">
<h1>Theory Partial_Function_MR</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Rene Thiemann, License: LGPL *)</span>

<span class="keyword1"><span class="command">theory</span></span> Partial_Function_MR
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"partial_function_mr"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span>  <span class="quoted"><span class="plain_text">‹Register the \isa{partial-function-mr} command›</span></span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹partial_function_mr.ML›</span>
              
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Register the "option"-monad›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obviously, the map-function for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>-monad is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">map_option</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, derive the required identity lemma.›</span></span>

<span class="keyword1" id="Partial_Function_MR-option_map_id"><span class="command">lemma</span></span> option_map_id<span class="main">:</span> <span class="quoted"><span class="quoted">"map_option <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Second, register <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">map_option</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as being monotone.›</span></span>
<span class="keyword1" id="Partial_Function_MR-option_map_mono"><span class="command">lemma</span></span> option_map_mono<span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mf<span class="main">:</span> <span class="quoted"><span class="quoted">"mono_option <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono_option <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map_option <span class="free">h</span> <span class="main">(</span><span class="free">B</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option"</span></span> <span class="keyword3"><span class="command">assume</span></span> fg<span class="main">:</span> <span class="quoted"><span class="quoted">"fun_ord option_ord <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> mf
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"option_ord <span class="main">(</span><span class="free">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">f</span></span></span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">g</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"option_ord <span class="main">(</span>map_option <span class="free">h</span> <span class="main">(</span><span class="free">B</span> <span class="skolem">f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_option <span class="free">h</span> <span class="main">(</span><span class="free">B</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> flat_ord_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And finally perform the registration. We need 
\begin{itemize}
\item a constructor for map: it takes a monadic term $mt$ of type \isa{mtT},
  a list of functions \isa{t-to-ss} with corresponding types in \isa{t-to-sTs},
  a resulting monadic type \isa{msT}, and it should return a monad term \isa{ms} of
  type \isa{msT} which
  is obtained by applying the functions on \isa{mt}. Although for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>-monad,
  the lengths of the lists will always be one, there might be more elements for monads having
  more than one type-parameter.
\item a function to perform type-construction for monads: it takes a list of fixed parameters
  and a list of flexible parameters and has to construct a monadic type out of these parameters.
  The user can freely choose which parameters should be fixed, and which are flexible.
  Only flexible parameters can be changes in the return type of each set of mutual recursive functions.
  Since in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>-monad we would like to be able to change the type-parameter, we ignore
  the fixed parameters here.
\item a function to deconstruct monadic types into fixed and flexible type arguments.
\item a compositionality theorem of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"map <span class="free"><span class="free">f</span></span> <span class="main"><span class="main">(</span></span>map <span class="free"><span class="free">g</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> map <span class="main"><span class="main">(</span></span><span class="free"><span class="free">f</span></span> <span class="keyword1"><span class="keyword1">o</span></span> <span class="free"><span class="free">g</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
\item an identity theorem of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"map <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">m</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">m</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
\end{itemize}
›</span></span>
<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="entity">Partial_Function_MR.init</span> 
  <span class="inner_quoted">"option"</span> 
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">mt</span><span class="main">,</span> <span class="entity">t_to_ss</span><span class="main">,</span> <span class="entity">mtT</span><span class="main">,</span> <span class="entity">msT</span><span class="main">,</span> <span class="entity">t_to_sTs</span><span class="main">)</span> <span class="main">=&gt;</span>
      list_comb <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map_option<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t_to_sTs</span> ---&gt; <span class="entity">mtT</span> --&gt; <span class="entity">msT</span><span class="main">)</span><span class="main">,</span> <span class="entity">t_to_ss</span><span class="main">)</span> $ <span class="entity">mt</span><span class="main">)</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">argTs</span><span class="main">)</span> <span class="main">=&gt;</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">argTs</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">mT</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span>Term.dest_Type <span class="entity">mT</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span> 
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.map_comp<span class="antiquote">}</span></span></span> 
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option_map_id<span class="antiquote">}</span></span></span>
›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Register the "tailrec"-monad›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the "tailrec"-monad (which is the identity monad) we take the identity
  function as map, there are no flexible parameters, and the monadic type itself is
  the (only) fixed argument. As a consequence, we can only define tail-recursive and 
  mutual recursive functions which share the same return type.›</span></span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="entity">Partial_Function_MR.init</span> 
  <span class="inner_quoted">"tailrec"</span> 
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">mt</span><span class="main">,</span> <span class="entity">t_to_ss</span><span class="main">,</span> <span class="entity">mtT</span><span class="main">,</span> <span class="entity">msT</span><span class="main">,</span> <span class="entity">t_to_sTs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mt</span><span class="main">)</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">commonT</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> hd <span class="entity">commonT</span><span class="main">)</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">mT</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="entity">mT</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">[</span><span class="main">]</span> 
  <span class="main">[</span><span class="main">]</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/partial_function_mr.ML">
<div class="head">
<h1>File ‹partial_function_mr.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Rene Thiemann, License: LGPL *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PARTIAL_FUNCTION_MR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> init<span class="main">:</span> string <span class="main">-&gt;</span> 
    <span class="comment1">(* make monad_map: monad term * funs * monad as typ * monad bs typ * a-&gt;b typs 
        -&gt; map_monad funs monad term *)</span>
    <span class="main">(</span>term * term list * typ * typ * typ list <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> 
    <span class="comment1">(* make monad type: fixed and flexible types *)</span>
    <span class="main">(</span>typ list * typ list <span class="main">-&gt;</span> typ<span class="main">)</span> <span class="main">-&gt;</span> 
    <span class="comment1">(* destruct monad type: fixed and flexible types *)</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> typ list * typ list<span class="main">)</span> <span class="main">-&gt;</span> 
    <span class="comment1">(* monad_map_compose thm: mapM f (mapM g x) = mapM (f o g) x *)</span>
    thm list <span class="main">-&gt;</span> 
    <span class="comment1">(* monad_map_ident thm: mapM (% y. y) x = x *)</span>
    thm list <span class="main">-&gt;</span> declaration

  <span class="keyword1"><span class="keyword">val</span></span> add_partial_function_mr<span class="main">:</span> string <span class="main">-&gt;</span> <span class="main">(</span>binding * typ option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> add_partial_function_mr_cmd<span class="main">:</span> string <span class="main">-&gt;</span> <span class="main">(</span>binding * string option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs_cmd</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list * local_theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Partial_Function_MR</span><span class="main">:</span> <span class="entity">PARTIAL_FUNCTION_MR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">partial_function_mr_trace</span> <span class="main">=</span>
  <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> partial_function_mr_trace<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace</span> <span class="entity">ctxt</span> <span class="entity">msg</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">partial_function_mr_trace</span> 
  <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="entity">msg</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">setup_data</span> <span class="main">=</span> <span class="entity">Setup_Data</span> <span class="keyword2"><span class="keyword">of</span></span> 
 <span class="main">{</span>mk_monad_map<span class="main">:</span> term * term list * typ * typ * typ list <span class="main">-&gt;</span> term<span class="main">,</span>
  mk_monadT<span class="main">:</span> typ list * typ list <span class="main">-&gt;</span> typ<span class="main">,</span>
  dest_monadT<span class="main">:</span> typ <span class="main">-&gt;</span> typ list * typ list<span class="main">,</span>
  monad_map_comp<span class="main">:</span> thm list<span class="main">,</span>
  monad_map_id<span class="main">:</span> thm list<span class="main">}</span><span class="main">;</span>

<span class="comment1">(* the following code has been copied from partial_function.ML *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Modes</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">setup_data</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="entity">data</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="entity">data</span><span class="main">;</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">known_modes</span> <span class="main">=</span> Symtab.keys o Modes.get o Context.Proof<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lookup_mode</span> <span class="main">=</span> Symtab.lookup o Modes.get o Context.Proof<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">curry_const</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Product_Type.curry<span class="antiquote">}</span></span><span class="main">,</span>
    <span class="main">[</span><span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> --&gt; <span class="entity">C</span><span class="main">,</span> <span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">]</span> ---&gt; <span class="entity">C</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_curry</span> <span class="entity">f</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> fastype_of <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
    Type <span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">S</span><span class="main">,</span> <span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">U</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="entity">curry_const</span> <span class="main">(</span><span class="entity">S</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> $ <span class="entity">f</span>
  <span class="main">|</span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"mk_curry"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">f</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">curry_n</span> <span class="entity">arity</span> <span class="main">=</span> funpow <span class="main">(</span><span class="entity">arity</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">mk_curry</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">uncurry_n</span> <span class="entity">arity</span> <span class="main">=</span> funpow <span class="main">(</span><span class="entity">arity</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">HOLogic.mk_case_prod</span><span class="main">;</span>    
<span class="comment1">(* end copy of partial_function.ML *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="entity">mode</span> <span class="entity">mk_monad_map</span> <span class="entity">mk_monadT</span> <span class="entity">dest_monadT</span> <span class="entity">monad_map_comp</span> <span class="entity">monad_map_id</span> <span class="entity">phi</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span><span class="main">;</span>
    <span class="comment1">(* TODO: are there morphisms required on mk_monad_map???, ... *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data'</span> <span class="main">=</span> <span class="entity">Setup_Data</span> 
      <span class="main">{</span>mk_monad_map<span class="main">=</span><span class="entity">mk_monad_map</span><span class="main">,</span> mk_monadT<span class="main">=</span><span class="entity">mk_monadT</span><span class="main">,</span> dest_monadT<span class="main">=</span><span class="entity">dest_monadT</span><span class="main">,</span> 
       monad_map_comp<span class="main">=</span>map <span class="entity">thm</span> <span class="entity">monad_map_comp</span><span class="main">,</span>monad_map_id<span class="main">=</span>map <span class="entity">thm</span> <span class="entity">monad_map_id</span><span class="main">}</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Modes.map <span class="main">(</span>Symtab.update <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="entity">data'</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span><span class="entity">T2</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span><span class="entity">T2</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_choiceT</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span> <span class="entity">ty</span>
  <span class="main">|</span> <span class="entity">mk_choiceT</span> <span class="main">(</span><span class="entity">ty</span> :: <span class="entity">more</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">mk_choiceT</span> <span class="entity">more</span><span class="main">)</span> 
  <span class="main">|</span> <span class="entity">mk_choiceT</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"mk_choiceT []"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_choice_resT</span> <span class="entity">mk_monadT</span> <span class="entity">dest_monadT</span> <span class="entity">mTs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">commonTs</span><span class="main">,</span><span class="entity">argTs</span><span class="main">)</span> <span class="main">=</span> map <span class="entity">dest_monadT</span> <span class="entity">mTs</span> |&gt; split_list |&gt; apfst hd<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="main">(</span>hd <span class="entity">argTs</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">mk_choiceT</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> nth <span class="entity">xs</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">argTs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_monadT</span> <span class="main">(</span><span class="entity">commonTs</span><span class="main">,</span><span class="entity">new</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_inj</span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="entity">t</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">mk_inj</span> <span class="main">(</span><span class="entity">ty</span> :: <span class="entity">more</span><span class="main">)</span> <span class="entity">t</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">moreT</span> <span class="main">=</span> <span class="entity">mk_choiceT</span> <span class="entity">more</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">allT</span> <span class="main">=</span> <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">moreT</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Inl<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">allT</span><span class="main">)</span> $ <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Inr<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">moreT</span> --&gt; <span class="entity">allT</span><span class="main">)</span> $ <span class="entity">mk_inj</span> <span class="entity">more</span> <span class="entity">t</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">mk_inj</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"mk_inj [] _ _"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_proj</span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="entity">t</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">mk_proj</span> <span class="main">(</span><span class="entity">ty</span> :: <span class="entity">more</span><span class="main">)</span> <span class="entity">t</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">moreT</span> <span class="main">=</span> <span class="entity">mk_choiceT</span> <span class="entity">more</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">allT</span> <span class="main">=</span> <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">moreT</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Sum_Type.projl<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">allT</span> --&gt; <span class="entity">ty</span><span class="main">)</span> $ <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_proj</span> <span class="entity">more</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Sum_Type.projr<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">allT</span> --&gt; <span class="entity">moreT</span><span class="main">)</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">mk_proj</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"mk_proj [] _ _"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">eqn</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">plain_eqn</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.focus NONE <span class="entity">eqn</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">HOLogic.dest_eq</span> <span class="main">(</span><span class="entity">HOLogic.dest_Trueprop</span> <span class="entity">plain_eqn</span><span class="main">)</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">head</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_infos</span> <span class="entity">lthy</span> <span class="entity">heads</span> <span class="main">(</span><span class="entity">fix</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">eqn</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">plain_eqn</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.focus NONE <span class="entity">eqn</span> <span class="entity">lthy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f_binding</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="main">=</span> <span class="entity">fix</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fname</span> <span class="main">=</span> Binding.name_of <span class="entity">f_binding</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.dest_eq</span> <span class="main">(</span><span class="entity">HOLogic.dest_Trueprop</span> <span class="entity">plain_eqn</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F</span> <span class="main">=</span> fold_rev lambda <span class="main">(</span><span class="entity">heads</span> @ <span class="entity">args</span><span class="main">)</span> <span class="entity">rhs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity</span> <span class="main">=</span> length <span class="entity">args</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">aTs</span><span class="main">,</span> <span class="entity">bTs</span><span class="main">)</span> <span class="main">=</span> chop <span class="entity">arity</span> <span class="main">(</span>binder_types <span class="entity">fT</span><span class="main">)</span><span class="main">;</span>    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tupleT</span> <span class="main">=</span> foldl1 <span class="entity">HOLogic.mk_prodT</span> <span class="entity">aTs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fT_uc</span> <span class="main">=</span> <span class="entity">tupleT</span> :: <span class="entity">bTs</span> ---&gt; body_type <span class="entity">fT</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">inT</span><span class="main">,</span><span class="entity">resT</span><span class="main">)</span> <span class="main">=</span> dest_funT <span class="entity">fT_uc</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_uc</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT_uc</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_cuc</span> <span class="main">=</span> <span class="entity">curry_n</span> <span class="entity">arity</span> <span class="entity">f_uc</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">f_cuc</span><span class="main">,</span> <span class="entity">f_uc</span><span class="main">,</span> <span class="entity">inT</span><span class="main">,</span> <span class="entity">resT</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">f_binding</span><span class="main">,</span><span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span><span class="entity">fT</span><span class="main">)</span><span class="main">,</span> <span class="entity">F</span><span class="main">,</span> <span class="entity">arity</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_var</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">=</span> Name.variant <span class="entity">name</span> <span class="main">(</span>Variable.names_of <span class="entity">ctxt</span><span class="main">)</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span>

<span class="comment1">(* partial_function_mr definition *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_add_partial_function_mr</span> <span class="entity">prep</span> <span class="entity">mode</span> <span class="entity">fixes_raw</span> <span class="entity">eqns_raw</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">setup_data</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">lookup_mode</span> <span class="entity">lthy</span> <span class="entity">mode</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> error <span class="main">(</span>cat_lines <span class="main">[</span><span class="inner_quoted">"Unknown mode "</span> ^ quote <span class="entity">mode</span> ^ <span class="inner_quoted">"."</span><span class="main">,</span>
        <span class="inner_quoted">"Known modes are "</span> ^ commas_quote <span class="main">(</span><span class="entity">known_modes</span> <span class="entity">lthy</span><span class="main">)</span> ^ <span class="inner_quoted">"."</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Setup_Data</span> <span class="main">{</span><span class="entity">mk_monad_map</span><span class="main">,</span> <span class="entity">mk_monadT</span><span class="main">,</span> <span class="entity">dest_monadT</span><span class="main">,</span> <span class="entity">monad_map_comp</span><span class="main">,</span> <span class="entity">monad_map_id</span><span class="main">}</span> <span class="main">=</span> <span class="entity">setup_data</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">eqns_raw</span> &lt; <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"require at least two function definitions"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">eq_abinding_eqns</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep</span> <span class="entity">fixes_raw</span> <span class="entity">eqns_raw</span> <span class="entity">lthy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">eqns_raw</span> <span class="main">=</span> length <span class="entity">fixes</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"# of eqns does not match # of constants"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fix_eq_abinding_eqns</span> <span class="main">=</span> <span class="entity">fixes</span> ~~ <span class="entity">eq_abinding_eqns</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heads</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">get_head</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">fix_eq_abinding_eqns</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fnames</span> <span class="main">=</span> map <span class="main">(</span>Binding.name_of o <span class="main">#</span><span class="inner_numeral">1</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">fixes</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fnames'</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o Term.dest_Free<span class="main">)</span> <span class="entity">heads</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_f</span> <span class="main">=</span> <span class="entity">fnames</span> ~~ <span class="entity">fnames'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span><span class="entity">g</span><span class="main">)</span> <span class="main">=&gt;</span> not <span class="main">(</span><span class="entity">f</span> <span class="main">=</span> <span class="entity">g</span><span class="main">)</span><span class="main">)</span> <span class="entity">f_f</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span> <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> 
      error <span class="main">(</span><span class="inner_quoted">"list of function symbols does not match list of equations:\n"</span> 
        ^ <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">fnames</span> ^ <span class="inner_quoted">"\nvs\n"</span> ^ <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">fnames'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">get_infos</span> <span class="entity">lthy</span> <span class="entity">heads</span><span class="main">)</span> <span class="entity">fix_eq_abinding_eqns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_cucs</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_ucs</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">3</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inTs</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">4</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resTs</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">5</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bindings_types</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">6</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Fs</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">7</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arities</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">8</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_args</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">9</span> <span class="entity">all</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_inT</span> <span class="main">=</span> <span class="entity">mk_choiceT</span> <span class="entity">inTs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_resT</span> <span class="main">=</span> <span class="entity">mk_choice_resT</span> <span class="entity">mk_monadT</span> <span class="entity">dest_monadT</span> <span class="entity">resTs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj</span> <span class="main">=</span> <span class="entity">mk_inj</span> <span class="entity">inTs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_fname</span> <span class="main">=</span> <span class="entity">fresh_var</span> <span class="entity">lthy</span> <span class="main">(</span>foldl1 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">a</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">b</span><span class="main">)</span> <span class="main">(</span><span class="entity">fnames</span> @ <span class="main">[</span>serial_string <span class="main">(</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_constT</span> <span class="main">=</span> <span class="entity">glob_inT</span> --&gt; <span class="entity">glob_resT</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_const</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">glob_fname</span><span class="main">,</span> <span class="entity">glob_constT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nums</span> <span class="main">=</span> <span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">all</span> - <span class="inner_numeral">1</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_res_inj_proj</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resT</span> <span class="main">=</span> nth <span class="entity">resTs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_Targs</span> <span class="main">=</span> <span class="entity">dest_monadT</span> <span class="entity">glob_resT</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_Targs</span> <span class="main">=</span> <span class="entity">dest_monadT</span> <span class="entity">resT</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> length <span class="entity">res_Targs</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inj_proj</span> <span class="entity">m</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resTs_m</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">resT</span> <span class="main">=&gt;</span> nth <span class="main">(</span><span class="entity">dest_monadT</span> <span class="entity">resT</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">m</span><span class="main">)</span> <span class="entity">resTs</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resT_arg</span> <span class="main">=</span> nth <span class="entity">resTs_m</span> <span class="entity">n</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">globT_arg</span> <span class="main">=</span> nth <span class="entity">glob_Targs</span> <span class="entity">m</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">resT_arg</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">globT_arg</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj</span> <span class="main">=</span> lambda <span class="entity">x</span> <span class="main">(</span><span class="entity">mk_inj</span> <span class="entity">resTs_m</span> <span class="entity">x</span> <span class="entity">n</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">proj</span> <span class="main">=</span> lambda <span class="entity">y</span> <span class="main">(</span><span class="entity">mk_proj</span> <span class="entity">resTs_m</span> <span class="entity">y</span> <span class="entity">n</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">inj</span><span class="main">,</span> <span class="entity">resT_arg</span> --&gt; <span class="entity">globT_arg</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">proj</span><span class="main">,</span> <span class="entity">globT_arg</span> --&gt; <span class="entity">resT_arg</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">inj</span><span class="main">,</span><span class="entity">proj</span><span class="main">)</span> <span class="main">=</span> map <span class="entity">inj_proj</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span><span class="entity">m</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> |&gt; split_list
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t_to_ss_inj</span><span class="main">,</span><span class="entity">t_to_sTs_inj</span><span class="main">)</span> <span class="main">=</span> split_list <span class="entity">inj</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t_to_ss_proj</span><span class="main">,</span><span class="entity">t_to_sTs_proj</span><span class="main">)</span> <span class="main">=</span> split_list <span class="entity">proj</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">mt</span> <span class="main">=&gt;</span> <span class="entity">mk_monad_map</span> <span class="main">(</span><span class="entity">mt</span><span class="main">,</span> <span class="entity">t_to_ss_inj</span><span class="main">,</span> <span class="entity">resT</span><span class="main">,</span> <span class="entity">glob_resT</span><span class="main">,</span> <span class="entity">t_to_sTs_inj</span><span class="main">)</span><span class="main">,</span>
          <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">mt</span> <span class="main">=&gt;</span> <span class="entity">mk_monad_map</span> <span class="main">(</span><span class="entity">mt</span><span class="main">,</span> <span class="entity">t_to_ss_proj</span><span class="main">,</span> <span class="entity">glob_resT</span><span class="main">,</span> <span class="entity">resT</span><span class="main">,</span> <span class="entity">t_to_sTs_proj</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">res_inj</span><span class="main">,</span> <span class="entity">res_proj</span><span class="main">)</span> <span class="main">=</span> map <span class="entity">mk_res_inj_proj</span> <span class="entity">nums</span> |&gt; split_list
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_global_fun</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fname</span> <span class="main">=</span> nth <span class="entity">fnames</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inT</span> <span class="main">=</span> nth <span class="entity">inTs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">fresh_var</span> <span class="entity">lthy</span> <span class="main">(</span><span class="inner_quoted">"x_"</span> ^ <span class="entity">fname</span><span class="main">)</span><span class="main">,</span> <span class="entity">inT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj_xs</span> <span class="main">=</span> <span class="entity">inj</span> <span class="entity">xs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_inj_xs</span> <span class="main">=</span> <span class="entity">glob_const</span> $ <span class="entity">inj_xs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_inj_xs_map</span> <span class="main">=</span> nth <span class="entity">res_proj</span> <span class="entity">n</span> <span class="entity">glob_inj_xs</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> lambda <span class="entity">xs</span> <span class="entity">glob_inj_xs_map</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="main">(</span><span class="entity">xs</span><span class="main">,</span><span class="entity">res</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xss</span><span class="main">,</span><span class="entity">global_funs</span><span class="main">)</span> <span class="main">=</span> map <span class="entity">mk_global_fun</span> <span class="entity">nums</span> |&gt; split_list
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cases</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> nth <span class="entity">xss</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F</span> <span class="main">=</span> nth <span class="entity">Fs</span> <span class="entity">n</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity</span> <span class="main">=</span> nth <span class="entity">arities</span> <span class="entity">n</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F_uc</span> <span class="main">=</span>
          fold_rev lambda <span class="entity">f_ucs</span> <span class="main">(</span><span class="entity">uncurry_n</span> <span class="entity">arity</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">F</span><span class="main">,</span> <span class="entity">f_cucs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F_uc_inst</span> <span class="main">=</span> Term.betapplys <span class="main">(</span><span class="entity">F_uc</span><span class="main">,</span><span class="entity">global_funs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> lambda <span class="entity">xs</span> <span class="main">(</span>nth <span class="entity">res_inj</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">F_uc_inst</span> $ <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">res</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_cases</span> <span class="main">=</span> map <span class="entity">mk_cases</span> <span class="entity">nums</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combine_cases</span> <span class="main">[</span><span class="entity">cs</span><span class="main">]</span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="main">=</span> <span class="entity">cs</span>
      <span class="main">|</span> <span class="entity">combine_cases</span> <span class="main">(</span><span class="entity">cs</span> :: <span class="entity">more</span><span class="main">)</span> <span class="main">(</span><span class="entity">inT</span> :: <span class="entity">moreTy</span><span class="main">)</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">moreT</span> <span class="main">=</span> <span class="entity">mk_choiceT</span> <span class="entity">moreTy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sumT</span> <span class="main">=</span> <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">inT</span><span class="main">,</span> <span class="entity">moreT</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_const</span> <span class="main">=</span> Const 
              <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> case_sum<span class="antiquote">}</span></span><span class="main">,</span>
               <span class="main">(</span><span class="entity">inT</span> --&gt; <span class="entity">glob_resT</span><span class="main">)</span> --&gt; <span class="main">(</span><span class="entity">moreT</span> --&gt; <span class="entity">glob_resT</span><span class="main">)</span> --&gt; <span class="entity">sumT</span> --&gt; <span class="entity">glob_resT</span><span class="main">)</span>        
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">case_const</span> $ <span class="entity">cs</span> $ <span class="entity">combine_cases</span> <span class="entity">more</span> <span class="entity">moreTy</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">combine_cases</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"combine_cases with incompatible argument lists"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_x_name</span> <span class="main">=</span> <span class="entity">fresh_var</span> <span class="entity">lthy</span> <span class="main">(</span><span class="inner_quoted">"x_"</span> ^ <span class="entity">glob_fname</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_x</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">glob_x_name</span><span class="main">,</span><span class="entity">glob_inT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">combine_cases</span> <span class="entity">all_cases</span> <span class="entity">inTs</span> $ <span class="entity">glob_x</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">glob_const</span> $ <span class="entity">glob_x</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_binding</span> <span class="main">=</span> Binding.name <span class="main">(</span><span class="entity">glob_fname</span><span class="main">)</span> |&gt; Binding.concealed
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_attrib_binding</span> <span class="main">=</span> Binding.empty_atts
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace</span> <span class="entity">lthy</span> <span class="inner_quoted">"invoking partial_function on global function"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">priv_lthy</span> <span class="main">=</span> <span class="entity">lthy</span>
      |&gt; Proof_Context.private_scope <span class="main">(</span>Binding.new_scope<span class="main">(</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">glob_const</span><span class="main">,</span> <span class="entity">glob_simp_thm</span><span class="main">)</span><span class="main">,</span><span class="entity">priv_lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">priv_lthy</span>
      |&gt; <span class="entity">Partial_Function.add_partial_function</span> <span class="entity">mode</span> 
        <span class="main">[</span><span class="main">(</span><span class="entity">glob_binding</span><span class="main">,</span>SOME <span class="entity">glob_constT</span><span class="main">,</span>NoSyn<span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">glob_attrib_binding</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_lthy</span> <span class="main">=</span> <span class="entity">priv_lthy'</span> 
      |&gt; Proof_Context.restore_naming <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace</span> <span class="entity">lthy</span> <span class="inner_quoted">"deriving simp rules for separate functions from global function"</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_f</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">fdefs</span><span class="main">,</span><span class="entity">rhss</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">fbinding</span><span class="main">,</span><span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> nth <span class="entity">bindings_types</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fname</span> <span class="main">=</span> nth <span class="entity">fnames</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inT</span> <span class="main">=</span> nth <span class="entity">inTs</span> <span class="entity">n</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity</span> <span class="main">=</span> nth <span class="entity">arities</span> <span class="entity">n</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">fresh_var</span> <span class="entity">lthy</span> <span class="main">(</span><span class="inner_quoted">"x_"</span> ^ <span class="entity">fname</span><span class="main">)</span><span class="main">,</span> <span class="entity">inT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj_argsProd</span> <span class="main">=</span> <span class="entity">inj</span> <span class="entity">x</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">call</span> <span class="main">=</span> <span class="entity">glob_const</span> $ <span class="entity">inj_argsProd</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">post</span> <span class="main">=</span> nth <span class="entity">res_proj</span> <span class="entity">n</span> <span class="entity">call</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">curry_n</span> <span class="entity">arity</span> <span class="main">(</span>lambda <span class="entity">x</span> <span class="entity">post</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">f_def</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> 
          Local_Theory.define_internal <span class="main">(</span><span class="main">(</span><span class="entity">fbinding</span><span class="main">,</span><span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="main">(</span><span class="entity">f</span> :: <span class="entity">fs</span><span class="main">,</span> <span class="entity">f_def</span> :: <span class="entity">fdefs</span><span class="main">,</span><span class="entity">rhs</span> :: <span class="entity">rhss</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fs</span><span class="main">,</span><span class="entity">fdefs</span><span class="main">,</span><span class="entity">f_rhss</span><span class="main">,</span><span class="entity">local_lthy</span><span class="main">)</span> <span class="main">=</span> fold_rev <span class="entity">define_f</span> <span class="entity">nums</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="entity">glob_lthy</span><span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">glob_simp_thm'</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case_new</span> <span class="entity">n</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F</span> <span class="main">=</span> nth <span class="entity">Fs</span> <span class="entity">n</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity</span> <span class="main">=</span> nth <span class="entity">arities</span> <span class="entity">n</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Finst</span> <span class="main">=</span> <span class="entity">uncurry_n</span> <span class="entity">arity</span> <span class="main">(</span>Term.betapplys <span class="main">(</span><span class="entity">F</span><span class="main">,</span><span class="entity">fs</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> nth <span class="entity">xss</span> <span class="entity">n</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> lambda <span class="entity">xs</span> <span class="main">(</span>nth <span class="entity">res_inj</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">Finst</span> $ <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> 
            <span class="entity">res</span>
          <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_cases</span> <span class="main">=</span> map <span class="entity">mk_case_new</span> <span class="entity">nums</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">combine_cases</span> <span class="entity">new_cases</span> <span class="entity">inTs</span> $ <span class="entity">glob_x</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">glob_const</span> $ <span class="entity">glob_x</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        Goal.prove <span class="entity">local_lthy</span> <span class="main">[</span><span class="entity">glob_x_name</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>prems <span class="main">=</span> <span class="main">_</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=&gt;</span> 
            Thm.instantiate' <span class="main">[</span><span class="main">]</span> <span class="main">[</span>SOME <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">glob_x</span><span class="main">)</span><span class="main">]</span> <span class="entity">glob_simp_thm</span>
            |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">simp_thm</span> <span class="main">=&gt;</span> <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">simp_thm</span><span class="main">]</span> THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">fdefs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_simp_thm</span> <span class="entity">n</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> nth <span class="entity">all_args</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">args</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> nth <span class="entity">fs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">F</span> <span class="main">=</span> nth <span class="entity">Fs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fdef</span> <span class="main">=</span> nth <span class="entity">fdefs</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span><span class="entity">args</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mhs</span> <span class="main">=</span> Term.betapplys <span class="main">(</span>nth <span class="entity">f_rhss</span> <span class="entity">n</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">F</span><span class="main">,</span><span class="entity">fs</span><span class="main">)</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq1</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">mhs</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq2</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>      
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thm1</span> <span class="main">=</span> Goal.prove <span class="entity">local_lthy</span> <span class="entity">arg_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq1</span> 
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>prems <span class="main">=</span> <span class="main">_</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">fdef</span><span class="main">]</span><span class="main">)</span>
  
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thm2</span> <span class="main">=</span> Goal.prove <span class="entity">local_lthy</span> <span class="entity">arg_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq2</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>prems <span class="main">=</span> <span class="main">_</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=&gt;</span> 
            <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">glob_simp_thm'</span><span class="main">]</span>
            THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sum.simps curry_def split<span class="antiquote">}</span></span></span>
            THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> o_def<span class="antiquote">}</span></span></span> :: <span class="entity">monad_map_comp</span><span class="main">)</span>
            THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">monad_map_id</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sum.sel<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>        
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">simp_thm1</span><span class="main">,</span><span class="entity">simp_thm2</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> map <span class="entity">mk_simp_thm</span> <span class="entity">nums</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register</span> <span class="entity">n</span> <span class="entity">lthy</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thm</span> <span class="main">=</span> nth <span class="entity">simp_thms</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_abinding</span> <span class="main">=</span> nth <span class="entity">eq_abinding_eqns</span> <span class="entity">n</span> |&gt; fst
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fname</span> <span class="main">=</span> nth <span class="entity">fnames</span> <span class="entity">n</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> nth <span class="entity">fs</span> <span class="entity">n</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="entity">lthy</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="entity">eq_abinding</span><span class="main">,</span> <span class="main">[</span><span class="entity">simp_thm</span><span class="main">]</span><span class="main">)</span>
        |-&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span> <span class="main">=&gt;</span> 
          <span class="entity">Spec_Rules.add</span> Binding.empty <span class="entity">Spec_Rules.equational_recdef</span> <span class="main">[</span><span class="entity">f</span><span class="main">]</span> <span class="entity">simps</span>
          #&gt; Local_Theory.note 
            <span class="main">(</span><span class="main">(</span>Binding.qualify true <span class="entity">fname</span> <span class="main">(</span>Binding.name <span class="inner_quoted">"simps"</span><span class="main">)</span><span class="main">,</span>
              <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span> #&gt;&gt; snd #&gt;&gt; hd<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">register</span> <span class="entity">i</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">of</span></span>
       <span class="main">(</span><span class="entity">simp</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">simps</span> @ <span class="main">[</span><span class="entity">simp</span><span class="main">]</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span><span class="main">)</span> <span class="entity">nums</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">local_lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_partial_function_mr</span> <span class="main">=</span> <span class="entity">gen_add_partial_function_mr</span> <span class="entity">Specification.check_multi_specs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_partial_function_mr_cmd</span> <span class="main">=</span> <span class="entity">gen_add_partial_function_mr</span> <span class="entity">Specification.read_multi_specs</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mode</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Parse.name --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">partial_function_mr</span><span class="antiquote">}</span></span></span> 
    <span class="inner_quoted">"define mutually recursive partial functions"</span>
    <span class="main">(</span><span class="entity">mode</span> -- <span class="entity">Parse_Spec.specification</span>
      &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">specs</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">add_partial_function_mr_cmd</span> <span class="entity">mode</span> <span class="entity">fixes</span> <span class="entity">specs</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Partial_Function_MR_Examples">
<div class="head">
<h1>Theory Partial_Function_MR_Examples</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Rene Thiemann, License: LGPL *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Partial_Function_MR_Examples
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Partial_Function_MR.html">Partial_Function_MR</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
  <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Collatz function›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we define the Collatz function, 
which is artificially encoded via mutually recursive functions.
As second argument we store the intermediate values.
It is currently unknown whether this function is terminating for all inputs or not.›</span></span>

<span class="keyword1"><span class="command">partial_function_mr</span></span> <span class="main">(</span>tailrec<span class="main">)</span> <span class="entity">collatz</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">even_case</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">odd_case</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">collatz</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">::</span> int<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> rev <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> 
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">even_case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="free">odd_case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">even_case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free">collatz</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">odd_case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free">collatz</span> <span class="main">(</span><span class="numeral">3</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The equations are registered as code-equations.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>collatz <span class="numeral">327</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">144</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The equations are accessible via .simps, but are not put in the standard simpset.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"collatz <span class="numeral">5</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">16</span><span class="main">,</span><span class="numeral">8</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="main">1</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collatz.simps even_case.simps<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Evaluating expressions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that we also provide a least fixpoint operator.
  Hence, the evaluation function will clearly be partial.
  The example also illustrates the usage
  of polymorphism and of different return types.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following datatype, \isa{Mu b f a} encodes the least $n$ such that $b(f^n(a))$.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bexp <span class="main">=</span> 
  BConst <span class="quoted">bool</span>
<span class="main">|</span> Less <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span>
<span class="main">|</span> Eq <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span>
<span class="main">|</span> And <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bexp"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="tfree">'a</span> aexp <span class="main">=</span>
  Plus <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span>
<span class="main">|</span> Div <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span>
<span class="main">|</span> IfThenElse <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span>
<span class="main">|</span> AConst <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
<span class="main">|</span> Mu <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> bexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> aexp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> aexp"</span></span> 

<span class="keyword1"><span class="command">partial_function_mr</span></span> <span class="main">(</span>option<span class="main">)</span> 
  <span class="entity">b_eval</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">a_eval</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">mu_eval</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">b_eval</span> <span class="free"><span class="bound"><span class="entity">bexp</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">bexp</span></span></span> <span class="keyword1">of</span>
     BConst <span class="bound">b</span> <span class="main">⇒</span> Some <span class="bound">b</span>
   <span class="main">|</span> Less <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x1</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a1</span><span class="main">;</span>
        <span class="bound">x2</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a2</span><span class="main">;</span>
        Some <span class="main">(</span><span class="bound">x1</span> <span class="main">&lt;</span> <span class="bound">x2</span><span class="main">)</span>
     <span class="main">}</span>
   <span class="main">|</span> Eq <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x1</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a1</span><span class="main">;</span>
        <span class="bound">x2</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a2</span><span class="main">;</span>
        Some <span class="main">(</span><span class="bound">x1</span> <span class="main">=</span> <span class="bound">x2</span><span class="main">)</span>
     <span class="main">}</span>
   <span class="main">|</span> And <span class="bound">be1</span> <span class="bound">be2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b1</span> <span class="main">←</span> <span class="free">b_eval</span> <span class="bound">be1</span><span class="main">;</span>
        <span class="bound">b2</span> <span class="main">←</span> <span class="free">b_eval</span> <span class="bound">be2</span><span class="main">;</span>
        Some <span class="main">(</span><span class="bound">b1</span> <span class="main">∧</span> <span class="bound">b2</span><span class="main">)</span>
     <span class="main">}</span>
  <span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">a_eval</span> <span class="free"><span class="bound"><span class="entity">aexp</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">aexp</span></span></span> <span class="keyword1">of</span>
     AConst <span class="bound">x</span> <span class="main">⇒</span> Some <span class="bound">x</span>
   <span class="main">|</span> Plus <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x1</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a1</span><span class="main">;</span>
        <span class="bound">x2</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a2</span><span class="main">;</span>
        Some <span class="main">(</span><span class="bound">x1</span> <span class="main">+</span> <span class="bound">x2</span><span class="main">)</span>
     <span class="main">}</span>
   <span class="main">|</span> Div <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x1</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a1</span><span class="main">;</span>
        <span class="bound">x2</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="bound">a2</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="bound">x2</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="bound">x1</span> <span class="main">/</span> <span class="bound">x2</span><span class="main">)</span>
     <span class="main">}</span>
   <span class="main">|</span> IfThenElse <span class="bound">bexp</span> <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> <span class="free">b_eval</span> <span class="bound">bexp</span><span class="main">;</span>
        <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="free">a_eval</span> <span class="bound">a1</span> <span class="keyword1">else</span> <span class="free">a_eval</span> <span class="bound">a2</span><span class="main">)</span>
     <span class="main">}</span>
   <span class="main">|</span> Mu <span class="bound">b</span> <span class="bound">f</span> <span class="bound">a</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="free">mu_eval</span> <span class="bound">b</span> <span class="bound">f</span> <span class="bound">a</span> <span class="main">0</span>
     <span class="main">}</span>
  <span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mu_eval</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> <span class="free">a_eval</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="bound">check</span> <span class="main">←</span> <span class="free">b_eval</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> 
      <span class="main">(</span><span class="keyword1">if</span> <span class="bound">check</span> <span class="keyword1">then</span> Some <span class="main">(</span>of_nat <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="keyword1">else</span> 
       <span class="free">mu_eval</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">five_minus_two</span> <span class="main">=</span> a_eval <span class="main">(</span>Mu <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> Eq <span class="main">(</span>AConst <span class="numeral">5</span><span class="main">)</span> <span class="main">(</span>AConst <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> Plus <span class="main">(</span>AConst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>AConst <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>AConst <span class="main">(</span><span class="numeral">2</span> <span class="main">::</span> rat<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted">five_minus_two</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹An example with contexts›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Mutual recursive partial functions also work within contexts.›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">y</span> <span class="main">::</span> <span class="quoted">int</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">partial_function_mr</span></span> <span class="main">(</span>tailrec<span class="main">)</span> <span class="entity">foo</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">bar</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">foo</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">foo</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free">bar</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bar</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="free">foo</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span>"</span></span> 
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>