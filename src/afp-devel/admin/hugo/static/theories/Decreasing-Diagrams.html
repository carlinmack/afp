<div id="Decreasing_Diagrams">
<div class="head"><h1>Theory Decreasing_Diagrams</h1>
<span class="command">theory</span> <span class="name">Decreasing_Diagrams</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Multiset.html"><span class="name">Multiset</span></a> <a href="../Abstract-Rewriting/Abstract_Rewriting.html"><span class="name">Abstract_Rewriting</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Formalization of Decreasing Diagrams
    Author:      Harald Zankl  &lt;Harald.Zankl at uibk.ac.at&gt;, 2012
    Maintainer:  Harald Zankl  &lt;Harald.Zankl at uibk.ac.at&gt;, 2013
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Copyright 2012 Harald Zankl

This formalization is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later version.

This formalization is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with the formalization. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Decreasing Diagrams"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Decreasing_Diagrams</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstract-Rewriting.Abstract_Rewriting"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Valley Version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This section follows~\cite{vO94}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Appendix›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹interaction of multisets with sets›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>diff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a multiset ⇒ 'a set ⇒ 'a multiset"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diff M S = filter_mset (λx. x ∉ S) M"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intersect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a multiset ⇒ 'a set ⇒ 'a multiset"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intersect M S = filter_mset (λx. x ∈ S) M"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span> </span><span>diff</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-s"</span></span></span><span> </span><span>800</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span> </span><span>intersect</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∩s"</span></span></span><span> </span><span>800</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_diff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count (M -s A) a = count M a * of_bool (a ∉ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_mset_diff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_mset (M -s A) = set_mset M - A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_eq_singleton_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"M -s A = {#a#} ⟹ a ∈ (set_mset M - A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>filter_mset_eq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_intersect</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count (M ∩s A) a = count M a * of_bool (a ∈ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intersect_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_mset_intersect</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_mset (M ∩s A) = set_mset M ∩ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intersect_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_from_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}-s S = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M -s {} = M"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>multiset_eqI</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>submultiset_implies_subset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆# N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ set_mset N"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mset_subset_eqD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_implies_remove_empty</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M -s S = {#}"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_empty_implies_subset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M -s S = {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set_mset M"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set_mset (M -s S)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemmaA_3_8</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(M + N) -s S = (M -s S) + (N -s S)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>multiset_eqI</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemmaA_3_9</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(M -s S) -s T = M -s (S ∪ T)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>multiset_eqI</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemmaA_3_10</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = (M ∩s S) + (M -s S)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>intersect_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemmaA_3_11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M -s T) ∩s S = (M ∩s S) -s T"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>intersect_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>multiset_eqI</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multisets›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 2.5(1)›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a set ⇒ 'a set"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r S = {y . ∃x ∈ S. (y,x) ∈ r}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a multiset ⇒ 'a set"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r M = ds r (set_mset M)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a list ⇒ 'a set"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r σ = ds r (set σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span> </span><span>ds</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↓s"</span></span></span><span> </span><span>900</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span> </span><span>dm</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↓m"</span></span></span><span> </span><span>900</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span> </span><span>dl</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↓l"</span></span></span><span> </span><span>900</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹missing but useful›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ds_ds_subseteq_ds</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r (ds r S) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ds r (ds r S)"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,z) ∈ r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem</span><span> </span><span>t</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹from PhD thesis of van Oostrom›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ds_monotone</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r S ⊆ ds r T"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ ds r T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r S ⊆ ds r T"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>ds_monotone</span><span> </span><span>ds_ds_subseteq_ds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 2.5(2)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹strict order (mult) is used from Multiset.thy›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mult_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a multiset rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mult_eq r = (mult1 r)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mul</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a multiset rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mul r = {(M,N).∃I J K. M = I + K ∧ N = I + J ∧ set_mset K ⊆ dm r J ∧ J ≠ {#}}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mul_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a multiset rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mul_eq r = {(M,N).∃I J K. M = I + K ∧ N = I + J ∧ set_mset K ⊆ dm r J}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_mul_eqI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ r ↓m J"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M, N) ∈ mul_eq r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mul_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>downset_intro</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k∈set_mset K.∃j∈set_mset J.(k,j)∈r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈set_mset K"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>downset_elim</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k∈set_mset K.∃j∈set_mset J.(k,j)∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k∈ set_mset K"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃j∈set_mset J.(k,j)∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹to closure-free representation›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_eq_implies_one_or_zero_step</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I J K. N = I + J ∧ M = I + K ∧ set_mset K ⊆ dm r J"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_implies_one_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>downset_intro</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>rtrancl_eq_or_trancl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_eq_def</span><span> </span><span>mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = N + {#} ∧ M = M + {#} ∧ set_mset {#} ⊆ dm r{#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹from closure-free representation›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_step_implies_mult_eq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(I+K,I+J)∈mult_eq r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset J = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>downset_elim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>all_not_in_conv</span><span> </span><span>emptyE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mset_eq_empty_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(I+K,I+J)∈ mult r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mset_eq_empty_iff</span><span> </span><span>assms</span><span> </span><span>one_step_implies_mult</span><span> </span><span>downset_elim</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_eq_def</span><span> </span><span>mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_is_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult r = mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult r ⊆ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mult r"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_implies_one_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>downset_intro</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mul r ⊆ mult r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mul r"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mult r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one_step_implies_mult</span><span> </span><span>assms</span><span> </span><span>downset_elim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_eq_is_mul_eq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult_eq r = mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult_eq r ⊆ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span>M</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mult_eq r"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,M) ∈ mult r"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_is_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>mul_def</span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N = M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>rtranclD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_def</span><span> </span><span>mult_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M + {#} ∧ N = N + {#} ∧ set_mset {#} ⊆ dm r {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mul_eq r ⊆ mult_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one_step_implies_mult_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mul_eq r = (mul r)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mul_eq r ⊆ (mul r)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ (mul r)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"J = {#}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mul_eq r ⊇ (mul r)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ (mul r)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = N"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M + {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = M + {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset {#} ⊆ dm r {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹useful properties on multisets›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_reflexive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,M) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M + {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset {#} ⊆ dm r {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_trans</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,P) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,P) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_eq_is_mul_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>mult_eq_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_singleton</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M, {#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {#α#} ∨ set_mset M ⊆ dm r {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{#α#} = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"I = {#}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J = {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>3</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I = {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>union_is_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>union_is_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>i</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_and_mul_eq_imp_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,P) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,P) ∈ mul r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_is_mul</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>mult_eq_is_mul_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>mult_def</span><span> </span><span>mult_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_and_mul_imp_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N,P) ∈ mul r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,P) ∈ mul r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_is_mul</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>mult_eq_is_mul_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>mult_def</span><span> </span><span>mult_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (mul r)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_is_mul</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_is_empty_imp_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M -s dm r {#α#} = {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,{#α#}) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ dm r {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>remove_empty_implies_subset</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {#}+M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#α#}={#}+{#α#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#α#} ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_1_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r (S ∪ T) = ds r S ∪ ds r T"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mset_union</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_1_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (σ@τ) = dl r σ ∪ dl r τ"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span>set_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_1_multiset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r (M + N) = dm r M ∪ dm r N"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>set_mset_union</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_1_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dm r M) - ds r S ⊆ dm r (M -s S)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹missing but useful›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dl_monotone</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (σ@τ) ⊆ dl r (σ@τ'@τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6.2›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_2_a</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆# N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>J</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N=M+J"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mset_subset_eq_exists_conv</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M + {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = M + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset {#} ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_not_equal_imp_elt</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N)∈mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈set_mset M - set_mset N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z∈set_mset N.(y,z)∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N=I+J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M=I+K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>downset_elim</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_2_b</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r M ⊆ dm r N"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r M"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r N"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>F2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y∈set_mset M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x,y)∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ z ∈ set_mset N. (x,z)∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈set_mset N"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_not_equal_imp_elt</span><span> </span><span>assms</span><span> </span><span>F2</span><span> </span><span>F3</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6.3›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ds_trans_contrapos</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ ds r S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ ds r S"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dm_max_elt</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r M ⟹ ∃ y ∈ set_mset (M -s dm r M). (x,y) ∈ r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>add</span><span> </span><span>p</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (dm r P ∪ dm r {#p#})"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_mem_dm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ dm r {#p#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span>irrefl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r P"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>relp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,p) ∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ dm r P"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>relp</span><span> </span><span>t</span><span> </span><span>ds_trans_contrapos</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_mem_dm</span><span> </span><span>relp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ dm r P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ dm r {#p#}"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rely</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,p) ∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>relp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,p) ∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely</span><span> </span><span>t</span><span> </span><span>key</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_memp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ set_mset P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely</span><span> </span><span>key</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>memp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ set_mset (P + {#p#})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ dm r P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ds_trans_contrapos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>key</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rely</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ dm r (P + {#p#})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_mem_dm</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>relp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>key</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dm_subset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r M ⊆ dm r (M -s dm r M)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>dm_max_elt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dm_eq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r M = dm r (M -s dm r M)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dm_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_3</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ I' J' K' . N = I' + J' ∧ M = I' + K' ∧ J' ∩# K' = {#} ∧ set_mset K' ⊆ dm r J'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (J ∩# K) ⊆ r ↓m J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ↓m J = set_mset (J ∩# K) ∪ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (J -s dm r J) ⊆ set_mset (J - (J ∩# K))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Multiset.count_diff</span><span> </span><span>add.left_neutral</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>mem_Collect_eq</span><span> </span><span>not_gr0</span><span> </span><span>set_mset_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = (I + (J ∩# K)) + (J - (J ∩# K))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_union_cancelL</span><span> </span><span>subset_mset.inf_le2</span><span> </span><span>multiset_diff_union_assoc</span><span> </span><span>multiset_inter_commute</span><span> </span><span>union_commute</span><span> </span><span>union_lcomm</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = (I + (J ∩# K)) + (K - (J ∩# K))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_subset_eq_self</span><span> </span><span>diff_union_cancelL</span><span> </span><span>2</span><span> </span><span>multiset_diff_union_assoc</span><span> </span><span>multiset_inter_commute</span><span> </span><span>multiset_inter_def</span><span> </span><span>union_assoc</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (K-(J∩#K)) ⊆ dm r (J-(J∩#K))"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (K-(J∩#K)) ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Multiset.diff_subset_eq_self</span><span> </span><span>mset_subset_eqD</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = dm r (J -s dm r J)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dm_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ dm r (J - (J ∩# K))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ds_monotone</span><span class="delimiter">[</span><span>OF</span><span> </span><span>key</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(J-(J∩#K)) ∩# (K-(J∩#K)) = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>multiset_eqI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  (* initial proof by Bertram Felgenhauer *)
lemma lemma2_6_3_step:
assumes t:"trans r" and i:"irrefl r" and P:"set_mset K ⊆ dm r J" shows "set_mset (K-(J∩#K)) ⊆ dm r (J-(J∩#K))" proof
 fix k assume K: "k ∈ set_mset (K - (J∩#K))" show "k ∈ dm r (J - (J∩#K))" proof -
  have k: "k ∈# K" using K by simp
  have step: "k ∈ dm r (J-K)" proof -
   {
   fix P have "P ≤ K ⟹ k ∈ dm r (J-P)" using k proof (induct P arbitrary:k rule:multiset_induct)
    case empty thus ?case using P by auto
   next
    case (add Q q)
    have h1: "q ∈# K" and h2: "Q ≤ K" using mset_subset_eq_insertD[OF add(2)] by auto
    obtain j where mem1: "j∈set_mset (J - Q)" and rel1: "(k, j) ∈ r" using add(1)[OF h2 add(3)] unfolding dm_def ds_def by auto
    show ?case proof (cases "j ∈# J - (Q + {#q#})")
     case True thus ?thesis using rel1 unfolding dm_def ds_def by force
    next
     case False hence eq: "q = j" using mem1 by (cases "q = j") auto
     obtain j2 where mem2: "j2∈set_mset (J - Q)" and rel2: "(j, j2) ∈ r" using eq add(1)[OF h2 h1] unfolding dm_def ds_def by auto
     have rel: "(k,j2) ∈ r" using transD[OF assms(1) rel1 rel2] by auto
     have "j2 ≠ q" using rel2 eq i irrefl_def by fast
     thus ?thesis using rel mem2 unfolding dm_def ds_def by (cases "j2=k") auto
    qed
   qed
   }
   thus ?thesis by auto
  qed
  have eq: "J - K = J - (J ∩# K)" by (rule multiset_eqI) auto
  show ?thesis using step unfolding eq dm_def ds_def by auto
 qed
qed

lemma lemma2_6_3: assumes t: "trans r" and i: "irrefl r" and "(M,N) ∈ mul_eq r"
shows "∃ I J K. N = I + J ∧ M = I + K ∧ J∩#K = {#} ∧ set_mset K ⊆ dm r J" proof -
 from assms(1,3)
 obtain I J K where f1:"N = I + J" and f2:"M = I + K" and f3:"set_mset K ⊆ dm r J" unfolding mul_eq_def by fast
 hence "N = (I + (J ∩# K)) + (J - (J ∩# K))"
  by (metis diff_union_cancelL inf_le2 multiset_diff_union_assoc multiset_inter_commute union_commute union_lcomm)
 moreover have "M = (I + (J ∩# K)) + (K - (J ∩# K))"
  by (metis diff_le_self diff_union_cancelL f1 f2 f3 multiset_diff_union_assoc multiset_inter_commute multiset_inter_def union_assoc)
 moreover have "(J-(J∩#K)) ∩# (K-(J∩#K)) = {#}" by (rule multiset_eqI) auto
 ultimately show ?thesis using lemma2_6_3_step[OF t i f3] by auto
qed
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6.4›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_4</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ≠ {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ dm r N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {#} + M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = {#} + N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_5_a</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r S ⊆ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M -s S, N -s S) ∈ mul_eq r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N=I+J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M=I+K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>best</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M -s S = I -s S + K -s S"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"N -s S = I -s S + J -s S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lemmaA_3_8</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (K-sS) ⊆ dm r (J-sS)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (K-sS) ⊆ set_mset (K-s (ds r S))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset(K-s (ds r S)) ⊆ (dm r J) - (ds r S)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dm r J) - (ds r S) ⊆ dm r (J -s S)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_1_diff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>in_mul_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_5_a'</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M -s ds r S, N -s ds r S) ∈ mul_eq r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma2_6_5_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>ds_ds_subseteq_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6.6›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Q + M,Q + N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Q+N=(Q+I)+J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Q+M=(Q+I)+K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_left_one</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ I J K. add_mset q N = I + J ∧ add_mset q  M = I + K ∧ (J∩#K={#}) ∧ set_mset K ⊆ dm r J"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ I2 J K. N = I2 + J ∧ M = I2 + K ∧ set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#q#} + N = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{#q#} + M = I + K"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(J ∩# K = {#})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q∈#I"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈# I"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈# J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnE</span><span> </span><span>multi_member_this</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈# K"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnE</span><span> </span><span>multi_member_this</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ q ∈# (J ∩# K)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ I2. I = add_mset q I2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>multi_member_split</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ I2. add_mset q N = (add_mset q I2) + J ∧ add_mset q M = (add_mset q I2) + K"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_6_b_one</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(add_mset q M, add_mset q N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_left_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lemma2_6_3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_6_b'</span><span> </span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Q + M, Q + N) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>add</span><span> </span><span>q</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_b_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>union_mset_add_mset_left</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_9</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Q+M,Q+N) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>F1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q+N=Q+I+J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q+M=Q+I+K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F1</span><span> </span><span>F2</span><span> </span><span>union_commute</span><span> </span><span>union_lcomm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>F3</span><span> </span><span>F4</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 2.6.7›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_7_a</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset Q ⊆ dm r N - dm r M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Q+M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N=I+J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M=I+K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset(Q+K) ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma2_6_1_diff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(I+(Q+K),I+J) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>C</span><span> </span><span>union_assoc</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹missing?; similar to lemma\_2.6.2?›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_8</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M -s T,M -s S) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M -s T) ⊆# (M -s S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_absorb2</span><span> </span><span>Un_commute</span><span> </span><span>lemmaA_3_10</span><span> </span><span>lemmaA_3_9</span><span> </span><span>mset_subset_eq_add_right</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_2_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lexicographic maximum measure›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Def 3.1: lexicographic maximum measure›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lexmax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a list ⇒ 'a multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"lexmax r [] = {#}"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r (α#σ) =  {#α#} + (lexmax r σ -s ds r {α})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span> </span><span>lexmax</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_|_|"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lexmax_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r|[α]| = {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexmax.simps</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 3.2›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 3.2(1)›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_2_1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ↓m r|σ| = r ↓l σ"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>α</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dm r {#α#} ∪ dm r (r|σ| -s ds r {α}) = dm r {#α#} ∪ dl r σ"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⊆ ?R"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>diff_def</span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R ⊆ ?L"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?R"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?L"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r {#α#}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dm r (lexmax r σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ (ds r (ds r {α}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>ds_ds_subseteq_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem</span><span> </span><span>lemma2_6_1_diff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_multiset</span><span> </span><span>lexmax.simps</span><span> </span><span>dl_def</span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 3.2(2)›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_2_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r|σ@τ| = r|σ| + (r|τ| -s r ↓l σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span>lexmax.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>α</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r (α#σ@τ) = {#α#} + ((lexmax r (σ@τ)) -s (ds r {α}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = {#α#} + ((lexmax r σ + ((lexmax r τ) -s (dl r σ))) -s (ds r {α}))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = {#α#} + ((lexmax r σ) -s (ds r {α})) + (((lexmax r τ) -s (dl r σ)) -s (ds r {α}))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_8</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = lexmax r (α#σ) + (((lexmax r τ) -s (dl r σ)) -s (ds r {α}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = lexmax r (α#σ) + ((lexmax r τ) -s (dl r (α#σ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_9</span><span> </span><span>dl_def</span><span> </span><span>dm_def</span><span> </span><span>lemma2_6_1_set</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 3.3›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>D</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ' = ((r|σ@τ'|, r|τ| + r|σ| ) ∈ mul_eq r
                 ∧ (r|τ@σ'|, r|τ| + r|σ| ) ∈ mul_eq r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>D_eq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|τ'| -s dl r σ,r|τ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ'| -s dl r τ,r|σ| ) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_commute</span><span> </span><span>lemma2_6_6_b'</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_commute</span><span> </span><span>lemma2_6_6_b'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>D_inv</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|τ'| -s dl r σ,r|τ| ) ∈ mul_eq r"</span></span></span><span>
</span><span>                                                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ'| -s dl r τ,r|σ| ) ∈ mul_eq r"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ' = ((r|τ'| -s dl r σ,r|τ| ) ∈ mul_eq r
                        ∧ (r|σ'| -s dl r τ,r|σ| ) ∈ mul_eq r)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>D_eq</span><span> </span><span>D_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mirror_D</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r σ τ τ' σ'"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proposition 3.4›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LD_1'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a ⇒ 'a ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_1' r β α σ1 σ2 σ3 =
 (set σ1 ⊆ ds r {β} ∧ length σ2 ≤ 1 ∧ set σ2 ⊆ {α} ∧ set σ3 ⊆ ds r {α,β})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LD'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a ⇒ 'a
  ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD' r β α σ1 σ2 σ3 τ1 τ2 τ3 = (LD_1' r β α σ1 σ2 σ3 ∧ LD_1' r α β τ1 τ2 τ3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auxiliary properties on multisets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r|σ| ⊆# mset σ"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexmax.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>τ</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r τ -s ds r {s} ⊆# mset τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemmaA_3_10</span><span> </span><span>mset_subset_eq_add_right</span><span> </span><span>subset_mset.order_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_1' r β α σ1 σ2 σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 = [] ∨ σ2 = [α]"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>LD_1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>σ2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proposition3_4_step</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_1' r β α σ1 σ2 σ3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ1@σ2@σ3| -s (dm r {#β#}), r|[α]| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ1 ⊆ dm r {#β#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD'_def</span><span> </span><span>LD_1'_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (lexmax r σ1) ⊆ dm r {#β#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>submultiset_implies_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r σ1 -s dm r {#β#} = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_implies_remove_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ3 ⊆ dl r σ2 ∪ dl r σ1 ∪ dm r {#β#} ∪ dm r {#α#}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l ⊆ ?r"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD'_def</span><span> </span><span>LD_1'_def</span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (lexmax r σ3) ⊆ ?r "</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>submultiset_implies_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pre3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r σ3 -s ?r = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_implies_remove_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>two</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(lexmax r σ2 -s dl r σ1) -s dm r {#β#} = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pre3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(((lexmax r σ3 -s dl r σ2) -s dl r σ1) -s dm r {#β#}) -s dm r {#α#} = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span>dl_def</span><span> </span><span>lemmaA_3_9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>three</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(((lexmax r σ3 -s dl r σ2) -s dl r σ1) -s dm r {#β#},{#α#}) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_is_empty_imp_mul</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>three</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span>lexmax_singleton</span><span> </span><span>lemmaA_3_8</span><span> </span><span>one</span><span> </span><span>two</span><span> </span><span>mul_def</span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 = [α]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((lexmax r σ2 -s dl r σ1) -s dm r {#β#},{#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_8</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>empty_subsetI</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq</span><span> </span><span>lexmax.simps</span><span> </span><span>diff_from_empty</span><span> </span><span>lemmaA_3_9</span><span> </span><span>diff_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pre3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r σ3 -s ((dl r σ2 ∪ dm r {#α#}) ∪ dl r σ1 ∪ dm r {#β#}) = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq</span><span> </span><span>lemmaA_3_9</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>three</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((lexmax r σ3 -s dl r σ2) -s dl r σ1) -s dm r {#β#} = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Un_absorb</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_9</span><span> </span><span>eq</span><span> </span><span>dm_def</span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span>lexmax_singleton</span><span> </span><span>lemmaA_3_8</span><span> </span><span>one</span><span> </span><span>three</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>two</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proposition3_4</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ld</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LD' r β α σ1 σ2 σ3 τ1 τ2 τ3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r [β] [α] (σ1@σ2@σ3) (τ1@τ2@τ3)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proposition3_4_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>ld</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD'_def</span><span> </span><span>D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>dl_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*reverse direction*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lexmax_decompose</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈# r|σ|"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃σ1 σ3. (σ=σ1@[α]@σ3 ∧ α ∉ dl r σ1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>β</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"α=β"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"β#as = σ1@[α]@σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∉ dl r σ1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈# r|as|-s ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈# r|as| ∧ α ∉ ds r {β}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = σ1 @ [α] @ σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∉ dl r σ1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"β#as = (β#σ1) @ [α] @ σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"α ∉ dl r (β#σ1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lexmax_elt</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (set σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set_mset r|σ|"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. (x,y) ∈ r ∧ y ∈ set_mset r|σ|"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set_mset r|as|"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ r ∧ y ∈ set_mset r|as|"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ ds r {a}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>transD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexmax.simps</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span>lexmax.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lexmax_set</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset r|σ| ⊆ r ↓s S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ ⊆ r ↓s S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set σ"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set_mset r|σ|"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lexmax_elt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>A</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ r ∧ y ∈ set_mset r|σ|"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel</span><span> </span><span>assms</span><span> </span><span>transD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>drop_left_mult_eq</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N+M,M) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M+N,M+{#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(N,{#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_b'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} = I + J ∧ N = I + K ∧ set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹generalized to lists›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proposition3_4_inv_lists</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|σ| -s r ↓l β, {#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?M,_) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2 σ3. ((σ = σ1@σ2@σ3) ∧ set σ1 ⊆ dl r β ∧ length σ2 ≤ 1 ∧ set σ2 ⊆ {α}) ∧ set σ3 ⊆ dl r (α#β)"</span></span></span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈# ?M"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈# r|σ|"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ=σ1@[α]@σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>alpha</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∉ dl r σ1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((r|σ1|-sdl r β) + (r|[α]|-s (dl r σ1 ∪ dl r β)) + (r|σ3| -s (dl r [α] ∪ dl r σ1 ∪ dl r β)), {#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?M1 + ?M2 + ?M3,_) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma</span><span> </span><span>lemma3_2_2</span><span> </span><span>lemmaA_3_8</span><span> </span><span>lemmaA_3_9</span><span> </span><span>LD_1'_def</span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∉ dl r β"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M2 = {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexmax_singleton</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?M1+?M3 + {#α#},{#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span>union_assoc</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?M1+?M3 = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>drop_left_mult_eq</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ1|-sdl r β) = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset r|σ1| ⊆ ds r (set β)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_empty_implies_subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ1 ⊆ ds r (set β)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sigma2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length [α] ≤ 1 ∧ set [α] ⊆ {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"dl r σ1 ⊆ dl r β"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sigma1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sub2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r σ1 ∪ dl r β = dl r β"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"?M3 = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r|σ3|-s (ds r {α} ∪ ds r (set β)) = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Un_assoc</span><span> </span><span>sub2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r|σ3|-s (ds r ({α} ∪ (set β))) = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_set</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset r|σ3| ⊆ ds r ({α} ∪ (set β))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_empty_implies_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ3 ⊆ ds r ({α} ∪ (set β))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma</span><span> </span><span>sigma1</span><span> </span><span>sigma2</span><span> </span><span>sigma3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>sigma2</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset ?M ⊆ dm r {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_singleton</span><span class="delimiter">[</span><span>OF</span><span> </span><span>k</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>diff_eq_singleton_imp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset r|σ| ⊆ ds r ({α} ∪ (set β))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>dm_def</span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ ⊆ ds r ({α} ∪ (set β))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>bot_least</span><span> </span><span>empty_set</span><span> </span><span>le0</span><span> </span><span>length_0_conv</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proposition3_4_inv_step</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|σ| -s r ↓l [β], {#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?M,_) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2 σ3. ((σ = σ1@σ2@σ3) ∧ LD_1' r β α σ1 σ2 σ3)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proposition3_4_inv_lists</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_1'_def</span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proposition3_4_inv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r [β] [α] σ τ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2 σ3 τ1 τ2 τ3. (σ = σ1@σ2@σ3 ∧ τ = τ1@τ2@τ3 ∧ LD' r β α σ1 σ2 σ3 τ1 τ2 τ3)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proposition3_4_inv_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>D_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexmax_singleton</span><span> </span><span>LD'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 3.5›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r υ σ' σ'' υ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lexmax r (τ @ υ @ σ''), lexmax r (τ @ υ) + lexmax r σ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r (τ @ υ @ σ'') = (lexmax r (τ @ υ) + ((lexmax r σ'') -s (dl r (τ@υ))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"… = lexmax r (τ@υ) + (((lexmax r σ'') -s dl r υ) -s dl r τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lemma2_6_1_list</span><span> </span><span>lemmaA_3_9</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(…,lexmax r (τ@υ) + (lexmax r σ' -s dl r τ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>lemma2_6_5_a'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>D_eq</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?R,lexmax r (τ@υ) + lexmax r σ) ∈ mul_eq r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>D_eq</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>claim1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ@τ'| + ((r|υ'| -s r ↓l (σ@τ')) ∩s r ↓l τ),r|σ| + r|τ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?F+?H,?G) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?F,?G) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset ?H ⊆ (dm r ?G) - (dm r ?F)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?L ⊆ _)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset ?H = set_mset ((lexmax r υ' ∩s dl r τ) -s dl r (σ@τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"… ⊆ (dl r τ - dl r (σ@τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span>intersect_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ ((dl r σ ∪ dl r τ) - dl r (σ@τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_multiset</span><span> </span><span>lemma3_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_7_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>2</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step3</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ↓l (σ@τ) ⊇ (r ↓m (r|σ'| + r|τ| ))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (σ@τ) = dm r (lexmax r τ + lexmax r σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (τ@σ') = dm r (lexmax r σ' + lexmax r τ)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_list</span><span> </span><span>lemma3_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>lemma2_6_1_multiset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lemma2_6_2_b</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>lemma3_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>claim2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((r|υ'| -s  r ↓l (σ@τ')) -s r ↓l τ, (r|υ'| -s r ↓l σ') -s r ↓l τ) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?L,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = lexmax r υ' -s (dl r (σ@τ'@τ))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_9</span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>lemma2_6_1_list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(…,lexmax r υ' -s dl r (σ@τ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_8</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>dl_monotone</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(?R,lexmax r υ' -s dm r (lexmax r σ' + lexmax r τ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_8</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>step3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R = (lexmax r υ' -s dl r σ') -s dl r τ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>lemma2_6_1_multiset</span><span> </span><span>lemmaA_3_9</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r υ σ' σ'' υ'"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|(σ @ τ' @ υ')|, r|σ| + r|(τ@υ)| ) ∈ mul_eq r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r (σ@τ'@υ') = lexmax r (σ@τ') + (lexmax r υ' -s dl r (σ@τ'))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = lexmax r (σ@τ') + ((lexmax r υ' -s dl r (σ@τ')) ∩s dl r τ) + ((lexmax r υ' -s dl r (σ@τ')) -s dl r τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemmaA_3_10</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(…, lexmax r σ + lexmax r τ + ((lexmax r υ' -s dl r (σ@τ')) -s dl r τ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>claim1</span><span> </span><span>lemma2_6_6_a</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?R, lexmax r σ + lexmax r τ + (((lexmax r υ' -s dl r σ') -s dl r τ))) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>claim2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?R, lexmax r σ + lexmax r τ + lexmax r υ -s dl r τ) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lemma2_6_5_a'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>D_eq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R = lexmax r σ + lexmax r (τ@υ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_assoc</span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r υ σ' σ'' υ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r (τ@υ) σ σ'' (τ'@υ')"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span>append_assoc</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma3_5_1</span><span> </span><span>lemma3_5_2</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M ∩s dl r τ,lexmax r τ) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ=x#xs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lexmax r τ ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (M ∩sdl r τ) ⊆ dm r (lexmax r τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>intersect_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 3.6›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_6</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|σ'| + r|υ|, r|σ| + r|τ@υ| ) ∈ mul r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?L,?R) ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ((lexmax r σ' + lexmax r υ) ∩s dl r τ) + ((lexmax r σ' + lexmax r υ) -s dl r τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_10</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(…,lexmax r τ + ((lexmax r σ' + lexmax r υ) -s dl r τ)) ∈ mul r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R2) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_9</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>step2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>ne</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R2 = lexmax r τ + (lexmax r σ' -s dl r τ) + (lexmax r υ -s dl r τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemmaA_3_8</span><span> </span><span>union_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = lexmax r (τ@σ') + (lexmax r υ -s dl r τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(…,lexmax r σ + lexmax r τ + (lexmax r υ -s dl r τ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_,?R5) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma2_6_6_a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R5 = ?R"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_and_mul_eq_imp_mul</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_6_v</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D r τ σ σ' τ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|τ'| + r|υ|, r|τ| + r|σ@υ| ) ∈ mul r"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma3_6</span><span> </span><span>mirror_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Labeled Rewriting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 3.7›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>lars</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a×'b×'a) set"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>seq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a×('b×'a)list)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ars</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,[]) ∈ seq ars"</span></span></span><span>
</span><span>     </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,α,b) ∈ ars ⟹ (b,ss) ∈ seq ars ⟹ (a,(α,b) # ss) ∈ seq ars"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) seq ⇒ 'a"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss = (if snd ss = [] then fst ss else snd (last (snd ss)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹results on seqs›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_tail1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,x#xs) ∈ seq lars"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x,xs) ∈ seq lars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,fst x,snd x) ∈ lars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s,x#xs) = lst (snd x,xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x,xs)∈ seq lars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,fst x,snd x) ∈ lars"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s,x#xs) = lst (snd x,xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_chop</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss@ts) ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss) ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst(s,ss),ts) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,x#(xs@ts)) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x,xs) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst(s,ss),ts) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (snd x,xs),ts) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_concat_helper</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ls) ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss2 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s,ls) = fst ss2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ls@snd ss2) ∈ seq ars ∧ (lst (s,ls@snd ss2) = lst ss2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ls</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>ss2</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x,xs) ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,fst x,snd x) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (snd x,xs) = fst ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_tail1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mem</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_concat</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss2 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss1 = fst ss2"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ss1,snd ss1@snd ss2) ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (fst ss1,snd ss1@snd ss2) = lst ss2)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ss1,snd ss1@snd ss2) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat_helper</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (fst ss1,snd ss1@snd ss2) = lst ss2)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>surjective_pairing</span><span> </span><span>seq_concat_helper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹diagrams›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>diagram</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars d = (let (τ,σ,σ',τ') = d in {σ,τ,σ',τ'} ⊆ seq ars ∧
   fst σ = fst τ ∧ lst σ = fst τ' ∧ lst τ = fst σ' ∧ lst σ' = lst τ')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>labels</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) seq ⇒ 'b list"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ss = map fst (snd ss)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>D2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r d = (let (τ,σ,σ',τ') = d in D r (labels τ) (labels σ) (labels σ') (labels τ'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_d</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (υ,σ',σ'',υ')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars ((fst τ,snd τ@snd υ),σ,σ'',(fst τ'),snd τ'@snd υ')"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"υ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ = fst υ"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"υ' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ' = fst υ'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau'</span><span> </span><span>upsilon'</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau</span><span> </span><span>upsilon</span><span> </span><span>o</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_d_v</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (τ',υ,υ',τ'')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (τ,(fst σ,snd σ@snd υ),(fst σ',snd σ'@snd υ'),τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (σ,τ,τ',σ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (υ,τ',τ'',υ')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5_d</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d1</span><span> </span><span>d2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5'</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (υ,σ',σ'',υ')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r ((fst τ,snd τ@snd υ),σ,σ'',(fst τ'),snd τ'@snd υ')"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma3_5</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5'_v</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (τ',υ,υ',τ'')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (τ, (fst σ,snd σ@snd υ),(fst σ',snd σ'@snd υ'),τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"D2 r (σ,τ,τ',σ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (υ,τ',τ'',υ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mirror_D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>D1</span><span> </span><span>D2</span><span class="delimiter">]</span><span> </span><span>mirror_D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trivial_diagram</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (σ,(fst σ,[]),(lst σ,[]),σ)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span>Let_def</span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trivial_D2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (σ,(fst σ,[]),(lst σ,[]),σ)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D2_def</span><span> </span><span>D_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_reflexive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lift to combined concept *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'b rel ⇒ ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r d = (diagram ars d ∧ D2 r d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_DD</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (υ,σ',σ'',υ')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r ((fst τ,snd τ@snd υ),σ,σ'',(fst τ'),snd τ'@snd υ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma3_5_d</span><span> </span><span>lemma3_5'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma3_5_DD_v</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ',υ,υ',τ'')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ, (fst σ,snd σ@snd υ),(fst σ',snd σ'@snd υ'),τ'')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lemma3_5_d_v</span><span> </span><span>lemma3_5'_v</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trivial_DD</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (σ,(fst σ,[]),(lst σ,[]),σ)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>trivial_diagram</span><span> </span><span>trivial_D2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mirror_DD</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (σ,τ,τ',σ')"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mirror_D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹well-foundedness of rel r›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>measure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ ('a,'b) seq × ('a,'b) seq ⇒ 'b multiset"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure r P = r|labels (fst P)| + r|labels (snd P)|"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ (('a,'b) seq × ('a,'b) seq) rel"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pex r = {(P1,P2). (measure r P1,measure r P2) ∈ mul r}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfi</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"relr = pex r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wf (relr)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wf (mul r)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ SN ((relr)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_iff_wf</span><span> </span><span>converse_converse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. (s i, s (Suc i)) ∈ relr¯"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_def</span><span> </span><span>SN_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i. (measure r (s i), measure r (s (Suc i))) ∈ (mul r)¯"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pex_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ SN ((mul r)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chain_imp_not_SN_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fact</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_iff_wf</span><span> </span><span>converse_converse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (pex r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>wfi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹main result›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>peak</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars p = (let (τ,σ) = p in {τ,σ} ⊆ seq ars ∧ fst τ = fst σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>local_peak</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_peak ars p = (let (τ,σ) = p in peak ars p ∧ length (snd τ) = 1 ∧ length (snd σ) = 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹proof of Theorem 3.7›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LD_imp_D</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀P. (local_peak ars P ⟶ (∃ σ' τ'. DD ars r (fst P,snd P,σ',τ')))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ σ' τ'. DD ars r (fst P,snd P,σ',τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>acyclic_irrefl</span><span> </span><span>trancl_id</span><span> </span><span>wf_acyclic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (pex r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>wf_induct_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>τ</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decompose</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P = (τ,σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"τ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sigma</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sigma_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst σ = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd τ"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mirror_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>trivial_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sigma</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>sigma_s</span><span> </span><span>Nil</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>β_step</span><span> </span><span>υ_step</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ = (s,[β_step]@υ_step)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" (s,[β_step]@υ_step) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trivial_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>sigma_s</span><span> </span><span>Nil</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>α_step</span><span> </span><span>ρ_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (s,[α_step]@ρ_step)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma_s</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[α_step]@ρ_step) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alpha</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[α_step]) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?α ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rho</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (s,[α_step]),ρ_step) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ρ ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sigma2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>beta</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[β_step]) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?β ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (s,[β_step]),υ_step) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?υ ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_peak ars (?β,?α)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha</span><span> </span><span>beta</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>κ</span><span> </span><span>μ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"DD ars r (?β,?α,κ,μ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>kappa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"κ∈seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"μ∈seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_IH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" peak ars (?υ,κ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>upsilon</span><span> </span><span>kappa</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>beta_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?β ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r (labels ?β) (labels ?α) (labels κ) (labels μ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"((?υ,κ), (τ,?α)) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_6</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>beta_ne</span><span> </span><span>dec</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span>labels_def</span><span> </span><span>tau_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lexmax r (labels τ) + lexmax r (labels (?α)), lexmax r (labels τ) + lexmax r (labels σ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?l,?r) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma_dec</span><span> </span><span>labels_def</span><span> </span><span>snd_conv</span><span> </span><span>list.map</span><span> </span><span>lexmax.simps</span><span> </span><span>diff_from_empty</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lemma2_6_2_a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((?υ,κ),P) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma_s</span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_and_mul_eq_imp_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>κ'</span><span> </span><span>υ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (?υ,κ,κ',υ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P_IH1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>kappa'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"κ'∈seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"υ'∈seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tau'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst μ,snd μ@(snd υ')) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ' ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mu</span><span> </span><span>upsilon'</span><span class="delimiter">]</span><span> </span><span>D</span><span> </span><span>IH1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DIH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,?α,κ',?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>D</span><span> </span><span>IH1</span><span class="delimiter">]</span><span> </span><span>tau_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>dec_dih1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r (labels τ) (labels ?α) (labels κ') (labels ?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DIH1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_IH2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars (?τ',?ρ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau'</span><span> </span><span>rho</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alpha_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?α ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((?τ',?ρ),P) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_6_v</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>alpha_ne</span><span> </span><span>dec_dih1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span>labels_def</span><span> </span><span>sigma_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ρ'</span><span> </span><span>τ''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IH2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (?τ',?ρ,ρ',τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P_IH2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5_DD_v</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>DIH1</span><span> </span><span>IH2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>sigma_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CR with unlabeling›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unlabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'a rel"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlabel ars = {(a,c). ∃b. (a,b,c) ∈ ars}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_imp_seq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ss ∈ seq ars. fst ss = a ∧ lst ss = b"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(a,α,b) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unlabel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,[(α,b)]) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ss ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?ss = a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?ss = b"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_imp_seq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)^*"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ss ∈ seq ars. fst ss = a ∧ lst ss = b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)^^n"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>ars</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,[]) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_eqD</span><span> </span><span>snd_conv</span><span> </span><span>lst_def</span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,c) ∈ (unlabel ars)^^m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c,b) ∈ (unlabel ars)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst ss = a"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ts1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ts3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst ts = b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss = fst ts"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>steps</span><span> </span><span>step_imp_seq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss1</span><span> </span><span>ts1</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss2</span><span> </span><span>ts3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_imp_unlabeled_step</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b,c) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,c) ∈ (unlabel ars)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unlabel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_imp_steps</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ss = a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss = b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)^*"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ls</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,ls) ∈ seq (ars)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (a,ls) = b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ls</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(a,fst x,snd x) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x,b) ∈ (unlabel ars)^*"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_imp_unlabeled_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fst</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_vs_steps</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)^* = (∃ss. fst ss = a ∧ lst ss = b ∧ ss ∈ seq ars)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_steps</span><span> </span><span>steps_imp_seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>D_imp_CR</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀P. (peak ars P ⟶ (∃ σ' τ'. DD ars r (fst P,snd P,σ',τ')))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR (unlabel ars)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ (unlabel ars)^*"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,c) ∈ (unlabel ars)^*"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,c) ∈ (unlabel ars)<span class="hidden">⇧</span><sup>↓</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss1</span><span> </span><span>ss2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" peak ars (ss1,ss2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss1 = b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss2 = c"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_vs_steps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss3</span><span> </span><span>ss4</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dia</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (ss1,ss2,ss3,ss4)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dia</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss3 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss4 ∈ seq ars"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss3_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ss3 = b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss3_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ss3 = d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss4_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ss4 = c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss4_2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst ss4 = d"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_steps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss3</span><span> </span><span>ss3_1</span><span> </span><span>ss3_2</span><span class="delimiter">]</span><span> </span><span>seq_imp_steps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss4</span><span> </span><span>ss4_1</span><span> </span><span>ss4_2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b set ⇒ 'a rel ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD L ars = (∃ (r:: ('b rel)) (lrs::('a,'b) lars). (ars = unlabel lrs) ∧ trans r ∧ wf r ∧ (∀P. (local_peak lrs P ⟶ (∃ σ' τ'. (DD lrs r (fst P,snd P,σ',τ'))))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sound</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD L ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR ars"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>LD_imp_D</span><span> </span><span>D_imp_CR</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Application: Newman's Lemma›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>measure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lab_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lrs = {(a,c,b). c = a ∧ (a,b) ∈ ars}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,(α,t) # ss) ∈ seq lrs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels (t,ss)) ⊆ ds ((ars^+)¯) {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>α</span><span> </span><span>t</span><span> </span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>β</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x = (β,u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans ((ars^+)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>trans_converse</span><span> </span><span>trans_trancl</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, α, t) ∈ lrs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(t,(β,u)#xs) ∈ seq lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>fst_conv</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels (u, xs)) ⊆ ds ((ars^+)¯) {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{β} ⊆ ds ((ars^+)¯) {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span>cs</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span>lab_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>key</span><span class="delimiter">]</span><span> </span><span>key</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>newman</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WCR ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR ars"</span></span></span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L =  {a . ∃ b. (a,b) ∈ ars}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>lrs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lab_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lrs  = {(a,c,b). c = a ∧ (a,b) ∈ ars})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ars = unlabel lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unlabel_def</span><span> </span><span>lab_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans ((ars^+)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_converse</span><span> </span><span>trans_trancl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf ((ars^+)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wf_trancl</span><span> </span><span>trancl_converse</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_iff_wf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀P. (local_peak lrs P --&gt; (∃ σ' τ'. DD lrs ((ars^+)¯) (fst P,snd P,σ',τ')))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>P</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_peak lrs P --&gt; (∃ σ' τ'. DD lrs ((ars^+)¯) (fst P,snd P,σ',τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_peak lrs P"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ σ' τ'. DD lrs ((ars^+)¯) (fst P,snd P,σ',τ'))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?DD"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lab_eq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ars = unlabel lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unlabel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{τ,σ} ⊆ seq lrs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (snd τ) = 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (snd σ) = 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = (τ,σ)"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ = fst σ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>β</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd τ = [(β,b)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ = (a,[(β,b)])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>alb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,β,b) ∈ lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>insert_subset</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = β"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alb</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lab_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd σ = [(α,c)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (a,[(α,c)])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>p</span><span> </span><span>prod.collapse</span><span> </span><span>tau</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>alc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,α,c) ∈ lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>insert_subset</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,c) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = α"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alb</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lab_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tau</span><span> </span><span>sigma</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ = a ∧ fst σ = a ∧ lst τ = b ∧ lst σ = c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,d) ∈ ars^*"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c,d) ∈ ars^*"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ'</span><span> </span><span>τ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sigma'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' ∈ seq lrs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sigma'1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst σ' = b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ' = d"</span></span></span><span>
</span><span>                           </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>tau'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"τ' ∈ seq lrs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ' = c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ' = d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps_imp_seq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lab</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"diagram lrs (fst P, snd P, σ', τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span>A</span><span> </span><span>ts</span><span> </span><span>fl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(a,(β,b)# snd σ') ∈ seq lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fst σ' = b›</span></span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>alb</span><span class="delimiter">]</span><span> </span><span>sigma'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ') ⊆ ds ((ars^+)¯) {β}"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>measure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lab_eq</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fst σ' = b›</span></span></span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(a,(α,c)# snd τ') ∈ seq lrs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fst τ' = c›</span></span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>alc</span><span class="delimiter">]</span><span> </span><span>tau'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ww</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels τ') ⊆ ds ((ars^+)¯) {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>measure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lab_eq</span><span class="delimiter">]</span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fst τ' = c›</span></span></span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl ((ars^+)¯)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SN_imp_acyclic</span><span> </span><span>acyclic_converse</span><span> </span><span>acyclic_irrefl</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>trancl_converse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vv</span><span> </span><span>ww</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ld</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LD' ((ars^+)¯) β α (labels σ') [] [] (labels τ') [] []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD'_def</span><span> </span><span>LD_1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ((ars^+)¯) (labels (fst P)) (labels (snd P)) (labels σ') (labels τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proposition3_4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>ld</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P</span><span> </span><span>sigma</span><span> </span><span>tau</span><span> </span><span>lst_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>d</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DD lrs ((ars^+)¯) (fst P, snd P, σ', τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD L ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lab</span><span> </span><span>t</span><span> </span><span>w</span><span> </span><span>ps</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion Version›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This section follows~\cite{vO08a}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auxiliary results on multisets›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_add_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,M+P) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M + {#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset {#} ⊆ dm r P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_add_right</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N+P) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N + P = I + (J + P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ ds r (set_mset J ∪ set_mset P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J+P ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>lemma2_6_1_set</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ ds r (set_mset (J+P ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_eq_and_ds_imp_ds</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset N ⊆ ds r S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset I ⊆ ds r S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset J ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r (set_mset J) ⊆ ds r S"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k1</span><span> </span><span>a</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2_6_2_set</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds r S ⊆ ds r T"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leq_imp_subseteq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆# N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset M ⊆ set_mset N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mset_subset_eqD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mul_add_mul_eq_imp_mul</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mul r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P,Q) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M+P,N+Q) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K ⊆ dm r J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I2</span><span> </span><span>J2</span><span> </span><span>K2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P = I2 + K2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = I2 + J2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset K2 ⊆ dm r J2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M + P = (I + I2) + (K + K2)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>union_commute</span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N + Q = (I + I2) + (J + J2)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>union_commute</span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (K + K2) ⊆ dm r (J + J2)"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma2_6_1_multiset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹labeled conversion›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>conv</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × ((bool × 'b × 'a) list))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) conv set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ars</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,[]) ∈ conv ars"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,α,b) ∈ ars ⟹ (b,ss) ∈ conv ars ⟹ (a,(True,α,b) # ss) ∈ conv ars"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,α,a) ∈ ars ⟹ (b,ss) ∈ conv ars ⟹ (a,(False,α,b) # ss) ∈ conv ars"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>labels_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) conv ⇒ 'b list"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels_conv c = map (λq. (fst (snd q))) (snd c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>measure_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ ('a,'b) conv ⇒ 'b multiset"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure_conv r c = lexmax r (labels_conv c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lst_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) conv ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,[]) = s"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,(d,α,t) # ss) = lst_conv (t,ss)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>local_diagram1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_diagram1 ars β α σ1 σ2 σ3 =
  (local_peak ars (β,α) ∧ {σ1,σ2,σ3} ⊆ seq ars ∧ lst β = fst σ1 ∧ lst σ1 = fst σ2 ∧ lst σ2 = fst σ3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LDD1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'b rel ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LDD1 ars r β α σ1 σ2 σ3 =  (local_diagram1 ars β α σ1 σ2 σ3 ∧
  LD_1' r (hd (labels β)) (hd (labels α)) (labels σ1) (labels σ2) (labels σ3))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LDD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'b rel ⇒ ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq × ('a,'b) seq ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LDD ars r d = (let (β,α,σ1,σ2,σ3,τ1,τ2,τ3) = d in LDD1 ars r β α σ1 σ2 σ3 ∧ LDD1 ars r α β τ1 τ2 τ3 ∧ lst σ3 = lst τ3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>local_triangle1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) conv ⇒ ('a,'b) seq ⇒ ('a,'b) conv ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_triangle1 ars β α σ1 σ2 σ3 =
  (local_peak ars (β,α) ∧ σ2 ∈ seq ars ∧ {σ1,σ3} ⊆ conv ars ∧ lst β = fst σ1 ∧ lst_conv σ1 = fst σ2 ∧ lst σ2 = fst σ3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LT1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'b rel ⇒ ('a,'b) seq ⇒ ('a,'b) seq ⇒ ('a,'b) conv ⇒ ('a,'b) seq ⇒ ('a,'b) conv ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LT1 ars r β α σ1 σ2 σ3 = (local_triangle1 ars β α σ1 σ2 σ3 ∧
  LD_1' r (hd (labels β)) (hd (labels α)) (labels_conv σ1) (labels σ2) (labels_conv σ3))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) lars ⇒ 'b rel ⇒ ('a,'b) seq × ('a,'b) seq × ('a,'b) conv × ('a,'b) seq × ('a,'b) conv × ('a,'b) conv × ('a,'b) seq × ('a,'b) conv ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LT ars r t = (let (β,α,σ1,σ2,σ3,τ1,τ2,τ3) = t in LT1 ars r β α σ1 σ2 σ3 ∧ LT1 ars r α β τ1 τ2 τ3 ∧ lst_conv σ3 = lst_conv τ3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_tail1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,(d,α,t)#xs) ∈ conv ars"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,xs) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⟹ (s,α,t) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬d ⟹ (t,α,s) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,(d,α,t)#xs) = lst_conv (t,xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,xs) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⟹ (s,α,t) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬d ⟹ (t,α,s) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,(d,α,t)#xs) = lst_conv (t,xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_conv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_chop</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss1@ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss1) ∈ conv ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst_conv (s,ss1),ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss1) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t'</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>α</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = (d,α,t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_cases3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t' # ts @ ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, ts @ ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⟹ (s,α,t) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬d ⟹ (t,α,s) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>conv.intros</span><span> </span><span>d1</span><span> </span><span>d2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst_conv (s,ss1),ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv.intros</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>last.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t'</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>α</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = (d,α,t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_cases3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t' # ts @ ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd (snd t'), ts @ ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span>last.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_concat_helper</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ls) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss2 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,ls) = fst ss2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ls@snd ss2) ∈ conv ars ∧ (lst_conv (s,ls@snd ss2) = lst_conv ss2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ls</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>ss2</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>α</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = (d,α,t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod_cases3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,xs) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"d ⟹ (s,α,t) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬d ⟹ (t,α,s) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst_conv (t,xs) = fst ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,xs@snd ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (t,xs@snd ss2) = lst_conv ss2"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tl</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>lst</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv.intros</span><span> </span><span>d1</span><span> </span><span>d2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span>lst_conv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_concat</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss2 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ss1 = fst ss2"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ss1,snd ss1@snd ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst_conv (fst ss1,snd ss1@snd ss2) = lst_conv ss2)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ss1,snd ss1@snd ss2) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat_helper</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst_conv (fst ss1,snd ss1@snd ss2) = lst_conv ss2)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>surjective_pairing</span><span> </span><span>conv_concat_helper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_concat_labels</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss2 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ss1) ⊆ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ss2) ⊆ T"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv (fst ss1,snd ss1@snd ss2)) ⊆ S ∪ T"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_conv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_decompose</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ = σ1'@σ2'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2. ({σ1,σ2} ⊆ seq ars ∧ σ = (fst σ1,snd σ1@snd σ2) ∧ lst σ1 = fst σ2 ∧ lst σ2 = lst σ ∧ labels σ1 = σ1' ∧ labels σ2 = σ2')"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (s,ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_dec</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>σ1'</span><span> </span><span>σ2'</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,x) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(snd x,xs) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_tail1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,[x]) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>seq_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst x#labels (snd x,xs) = σ1'@σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span>snd_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1'=[]"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>ls</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ2'_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2' = l#ls"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst x = l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"labels (snd x,xs) = []@ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x, xs) = (fst σ1, snd σ1 @ snd σ2)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ1 = fst σ2"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"labels σ1 = []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ2 = ls"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span> </span><span>y2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst (snd x,xs) = fst σ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 = (snd x,[])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd x = fst σ1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = snd σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd x = fst σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 = (snd x,xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst (s, [x]) = fst σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{(s,[]), (s,x# snd σ2)} ⊆ seq ars"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{?σ1,?σ2} ⊆ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps</span><span> </span><span>_</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, x # xs) = (fst ?σ1, snd ?σ1 @ snd ?σ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ1 = fst ?σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ2 = lst (s,x#xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels (s,[]) = σ1'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?σ2 = σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>y1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ2'_dec</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>ls</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ1'_dec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ1' = l#ls"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>y1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst x = l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"labels (snd x,xs) = ls @ σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2 ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd x, xs) = (fst σ1, snd σ1 @ snd σ2)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lst σ1 = fst σ2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ2 = lst (snd x, xs)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ1 = ls"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ2 = σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span> </span><span>y2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s,x# snd σ1),σ2} ⊆ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{?σ1,_} ⊆ seq ars"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps</span><span class="delimiter">]</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,x#xs) = (fst ?σ1,snd ?σ1@snd σ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ1 = fst σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ2 = lst (s, x # xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?σ1 = σ1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>σ1'_dec</span><span> </span><span>y1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ2 = σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_imp_conv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,ss) ∈ seq ars"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,map (λstep. (True,step)) ss) ∈ conv ars ∧
       lst_conv (s,map (λstep.(True,step)) ss) = lst (s,ss) ∧
       labels (s,ss) = labels_conv (s,map (λstep.(True,step)) ss)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span> </span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span>labels_def</span><span> </span><span>labels_conv_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t'</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t'_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = (fst t',snd t')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,fst t',snd t') ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(snd t',ts) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_tail1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(snd t', map (Pair True) ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>y2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (snd t', ts) = lst_conv (snd t', map (Pair True) ts)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>y3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels (snd t', ts) = labels_conv (snd t', map (Pair True) ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,(True,fst t',snd t')#map (Pair True) ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>y1</span><span> </span><span>conv.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s,(fst t',snd t')#ts) = lst_conv (s, map (Pair True) ((fst t',snd t')#ts))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list.map</span><span> </span><span>lst_def</span><span> </span><span>lst_conv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels (s,(fst t',snd t')#ts) = labels_conv (s,map (Pair True) ((fst t',snd t')#ts))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list.map</span><span> </span><span>labels_def</span><span> </span><span>labels_conv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>conv_mirror</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b) conv ⇒ ('a,'b) conv"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conv_mirror σ = (let (s,ss) = σ in case ss of
             [] ⇒ (s,ss)
         | x#xs ⇒ let (d,α,t) = x in
                   (fst (conv_mirror (t,xs)),snd (conv_mirror (t,xs))@[(¬d,α,s)]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_mirror</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ conv ars"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conv_mirror σ ∈ conv ars ∧
      set (labels_conv (conv_mirror σ)) = set (labels_conv σ) ∧
      fst σ = lst_conv (conv_mirror σ) ∧
      lst_conv σ = fst (conv_mirror σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (s,ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_dec</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv.intros</span><span>  </span><span>conv_mirror.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t'</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>α</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t'_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = (d,α,t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod_cases3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(t, ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⟹ (s,α,t) ∈ ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬d ⟹ (t,α,s) ∈ ars"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst_conv (s,t'#ts) = lst_conv (t,ts)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conv_tail1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t'_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,[(¬d,α,s)]) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>conv.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>conv.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>conv.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>conv.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conv_mirror (s,t'#ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>r</span><span> </span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>t'_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv (conv_mirror (s, t' # ts))) = set (labels_conv (s, t' # ts))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_conv_def</span><span> </span><span>t'_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (s, t' # ts) = lst_conv (conv_mirror (s, t' # ts))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_dec</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>conv_concat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (s, t' # ts) = fst (conv_mirror (s, t' # ts))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_dec</span><span> </span><span>4</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DD_subset_helper</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|τ@σ'|, r|τ| + r|σ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|τ| + r|σ| ) ⊆ ds r S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset r|σ'| ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|τ| + r|σ'| -s dl r (τ) , r|τ| + r|σ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset (r|τ| + r|σ| ) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ds r (set_mset r|τ| ) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|τ| + (r|σ'| -s dl r τ)) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_and_ds_imp_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>d</span><span> </span><span>assm</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|σ'| -s ds r (set τ)) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|σ'| -s ds r (set τ)) ∪ ds r (set τ) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>t</span><span> </span><span>dl_def</span><span> </span><span>dm_def</span><span> </span><span>le_sup_iff</span><span> </span><span>lemma3_2_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DD_subset_ds</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (τ,σ)) ⊆ ds r S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (σ',τ')) ⊆ ds r S"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels τ @ labels σ'|, r|labels τ| + r|labels σ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels σ @ labels τ'|, r|labels σ| + r|labels τ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span>D_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD_subset_helper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>d1</span><span class="delimiter">]</span><span> </span><span>DD_subset_helper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>d2</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conv_imp_valley</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y . ((y,((s,[α_step]@ρ_step),(s,[β_step]@υ_step))) ∈ pex r ⟹ peak ars y ⟹ ∃σ' τ'. DD ars r (fst y, snd y, σ', τ'))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. ((y,?P) ∈ _ ⟹ _ ⟹ _)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"δ1 ∈ conv ars"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r δ1) ⊆ dm r M"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,{#fst α_step,fst β_step#}) ∈ mul_eq r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ τ. ({σ,τ} ⊆ seq ars ∧ fst σ = fst δ1 ∧ fst τ = lst_conv δ1 ∧ lst σ = lst τ ∧ set_mset (measure r (σ,τ)) ⊆ dm r M)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sigma1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ1 = (s,ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma1</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,[]) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r ((s,[]),(s,[]))) ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t'</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>β</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' = (d,β,t)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>dic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{β} ⊆ ds r (set_mset M)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span>measure_conv_def</span><span> </span><span>labels_conv_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>one</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ds r {β} ⊆ dm r M "</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_ds_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>dic</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r (t,ts) -s ds r {β})  ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_conv_def</span><span> </span><span>labels_conv_def</span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r (t,ts)) ⊆ dm r M ∪ ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mset_def</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ts2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r (t,ts)) ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dic</span><span> </span><span>one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,ts) ∈ conv ars"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ts</span><span> </span><span>ts2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ'</span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span>ih</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{σ', τ} ⊆ seq ars ∧ fst σ' = fst (t,ts) ∧ fst τ = lst_conv (t, ts) ∧ lst σ' = lst τ ∧ set_mset (measure r (σ',τ)) ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"!!x. x ∈# r|map fst (snd σ')|-sds r {β} ⟹ x ∈# r|map fst (snd σ')|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,β,t) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,(β,t)# snd σ') ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?σ ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{?σ,τ} ⊆ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ?σ) = fst (s, t' # ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ = lst_conv (s, t' # ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span>lst_conv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ = lst τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(s, (β, t) # snd σ') ∈ seq ars›</span></span></span><span> </span><span>fst_conv</span><span> </span><span>ih</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (?σ,τ)) ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff</span><span> </span><span>ih</span><span> </span><span>dic</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(t,β,s) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_tail1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,[(β,s)]) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"peak ars ((t,[(β,s)]),σ')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars ?y"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq.intros</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r ?y) ⊆ ds r (set_mset M)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>dic</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span>dm_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ≠ {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span>dic</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(measure r ?y,M) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_0</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"({#fst α_step#}+{#fst β_step#},measure r ?P) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_lcomm</span><span> </span><span>union_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_add_right</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{#fst α_step#}+{#fst β_step#}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>union_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(M,measure r ?P) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>mul_eq_trans</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_commute</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>w</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(?y,?P) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pex_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_and_mul_eq_imp_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ''</span><span> </span><span>τ''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>DD</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"DD ars r ((t,[(β,s)]),σ',σ'',τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'' ∈ seq ars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst σ'' = fst (s, t' # ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ'' = lst τ''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tau''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ'' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ = fst τ''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(fst τ,snd τ @ snd τ'') ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ''' ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ'' = lst (fst τ,snd τ@ snd τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>tau''</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?τ''' = lst_conv (s,t'#ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ'' = lst ?τ'''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>dec</span><span> </span><span>lst_conv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (σ'',τ'')) ⊆ ds r (set_mset M)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD_subset_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>DD</span><span> </span><span>mp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|labels σ''| + r|labels τ| + (r|labels τ''| -s (dl r (labels τ)) )) ⊆ dm r M"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>dm_def</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (σ'',?τ''')) ⊆ dm r M"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lemma3_2_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma</span><span> </span><span>tau</span><span> </span><span>tau2</span><span> </span><span>fin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>labels_multiset</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels σ) ≤ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ) ⊆ {α}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|labels σ|, {#α#}) ∈ mul_eq r"</span></span></span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd σ"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r|labels σ| = {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mul_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length (labels σ) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ = a#as"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neq_Nil_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ = [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ) = {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|labels σ| ) = {#α#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span> </span><span>lexmax.simps</span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_reflexive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decreasing_imp_local_decreasing</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels τ) ⊆ ds r {β}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels σ) ≤ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ) ⊆ {α}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃σ1 σ2 σ3. (σ'=(fst σ1,snd σ1@snd σ2@snd σ3) ∧ lst σ1=fst σ2 ∧ lst σ2 = fst σ3 ∧ lst σ3 = lst σ'
                 ∧ LD_1' r β α (labels σ1) (labels σ2) (labels σ3))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"set (labels τ') ⊆ ds r ({α,β})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2 σ3. (σ' = (fst σ1,snd σ1@snd σ2@snd σ3) ∧
         lst σ1 = fst σ2 ∧ lst σ2 = fst σ3 ∧ lst σ3 = lst σ' ∧ LD_1' r β α (labels σ1) (labels σ2) (labels σ3))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ' ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|labels σ'| -s dl r (labels τ),r|labels σ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_eq</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (labels τ) ⊆ ds r (ds r {β})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dl r (labels τ) ⊆ ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ds_ds_subseteq_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels σ'| -s ds r {β},r|labels σ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_def</span><span> </span><span>lemma2_6_8</span><span> </span><span>mul_eq_trans</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels σ'| -s dl r [β],{#α#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>labels_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1'</span><span> </span><span>σ2'</span><span> </span><span>σ3'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"labels σ' = σ1'@(σ2'@σ3')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ1'l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ1' ⊆ ds r {β}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>σ2'l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length σ2' ≤ 1 ∧ set σ2' ⊆ {α}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3'l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set σ3' ⊆ ds r {α,β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proposition3_4_inv_lists</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ23</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ1 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ23 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ1 = fst σ23"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf1b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ' = lst σ23"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>σ'_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ' = (fst σ1,snd σ1@snd σ23)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ1l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"labels σ1 = σ1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"labels σ23 = σ2'@σ3'"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_decompose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>σ'</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ2</span><span> </span><span>σ3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ2 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ3 ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst σ2 = fst σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf2b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst σ23 = lst σ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>σ23_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ23 = (fst σ2,snd σ2@snd σ3)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ2l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ2 = σ2'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ3 = σ3'"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_decompose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>σ23</span><span> </span><span>l2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' = (fst σ1, snd σ1 @ snd σ2 @ snd σ3)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ1</span><span> </span><span>σ2</span><span> </span><span>σ3</span><span> </span><span>σ'_eq</span><span> </span><span>σ23_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ1 = fst σ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lf1</span><span> </span><span>σ23_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ2 = fst σ3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lf2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ3 = lst σ'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lf1b</span><span> </span><span>lf2b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ1) ⊆ ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ1l</span><span> </span><span>σ1'l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels σ2) ≤ 1 ∧ set (labels σ2) ⊆ {α}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ2l</span><span> </span><span>σ2'l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ3) ⊆ ds r {α, β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ3l</span><span> </span><span>σ3'l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels τ') ⊆ ds r ({α,β})"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels τ'| -s dl r (labels σ),r|labels τ| ) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span>D_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset r|labels τ| ⊆ ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_imp_subseteq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|labels τ'|-s ds r (set (labels σ))) ⊆ ds r {β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_and_ds_imp_ds</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|labels τ'| ) ⊆ ds r {β} ∪ ds r (set (labels σ))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|labels τ'| ) ⊆ ds r {α,β}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ds_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>local_decreasing_extended_imp_decreasing</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LT1 ars r (s,[β_step]) (s,[α_step]) γ1 γ2 γ3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"!!y . ((y,((s,[β_step]@υ_step),(s,[α_step]@ρ_step))) ∈ pex r ⟹ peak ars y ⟹ ∃σ' τ'. DD ars r (fst y, snd y, σ', τ'))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. ((y,?P) ∈ _ ⟹ _ ⟹ _)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ1 σ2 σ3' γ1'''. ({σ1,σ2,σ3',γ1'''} ⊆ seq ars ∧
  set (labels σ1) ⊆ ds r {fst β_step} ∧ length (labels σ2) ≤ 1 ∧ set (labels σ2) ⊆ {fst α_step} ∧ set (labels σ3') ⊆ ds r {fst α_step,fst β_step}) ∧
  set (labels γ1''') ⊆ ds r {fst α_step,fst β_step} ∧
  snd β_step = fst σ1 ∧ lst σ1 = fst σ2 ∧ lst σ2 = fst σ3' ∧ lst σ3' = lst γ1''' ∧ fst γ1''' = fst γ3"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>labels_multiset</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels γ2|,{#fst α_step#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span>LD_1'_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>γ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ1 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ3 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ2_l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels γ2) ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ2_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels γ2) ⊆ {fst α_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ3_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv γ3) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv γ1) ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT_def</span><span> </span><span>LD'_def</span><span> </span><span>LT1_def</span><span> </span><span>LD_1'_def</span><span> </span><span>labels_def</span><span> </span><span>local_triangle1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r γ1) ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_conv_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>set_mset_mset</span><span> </span><span>submultiset_implies_subset</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>γ1_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r γ1) ⊆ dm r {#fst β_step#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"({#fst β_step#}, {#fst β_step, fst α_step#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_add_right</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#_#}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>γ1'</span><span> </span><span>γ1''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>γ1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ1' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ1''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ1'' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eqx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst γ1' = fst γ1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"fst γ1'' = lst_conv γ1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ1'_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst γ1' = lst γ1''"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure r (γ1',γ1'')) ⊆ dm r {#fst β_step#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_imp_valley</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>IH</span><span> </span><span>γ1</span><span> </span><span>γ1_s</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"peak ars (γ1'',γ2)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars ?Q"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT_def</span><span> </span><span>LD'_def</span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>m2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>γ1's</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels γ1') ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ1''s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels γ1'') ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lexmax_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>m2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τ1'_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels γ1''|,{#fst β_step#}) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_def</span><span> </span><span>mul_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dm_def</span><span> </span><span>empty_neutral</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>set_mset_single</span><span> </span><span>add_mset_not_empty</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(r|labels γ1''| + r|labels γ2|,{#fst α_step#}+{#fst β_step#}) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_add_mul_eq_imp_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>τ1'_m</span><span> </span><span>s2</span><span class="delimiter">]</span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r|labels γ1''| + r|labels γ2|, {#fst α_step,fst β_step#} + (r|map fst ρ_step|-sds r {fst α_step} + r|map fst υ_step|-sds r {fst β_step})) ∈ mul r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_add_right</span><span class="delimiter">[</span><span>OF</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_commute</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(?Q,?P) ∈ pex r"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>union_assoc</span><span> </span><span>union_commute</span><span> </span><span>union_lcomm</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>γ1'''</span><span> </span><span>σ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>DD</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"DD ars r (γ1'',γ2,σ',γ1''')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ1'''</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"γ1''' ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>decreasing_imp_local_decreasing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>DD</span><span> </span><span>γ1''s</span><span> </span><span>γ2_l</span><span> </span><span>γ2_s</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1'</span><span> </span><span>σ2'</span><span> </span><span>σ3'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ'_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' = (fst σ1', snd σ1' @ snd σ2' @ snd σ3')"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ1' = fst σ2'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ2' = fst σ3'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ3' = lst σ'"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ1s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ1') ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ2l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels σ2') ≤ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ2's</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ2') ⊆ {fst α_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ3') ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3's</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ3') ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ1'''s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels γ1''') ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ'_ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst σ1', snd σ1' @ snd σ2' @ snd σ3') ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ'</span><span> </span><span>σ'_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ1'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ1' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tmp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst σ2',snd σ2'@snd σ3') ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>σ'_ds</span><span class="delimiter">]</span><span> </span><span>surjective_pairing</span><span> </span><span>eq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ2' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ3' ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tmp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surjective_pairing</span><span> </span><span>eq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst γ1' = fst σ1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span>γ1'_eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ'_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst γ1',snd γ1'@snd σ1') ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?σ1 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst (fst γ1', snd γ1' @ snd σ1') = lst σ1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>γ1'</span><span> </span><span>σ1'</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels ?σ1) ⊆ ds r {fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ1s</span><span> </span><span>γ1's</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd β_step = fst ?σ1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span>lst_def</span><span> </span><span>σ'_dec</span><span> </span><span>eqx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ1 = fst σ2'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq0</span><span> </span><span>eq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ3' = lst γ1'''"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq1</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst γ1''' = fst γ3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DD</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ2'</span><span> </span><span>σ2's</span><span> </span><span>σ3'</span><span> </span><span>σ3's</span><span>  </span><span>γ1'''</span><span> </span><span>γ1'''s</span><span> </span><span>eq1</span><span> </span><span>surjective_pairing</span><span> </span><span>σ2l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LDD_imp_DD</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LDD ars r (τ,σ,σ1,σ2,σ3,τ1,τ2,τ3)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ' τ'. DD ars r (τ,σ,σ',τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels σ) = 1"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>local_peak_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ = [α]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>append_butlast_last_id</span><span> </span><span>butlast_conv_take</span><span> </span><span>diff_self_eq_0</span><span> </span><span>length_0_conv</span><span> </span><span>take_0</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>σl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels σ = [hd (labels σ)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (labels τ) = 1"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>local_peak_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>β</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels τ = [β]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>append_butlast_last_id</span><span> </span><span>butlast_conv_take</span><span> </span><span>diff_self_eq_0</span><span> </span><span>length_0_conv</span><span> </span><span>take_0</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>τl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels τ = [hd (labels τ)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(fst σ1,snd σ1@snd σ2@snd σ3) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?σ' ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>τ'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(fst τ1,snd τ1@snd τ2@snd τ3) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ' ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_eqD</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_eqD</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sigmas</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?σ' = fst σ1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?σ' = lst σ3"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>σ'</span><span> </span><span>append_assoc</span><span> </span><span>seq_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>seq_concat_helper</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>taus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?τ' = fst τ1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst ?τ' = lst τ3"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>τ'</span><span> </span><span>append_assoc</span><span> </span><span>seq_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>seq_concat_helper</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diagram ars (τ,σ,?σ',?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span>diagram_def</span><span> </span><span>local_peak_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigmas</span><span> </span><span>taus</span><span> </span><span>σ'</span><span> </span><span>τ'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D2 r (τ,σ,?σ',?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>proposition3_4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>σl</span><span> </span><span>τl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>D2_def</span><span> </span><span>LD'_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LT_imp_DD</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"!!y . ((y,((s,[β_step]@υ_step),(s,[α_step]@ρ_step))) ∈ pex r ⟹ peak ars y ⟹ ∃σ' τ'. DD ars r (fst y, snd y, σ', τ'))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. ((y,?P) ∈ _ ⟹ _ ⟹ _)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LT ars r ((s,[β_step]),(s,[α_step]),γ1,γ2,γ3,δ1,δ2,δ3)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ κ μ. DD ars r ((s,[β_step]),(s,[α_step]),κ,μ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LT</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LTa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LT1 ars r (s,[β_step]) (s,[α_step]) γ1 γ2 γ3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LTb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LT1 ars r (s,[α_step]) (s,[β_step]) δ1 δ2 δ3"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>local_decreasing_extended_imp_decreasing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LTa</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>IH</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>σ2</span><span> </span><span>σ3'</span><span> </span><span>γ1'''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sigmas</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{σ1,σ2,σ3',γ1'''} ⊆ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>onetwo1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ1) ⊆ ds r {fst β_step} ∧ length (labels σ2) ≤ 1 ∧ set (labels σ2) ⊆ {fst α_step} ∧
    set (labels σ3') ⊆ ds r {fst α_step, fst β_step} ∧ set (labels γ1''') ⊆ ds r {fst α_step,fst β_step} ∧
     snd β_step = fst σ1 ∧ lst σ1 = fst σ2 ∧ lst σ2 = fst σ3' ∧ lst σ3' = lst γ1''' ∧ fst γ1''' = fst γ3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. (y, (s, [α_step] @ ρ_step),(s,[β_step] @ υ_step)) ∈ pex r ⟹ peak ars y ⟹ ∃σ' τ'. DD ars r (fst y, snd y, σ', τ')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>local_decreasing_extended_imp_decreasing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LTb</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>ih2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ1</span><span> </span><span>τ2</span><span> </span><span>τ3'</span><span> </span><span>δ1'''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>taus</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{τ1,τ2,τ3',δ1'''} ⊆ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>onetwo2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels τ1) ⊆ ds r {fst α_step} ∧ length (labels τ2) ≤ 1 ∧ set (labels τ2) ⊆ {fst β_step} ∧
    set (labels τ3') ⊆ ds r {fst β_step,fst α_step} ∧ set (labels δ1''') ⊆ ds r {fst β_step,fst α_step} ∧
     snd α_step = fst τ1 ∧ lst τ1 = fst τ2 ∧ lst τ2 = fst τ3' ∧ lst τ3' = lst δ1''' ∧ fst δ1''' = fst δ3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>γ3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ3 ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ3m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set (labels_conv γ3) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>δ3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ3 ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c2 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ3m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv δ3) ⊆ ds r {fst β_step,fst α_step}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv γ3 = lst_conv δ3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LT</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LT_def</span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span>LD_1'_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ3m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv δ3) ⊆ ds r {fst α_step, fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*concat*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>δ1'''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ1''' ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>taus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>γ1'''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ1''' ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigmas</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst δ1''',map (Pair True) (snd δ1''')) ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c0 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_conv</span><span> </span><span>δ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst δ1''' = lst_conv ?c0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_conv</span><span> </span><span>δ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c0) ⊆ ds r {fst β_step,fst α_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onetwo2</span><span> </span><span>seq_imp_conv</span><span> </span><span>δ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c1l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c0) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"conv_mirror ?c0 ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv (conv_mirror ?c0)) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"fst (conv_mirror ?c0) = lst τ3'"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"lst_conv (conv_mirror ?c0) = fst δ3"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_mirror</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c1</span><span class="delimiter">]</span><span> </span><span>c11</span><span> </span><span>c1l</span><span> </span><span>c1</span><span> </span><span>onetwo2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c2 ∈ conv ars"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c2) ⊆ ds r {fst α_step, fst β_step}"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"fst ?c2 = fst δ3"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c2 = lst_conv γ3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ3</span><span> </span><span>eq</span><span> </span><span>δ3m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conv_mirror γ3 ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c3 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv (conv_mirror γ3)) = set (labels_conv γ3)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_mirror</span><span class="delimiter">[</span><span>OF</span><span> </span><span>γ3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c3 ∈ conv ars"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c3) ⊆ ds r {fst α_step, fst β_step}"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"fst ?c3 = lst_conv δ3"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c3 = fst γ1'''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_mirror</span><span class="delimiter">[</span><span>OF</span><span> </span><span>γ3</span><span class="delimiter">]</span><span> </span><span>eq</span><span> </span><span>onetwo1</span><span> </span><span>γ3m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst γ1''',map (Pair True) (snd γ1''')) ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c4 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv (fst γ1''',map (Pair True) (snd γ1'''))) = set (labels γ1''')"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_conv</span><span> </span><span>γ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_conv</span><span> </span><span>γ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c4 ∈ conv ars"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c4 = lst γ1'''"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c4) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>seq_imp_conv</span><span> </span><span>γ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_imp_conv</span><span> </span><span>γ1'''</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>onetwo1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c1 = fst ?c2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c12</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ?c1,snd ?c1@snd ?c2) ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c12 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"fst (fst ?c1,snd ?c1@snd ?c2) = fst ?c1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (fst ?c1,snd ?c1@snd ?c2) = lst_conv ?c2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c12 = fst ?c3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c12</span><span> </span><span>c3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c123</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ?c12,snd ?c12@snd ?c3) ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c123 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"fst (fst ?c12,snd ?c12@snd ?c3) = fst ?c12"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (fst ?c12,snd ?c12@snd ?c3) = lst_conv ?c3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c12</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c123 = fst ?c4"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c123</span><span> </span><span>c2</span><span> </span><span>c4</span><span> </span><span>onetwo1</span><span> </span><span>onetwo2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1234</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst ?c123,snd ?c123@snd ?c4) ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1234 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"fst (fst ?c123,snd ?c123@snd ?c4) = fst ?c123"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv (fst ?c123,snd ?c123@snd ?c4) = lst_conv ?c4"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c123</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c4</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c1234</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1234 ∈ conv ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1234 ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"fst (?c1234) = lst τ3'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ?c1234 = lst σ3'"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>onetwo1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c12l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c12) ⊆ ds r {fst α_step, fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat_labels</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c123l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c123) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat_labels</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c12</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>c12l</span><span> </span><span>c3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1234l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set (labels_conv ?c1234) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conv_concat_labels</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c123</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c4</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>c123l</span><span> </span><span>c4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (r|labels_conv ?c1234| ) ⊆ ds r {fst α_step,fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>submultiset_implies_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lexmax_le_multiset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r ?c1234) ⊆ dm r {#fst β_step, fst α_step#}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>measure_conv_def</span><span> </span><span>dm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r ?c1234) ⊆ dm r {#fst α_step, fst β_step#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c1234</span><span> </span><span>m</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ρ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ρ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ρ ∈ conv ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ρm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set_mset (measure_conv r ρ) ⊆ dm r {# fst α_step, fst β_step#}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ρ = lst τ3'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst_conv ρ = lst σ3'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"({#fst α_step,fst β_step#},{#fst β_step,fst α_step#}) ∈ mul_eq r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_eq_reflexive</span><span> </span><span>add_mset_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conv_imp_valley</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>IH</span><span> </span><span>ρ</span><span> </span><span>ρm</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>τ3''</span><span> </span><span>σ3''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>τ3''</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"τ3'' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ3''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ3'' ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fst τ3'' = fst ρ ∧ fst σ3'' = lst_conv ρ ∧ lst τ3'' = lst σ3'' ∧
    set_mset (measure r (τ3'', σ3'')) ⊆ dm r {#fst α_step, fst β_step#}"</span></span></span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels σ3'') ⊆ ds r {fst α_step, fst β_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>insert_commute</span><span> </span><span>lexmax_set</span><span> </span><span>subsetD</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (labels τ3'') ⊆ ds r {fst β_step, fst α_step}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dm_def</span><span> </span><span>measure_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>insert_commute</span><span> </span><span>lexmax_set</span><span> </span><span>subsetD</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ1_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s, [β_step]) = fst σ1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>τ1_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst (s, [α_step]) = fst τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onetwo1</span><span> </span><span>onetwo2</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" lst τ3'' = lst σ3''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst σ3' = fst σ3''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>τ_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst τ3' = fst τ3''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>eq1</span><span> </span><span>eq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ3'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(fst σ3',snd σ3'@snd σ3'') ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?σ3 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>σ3''</span><span> </span><span>σ_eq</span><span class="delimiter">]</span><span> </span><span>sigmas</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τ3'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(fst τ3',snd τ3'@snd τ3'') ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ3 ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>τ3''</span><span> </span><span>τ_eq</span><span class="delimiter">]</span><span> </span><span>taus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?σ3 = lst σ2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?τ3 = lst τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onetwo1</span><span> </span><span>onetwo2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lst ?σ3 = lst ?τ3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqn</span><span> </span><span>σ3''</span><span> </span><span>σ3'</span><span> </span><span>σ_eq</span><span> </span><span>τ3''</span><span> </span><span>τ_eq</span><span> </span><span>τ3'</span><span> </span><span>seq_chop</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_diagram1 ars (s, [β_step]) (s, [α_step]) σ1 σ2 (fst σ3', snd σ3' @ snd σ3'')"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigmas</span><span> </span><span>σ3'</span><span> </span><span>onetwo1</span><span> </span><span>σ1_eq</span><span> </span><span>LT</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_diagram1_def</span><span>  </span><span>LT_def</span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_diagram1 ars (s,[α_step]) (s,[β_step]) τ1 τ2 (fst τ3',snd τ3'@snd τ3'')"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>taus</span><span> </span><span>τ3'</span><span> </span><span>onetwo2</span><span> </span><span>τ1_eq</span><span> </span><span>LT</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_diagram1_def</span><span> </span><span>LT_def</span><span> </span><span>LT1_def</span><span> </span><span>local_triangle1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_1' r (hd (labels (s, [β_step]))) (hd (labels (s, [α_step]))) (labels σ1) (labels σ2) (labels (fst σ3', snd σ3' @ snd σ3''))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onetwo1</span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_1'_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_1' r (hd (labels (s, [α_step]))) (hd (labels (s, [β_step]))) (labels τ1) (labels τ2) (labels (fst τ3', snd τ3' @ snd τ3''))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onetwo2</span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_1'_def</span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LDD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LDD ars r ((s,[β_step]),(s,[α_step]),σ1,σ2,?σ3,τ1,τ2,?τ3)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lst</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LDD_def</span><span> </span><span>LDD1_def</span><span> </span><span>local_diagram1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LDD_imp_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>LDD</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LT_imp_D</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. (local_peak ars p ⟶ (∃ γ1 γ2 γ3 δ1 δ2 δ3. LT ars r (fst p,snd p,γ1,γ2,γ3,δ1,δ2,δ3)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ σ' τ'. DD ars r (fst P,snd P,σ',τ'))"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>acyclic_irrefl</span><span> </span><span>trancl_id</span><span> </span><span>wf_acyclic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (pex r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>wf_induct_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>τ</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decompose</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P = (τ,σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"τ ∈ seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sigma</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"σ ∈ seq ars"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst τ = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sigma_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst σ = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd τ"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mirror_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>trivial_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sigma</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>sigma_s</span><span> </span><span>Nil</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>β_step</span><span> </span><span>υ_step</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ = (s,[β_step]@υ_step)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tau2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" (s,[β_step]@υ_step) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trivial_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau_s</span><span> </span><span>sigma_s</span><span> </span><span>Nil</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>DD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>α_step</span><span> </span><span>ρ_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma_dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (s,[α_step]@ρ_step)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma_s</span><span> </span><span>surjective_pairing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sigma2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[α_step]@ρ_step) ∈ seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sigma</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alpha</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[α_step]) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?α ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rho</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (s,[α_step]),ρ_step) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ρ ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sigma2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>alpha'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,fst α_step, snd α_step) ∈ ars"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_tail1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>beta</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s,[β_step]) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?β ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst (s,[β_step]),υ_step) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?υ ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_chop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tau2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"local_peak ars (?β,?α)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha</span><span> </span><span>beta</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>local_peak_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* difference begin*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>γ1</span><span> </span><span>γ2</span><span> </span><span>γ3</span><span> </span><span>δ1</span><span> </span><span>δ2</span><span> </span><span>δ3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>LT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LT ars r (?β, ?α, γ1, γ2, γ3, δ1, δ2, δ3)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P = ((s,[β_step]@υ_step),(s,[α_step]@ρ_step))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P = ?P"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tau_dec</span><span> </span><span>sigma_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>κ</span><span> </span><span>μ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"DD ars r (?β,?α,κ,μ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LT_imp_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t</span><span> </span><span>i</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>LT</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*difference end*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>kappa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"κ∈seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"μ∈seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_IH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" peak ars (?υ,κ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>upsilon</span><span> </span><span>kappa</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>beta_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?β ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r (labels ?β) (labels ?α) (labels κ) (labels μ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"((?υ,κ), (τ,?α)) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_6</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>beta_ne</span><span> </span><span>dec</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span>labels_def</span><span> </span><span>tau_dec</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_commute</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lexmax r (labels τ) + lexmax r (labels (?α)), lexmax r (labels τ) + lexmax r (labels σ)) ∈ mul_eq r"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?l,?r) ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma_dec</span><span> </span><span>labels_def</span><span> </span><span>snd_conv</span><span> </span><span>list.map</span><span> </span><span>lexmax.simps</span><span> </span><span>diff_from_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lemma2_6_2_a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((?υ,κ),P) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sigma_s</span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mul_and_mul_eq_imp_mul</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>κ'</span><span> </span><span>υ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (?υ,κ,κ',υ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P_IH1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>kappa'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"κ'∈seq ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upsilon'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"υ'∈seq ars"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tau'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst μ,snd μ@(snd υ')) ∈ seq ars"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ' ∈ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_concat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mu</span><span> </span><span>upsilon'</span><span class="delimiter">]</span><span> </span><span>D</span><span> </span><span>IH1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DIH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (τ,?α,κ',?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5_DD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>D</span><span> </span><span>IH1</span><span class="delimiter">]</span><span> </span><span>tau_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>dec_dih1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D r (labels τ) (labels ?α) (labels κ') (labels ?τ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DIH1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>D2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_IH2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"peak ars (?τ',?ρ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tau'</span><span> </span><span>rho</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DD_def</span><span> </span><span>diagram_def</span><span> </span><span>peak_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alpha_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels ?α ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((?τ',?ρ),P) ∈ pex r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_6_v</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>alpha_ne</span><span> </span><span>dec_dih1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pex_def</span><span> </span><span>measure_def</span><span> </span><span>decompose</span><span> </span><span>labels_def</span><span> </span><span>sigma_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ρ'</span><span> </span><span>τ''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IH2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DD ars r (?τ',?ρ,ρ',τ'')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P_IH2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lemma3_5_DD_v</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span>DIH1</span><span> </span><span>IH2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decompose</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>sigma_dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LD_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b set ⇒ 'a rel ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_conv L ars = (∃ (r:: ('b rel)) (lrs::('a,'b) lars). (ars = unlabel lrs) ∧ trans r ∧ wf r ∧ (∀p. (local_peak lrs p ⟶ (∃ γ1 γ2 γ3 δ1 δ2 δ3. LT lrs r (fst p,snd p,γ1,γ2,γ3,δ1,δ2,δ3)))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sound_conv</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LD_conv L ars"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR ars"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>LT_imp_D</span><span> </span><span>D_imp_CR</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LD_conv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>D</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>measure</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>split</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>