<div id="Irreducible">
<div class="head">
<h1>Theory Irreducible</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:    Irreducible.thy
    Author:   Max Wagner
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Minimality under Irreducible Control Flow›</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Braun~et~al.~\cite{braun13cc} provide an extension to the original construction algorithm to ensure
minimality according to Cytron's definition even in the case of irreducible control flow. This extension
establishes the property of being \emph{redundant-scc-free}, i.e.\ the resulting graph $G$ contains no
subsets inducing a strongly connected subgraph $G'$ via \pf s such that $G'$ has less than two
$\phi$ arguments in $G\setminus G'$. In this section we will show that a graph with this property is Cytron-minimal.

Our formalization follows the proof sketch given in \cite{braun13cc}.
We first provide a formal proof of Lemma 1 from \cite{braun13cc} which states that every redundant set of \pf s contains at least one redundant SCC.
A redundant set of \pf s is a set $P$ of \pf s with $P \cup \{v\} \supseteq A$, where $A$ is the union over all \pf s arguments contained in $P$.
I.e.\ $P$ references at most one SSA value ($v$) outside $P$.
A redundant SCC is a redundant set that is strongly connected according to the \emph{is-argument} relation.

Next, we show that a CFG in SSA form without redundant sets of \pf s is Cytron-minimal.

Finally putting those results together, we conclude that the extension to Braun~et~al.'s algorithm always produces minimal SSA form.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Irreducible
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../Formal_SSA/Minimality.html">Formal_SSA.Minimality</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> CFG_SSA_Transformed
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proof of Lemma 1 from Braun~et~al.›</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹To preserve readability, we won't distinguish between graph nodes and the \pf s contained inside such a node.›</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The graph induced by the $\phi$ network contained in the vertex set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Note that the edges
of this graph are not necessarily a subset of the edges of the input graph.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">induced_phi_graph</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">φ</span><span class="main">,</span><span class="bound">φ'</span><span class="main">)</span><span class="main">.</span> phiArg <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">φ</span> <span class="bound">φ'</span><span class="main">}</span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">×</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹For the purposes of this section, we define a "redundant set" as a nonempty set of \pf s with
at most one $\phi$ argument outside itself. A redundant SCC is defined analogously. Note that since
any uses of values in a redundant set can be replaced by uses of its singular argument (without
modifying program semantics), the name is adequate.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">redundant_set</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">⊆</span> dom <span class="main">(</span>phi <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v'</span> <span class="main">∈</span> allVars <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ'</span><span class="main">.</span> phiArg <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">φ</span> <span class="bound">φ'</span> <span class="main">⟶</span> <span class="bound">φ'</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">redundant_scc</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span> <span class="main">≡</span> redundant_set <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span> <span class="main">∧</span> is_scc <span class="main">(</span>induced_phi_graph <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span>"</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We prove an important lemma via condensation graphs of $\phi$ networks, so the relevant definitions are introduced here.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">condensation_nodes</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">condensation_edges</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>scc_of <span class="main">(</span>induced_phi_graph <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="bound">x</span><span class="main">,</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>induced_phi_graph <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> Id"</span></span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹For a finite <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the condensation graph induced by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finite and acyclic.›</span></span>

<span class="keyword1" id="Irreducible-condensation_finite"><span class="command">lemma</span></span> condensation_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The set of edges of the condensation graph, spanning at most all $\phi$ nodes and their arguments (both of which are finite sets), is finite itself.›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?phiEdges</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?phiEdges</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?phiDomRan</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">(</span>dom <span class="main">(</span>phi <span class="free">g</span><span class="main">)</span> <span class="main">×</span> <span class="main">⋃</span> <span class="main">(</span>set <span class="main">`</span> <span class="main">(</span>ran <span class="main">(</span>phi <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> phi_finite
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?phiDomRan</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imageE phi_finite map_dom_ran_finite<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?phiEdges</span> <span class="main">⊆</span> <span class="var">?phiDomRan</span>"</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subst<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> <span class="var">?phiEdges</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="var">?phiDomRan</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> phiArg_def<span class="main">)</span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹finite <span class="var">?phiDomRan</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?phiEdges</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Finite_Set.rev_finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> finite <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> <span class="main">(</span><span class="var">?phiEdges</span> <span class="main">∩</span> <span class="main">(</span><span class="free">P</span> <span class="main">×</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def induced_phi_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹auxiliary lemmas for acyclicity›</span></span>

<span class="keyword1" id="Irreducible-condensation_nodes_edges"><span class="command">lemma</span></span> condensation_nodes_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>condensation_nodes <span class="free">g</span> <span class="free">P</span> <span class="main">×</span> condensation_nodes <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def condensation_nodes_def induced_phi_graph_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1" id="Irreducible-condensation_edge_impl_path"><span class="command">lemma</span></span> condensation_edge_impl_path<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">∈</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> x_y_props<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">y</span>"</span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹All that's left is to combine these paths.›</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span> x_y_props<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> is_scc_connected scc_of_is_scc<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> assms<span class="main">(</span>3<span class="main">)</span> x_y_props<span class="main">(</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">b</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> is_scc_connected scc_of_is_scc<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_y_props<span class="main">(</span>1<span class="main">)</span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Irreducible-path_in_condensation_impl_path"><span class="command">lemma</span></span> path_in_condensation_impl_path<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">∈</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">φ<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>trancl_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> condensation_edges <span class="free">g</span> <span class="free">P</span>"</span></span>

  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_scc <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>y</sub></span><span class="main">.</span> <span class="bound">φ<span class="hidden">⇩</span><sub>y</sub></span> <span class="main">∈</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> scc_non_empty' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>y</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> φ<span class="hidden">⇩</span><sub>y</sub>_in_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>y</sub></span> <span class="main">∈</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">assume</span></span> φ<span class="hidden">⇩</span><sub>b</sub>_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="skolem">z</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">.</span> <span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">∈</span> <span class="free">a</span> <span class="main">⟹</span> <span class="bound">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="skolem">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="bound">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span> φ<span class="hidden">⇩</span><sub>y</sub>_in_y
  <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>a</sub>_to_φ<span class="hidden">⇩</span><sub>y</sub><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>y</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> condensation_edge_impl_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> φ<span class="hidden">⇩</span><sub>b</sub>_elem φ<span class="hidden">⇩</span><sub>y</sub>_in_y <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> condensation_edges <span class="free">g</span> <span class="free">P</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">φ<span class="hidden">⇩</span><sub>y</sub></span><span class="main">,</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> condensation_edge_impl_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> φ<span class="hidden">⇩</span><sub>a</sub>_to_φ<span class="hidden">⇩</span><sub>y</sub>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">φ<span class="hidden">⇩</span><sub>a</sub></span><span class="main">,</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>condensation_edge_impl_path<span class="main">)</span>


<span class="keyword1" id="Irreducible-condensation_acyclic"><span class="command">lemma</span></span> condensation_acyclic<span class="main">:</span> <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> acyclicI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Assume there is a cycle in the condensation graph.›</span></span>
  <span class="keyword3"><span class="command">assume</span></span> cyclic<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> nonrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Then there must be a second SCC <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span> on this path.›</span></span>
  <span class="keyword1"><span class="command">from</span></span> this cyclic
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> b_on_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> converse_tranclE<span class="main">)</span>

  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>condensation_nodes <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="main">(</span>condensation_nodes <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> condensation_nodes_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> nodes_are_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"is_scc <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"is_scc <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> scc_of_is_scc <span class="keyword1"><span class="command">unfolding</span></span> induced_phi_graph_def condensation_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹However, the existence of this path means all nodes in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are mutually reachable.›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>x</sub></span><span class="main">.</span> <span class="bound">φ<span class="hidden">⇩</span><sub>x</sub></span> <span class="main">∈</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>b</sub></span><span class="main">.</span> <span class="bound">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nodes_are_scc scc_non_empty' ex_in_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>x</sub></span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> φxb_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>x</sub></span> <span class="main">∈</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">with</span></span> nodes_are_scc<span class="main">(</span>1<span class="main">)</span> b_on_path path_in_condensation_impl_path condensation_edge_impl_path φxb_elem<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>b</sub></span> <span class="main">∈</span> <span class="skolem">x</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> is_scc_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹This however means <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be the same SCC, which is a contradiction to the nonreflexivity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">condensation_edges</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">with</span></span> nodes_are_scc φxb_elem
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> is_scc_unique<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"induced_phi_graph <span class="free">g</span> <span class="free">P</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> b_on_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> nonrefl
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Since the condensation graph of a set is acyclic and finite, it must have a leaf.›</span></span>
<span class="keyword1" id="Irreducible-Ex_condensation_leaf"><span class="command">lemma</span></span> Ex_condensation_leaf<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">leaf</span><span class="main">.</span> <span class="bound">leaf</span> <span class="main">∈</span> <span class="main">(</span>condensation_nodes <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">scc</span><span class="main">.</span><span class="main">(</span><span class="bound">leaf</span><span class="main">,</span> <span class="bound">scc</span><span class="main">)</span> <span class="main">∉</span> condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> wfE_min<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> condensation_finite condensation_acyclic
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span><span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_acyclic_wf_converse<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">leaf</span>
    <span class="keyword3"><span class="command">assume</span></span> leaf_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">leaf</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword3"><span class="command">assume</span></span> leaf_is_leaf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">scc</span> <span class="main">∉</span> condensation_nodes <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">scc</span><span class="main">,</span> <span class="skolem">leaf</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main">¯</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">scc</span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">leaf</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">scc</span><span class="main">.</span> <span class="main">(</span><span class="skolem">leaf</span><span class="main">,</span> <span class="bound">scc</span><span class="main">)</span> <span class="main">∉</span> condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> condensation_nodes_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">leaf</span><span class="main">.</span> <span class="bound">leaf</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">scc</span><span class="main">.</span> <span class="main">(</span><span class="bound">leaf</span><span class="main">,</span> <span class="bound">scc</span><span class="main">)</span> <span class="main">∉</span> condensation_edges <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Irreducible-scc_in_P"><span class="command">lemma</span></span> scc_in_P<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">⊆</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">⊆</span> <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> y_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">=</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> y_props
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">⊆</span> <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>y_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="improper">x</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> different<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">n</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_scc_connected scc_of_is_scc node_in_scc_of_node<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> different
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtranclD<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> tranclE<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> step
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> induced_phi_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> this assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> x_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> imageE<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">scc</span></span> <span class="quoted"><span class="quoted">"scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> condensation_nodes_def x_node <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Irreducible-redundant_scc_phis"><span class="command">lemma</span></span> redundant_scc_phis<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"redundant_set <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∈</span> condensation_nodes <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"phi <span class="free">g</span> <span class="free">x</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> domIff redundant_set_def scc_in_P subsetCE<span class="main">)</span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The following lemma will be important for the main proof of this section.
If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is redundant, a leaf in the condensation graph induced by P corresponds to a strongly connected set
with at most one argument, thus a redundant strongly connected set exists.›</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Lemma 1. Every redundant set contains a redundant SCC.›</span></span>

<span class="keyword1" id="Irreducible-1"><span class="command">lemma</span></span> 1<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"redundant_set <span class="free">g</span> <span class="free">P</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">scc</span></span> <span class="main">⊆</span> <span class="free">P</span><span class="main">.</span> redundant_scc <span class="free">g</span> <span class="free">P</span> <span class="bound">scc</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms Ex_condensation_leaf<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">leaf</span></span> <span class="keyword2"><span class="keyword">where</span></span> leaf_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">leaf</span> <span class="main">∈</span> <span class="main">(</span>condensation_nodes <span class="free">g</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">scc</span><span class="main">.</span> <span class="main">(</span><span class="skolem">leaf</span><span class="main">,</span> <span class="bound">scc</span><span class="main">)</span> <span class="main">∉</span> condensation_edges <span class="free">g</span> <span class="free">P</span>"</span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> redundant_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_scc <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">leaf</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">leaf</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> scc_non_empty'<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">leaf</span> <span class="main">⊆</span> dom <span class="main">(</span>phi <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> subset_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ballI<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> redundant_scc_phis leaf_props<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pred</span></span> <span class="keyword2"><span class="keyword">where</span></span> pred_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pred</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">φ</span><span class="main">∈</span><span class="free">P</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ'</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ</span> <span class="bound">φ'</span> <span class="main">⟶</span> <span class="bound">φ'</span> <span class="main">∈</span> <span class="free">P</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> redundant_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Any argument of a \pf\ in the leaf SCC which is \emph{not} in the leaf SCC itself must be the unique argument of P›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">φ</span> <span class="skolem">φ'</span>

    <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>in_P<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∉</span> <span class="skolem">leaf</span> <span class="main">∧</span> <span class="skolem">φ'</span> <span class="main">∈</span> <span class="free">P</span>"</span></span> <span class="main">|</span> <span class="main">(</span>neither<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∉</span> <span class="skolem">leaf</span> <span class="main">∧</span> <span class="skolem">φ'</span> <span class="main">∉</span> <span class="free">P</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∉</span> <span class="skolem">leaf</span> <span class="main">∧</span> <span class="skolem">φ'</span> <span class="main">∈</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∈</span> <span class="skolem">leaf</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∈</span> <span class="skolem">leaf</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ</span> <span class="main">∈</span> <span class="skolem">leaf</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="skolem">φ</span> <span class="skolem">φ'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">case</span></span> in_P <span class="comment1">― ‹In this case <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">leaf</span></span><span class="antiquote">}</span></span> wasn't really a leaf, a contradiction›</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> in_P that leaf_props<span class="main">(</span>1<span class="main">)</span> scc_in_P<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">leaf</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">P</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">φ</span><span class="main">,</span> <span class="skolem">φ'</span><span class="main">)</span> <span class="main">∈</span> induced_phi_graph <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> induced_phi_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">leaf</span><span class="main">,</span> scc_of <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">φ'</span><span class="main">)</span> <span class="main">∈</span> condensation_edges <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> condensation_edges_def
       <span class="keyword1"><span class="command">using</span></span> leaf_props<span class="main">(</span>1<span class="main">)</span> that <span class="quoted"><span class="quoted">‹is_scc <span class="main">(</span>induced_phi_graph <span class="free">g</span> <span class="free">P</span><span class="main">)</span> <span class="skolem">leaf</span>›</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> condensation_nodes_def
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> is_scc_unique node_in_scc_of_node pair_imageI scc_of_is_scc<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> leaf_props<span class="main">(</span>2<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> neither <span class="comment1">― ‹In which case <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">P</span></span><span class="antiquote">}</span></span> itself wasn't redundant, a contradiction›</span>
      <span class="keyword1"><span class="command">with</span></span> that leaf_props pred_props
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>redundant_set <span class="free">g</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> redundant_set_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> rev_subsetD scc_in_P<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span> <span class="comment1">― ‹the other cases are trivial›</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> pred_props<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v'</span><span class="main">∈</span>allVars <span class="free">g</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ</span><span class="main">∈</span><span class="skolem">leaf</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ'</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ</span> <span class="bound">φ'</span> <span class="main">⟶</span> <span class="bound">φ'</span> <span class="main">∈</span> <span class="skolem">leaf</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">v'</span><span class="main">}</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"redundant_scc <span class="free">g</span> <span class="free">P</span> <span class="skolem">leaf</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> redundant_scc_def redundant_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> leaf_props<span class="main">(</span>1<span class="main">)</span> scc_in_P <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proof of Minimality›</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We inductively define the reachable-set of a \pf\ as all \pf s reachable from a given node via an
unbroken chain of $\phi$ argument edges to unnecessary \pf s.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">reachable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'val</span> <span class="main">⇒</span> <span class="tfree">'val</span> set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">φ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'val</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> refl<span class="main">:</span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="free">φ</span> <span class="main">⟹</span> <span class="free">φ</span> <span class="main">∈</span> <span class="free">reachable</span> <span class="free">g</span> <span class="free">φ</span>"</span></span>
  <span class="main">|</span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">φ'</span></span></span> <span class="main">∈</span> <span class="free">reachable</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">⟹</span> phiArg <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">φ'</span></span></span> <span class="free"><span class="bound"><span class="entity">φ''</span></span></span> <span class="main">⟹</span> unnecessaryPhi <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">φ''</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">φ''</span></span></span> <span class="main">∈</span> <span class="free">reachable</span> <span class="free">g</span> <span class="free">φ</span>"</span></span>


<span class="keyword1" id="Irreducible-reachable_props"><span class="command">lemma</span></span> reachable_props<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ'</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">φ</span> <span class="free">φ'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="free">φ'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable.induct<span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We call the transitive arguments of a \pf\ not in its reachable-set the "true arguments" of this \pf.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">trueArgs</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="bound">φ'</span> <span class="main">∉</span> reachable <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ''</span> <span class="main">∈</span> reachable <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">.</span> phiArg <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">φ''</span> <span class="bound">φ'</span><span class="main">}</span>"</span></span>


<span class="keyword1" id="Irreducible-preds_finite"><span class="command">lemma</span></span> preds_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>trueArgs <span class="free">g</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>trueArgs <span class="free">g</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"infinite <span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ''</span> <span class="bound">φ'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> phiarg_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ</span> <span class="bound">φ'</span><span class="main">}</span> <span class="main">=</span> <span class="main">⋃</span> <span class="main">(</span>set <span class="main">`</span><span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span><span class="main">.</span> phi <span class="free">g</span> <span class="bound">a</span> <span class="main">=</span> Some <span class="bound">b</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> phiArg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the true arguments of a \pf\ are infinite in number, there must be an infinite number of \pf s\ldots›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ</span> <span class="bound">φ'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> infinite_super<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ''</span> <span class="bound">φ'</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> phiarg_set
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>ran <span class="main">(</span>phi <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ran_def phiArg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Which cannot be.›</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>phi_finite map_dom_ran_finite<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Any unnecessary $\phi$ with less than 2 true arguments induces with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free"><span class="free">g</span></span> <span class="free"><span class="free">φ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> a redundant set itself.›</span></span>

<span class="keyword1" id="Irreducible-few_preds_redundant"><span class="command">lemma</span></span> few_preds_redundant<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>trueArgs <span class="free">g</span> <span class="free">φ</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span>"</span></span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="free">φ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"redundant_set <span class="free">g</span> <span class="main">(</span>reachable <span class="free">g</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> redundant_set_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free">g</span> <span class="free">φ</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> empty_iff reachable.intros<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free">g</span> <span class="free">φ</span> <span class="main">⊆</span> dom <span class="main">(</span>phi <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> domIff reachable.cases subsetI unnecessaryPhi_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>single<span class="main">)</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>trueArgs <span class="free">g</span> <span class="free">φ</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span> <span class="main">(</span>empty<span class="main">)</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>trueArgs <span class="free">g</span> <span class="free">φ</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">pred</span><span class="main">∈</span>allVars <span class="free">g</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ'</span><span class="main">∈</span>reachable <span class="free">g</span> <span class="free">φ</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ''</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ'</span> <span class="bound">φ''</span> <span class="main">⟶</span> <span class="bound">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">pred</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> single
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pred</span></span> <span class="keyword2"><span class="keyword">where</span></span> pred_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"trueArgs <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_eq_1_singleton <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pred</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Int_Collect phiArg_in_allVars<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> pred_prop
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">φ'</span><span class="main">∈</span>reachable <span class="free">g</span> <span class="free">φ</span><span class="main">.</span> <span class="main">∀</span><span class="bound">φ''</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ'</span> <span class="bound">φ''</span> <span class="main">⟶</span> <span class="bound">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">pred</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">from</span></span> allDefs_in_allVars<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ</span>"</span></span><span class="main">]</span> assms
    <span class="keyword1"><span class="command">have</span></span> phi_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> unnecessaryPhi_def phiDefs_def allDefs_def defNode_def phi_def trueArgs_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> domIff phis_in_αn<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> empty assms<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> no_preds<span class="main">:</span> <span class="quoted"><span class="quoted">"trueArgs <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> card_0_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> preds_finite<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ballI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> impI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">φ'</span> <span class="skolem">φ''</span>
      <span class="keyword3"><span class="command">assume</span></span> phis_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span> <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="skolem">φ'</span> <span class="skolem">φ''</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> no_preds
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> trueArgs_def
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> phis_props
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ''</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">φ'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ''</span><span class="main">∈</span>reachable <span class="free">g</span> <span class="free">φ</span><span class="main">.</span> phiArg <span class="free">g</span> <span class="bound">φ''</span> <span class="bound">φ'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> phis_props no_preds
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> trueArgs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ''</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span> <span class="main">∪</span> <span class="main">{</span><span class="free">φ</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phi_var<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Irreducible-phiArg_trancl_same_var"><span class="command">lemma</span></span> phiArg_trancl_same_var<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup><span class="hidden">⇧</span><sup>+</sup></span> <span class="free">φ</span> <span class="free">n</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="free">var</span> <span class="free">g</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tranclp_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_same_var<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
 <span class="keyword1"><span class="command">using</span></span> phiArg_same_var <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The following path extension lemma will be used a number of times in the inner induction of the
main proof. Basically, the idea is to extend a path ending in a $\phi$ argument to the corresponding \pf\ 
while preserving disjointness to a second path.›</span></span>

<span class="keyword1" id="Irreducible-phiArg_disjoint_paths_extend"><span class="command">lemma</span></span> phiArg_disjoint_paths_extend<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> <span class="free">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">s</span> <span class="main">=</span> <span class="free">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">∈</span> <span class="free">oldDefs</span> <span class="free">g</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">∈</span> <span class="free">oldDefs</span> <span class="free">g</span> <span class="free">m</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span><span class="main">-</span><span class="free">ns</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">m</span><span class="main">-</span><span class="free">ms</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ns</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">r</span>"</span></span>
<span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">ns'</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span><span class="main">-</span><span class="free">ns</span><span class="main">@</span><span class="free">ns'</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span><span class="main">@</span><span class="free">ns'</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>True<span class="main">)</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the node to extend the path to is already the endpoint, the lemma is trivial.›</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>7<span class="main">,</span>8<span class="main">,</span>9<span class="main">)</span> in_set_butlastD
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span><span class="main">-</span><span class="free">ns</span><span class="main">@</span><span class="main">[]</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span><span class="main">@</span><span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹It suffices to obtain any path from r to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
     However, since we'll need the corresponding predecessor of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> later, we must do this as follows:›</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>10<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> phiArg_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> allDefs_in_allVars phiDefs_in_allDefs phi_def phi_phiDefs phis_in_αn<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>10<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">rs'</span></span> <span class="skolem"><span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> rs'_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> defNode <span class="free">g</span> <span class="free">r</span><span class="main">-</span><span class="skolem">rs'</span><span class="main">→</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"old.EntryPath <span class="free">g</span> <span class="skolem">rs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> phiUses <span class="free">g</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> set <span class="main">(</span>old.predecessors <span class="free">g</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_path_ex'<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rs</span> <span class="main">=</span> <span class="skolem">rs'</span><span class="main">@</span><span class="main">[</span>defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> rs'_props<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span> old.EntryPath_distinct old.path2_hd
  <span class="keyword1"><span class="command">have</span></span> rs'_loopfree<span class="main">:</span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∉</span> set <span class="main">(</span>tl <span class="skolem">rs'</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Misc.distinct_hd_tl<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> False assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">r</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_distinct_nodes<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>phiArg_in_allVars<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> phiArg_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> allDefs_in_allVars phiDefs_in_allDefs phi_def phi_phiDefs phis_in_αn<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> rs'_props
  <span class="keyword1"><span class="command">have</span></span> rs_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> defNode <span class="free">g</span> <span class="free">r</span><span class="main">-</span><span class="skolem">rs</span><span class="main">→</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">rs</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∉</span> set <span class="main">(</span>tl <span class="skolem">rs</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> hd <span class="skolem">rs'</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2 <span class="keyword1"><span class="command">using</span></span> rs'_props<span class="main">(</span>1<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> old.path2_hd<span class="main">)</span>
     <span class="keyword1"><span class="command">using</span></span> old.path2_snoc old.path2_def rs'_props<span class="main">(</span>1<span class="main">)</span> rs_def rs'_loopfree <span class="quoted"><span class="quoted">‹defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">rs</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> inter_empty<span class="main">:</span> True
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the intersection of these is empty, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tl <span class="skolem"><span class="skolem">rs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is already the extension we're looking for›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ex_in_conv<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ms</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> rs_props<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>in_ns<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ns</span>"</span></span> <span class="main">|</span> <span class="main">(</span>in_rs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span>tl <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff butlast_append in_set_butlastD set_append<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> x_props<span class="main">(</span>2<span class="main">)</span> assms<span class="main">(</span>9<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjoint_elem<span class="main">)</span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> x_props<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> inter_empty in_set_tlD List.butlast_tl disjoint_iff_not_equal<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>assms<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> rs_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> old.path2_app<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> inter_ex<span class="main">:</span> False
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the intersection is nonempty, there must be a first point of intersection <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command">from</span></span> inter_ex assms<span class="main">(</span>7<span class="main">,</span>8<span class="main">)</span> rs_props
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">ri</span></span> <span class="keyword2"><span class="keyword">where</span></span> ri_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> defNode <span class="free">g</span> <span class="free">r</span><span class="main">-</span><span class="skolem">ri</span><span class="main">→</span><span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> set <span class="free">ms</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="skolem">ri</span><span class="main">)</span><span class="main">.</span> <span class="bound">n</span> <span class="main">∉</span> set <span class="free">ms</span>"</span></span> <span class="quoted"><span class="quoted">"prefix <span class="skolem">ri</span> <span class="skolem">rs</span>"</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> old.path2_split_first_prop<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="skolem">rs</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span> <span class="main">∈</span> set <span class="free">ms</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal in_set_butlastD<span class="main">)</span>
     <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>8<span class="main">)</span> old.path2_prefix_ex
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ms'</span></span> <span class="keyword2"><span class="keyword">where</span></span> ms'_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">m</span> <span class="main">-</span><span class="skolem">ms'</span><span class="main">→</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"prefix <span class="skolem">ms'</span> <span class="free">ms</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∉</span> set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We proceed by case distinction:
      <span class="antiquoted"><span class="antiquoted">▪</span></span> if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">i</span></span> <span class="main"><span class="main">=</span></span> defNode <span class="free"><span class="free">g</span></span> <span class="free"><span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the path <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ri</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is already the path extension we're looking for
      <span class="antiquoted"><span class="antiquoted">▪</span></span> Otherwise, the fact that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is on the path from $\phi$ argument to the $\phi$ itself leads to a contradiction.
        However, we still need to distinguish the cases of whether <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m</span></span> <span class="main"><span class="main">=</span></span> <span class="skolem"><span class="skolem">i</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
    <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>ri_is_valid<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="main">|</span> <span class="main">(</span>m_i_same<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span> <span class="main">|</span> <span class="main">(</span>m_i_differ<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="free">thesis</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> ri_is_valid
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ri</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a valid path extension.›</span></span>
      <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>7<span class="main">)</span> ri_props<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span> <span class="main">-</span><span class="free">ns</span><span class="main">@</span><span class="main">(</span>tl <span class="skolem">ri</span><span class="main">)</span><span class="main">→</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span><span class="main">@</span><span class="main">(</span>tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> contr<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> this
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ms</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>9<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> x_props <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span><span class="main">-</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span>›</span></span> <span class="quoted"><span class="quoted">‹defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">r</span>›</span></span> assms<span class="main">(</span>7<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span>tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span>"</span></span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff append_Nil2 butlast_append old.path2_last set_append<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> x_props<span class="main">(</span>2<span class="main">)</span> ri_props<span class="main">(</span>3<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> FormalSSA_Misc.in_set_tlD List.butlast_tl<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> m_i_same
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m</span></span> <span class="main"><span class="main">=</span></span> <span class="skolem"><span class="skolem">i</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we have, with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, a variable definition on the path from a \pf\ to its argument.
          This constitutes a contradiction to the conventional property.›</span></span>
      <span class="keyword1"><span class="command">note</span></span> rs'_props<span class="main">(</span>1<span class="main">)</span> rs'_loopfree
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> allDefs <span class="free">g</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> rs'_props<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> allUses <span class="free">g</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> allUses_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> rs_props<span class="main">(</span>1<span class="main">)</span> m_i_same rs_def ri_props<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">r</span>›</span></span> assms<span class="main">(</span>7<span class="main">,</span>9<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="skolem">rs'</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_elem hd_append in_hd_or_tl_conv in_prefix list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> old.path2_hd old.path2_last old.path2_last_in_ns prefix_snoc<span class="main">)</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>6<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">def<span class="hidden">⇩</span><sub>m</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">def<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">∈</span> allDefs <span class="free">g</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">def<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="free">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> oldDefs_def <span class="keyword1"><span class="command">using</span></span> defs_in_allDefs <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">def<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">≠</span> <span class="free">var</span> <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> conventional<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">var</span> <span class="free">g</span> <span class="skolem">def<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="free">V</span>›</span></span> assms<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> m_i_differ
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m</span></span> <span class="main"><span class="main">≠</span></span> <span class="skolem"><span class="skolem">i</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constitutes a proper path convergence point.›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="free">m</span> <span class="skolem">ms'</span> <span class="free">n</span> <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> old.pathsConvergeI<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">ms'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m_i_differ ms'_props old.path2_nontriv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ri_props old.path2_nontriv assms<span class="main">(</span>9<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> disjoint_elem old.path2_app old.path2_hd_in_ns<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> i'_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="free">ns</span> <span class="main">@</span> tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> ms'_props<span class="main">(</span>2<span class="main">)</span>
          <span class="keyword1"><span class="command">have</span></span> i'_not_in_ms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="free">ms</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_butlast_appendI prefixE<span class="main">)</span>

          <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>9<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∉</span> set <span class="free">ns</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">with</span></span> i'_props<span class="main">(</span>2<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span>tl <span class="skolem">ri</span><span class="main">)</span><span class="main">)</span>"</span></span>
             <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff butlast_append in_set_butlastD set_append<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="skolem">ri</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>in_set_tlD List.butlast_tl<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> i'_not_in_ms ri_props<span class="main">(</span>3<span class="main">)</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>in_set_butlastD<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">meson</span> disjoint_elem in_set_butlastD<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> ri_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> old.path2_app ms'_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹At this intersection of paths we can find a \pf.›</span></span>
      <span class="keyword1"><span class="command">from</span></span> this assms<span class="main">(</span>6<span class="main">,</span>5<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"necessaryPhi <span class="free">g</span> <span class="free">V</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> necessaryPhiI<span class="main">)</span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Before we can conclude that there is indeed a $\phi$ at <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we have to prove a couple of technicalities\ldots›</span></span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> m_i_differ ri_props<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> rs_def old.path2_last prefix_snoc
      <span class="keyword1"><span class="command">have</span></span> ri_rs'_prefix<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix <span class="skolem">ri</span> <span class="skolem">rs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">rs'_rest</span></span> <span class="keyword2"><span class="keyword">where</span></span> rs'_rest_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rs'</span> <span class="main">=</span> <span class="skolem">ri</span><span class="main">@</span><span class="skolem">rs'_rest</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> prefixE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> old.path2_last<span class="main">[</span><span class="operator">OF</span> ri_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> last_snoc<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">tmp</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ri</span> <span class="main">=</span> <span class="skolem">tmp</span><span class="main">@</span><span class="main">[</span><span class="skolem">i</span><span class="main">]</span>"</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">ri</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
        <span class="keyword1"><span class="command">using</span></span> ri_props<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> old.path2_not_Nil<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> that<span class="main">)</span>
       <span class="keyword1"><span class="command">using</span></span> append_butlast_last_id<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">with</span></span> rs'_rest_prop <span class="keyword1"><span class="command">have</span></span> rs'_rest_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rs'</span> <span class="main">=</span> <span class="skolem">tmp</span><span class="main">@</span><span class="skolem">i</span><span class="main">#</span><span class="skolem">rs'_rest</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> rs'_props<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">i</span> <span class="main">-</span><span class="skolem">i</span><span class="main">#</span><span class="skolem">rs'_rest</span><span class="main">→</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>old.path2_split<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">var</span> <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> <span class="free">V</span>›</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
      <span class="keyword1"><span class="command">from</span></span> rs'_props<span class="main">(</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> allUses <span class="free">g</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> allUses_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∉</span> set <span class="main">(</span>tl <span class="skolem">rs'</span><span class="main">)</span>›</span></span> rs'_rest_def
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∉</span> set <span class="skolem">rs'_rest</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">i</span> <span class="main">-</span><span class="skolem">i</span><span class="main">#</span><span class="skolem">rs'_rest</span><span class="main">→</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="skolem">rs'_rest</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> allDefs <span class="free">g</span> <span class="bound">x</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> defNode_eq list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> list.set_cases old.path2_cases old.path2_in_αn<span class="main">)</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>7<span class="main">,</span>9<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">i</span> <span class="main">-</span><span class="skolem">i</span><span class="main">#</span><span class="skolem">rs'_rest</span><span class="main">→</span> <span class="skolem">pred<span class="hidden">⇩</span><sub>φ</sub><span class="hidden">⇩</span><sub>r</sub></span>›</span></span> ri_props<span class="main">(</span>2<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∉</span> <span class="free">defs</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> defNode_eq defs_in_allDefs disjoint_elem old.path2_hd_in_αn old.path2_last_in_ns<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The convergence property gives us that there is a $\phi$ in the last node fulfilling <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">necessaryPhi</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
          on a path to a use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> without a definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
          Thus <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> bears a \pf\ for the value of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">phis</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Some <span class="bound">y</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> convergence_prop <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">g</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> n<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> v<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> ns<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">#</span><span class="skolem">rs'_rest</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>

      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="free">n</span><span class="main">-</span><span class="free">ns</span><span class="main">→</span>defNode <span class="free">g</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∈</span> set <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹set <span class="free">ns</span> <span class="main">∩</span> set <span class="free">ms</span> <span class="main">=</span> <span class="main">{}</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">∈</span> set <span class="free">ms</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>

      <span class="keyword1"><span class="command">from</span></span> ms'_props<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">αn</span> <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">αn</span> <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹However, we now have two definitions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>: one in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and one in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free"><span class="free">g</span></span> <span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which we know to be distinct.
          This is a contradiction to the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">allDefs_disjoint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-property.›</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">using</span></span> allDefs_disjoint <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">g</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> n<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">r</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> allDefs_def phiDefs_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> equalityCE<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> phi_def phis_phi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Irreducible-reachable_same_var"><span class="command">lemma</span></span> reachable_same_var<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ'</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="free">var</span> <span class="free">g</span> <span class="free">φ'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Nitpick.rtranclp_unfold phiArg_trancl_same_var reachable_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>


<span class="keyword1" id="Irreducible-φ_node_no_defs"><span class="command">lemma</span></span> φ_node_no_defs<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="free">φ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">∈</span> <span class="free">oldDefs</span> <span class="free">g</span> <span class="free">n</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ</span> <span class="main">≠</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms simpleDefs_phiDefs_var_disjoint defNode<span class="main">(</span>1<span class="main">)</span> not_None_eq phi_phiDefs
  <span class="keyword1"><span class="command">unfolding</span></span> unnecessaryPhi_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1" id="Irreducible-defNode_differ_aux"><span class="command">lemma</span></span> defNode_differ_aux<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="free">φ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≠</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="free">var</span> <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> reachable_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">=</span> defNode <span class="free">g</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> vars_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ</span> <span class="main">=</span> <span class="free">var</span> <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">=</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_trancl_same_var<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> reachable_props<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> IntD1 mem_Collect_eq rtranclpD<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>s</sub>_in_allVars<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> reachable_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">=</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="skolem">φ'</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtranclp.cases reachable_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_in_allVars<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> eq<span class="main">:</span> True
    <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">from</span></span> eq φ<span class="hidden">⇩</span><sub>s</sub>_in_allVars assms<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="free">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≠</span> <span class="free">var</span> <span class="free">g</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> defNode_var_disjoint<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> vars_eq assms<span class="main">(</span>5<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Theorem 1. A graph which does not contain any redundant set is minimal according to Cytron et al.'s definition of minimality.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> no_redundant_set_minimal<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> no_redundant_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">P</span><span class="main">.</span> redundant_set <span class="free">g</span> <span class="bound">P</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cytronMinimal <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cytronMinimal <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Assume the graph is not Cytron-minimal. Thus there is a \pf\ which does not sit at the
      convergence point of multiple liveness intervals.›</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ</span></span> <span class="keyword2"><span class="keyword">where</span></span> φ_props<span class="main">:</span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cytronMinimal_def unnecessaryPhi_def reachable_def unnecessaryPhi_def reachable.intros <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We consider the reachable-set of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has less than two true arguments, we
     know it to be a redundant set, a contradiction. Otherwise, we know there to be at least two
     paths from different definitions leading into the reachable-set of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

  <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>nontrivial<span class="main">)</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>trueArgs <span class="free">g</span> <span class="skolem">φ</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span> <span class="main">(</span>trivial<span class="main">)</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>trueArgs <span class="free">g</span> <span class="skolem">φ</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> linorder_not_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> trivial
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If there are less than 2 true arguments of this set, the set is trivially redundant (see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">few_preds_redundant</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).›</span></span>
    <span class="keyword1"><span class="command">from</span></span> this φ_props<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"redundant_set <span class="free">g</span> <span class="main">(</span>reachable <span class="free">g</span> <span class="skolem">φ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> few_preds_redundant<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> no_redundant_set
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> nontrivial
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If there are two or more necessary arguments, there must be disjoint paths from Defs to two of these \pf s.›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> assign_nodes_props<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">≠</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">¬</span> unnecessaryPhi <span class="free">g</span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> unnecessaryPhi <span class="free">g</span> <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="skolem">φ</span> <span class="bound">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="skolem">φ</span> <span class="bound">n</span><span class="main">}</span>"</span></span>
      <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"phiArg <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">s</span>"</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_take_two<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nontrivial<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> reachable.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reachable_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rtranclp_tranclp_tranclp tranclp.r_into_trancl tranclp_into_rtranclp<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> assign_nodes_props
    <span class="keyword1"><span class="command">have</span></span> φ_r_s_uneq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ</span> <span class="main">≠</span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ</span> <span class="main">≠</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> φ_props <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> assign_nodes_props this
    <span class="keyword1"><span class="command">have</span></span> r_s_in_tranclp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup><span class="hidden">⇧</span><sup>+</sup></span> <span class="skolem">φ</span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>phiArg <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup><span class="hidden">⇧</span><sup>+</sup></span> <span class="skolem">φ</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> mem_Collect_eq rtranclpD<span class="main">)</span> <span class="main">(</span><span class="operator">meson</span> assign_nodes_props<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> φ_r_s_uneq<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mem_Collect_eq rtranclpD<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="keyword2"><span class="keyword">where</span></span> V_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">s</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> phiArg_trancl_same_var<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> r_s_in_tranclp
    <span class="keyword1"><span class="command">have</span></span> r_s_allVars<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> phiArg_in_allVars tranclp.cases<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> V_props defNode_var_disjoint r_s_allVars assign_nodes_props<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> r_s_defNode_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="skolem">r</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="skolem"><span class="skolem">ns</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">ms</span></span> <span class="keyword2"><span class="keyword">where</span></span> r_s_path_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">∈</span> <span class="free">oldDefs</span> <span class="free">g</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span><span class="main">-</span><span class="skolem">ns</span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">∈</span> <span class="free">oldDefs</span> <span class="free">g</span> <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span><span class="main">-</span><span class="skolem">ms</span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"set <span class="skolem">ns</span> <span class="main">∩</span> set <span class="skolem">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ununnecessaryPhis_disjoint_paths<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="skolem">r</span></span> <span class="quoted"><span class="skolem">s</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> n_m_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> n_m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> r_s_path_props<span class="main">(</span>2<span class="main">)</span> old.path2_hd_in_ns
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> set <span class="skolem">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> n_m r_s_path_props<span class="main">(</span>4<span class="main">)</span> old.path2_hd_in_ns
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> set <span class="skolem">ms</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> r_s_path_props<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹These paths can be extended into paths reaching \pf s in our set.›</span></span>

    <span class="keyword1"><span class="command">from</span></span> V_props r_s_allVars r_s_path_props assign_nodes_props
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">rs</span></span> <span class="keyword2"><span class="keyword">where</span></span> rs_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="skolem">ms</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> phiArg_disjoint_paths_extend <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹(In fact, we can prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"set <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">ns</span></span><span class="main"><span class="main">@</span></span><span class="skolem"><span class="skolem">rs</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∩</span></span> set <span class="skolem"><span class="skolem">ms</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which we need for the next path extension.)›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∉</span> set <span class="skolem">ms</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> φ<span class="hidden">⇩</span><sub>r</sub>_in_ms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∉</span> set <span class="skolem">ms</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this r_s_path_props<span class="main">(</span>4<span class="main">)</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ms'</span></span> <span class="keyword2"><span class="keyword">where</span></span> ms'_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">ms'</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"prefix <span class="skolem">ms'</span> <span class="skolem">ms</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> old.path2_prefix_ex<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">ms</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="main">(</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">)</span> <span class="skolem">m</span> <span class="skolem">ms'</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> old.pathsConvergeI<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ns</span> <span class="main">@</span> <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ns</span> <span class="main">@</span> <span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> c_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="main">(</span>butlast <span class="skolem">ms'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> ms'_props<span class="main">(</span>2<span class="main">)</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="skolem">ms</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_prefix in_set_butlastD<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> c_props<span class="main">(</span>1<span class="main">)</span> rs_props<span class="main">(</span>2<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword1"><span class="command">have</span></span> m_n_φ<span class="hidden">⇩</span><sub>r</sub>_differ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> assign_nodes_props<span class="main">(</span>2<span class="main">,</span>3<span class="main">,</span>4<span class="main">,</span>5<span class="main">)</span> V_props r_s_path_props φ<span class="hidden">⇩</span><sub>r</sub>_in_ms
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
         <span class="keyword1"><span class="command">using</span></span> V_props<span class="main">(</span>1<span class="main">)</span> φ<span class="hidden">⇩</span><sub>r</sub>_in_ms assign_nodes_props<span class="main">(</span>8<span class="main">)</span> old.path2_in_αn phiArg_def phiArg_same_var r_s_path_props<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span> simpleDefs_phiDefs_var_disjoint
         <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> ms'_props<span class="main">(</span>1<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">ms'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> old.path2_nontriv <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> m_n_φ<span class="hidden">⇩</span><sub>r</sub>_differ rs_props<span class="main">(</span>1<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> old.path2_nontriv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rs_props set_mono_prefix ms'_props<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> V_props r_s_path_props
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"necessaryPhi' <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> necessaryPhi_def <span class="keyword1"><span class="command">using</span></span> assign_nodes_props<span class="main">(</span>8<span class="main">)</span> phiArg_same_var <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> reachable_props<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assign_nodes_props<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> unnecessaryPhi_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">with</span></span> rs_props
    <span class="keyword1"><span class="command">have</span></span> aux<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">ms</span> <span class="main">∩</span> set <span class="main">(</span><span class="skolem">ns</span> <span class="main">@</span> <span class="skolem">rs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal not_in_butlast old.path2_last<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>r</sub>_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">=</span> <span class="skolem">V</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> V_props<span class="main">(</span>1<span class="main">)</span> assign_nodes_props<span class="main">(</span>8<span class="main">)</span> phiArg_same_var <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>r</sub>_allVars<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> phiArg_def assign_nodes_props<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span> allDefs_in_allVars old.path2_tl_in_αn phiDefs_in_allDefs phi_phiDefs rs_props<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> V_props<span class="main">(</span>2<span class="main">)</span> φ<span class="hidden">⇩</span><sub>r</sub>_V r_s_allVars<span class="main">(</span>2<span class="main">)</span> φ<span class="hidden">⇩</span><sub>r</sub>_allVars r_s_path_props<span class="main">(</span>3<span class="main">)</span> r_s_path_props<span class="main">(</span>1<span class="main">)</span>
             r_s_path_props<span class="main">(</span>4<span class="main">)</span> rs_props<span class="main">(</span>1<span class="main">)</span> aux assign_nodes_props<span class="main">(</span>9<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ss</span></span> <span class="keyword2"><span class="keyword">where</span></span> ss_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">ms</span><span class="main">@</span><span class="skolem">ss</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ms</span><span class="main">@</span><span class="skolem">ss</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_disjoint_paths_extend<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal in_set_butlastD<span class="main">)</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="skolem">ms</span><span class="main">@</span><span class="skolem">ss</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">=</span> <span class="skolem">ns</span><span class="main">@</span><span class="skolem">rs</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> ind_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> rs_props<span class="main">(</span>1<span class="main">)</span> ss_props p<span class="hidden">⇩</span><sub>m</sub>_def p<span class="hidden">⇩</span><sub>n</sub>_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The following case will occur twice in the induction, with swapped identifiers, so we're proving it outside.
    Basically, if the paths <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> intersect, the first such intersection point must be a \pf\ in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free"><span class="free">g</span></span> <span class="skolem"><span class="skolem">φ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
    yielding the path convergence we seek.›</span></span>

    <span class="keyword1"><span class="command">have</span></span> path_crossing_yields_convergence<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span><span class="main">.</span> <span class="main">∃</span><span class="bound">ns</span> <span class="bound">ms</span><span class="main">.</span> old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="bound">ns</span> <span class="skolem">m</span> <span class="bound">ms</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">∩</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> that<span class="main">(</span>6<span class="main">)</span> split_list_first_propE
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span></span> <span class="skolem"><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>2</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="hidden">⇩</span><sub>z</sub>_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span> <span class="main">@</span> <span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">#</span> <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="main">∈</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span><span class="main">.</span> <span class="bound">n</span> <span class="main">∉</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>"</span></span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> split_list_first_propE<span class="main">)</span>

      <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">→</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span><span class="main">@</span><span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span><span class="main">→</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span>"</span></span> <span class="quoted"><span class="quoted">"prefix <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∉</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> old.path2_prefix_ex old.path2_split<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> V_props<span class="main">(</span>3<span class="main">)</span> reachable_same_var<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> reachable_same_var<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> phis_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">from</span></span> reachable_props<span class="main">(</span>1<span class="main">)</span> that<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> φ_props<span class="main">(</span>2<span class="main">)</span> phiArg_in_allVars
      <span class="keyword1"><span class="command">have</span></span> phis_allVars<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtranclp.cases<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Various inequalities for proving paths aren't trivial.›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> φ_node_no_defs phis_V<span class="main">(</span>1<span class="main">)</span> phis_allVars<span class="main">(</span>1<span class="main">)</span> r_s_path_props<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> reachable_props<span class="main">(</span>2<span class="main">)</span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">from</span></span> φ_node_no_defs reachable_props<span class="main">(</span>2<span class="main">)</span> that<span class="main">(</span>2<span class="main">)</span> r_s_path_props<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> phis_V<span class="main">(</span>2<span class="main">)</span> that phis_allVars
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹With this scenario, since <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"set <span class="main"><span class="main">(</span></span>butlast <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∩</span></span> set <span class="main"><span class="main">(</span></span>butlast <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, one of the paths <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must end somewhere within the other, however this means the \pf\ in that node must either be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

      <span class="keyword1"><span class="command">from</span></span> assms n<span class="hidden">⇩</span><sub>z</sub>_props
      <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>p<span class="hidden">⇩</span><sub>n</sub>_ends_in_p<span class="hidden">⇩</span><sub>m</sub><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="main">|</span> <span class="main">(</span>p<span class="hidden">⇩</span><sub>m</sub>_ends_in_p<span class="hidden">⇩</span><sub>n</sub><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> last <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> old.path2_last <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">from</span></span> n<span class="hidden">⇩</span><sub>z</sub>_props<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> False n<span class="hidden">⇩</span><sub>z</sub>_props<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_elem not_in_butlast old.path2_last<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span><span class="main">.</span> <span class="main">∃</span><span class="bound">ns</span> <span class="bound">ms</span><span class="main">.</span> old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="bound">ns</span> <span class="skolem">m</span> <span class="bound">ms</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> p<span class="hidden">⇩</span><sub>n</sub>_ends_in_p<span class="hidden">⇩</span><sub>m</sub>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="skolem">m</span> <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> old.pathsConvergeI<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> p<span class="hidden">⇩</span><sub>n</sub>_ends_in_p<span class="hidden">⇩</span><sub>m</sub> p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>›</span></span> p<span class="hidden">⇩</span><sub>n</sub>_ends_in_p<span class="hidden">⇩</span><sub>m</sub> p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">(</span>1<span class="main">)</span> old.path2_nontriv <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> that<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>"</span></span><span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span>›</span></span> old.path2_nontriv <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">from</span></span> that p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
           <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> butlast_prefix disjointI disjoint_elem in_prefix<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>reachable.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> p<span class="hidden">⇩</span><sub>m</sub>_ends_in_p<span class="hidden">⇩</span><sub>n</sub>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="skolem">m</span> <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span><span class="main">@</span><span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> old.pathsConvergeI<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> p<span class="hidden">⇩</span><sub>m</sub>_ends_in_p<span class="hidden">⇩</span><sub>n</sub>  p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≠</span> defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span><span class="main">)</span>"</span></span>
           <span class="keyword1"><span class="command">using</span></span> old.path2_nontriv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span>"</span></span><span class="main">]</span> old.path2_nontriv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">from</span></span> n<span class="hidden">⇩</span><sub>z</sub>_props p<span class="hidden">⇩</span><sub>n</sub>'_props<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub>'</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>1</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n<span class="hidden">⇩</span><sub>z</sub></span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
           <span class="keyword1"><span class="command">using</span></span> butlast_snoc disjointI in_prefix in_set_butlastD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>reachable.intros<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>


    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Since the reachable-set was built starting at a single $\phi$, these paths must at some
         point converge \emph{within} <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free"><span class="free">g</span></span> <span class="skolem"><span class="skolem">φ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command">from</span></span> assign_nodes_props<span class="main">(</span>3<span class="main">,</span>2<span class="main">)</span> ind_props V_props<span class="main">(</span>3<span class="main">)</span> φ<span class="hidden">⇩</span><sub>r</sub>_V φ<span class="hidden">⇩</span><sub>r</sub>_allVars
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span><span class="main">.</span> <span class="main">∃</span><span class="bound">ns</span> <span class="bound">ms</span><span class="main">.</span> old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="bound">ns</span> <span class="skolem">m</span> <span class="bound">ms</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> refl
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹In the induction basis, we know that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">φ</span></span> <span class="main"><span class="main">=</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and a path to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be obtained
          -- for this we need a second induction.›</span></span>
      <span class="keyword1"><span class="command">from</span></span> refl.prems refl.hyps <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable.induct<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> refl
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The first case, in which <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ<span class="hidden">⇩</span><sub>r</sub> = φ<span class="hidden">⇩</span><sub>s</sub> = φ›</span></span></span></span>, is trivial -- <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span> suffices.›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="skolem">m</span> <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>defNode <span class="free">g</span> <span class="skolem">φ</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> old.pathsConvergeI<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> refl V_props simpleDefs_phiDefs_var_disjoint <span class="keyword1"><span class="command">unfolding</span></span> unnecessaryPhi_def
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> domD domIff old.path2_hd_in_αn old.path2_nontriv phi_phiDefs r_s_path_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> r_s_path_props<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span><span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">→</span>defNode <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">φ</span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">φ'</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span><span class="main">)</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹In this case we have that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">φ</span></span> <span class="main"><span class="main">=</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and need to acquire a path going to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
            however with the aux.\ lemma we have, we still need that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are disjoint.›</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"set <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">∩</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> paths_cross<span class="main">:</span> False
          <span class="keyword1"><span class="command">with</span></span> step reachable.intros
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> path_crossing_yields_convergence<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span> <span class="quoted"><span class="skolem">φ</span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjointI disjoint_elem<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the paths are intersection-free, we can apply our path extension lemma to obtain the path needed.›</span></span>
          <span class="keyword1"><span class="command">from</span></span> step<span class="main">(</span>9<span class="main">,</span>8<span class="main">,</span>10<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">φ</span> <span class="main">∈</span> allVars <span class="free">g</span>›</span></span> r_s_path_props<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> step<span class="main">(</span>6<span class="main">,</span>5<span class="main">)</span> True step<span class="main">(</span>2<span class="main">)</span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ns</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">@</span><span class="skolem">ns</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ'</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">@</span><span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_disjoint_paths_extend<span class="main">)</span>

          <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">@</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> in_set_butlastD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">from</span></span> phiArg_same_var step.hyps<span class="main">(</span>2<span class="main">)</span> step.prems<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ'</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ'</span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> φ_props<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> phiArg_in_allVars reachable.cases step.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">∈</span>reachable <span class="free">g</span> <span class="skolem">φ</span><span class="main">.</span> <span class="main">∃</span><span class="bound">ns</span> <span class="bound">ms</span><span class="main">.</span> old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="bound">ns</span> <span class="skolem">m</span> <span class="bound">ms</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="bound">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> step.prems<span class="main">(</span>1<span class="main">)</span> φ_props V_props <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">n</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">@</span><span class="skolem">ns</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ'</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> step.IH<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">φ'</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹With the induction basis handled, we can finally move on to the induction proper.›</span></span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"set <span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">∩</span> set <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>s</sub>_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>3<span class="main">,</span>9<span class="main">)</span> reachable_same_var <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> phiArg_same_var<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> step<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> φ<span class="hidden">⇩</span><sub>s</sub>_allVars<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> allVars <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_in_allVars<span class="main">)</span>

        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>'</span></span> <span class="keyword2"><span class="keyword">where</span></span> tmp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">⊢</span> <span class="skolem">m</span> <span class="main">-</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>'</span><span class="main">→</span> defNode <span class="free">g</span> <span class="skolem">φ'</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>'</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>butlast <span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> phiArg_disjoint_paths_extend<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span></span> <span class="quoted"><span class="skolem">V</span></span>  <span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="quoted"><span class="skolem">φ'</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="main">(</span><span class="operator">metis</span> φ<span class="hidden">⇩</span><sub>s</sub>_V φ<span class="hidden">⇩</span><sub>s</sub>_allVars step r_s_path_props<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> True disjoint_iff_not_equal in_set_butlastD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

        <span class="keyword1"><span class="command">from</span></span> step<span class="main">(</span>5<span class="main">)</span> this<span class="main">(</span>1<span class="main">)</span> step<span class="main">(</span>7<span class="main">)</span> this<span class="main">(</span>2<span class="main">)</span> step<span class="main">(</span>9<span class="main">)</span> step<span class="main">(</span>10<span class="main">)</span> step<span class="main">(</span>11<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> step.IH<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub>'</span>"</span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> paths_cross<span class="main">:</span> False
        <span class="keyword1"><span class="command">with</span></span> step reachable.intros
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> path_crossing_yields_convergence<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>r</sub></span></span> <span class="quoted"><span class="skolem">φ<span class="hidden">⇩</span><sub>s</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="quoted"><span class="skolem">p<span class="hidden">⇩</span><sub>m</sub></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span></span> <span class="skolem"><span class="skolem">ns</span></span> <span class="skolem"><span class="skolem">ms</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"old.pathsConverge <span class="free">g</span> <span class="skolem">n</span> <span class="skolem">ns</span> <span class="skolem">m</span> <span class="skolem">ms</span> <span class="main">(</span>defNode <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> reachable_props <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">var</span> <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> V_props<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> phiArg_trancl_same_var rtranclpD<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"necessaryPhi' <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span> "</span></span> <span class="keyword1"><span class="command">using</span></span> r_s_path_props
      <span class="keyword1"><span class="command">unfolding</span></span> necessaryPhi_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span> <span class="main">∈</span> reachable <span class="free">g</span> <span class="skolem">φ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unnecessaryPhi <span class="free">g</span> <span class="skolem">φ<span class="hidden">⇩</span><sub>z</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> reachable_props<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> unnecessaryPhi_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Together with lemma 1, we thus have that a CFG without redundant SCCs is cytron-minimal, proving that the
     property established by Braun et al.'s algorithm suffices.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> no_redundant_SCC_minimal<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">P</span> <span class="bound">scc</span><span class="main">.</span> redundant_scc <span class="free">g</span> <span class="bound">P</span> <span class="bound">scc</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cytronMinimal <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms 1 no_redundant_set_minimal <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Finally, to conclude, we'll show that the above theorem is indeed a stronger assertion about a graph
     than the lack of trivial \pf s. Intuitively, this is because a set containing only a
     trivial \pf\ is a redundant set.›</span></span>

<span class="keyword1"><span class="command">corollary</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">P</span><span class="main">.</span> redundant_set <span class="free">g</span> <span class="bound">P</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>redundant <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"redundant <span class="free">g</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">P</span><span class="main">.</span> redundant_set <span class="free">g</span> <span class="bound">P</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"redundant <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"phi <span class="free">g</span> <span class="skolem">φ</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"trivial <span class="free">g</span> <span class="skolem">φ</span>"</span></span>
     <span class="keyword1"><span class="command">unfolding</span></span> redundant_def redundant_set_def dom_def phiArg_def trivial_def isTrivialPhi_def
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"redundant_set <span class="free">g</span> <span class="main">{</span><span class="skolem">φ</span><span class="main">}</span>"</span></span>
     <span class="keyword1"><span class="command">unfolding</span></span> redundant_set_def dom_def phiArg_def trivial_def isTrivialPhi_def
     <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>