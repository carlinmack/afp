<div id="Lib">
<div class="head"><h1>Theory Lib</h1>
<span class="command">theory</span> <span class="name">Lib</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic Mathematical Background Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_subset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M ⟹ finite {x∈M. P x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_powerset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M ⟹ finite {S. S⊆M}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fst_proj</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a*'b) set ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst_proj M ≡ {A. ∃B. (A,B)∈M}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snd_proj</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a*'b) set ⇒ 'b set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd_proj M ≡ {B. ∃A. (A,B)∈M}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_proj_mem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ∈ fst_proj M) = (∃B. (A,B)∈M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_proj_mem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(B ∈ snd_proj M) = (∃A. (A,B)∈M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_proj_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈fst_proj {(A,B)| A B. P A ∧ R A B}. P(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_proj_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈snd_proj {(A,B) | A B. P B ∧ R A B}. P(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map f (Cons x xs) = Cons (f x) (map f xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>List.list.map</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map f (append xs ys) = append (map f xs) (map f ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lockstep induction schema for two simultaneous least fixpoints.
  If the successor step and supremum step of two least fixpoint inflations
  preserve a relation, then that relation holds of the two respective least fixpoints.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfp_lockstep_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>monof</span><span> </span><span>monog</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::complete_lattice ⇒ 'a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::complete_lattice ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monof</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>monog</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono g"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A B. A ≤ lfp(f) ⟹ B ≤ lfp(g) ⟹ R A B ⟹ R (f(A)) (g(B))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R_Union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀M::('a*'b) set. (∀(A,B)∈M. R A B) ⟹ R (Sup (fst_proj M)) (Sup (snd_proj M))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R (lfp f) (lfp g)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using idea of proof of "Inductive.thy:lfp_ordinal_induct"*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(A,B). A ≤ lfp f ∧ B ≤ lfp g ∧ R A B}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R_Union</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>supdoes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R (Sup (fst_proj ?M)) (Sup (snd_proj ?M))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (fst_proj ?M) = lfp f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) = lfp g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>fle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (fst_proj ?M) ≤ lfp f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_proj_prop</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ≤ f (lfp f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monof</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>monoD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ≤ lfp f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monof</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lfp_unfold</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) ≤ lfp g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_proj_prop</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ≤ g (lfp g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monog</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>monoD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ≤ lfp g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monog</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lfp_unfold</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fsup</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fgsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f(Sup(fst_proj ?M)), g(Sup(snd_proj ?M))) ∈ ?M"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R_Union</span><span> </span><span>R_step</span><span> </span><span>Sup_le_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span>fle</span><span> </span><span>gle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fgsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ≤ Sup (fst_proj ?M)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_upper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_proj_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>fge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp f ≤ Sup (fst_proj ?M)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) = lfp g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) ≤ lfp g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gle</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fgsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ≤ Sup (snd_proj ?M)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_upper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>snd_proj_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>gge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp g ≤ Sup (snd_proj ?M)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supdoes</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_eq_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀A. (A∈M ⟹ f(A)=g(A)))
  ⟹ Sup {f(A) | A. A∈M} = Sup {g(A) | A. A∈M}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_corr_eq_chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀M::('a::complete_lattice*'a) set. (∀(A,B)∈M. f(A)=g(B)) ⟹ (Sup {f(A) | A. A∈fst_proj M} = Sup {g(B) | B. B∈snd_proj M})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prod_conv</span><span> </span><span>fst_proj_mem</span><span> </span><span>snd_proj_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Identifiers">
<div class="head"><h1>Theory Identifiers</h1>
<span class="command">theory</span> <span class="name">Identifiers</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Identifier Namespace Configuration›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Different configurations are possible for the namespace of identifiers. Finite support is the only important aspect of it.›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Identifiers, easiest finite case *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ident</span><span> </span><span class="delimiter">=</span><span> </span><span>char</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Identifiers, bigger finite case with longer identifiers *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
definition max_str:"MAX_STR = 1"
typedef ident = "{s::string. size s ≤ MAX_STR}"
  morphisms Rep_ident Abs_ident
  apply(auto)
  apply(rule exI[where x=Nil])
  by(auto simp add: max_str)

setup_lifting  ident.type_definition_ident 

lift_definition ilength::"ident ⇒ nat" is size done

lemma ident_bounded_length: "ilength x ≤ MAX_STR"
  apply (transfer fixing: s)
  apply (auto)
  done 

lemma finite_identifiers [simp]: "finite {x:ident . True}"
using ident_bounded_length 
  
lifting_update ident.lifting
lifting_forget ident.lifting
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The identifier used for the replacement marker in uniform substitutions›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>dotid</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dotid ≡ CHR ''.''"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Syntax">
<div class="head"><h1>Theory Syntax</h1>
<span class="command">theory</span> <span class="name">Syntax</span><br/>
<span class="keyword">imports</span> <a href="Identifiers.html"><span class="name">Identifiers</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Defines the syntax of Differential Game Logic as inductively defined data types.
  🌐‹https://doi.org/10.1145/2817824› 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15›
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Numeric literals›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>lit</span><span> </span><span class="delimiter">=</span><span> </span><span>real</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all real variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allidents</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allidents ≡ {x | x. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Variables and differential variables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>variable</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>RVar</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>DVar</span><span> </span><span>ident</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Var</span><span> </span><span>variable</span><span>
</span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span>lit</span><span>
</span><span class="delimiter">|</span><span> </span><span>Const</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>Func</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Plus</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Times</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Differential</span><span> </span><span>trm</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formulas and Hybrid Games›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>fml</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Pred</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Geq</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Not</span><span> </span><span>fml</span><span>                 </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"!"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>And</span><span> </span><span>fml</span><span> </span><span>fml</span><span>             </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&amp;&amp;"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Exists</span><span> </span><span>variable</span><span> </span><span>fml</span><span>
</span><span class="delimiter">|</span><span> </span><span>Diamond</span><span> </span><span>game</span><span> </span><span>fml</span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⟨ _ ⟩ _)"</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>game</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Game</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>Assign</span><span> </span><span>variable</span><span> </span><span>trm</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">":="</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Test</span><span> </span><span>fml</span><span>                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"?"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Choice</span><span> </span><span>game</span><span> </span><span>game</span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∪∪"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Compose</span><span> </span><span>game</span><span> </span><span>game</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";;"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Loop</span><span> </span><span>game</span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_**"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Dual</span><span> </span><span>game</span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_^d"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>ODE</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Derived operators›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Neg</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg θ = Times (Number (-1)) θ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Minus</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Minus θ η = Plus θ (Neg η)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ fml ⇒ fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"||"</span></span></span><span> </span><span>7</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Or P Q = Not (And (Not P) (Not Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Implies</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ fml ⇒ fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Implies P Q = Or Q (Not P)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ fml ⇒ fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↔"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Equiv P Q = Or (And P Q) (And (Not P) (Not Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Forall</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ⇒ fml ⇒ fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Forall x P = Not (Exists x (Not P))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Equals</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Equals θ θ' = ((Geq θ θ') &amp;&amp; (Geq θ' θ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Greater</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Greater θ θ' = ((Geq θ θ') &amp;&amp; (Not (Geq θ' θ)))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Justification: determinacy theorem justifies this equivalent syntactic abbreviation for box modalities from diamond modalities
  Theorem 3.1 🌐‹https://doi.org/10.1145/2817824››</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Box</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ fml ⇒ fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"([[_]]_)"</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Box α P = Not (Diamond α (Not P))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>TT</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"TT = Geq (Number 0) (Number 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FF</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FF = Geq (Number 0) (Number 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Skip</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"game"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Skip = Test TT"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inference: premises, then conclusion›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>inference</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml list * fml"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>sequent</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml list * fml list"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rule: premises, then conclusion›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>rule</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sequent list * sequent"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Structural Induction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Induction principles for hybrid games owing to their mutually recursive definition with formulas ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Game</span><span> </span><span>Assign</span><span> </span><span>ODE</span><span> </span><span>Test</span><span> </span><span>Choice</span><span> </span><span>Compose</span><span> </span><span>Loop</span><span> </span><span>Dual</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(⋀a. P (Game a)) 
    ⟹ (⋀x θ. P (Assign x θ))
    ⟹ (⋀x θ. P (ODE x θ))
    ⟹ (⋀φ. P (? φ))
    ⟹ (⋀α β. P α ⟹ P β ⟹ P (α ∪∪ β))
    ⟹ (⋀α β. P α ⟹ P β ⟹ P (α ;; β))
    ⟹ (⋀α. P α ⟹ P (α**))
    ⟹ (⋀α. P α ⟹ P (α^d))
    ⟹ P α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Pred</span><span> </span><span>Geq</span><span> </span><span>Not</span><span> </span><span>And</span><span> </span><span>Exists</span><span> </span><span>Diamond</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀x θ. P (Pred x θ))
  ⟹ (⋀θ η. P (Geq θ η))
  ⟹ (⋀φ. P φ ⟹ P (Not φ))
  ⟹ (⋀φ ψ. P φ ⟹ P ψ ⟹ P (And φ ψ))
  ⟹ (⋀x φ. P φ ⟹ P (Exists x φ))
  ⟹ (⋀α φ. P φ ⟹ P (Diamond α φ))
  ⟹ P φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>fml.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars ≡ {x::variable. True}"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Denotational_Semantics">
<div class="head"><h1>Theory Denotational_Semantics</h1>
<span class="command">theory</span> <span class="name">Denotational_Semantics</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Derivative.html"><span class="name">Derivative</span></a> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Derivative"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>         
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Denotational Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defines the denotational semantics of Differential Game Logic. 🌐‹https://doi.org/10.1145/2817824› 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹States›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Vector of reals over ident›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>Rvec</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ⇒ real"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rvec"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all worlds›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>worlds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"worlds = {ν. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars ≡ {x::variable. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all real variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allrvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allrvars ≡ {RVar x | x. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹the set of all differential variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>alldvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alldvars ≡ {DVar x | x. True}"</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ident_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite({x::ident. True})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>allvar_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars = allrvars ∪ alldvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>variable.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rvar_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite allrvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ident_finite</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹λx. RVar x›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dvar_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite alldvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ident_finite</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹λx. DVar x›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>allvars_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(allvars)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvar_cases</span><span> </span><span>dvar_finite</span><span> </span><span>rvar_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_Un</span><span class="delimiter">)</span><span> 
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Vagree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ state ⇒ variable set ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ≡ (∀i. i∈V ⟶ ν(i) = ν'(i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Uvariation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ state ⇒ variable set ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ν' U ≡ (∀i. ~(i∈U) ⟶ ν(i) = ν'(i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ν' (-V) = Vagree ν ν' V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Vagree_def</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V = Vagree ν' ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ⟹ Vagree ν' ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_union</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ⟹ Vagree ν ν' W ⟹ Vagree ν ν' (V∪W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ⟹ Vagree  ν' ν'' W ⟹ Vagree ν ν'' (V∩W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ∧ W⊆V ⟶ Vagree ν ν' W"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ν' {} = (ν=ν')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_univ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' allvars = (ν=ν')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_univ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ν' allvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_and</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ∧ Vagree ν ν' W ⟷ Vagree ν ν' (V∪W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' V ∨ Vagree ν ν' W ⟶ Vagree ν ν' (V∩W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ν U = Uvariation ν ω U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_sym_rel</span><span> </span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ν U ⟹ Uvariation ν ω U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ν U ⟹ Uvariation ν μ V ⟹ Uvariation ω μ (U∪V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_mon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊇ U ⟹ Uvariation ω ν U ⟹ Uvariation ω ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Interpretations</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mon_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono r = ((∀X Y. (X⊆Y ⟶ r(X)⊆r(Y))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹interpretations of symbols in ident›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>interp_rep</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ⇒ real) × (ident ⇒ (real ⇒ real)) × (ident ⇒ (real ⇒ bool)) × (ident ⇒ (state set ⇒ state set))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_interp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp_rep ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interp I ≡ case I of (_, _, _, G) ⇒ (∀a. mono (G a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>interp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{I:: interp_rep. is_interp I}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>raw_interp</span><span> </span><span>well_interp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λf. 0, λf x. 0, λp x. True, λa. λX. X) ∈ {I. is_interp I}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_interp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Consts</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"interp ⇒ ident ⇒ (real)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(F0, _, _, _). F0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Funcs</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ ident ⇒ (real ⇒ real)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(_, F, _, _). F"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Preds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ ident ⇒ (real ⇒ bool)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(_, _, P, _). P"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Games</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ ident ⇒ (state set ⇒ state set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(_, _, _, G). G"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹make interpretations›</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>mkinterp</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ⇒ real) × (ident ⇒ (real ⇒ real)) × (ident ⇒ (real ⇒ bool)) × (ident ⇒ (state set ⇒ state set))
⇒ interp"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(C, F, P, G). if ∀a. mono (G a) then (C, F, P, G) else (C, F, P, λ_ _. {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span> </span><span>is_interp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Consts_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (mkinterp(C,F,P,G)) = C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Funcs_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (mkinterp(C,F,P,G)) = F"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Preds_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (mkinterp(C,F,P,G)) = P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Games_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀a. mono (G a) ) ⟹ Games (mkinterp(C,F,P,G)) = G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mkinterp_eq</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Consts I = Consts J ∧ Funcs I = Funcs J ∧ Preds I = Preds J ∧ Games I = Games J) = (I=J)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X⊆Y ⟹ (Games I a)(X)⊆(Games I a)(Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>X</span><span> </span><span>Y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lifting_update</span></span><span> </span><span>interp.lifting</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>interp.lifting</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Semantics</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantic modification ‹repv ω x r› replaces the value of variable ‹x› in the state ‹ω› with r›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>repv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ variable ⇒ real ⇒ state"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ω x r = fun_upd ω x r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_def_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ω x r = (λy. if x = y then r else ω(y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_access</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv ω x r)(y) = (if (x=y) then r else ω(y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ω x (ω(x)) = ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_repv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω (repv ω x d) (-{x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_repv_self</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω (repv ω x d) {x} = (d=ω(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_repv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω (repv ω x d) {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics of Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>term_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ trm ⇒ (state ⇒ real)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Var x) = (λω. ω(x))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Number r) = (λω. r)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Const f) = (λω. (Consts I f))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Func f θ) = (λω. (Funcs I f)(term_sem I θ ω))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Plus θ η) = (λω. term_sem I θ ω + term_sem I η ω)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Times θ η) = (λω. term_sem I θ ω * term_sem I η ω)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Differential θ) = (λω. sum(λx. ω(DVar x)*deriv(λX. term_sem I θ (repv ω (RVar x) X))(ω(RVar x)))(allidents))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Solutions of Differential Equations›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*@note For simplicity, solutions are not limited to a smaller interval of existence*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>solution</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>solves_ODE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ solution ⇒ ident ⇒ trm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x θ ≡ (∀ζ::real.
     Vagree (F(0)) (F(ζ)) (-{RVar x, DVar x})
   ∧ F(ζ)(DVar x) = deriv(λt. F(t)(RVar x))(ζ)
   ∧ F(ζ)(DVar x) = term_sem I θ (F(ζ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics of Formulas and Games›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>fml_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ fml ⇒ (state set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>game_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ game ⇒ (state set ⇒ state set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Pred p θ) = {ω. (Preds I p)(term_sem I θ ω)}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Geq θ η) = {ω. term_sem I θ ω ≥ term_sem I η ω}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not φ) = {ω. ω ∉ fml_sem I φ}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (And φ ψ) = fml_sem I φ ∩ fml_sem I ψ"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Exists x φ) = {ω. ∃r. (repv ω x r) ∈ fml_sem I φ}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond α φ) = game_sem I α (fml_sem I φ)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Game a) = (λX. (Games I a)(X))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Assign x θ) = (λX. {ω. (repv ω x (term_sem I θ ω)) ∈ X})"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Test φ) = (λX. fml_sem I φ ∩ X)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Choice α β) = (λX. game_sem I α X ∪ game_sem I β X)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Compose α β) = (λX. game_sem I α (game_sem I β X))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop α) = (λX. ⋂{Z. X ∪ game_sem I α Z ⊆ Z})"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Dual α) = (λX. -(game_sem I α (-X)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (ODE x θ) = (λX. {ω. ∃F T. Vagree ω (F(0)) (-{DVar x}) ∧ F(T) ∈ X ∧ solves_ODE I F x θ})"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Validity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ⇒ fml ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I φ ≡ (∀ω. ω ∈ fml_sem I φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid φ ≡ (∀I.∀ω. ω ∈ fml_sem I φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_is_valid_in_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid φ = (∀I. valid_in I φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>locally_sound</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R ≡
  (∀I. (∀k. 0≤k ⟶ k&lt;length (fst R) ⟶ valid_in I (nth (fst R) k)) ⟶ valid_in I (snd R))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sound</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound R ≡
  (∀k. 0≤k ⟶ k&lt;length (fst R) ⟶ valid (nth (fst R) k)) ⟶ valid (snd R)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>locally_sound_is_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R ⟹ sound R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span> </span><span>sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_is_valid_in_all</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monotone Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_Test</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X⊆Y ⟹ game_sem I (Test φ) X ⊆ game_sem I (Test φ) Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X⊆Y ⟹ game_sem I α X ⊆ game_sem I α Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α1</span><span> </span><span>α2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α1</span><span> </span><span>α2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_mono</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λX. game_sem I α X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mon_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I α (X∪Y) ⊇ game_sem I α X ∪ game_sem I α Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>game_sem_union</span><span> </span><span class="delimiter">=</span><span> </span><span>game_union</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Fixpoint Semantics Alternative for Loops›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λZ. X ∪ game_sem I α Z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>mon_mono</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Consequence of Knaster-Tarski Theorem 3.5 of 🌐‹https://doi.org/10.1145/2817824››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_sem_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop α) = (λX. lfp(λZ. X ∪ game_sem I α Z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋂{Z. X ∪ game_sem I α Z ⊆ Z} = lfp(λZ. X ∪ game_sem I α Z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_back</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λX. lfp(λZ. X ∪ game_sem I α Z)) = game_sem I (Loop α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_iterate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop α) = (λX. X ∪ game_sem I α (game_sem I (Loop α) X))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>game_sem_loop</span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span>lfp_fixpoint</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_unwind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop α) = (λX. X ∪ game_sem I (Compose α (Loop α)) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_iterate</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_unwind_reduce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λX. X ∪ game_sem I (Compose α (Loop α)) X) = game_sem I (Loop α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_unwind</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lfp_ordinal_induct_set_cases</span><span> </span><span class="delimiter">=</span><span> </span><span>lfp_ordinal_induct_set</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>mono</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Read off a fixpoint induction scheme from the fact that loops have a least fixpoint semantics *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_loop_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀Z. Z ⊆ game_sem I (Loop α) X ⟹ P(Z) ⟹ P(X ∪ game_sem I α Z))
  ⟹ (⋀M. (∀Z∈M. P(Z)) ⟹ P(Sup M))
  ⟹ P(game_sem I (Loop α) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loopstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Z. Z ⊆ game_sem I (Loop α) X ⟹ P(Z) ⟹  P(X ∪ game_sem I α Z)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loopsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀M. (∀Z∈M. P(Z)) ⟹ P(Sup M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(lfp(λZ. X ∪ game_sem I α Z))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_ordinal_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹λZ. X ∪ game_sem I α Z›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>mono</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopstep</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Z</span><span class="delimiter">=</span><span>S</span><span class="delimiter">]</span><span> </span><span>game_sem_loop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span class="delimiter">=</span><span>α</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>loopstep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopsup</span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(game_sem I (Loop α) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof (induction rule: lfp_ordinal_induct_set_cases[where f=‹λZ. X ∪ game_sem I α Z›])
    case mono
    then show ?case using game_sem_loop_fixpoint_mono by simp
  next
    case (step S)
    then show ?case using loopstep by auto
  next
    case (union M)
    then show ?case using loopsup game_sem_loop by auto
  qed*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some Simple Obvious Observations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not φ) = -fml_sem I φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_not_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not (Not φ)) = fml_sem I φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_or</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Or φ ψ) = fml_sem I φ ∪ fml_sem I ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_implies</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Implies φ ψ) = (-fml_sem I φ) ∪ fml_sem I ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Implies_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TT_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid TT"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>TT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantic equivalence of formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fml_equiv</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml =&gt; fml =&gt; bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv φ ψ ≡ (∀I. fml_sem I φ = fml_sem I ψ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Substitutionality for Equivalent Formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_equiv_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv φ ψ ⟹ P (fml_sem I φ) ⟹ P (fml_sem I ψ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv φ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fml_sem I φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I φ = fml_sem I ψ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forw_subst</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_fml_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (φ ↔ ψ) = fml_equiv φ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_in_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (φ ↔ ψ) = ((fml_sem I φ) = (fml_sem I ψ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_in_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (φ → ψ) = ((fml_sem I φ) ⊆ (fml_sem I ψ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_in_def</span><span> </span><span>Implies_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (φ ↔ ψ) = (∀I. fml_sem I φ = fml_sem I ψ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_fml_equiv</span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (φ → ψ) = (∀I. (fml_sem I φ) ⊆ (fml_sem I ψ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Implies_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_equals</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω ∈ fml_sem I (Equals θ η)) = (term_sem I θ ω = term_sem I η ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equals_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_refl_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (φ ↔ φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equal_refl_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (Equals θ θ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equals_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_ODE_alt</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x θ ≡ (∀ζ::real.
     Vagree (F(0)) (F(ζ)) (-{RVar x, DVar x})
   ∧ F(ζ)(DVar x) = deriv(λt. F(t)(RVar x))(ζ)
   ∧ F(ζ) ∈ fml_sem I (Equals (Var (DVar x)) θ))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_equals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantic equivalence of games›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_equiv</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game =&gt; game =&gt; bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β ≡ (∀I X. game_sem I α X = game_sem I β X)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Substitutionality for Equivalent Games›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_equiv_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β ⟹ P (game_sem I α X) ⟹ P (game_sem I β X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (game_sem I α X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I α X = game_sem I β X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forw_subst</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_equiv_subst_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β ⟹ P (game_sem I α X) == P (game_sem I β X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_equiv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_id</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I Skip X = X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Skip_def</span><span> </span><span>TT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_iterate_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv (Loop α) (Choice Skip (Compose α (Loop α)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_equiv_def</span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>X</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>game_sem_loop_unwind_reduce</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∪ game_sem I (Compose α (Loop α)) X = game_sem I (Loop α) X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop α) X = game_sem I (Choice Skip (Compose α (Loop α))) X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skip_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_equiv_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv φ ψ ⟹ valid φ = valid ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_equiv_subst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_Vagree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x θ ⟹ (⋀ζ. Vagree (F(ζ)) (F(0)) (-{RVar x,DVar x}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_ODE_def</span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_Vagree_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) ω U ⟹ solves_ODE I F x θ ⟹ Uvariation (F(ζ)) ω (U∪{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>solves_ODE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_sym_rel</span><span> </span><span>Uvariation_trans</span><span> </span><span>double_complement</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Static_Semantics">
<div class="head"><h1>Theory Static_Semantics</h1>
<span class="command">theory</span> <span class="name">Static_Semantics</span><br/>
<span class="keyword">imports</span> <a href="Denotational_Semantics.html"><span class="name">Denotational_Semantics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Static Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantically-defined Static Semantics›</span></span></span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary notions of projection of winning conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹upward projection: ‹restrictto X V› is extends X to the states that agree on V with some state in X,
so variables outside V can assume arbitrary values.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>restrictto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set ⇒ variable set ⇒ state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"restrictto X V = {ν. ∃ω. ω∈X ∧ Vagree ω ν V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹downward projection: ‹selectlike X ν V› selects state ‹ν› on V in X,
so all variables of V are required to remain constant›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>selectlike</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set ⇒ state ⇒ variable set ⇒ state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"selectlike X ν V = {ω∈X. Vagree ω ν V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Free variables, semantically characterized.›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Free variables of a term›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVT t = {x. ∃I.∃ν.∃ω. Vagree ν ω (-{x}) ∧ ¬(term_sem I t ν = term_sem I t ω)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Free variables of a formula›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVF φ = {x. ∃I.∃ν.∃ω. Vagree ν ω (-{x}) ∧ ν ∈ fml_sem I φ ∧ ω ∉ fml_sem I φ}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Free variables of a hybrid game›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVG α = {x. ∃I.∃ν.∃ω.∃X. Vagree ν ω (-{x}) ∧ ν ∈ game_sem I α (restrictto X (-{x})) ∧ ω ∉ game_sem I α (restrictto X (-{x}))}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bound variables, semantically characterized.›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Bound variables of a hybrid game›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>BVG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BVG α = {x. ∃I.∃ω.∃X. ω ∈ game_sem I α X ∧ ω ∉ game_sem I α (selectlike X ω {x})}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simple Observations›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_elem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x∈BVG α) = (∃I ω X. ω ∈ game_sem I α X ∧ ω ∉ game_sem I α (selectlike X ω {x}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonBVG_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω {x})))
  ⟹ x∉BVG α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonBVG_inc_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀I ω X. (ω ∈ game_sem I α X) ⟹ (ω ∈ game_sem I α (selectlike X ω {x})))
  ⟹ x∉BVG α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVT_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVT t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVF_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVF e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVG_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVG a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Coincidence">
<div class="head"><h1>Theory Coincidence</h1>
<span class="command">theory</span> <span class="name">Coincidence</span><br/>
<span class="keyword">imports</span> <a href="Lib.html"><span class="name">Lib</span></a> <a href="Static_Semantics.html"><span class="name">Static_Semantics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL.Finite_Set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Static Semantics Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Auxiliaries</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The state interpolating ‹stateinterpol ν ω S› between ‹ν› and ‹ω› that is ‹ν› on ‹S› and ‹ω› elsewhere›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stateinterpol</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ state ⇒ variable set ⇒ state"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ν ω S = (λx. if (x∈S) then ν(x) else ω(x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>statediff</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ state ⇒ variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff ν ω = {x. ν(x)≠ω(x)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nostatediff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉statediff ν ω ⟹ ν(x)=ω(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>statediff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ν ω {} = ω"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ¬(x∈{})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. stateinterpol ν ω {} x = ω x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈S ⟹ (stateinterpol ν ω S)(x)=ν(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉S ⟹ (stateinterpol ν ω S)(x)=ω(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_stateinterpol</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol ν ω S) ν S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol ν ω S) ω (-S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_ror</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' (V∩W) ⟹ (∃ω. (Vagree ν ω V ∧ Vagree ω ν' W))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ν' (V∩W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x∈V∩W ⟶ ν(x)=ν'(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?w</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"stateinterpol ν ν' V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ?w V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ?w ν' W ∧ Vagree ?w ν' W"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀x. x∈V∩W ⟶ ν x = ν' x›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ?w V ∧ Vagree ?w ν' W"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remark 8 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15› about simple properties of projections›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_extends</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V ⊇ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto (restrictto X V) W = restrictto X (V∩W)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto (restrictto X V) W ⊆ restrictto X (V∩W)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X (V∩W) ⊆ restrictto (restrictto X V) W"</span></span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Vagree_ror mem_Collect_eq restrictto_def subsetI)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sledgehammer *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable ⇒ real) set ⇒ (variable ⇒ real) set ⇒ variable ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1. (∃v2. v2 ∈ x1 ∧ v2 ∉ x0) = (rr x0 x1 ∈ x1 ∧ rr x0 x1 ∉ x0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀F Fa. rr Fa F ∈ F ∧ rr Fa F ∉ Fa ∨ F ⊆ Fa"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable ⇒ real) ⇒ variable set ⇒ (variable ⇒ real) set ⇒ variable ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1 x2. (∃v3. v3 ∈ x2 ∧ Vagree v3 x0 x1) = (rra x0 x1 x2 ∈ x2 ∧ Vagree (rra x0 x1 x2) x0 x1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀F V f. (f ∉ {f. ∃fa. fa ∈ F ∧ Vagree fa f V} ∨ rra f V F ∈ F ∧ Vagree (rra f V F) f V) ∧ (f ∈ {f. ∃fa. fa ∈ F ∧ Vagree fa f V} ∨ (∀fa. fa ∉ F ∨ ¬ Vagree fa f V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ X ∧ Vagree f (v4_1 W V (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (rra (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (V ∩ W) X)) V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree f (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) W"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ∉ {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ∨ rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ∈ {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ⊆ {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬ Vagree (rra (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (V ∩ W) X) (v4_1 W V (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (rra (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (V ∩ W) X)) V ∨ ¬ Vagree (v4_1 W V (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (rra (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) (V ∩ W) X)) (rr {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W} {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)}) W) ∨ {f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ⊆ {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f. ∃fa. fa ∈ X ∧ Vagree fa f (V ∩ W)} ⊆ {f. ∃fa. fa ∈ {f. ∃fa. fa ∈ X ∧ Vagree fa f V} ∧ Vagree fa f W}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Vagree_ror</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrictto_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W⊇V ⟹ restrictto X W ⊆ restrictto X V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W⊇V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃U. V=W∩U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V=W∩U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V = restrictto (restrictto X W) U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V ⊇ restrictto X W"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrictto_extends</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X≠{} ⟹ restrictto X {} = worlds"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span> </span><span>worlds_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_shrinks</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X ν V ⊆ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (selectlike X ν V) ν W = selectlike X ν (V∪W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W⊇V ⟹ selectlike X ν W ⊆ selectlike X ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X ν {} = X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ selectlike X ν V) = (ν∈X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_complement</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (-X) ν V ⊆ -selectlike X ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X∪Y) ν V = selectlike X ν V ∪ selectlike Y ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_Sup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (Sup M) ν V = Sup {selectlike X ν V | X. X∈M}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(selectlike X ν V = selectlike Y ν V) = (∀μ. Uvariation μ ν (-V) ⟶ (μ∈X) = (μ∈Y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(selectlike X ν (-V) = selectlike Y ν (-V)) = (∀μ. Uvariation μ ν V ⟶ (μ∈X) = (μ∈Y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-V›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀μ. Uvariation μ ν (-V) ⟹ (μ∈X) = (μ∈Y))
  ⟹ (selectlike X ν V = selectlike Y ν V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹V›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀μ. Uvariation μ ν V ⟹ (μ∈X) = (μ∈Y))
  ⟹ (selectlike X ν (-V) = selectlike Y ν (-V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-V›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>co_selectlike</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-(selectlike X ν V) = (-X) ∪ {ω. ¬Vagree ω ν V}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_co_selectlike</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (-(selectlike X ν V)) ν V = selectlike (-X) ν V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_Vagree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ω V ⟹ selectlike X ν V = selectlike X ω V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_def</span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>similar_selectlike_mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ω V ⟹ (ν∈selectlike X ω V) = (ν∈X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* also see nonBVG_rule *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x∉BVG α) = (∀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω {x})))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span>monotone</span><span> </span><span>selectlike_shrinks</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹statediff› interoperability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' S ⟹ statediff ω ω' ⊆ -S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>statediff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_diff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ν ω (statediff ν ω) = ν"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>sp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(stateinterpol ν ω (statediff ν ω))(x) = ν(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈statediff ν ω"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span> </span><span>nostatediff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol v w S) (stateinterpol v w (insert z S)) (-{z})"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_FVT</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z∉FVT(t) ⟹ term_sem I t (stateinterpol ω ω' S) = term_sem I t (stateinterpol ω ω' (insert z S))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z∉FVT(t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⋀w. Vagree v w (-{z}) ⟹ (term_sem I t v = term_sem I t w)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FVT_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I t (stateinterpol ω ω' S) = term_sem I t (stateinterpol ω ω' (insert z S))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fvc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stateinterpol_insert</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coincidence Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coincidence for Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 10 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (FVT θ) ⟹ term_sem I θ ω = term_sem I θ ω'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (FVT θ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff ω ω' ⊆ -FVT(θ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S⊆-FVT(θ) ⟹ (term_sem I θ ω' = term_sem I θ (stateinterpol ω ω' S))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>z</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (statediff ω ω')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FVT_finite</span><span> </span><span>UNIV_def</span><span> </span><span>finite_compl</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹statediff ω ω'›</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>finS</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>isS</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_term_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ω' U ⟹ (FVT θ)∩U={} ⟹ term_sem I θ ω = term_sem I θ ω'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_term</span><span> </span><span>Uvariation_Vagree</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vagree_antimon</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_FVF</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z∉FVF(e) ⟹ 
  ((stateinterpol ω ω' S) ∈ fml_sem I e ⟷ (stateinterpol ω ω' (insert z S)) ∈ fml_sem I e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z∉FVF(e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>agr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol ω ω' S) (stateinterpol ω ω' (insert z S)) (-{z})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⋀w. (Vagree v w (-{z}) ⟹ (v∈fml_sem I e ⟹ w∈fml_sem I e))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FVF_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⋀w. (Vagree v w (-{z}) ⟹ ((v∈fml_sem I e) = (w∈fml_sem I e)))"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(stateinterpol ω ω' S) ∈ fml_sem I e ⟷ (stateinterpol ω ω' (insert z S)) ∈ fml_sem I e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coincidence for Formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 11 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_formula</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (FVF φ) ⟹ (ω ∈ fml_sem I φ ⟷ ω' ∈ fml_sem I φ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (FVF φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff ω ω' ⊆ -FVF(φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S⊆-FVF(φ) ⟹ (ω' ∈ fml_sem I φ ⟷ (stateinterpol ω ω' S) ∈ fml_sem I φ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>z</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (statediff ω ω')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FVF_finite</span><span> </span><span>UNIV_def</span><span> </span><span>finite_compl</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹statediff ω ω'›</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>finS</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>isS</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_formula_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ω' U ⟹ (FVF φ)∩U={} ⟹ (ω ∈ fml_sem I φ ⟷ ω' ∈ fml_sem I φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_formula</span><span> </span><span>Uvariation_Vagree</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_def</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>inf.commute</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coincidence for Games›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹Cignorabimus α V› is the set of all sets of variables that can be ignored for the coincidence game lemma›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Cignorabimus</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ variable set ⇒ variable set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Cignorabimus α V = {M. ∀I.∀ω.∀ω'.∀X. (Vagree ω ω' (-M) ⟶ (ω∈game_sem I α (restrictto X V)) ⟶ (ω'∈game_sem I α (restrictto X V)))}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Cignorabimus α V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_powerset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>allvars_finite</span><span class="delimiter">]</span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Set.finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_equiv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cignorabimus α V = {M. ∀I.∀ω.∀ω'.∀X. (Vagree ω ω' (-M) ⟶ (ω∈game_sem I α (restrictto X V)) = (ω'∈game_sem I α (restrictto X V)))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Vagree_sym_rel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ∈ Cignorabimus α V ∧ N⊆M ⟹ N ∈ Cignorabimus α V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-{}=allvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coempty</span><span> </span><span>Vagree_univ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cignorabimus contains nonfree variables›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊇FVG(α) ⟹ x∉V ⟹ {x}∈Cignorabimus α V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊇FVG(α)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉FVG(α)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹FVG α ⊆ V›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I v w. Vagree v w (-{x}) ⟹ (v ∈ game_sem I α (restrictto X (-{x})) ⟷ w ∈ game_sem I α (restrictto X (-{x})))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>FVG_def</span><span> </span><span>Vagree_sym_rel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}∈Cignorabimus α V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>ω'</span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (-{x}) ⟶ (ω∈game_sem I α (restrictto X V)) ⟶ (ω'∈game_sem I α (restrictto X V))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (-{x})"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω∈game_sem I α (restrictto X V)) ⟶ (ω'∈game_sem I α (restrictto X V))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω∈game_sem I α (restrictto X V)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω∈game_sem I α (restrictto (restrictto X V) (-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Int_absorb2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∉V›</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω'∈game_sem I α (restrictto (restrictto X V) (-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVG_def</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω'∈game_sem I α (restrictto X (V∩-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω'∈game_sem I α (restrictto X V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_absorb2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ω' ∈ game_sem I α (restrictto X (V ∩ - {x}))›</span></span></span><span> </span><span>subset_Compl_singleton</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cignorabimus is closed under union›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M∈Cignorabimus α V ⟹ N∈Cignorabimus α V ⟹ (M∪N)∈Cignorabimus α V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M∈Cignorabimus α V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N∈Cignorabimus α V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M∪N)∈Cignorabimus α V"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using a1 a2 unfolding Cignorabimus_def *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>ω'</span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' (-(M∪N))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω ω'.⋀X. (Vagree ω ω' (-M) ⟹  (ω∈game_sem I α (restrictto X V)) ⟹ (ω'∈game_sem I α (restrictto X V)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω ω'.⋀X. (Vagree ω ω' (-N) ⟹  (ω∈game_sem I α (restrictto X V)) ⟹ (ω'∈game_sem I α (restrictto X V)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ω' ω M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ?s (-(M∪N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ?s ω' (-(M∪N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω∈game_sem I α (restrictto X V) ⟹ ?s∈game_sem I α (restrictto X V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplD</span><span> </span><span>Vagree_def</span><span> </span><span>h1</span><span> </span><span>stateinterpol_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?s∈game_sem I α (restrictto X V) ⟹ ω'∈game_sem I α (restrictto X V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vagree_ror</span><span> </span><span>compl_sup</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>v2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω∈game_sem I α (restrictto X V) ⟹ ω'∈game_sem I α (restrictto X V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powersetup_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Base</span><span> </span><span>Cup</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"⋀C. (⋀M. M∈C ⟹ P M) ⟹
    (⋀S. (⋀M. M∈S ⟹ P M) ⟹ P (⋃S)) ⟹
     P (⋃C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Union_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃(insert x S) = x∪⋃S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powerset2up_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Finite</span><span> </span><span>Nonempty</span><span> </span><span>Base</span><span> </span><span>Cup</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(finite C) ⟹ (C≠{}) ⟹ (⋀M. M∈C ⟹ P M) ⟹
    (⋀M N. P M ⟹ P N ⟹ P (M∪N)) ⟹
     P (⋃C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀M. M∈S ⟹ M∈Cignorabimus α V) ⟹ (⋃S)∈Cignorabimus α V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"S={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nonem</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃S∈Cignorabimus α V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀M. M∈S ⟹ M∈Cignorabimus α V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonemp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"S≠{}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>powerset2up_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Finite</span><span>                                                   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>infinite_super</span><span> </span><span>subset_eq</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonemp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Base</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cup</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Cignorabimus_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 12 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_game</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' V ⟹ V⊇FVG(α) ⟹ (ω ∈ game_sem I α (restrictto X V)) = (ω' ∈ game_sem I α (restrictto X V))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω ω' V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊇ FVG α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}∈Cignorabimus α V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊇ FVG α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cignorabimus_init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-V = ⋃{xx. ∃x. xx={x} ∧ x∉V}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* finite *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-V)∈Cignorabimus α V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>base</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_step</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Cignorabimus_step mem_Collect_eq)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v V. v ∈ V ∨ ¬ FVG α ⊆ V ∨ {v} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ game ⇒ variable set set ⇒ variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1 x2. (∃v3. v3 ∈ x2 ∧ v3 ∉ Cignorabimus x1 x0) = (VV x0 x1 x2 ∈ x2 ∧ VV x0 x1 x2 ∉ Cignorabimus x1 x0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((∄v. VV V α {{v} |v. v ∉ V} = {v} ∧ v ∉ V) ∨ VV V α {{v} |v. v ∉ V} = {vv (VV V α {{v} |v. v ∉ V})} ∧ vv (VV V α {{v} |v. v ∉ V}) ∉ V) ∧ ((∃v. VV V α {{v} |v. v ∉ V} = {v} ∧ v ∉ V) ∨ (∀v. VV V α {{v} |v. v ∉ V} ≠ {v} ∨ v ∈ V))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{vv (VV V α {{v} |v. v ∉ V})} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(VV V α {{v} |v. v ∉ V} ≠ {vv (VV V α {{v} |v. v ∉ V})} ∨ vv (VV V α {{v} |v. v ∉ V}) ∈ V) ∨ VV V α {{v} |v. v ∉ V} ∉ {{v} |v. v ∉ V} ∨ VV V α {{v} |v. v ∉ V} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃v. VV V α {{v} |v. v ∉ V} = {v} ∧ v ∉ V) ⟶ VV V α {{v} |v. v ∉ V} ∉ {{v} |v. v ∉ V} ∨ VV V α {{v} |v. v ∉ V} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"VV V α {{v} |v. v ∉ V} ∉ {{v} |v. v ∉ V} ∨ VV V α {{v} |v. v ∉ V} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃{{v} |v. v ∉ V} ∈ Cignorabimus α V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Cignorabimus_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_game_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ω ω' U ⟹ U∩FVG(α)={} ⟹ (ω ∈ game_sem I α (restrictto X (-U))) = (ω' ∈ game_sem I α (restrictto X (-U)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_game</span><span> </span><span>Uvariation_Vagree</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>coincidence_game</span><span> </span><span>compl_le_swap1</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bound Effect Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹Bignorabimus α V› is the set of all sets of variables that can be ignored for boundeffect›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Bignorabimus</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ variable set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Bignorabimus α = {M. ∀I.∀ω.∀X. ω∈game_sem I α X ⟷ ω∈game_sem I α (selectlike X ω M)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Bignorabimus α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_powerset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>allvars_finite</span><span class="delimiter">]</span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Set.finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I α (selectlike X ω M) ⊆ game_sem I α X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>monotone</span><span> </span><span>selectlike_shrinks</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Bignorabimus α = {M. ∀I.∀ω.∀X. (ω∈game_sem I α X ⟶ ω∈game_sem I α (selectlike X ω M))}"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Bignorabimus_def Bignorabimus_single Collect_cong subsetCE)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer transformed*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable set ⇒ bool) ⇒ (variable set ⇒ bool) ⇒ variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p pa. (¬ p (VV pa p)) = pa (VV pa p) ∨ Collect p = Collect pa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Collect_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ game ⇒ variable ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ii</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ game ⇒ interp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ game ⇒ (variable ⇒ real) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1. (∃v2 v3 v4. (v3 ∈ game_sem v2 x1 v4) ≠ (v3 ∈ game_sem v2 x1 (selectlike v4 v3 x0))) = ((rr x0 x1 ∈ game_sem (ii x0 x1) x1 (FF x0 x1)) ≠ (rr x0 x1 ∈ game_sem (ii x0 x1) x1 (selectlike (FF x0 x1) (rr x0 x1) x0)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))} = {V. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Bignorabimus_single</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∉ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (selectlike (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))) ∨ rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∈ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬ (∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))) ∨ (∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))))) ∧ ((∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))) ∨ (rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∉ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α)) = (rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∈ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (selectlike (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∈ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) ⟶ (∃i f F. f ∈ game_sem i α F ∧ f ∉ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))) ∨ rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α ∈ game_sem (ii (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) α (selectlike (FF (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (rr (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))) α) (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i f F. f ∈ game_sem i α F ∧ f ∉ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬ (∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))) ≠ (∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))} = {V. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))) ∨ {V. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))} = {V. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬ (∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)))))) ≠ (∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f (VV (λV. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))) (λV. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V))))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))} = {V. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ∀i f F. (f ∈ game_sem i α F) = (f ∈ game_sem i α (selectlike F f V))} = {V. ∀i f F. f ∈ game_sem i α F ⟶ f ∈ game_sem i α (selectlike F f V)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ∈ Bignorabimus α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coempty</span><span> </span><span>selectlike_empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(α) ⟹ {x}∈Bignorabimus α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span>BVG_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ {x. ∃I ω X. ω ∈ game_sem I α X ∧ ω ∉ game_sem I α (selectlike X ω {x})}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃I ω X. ω ∈ game_sem I α X ∧ ω ∉ game_sem I α (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x} ∈ {M. ∀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω M))}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bignorabimus is closed under union›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M∈Bignorabimus α ⟹ N∈Bignorabimus α ⟹ (M∪N)∈Bignorabimus α"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M∈Bignorabimus α"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N∈Bignorabimus α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I.∀ω.∀X. (ω∈game_sem I α X) ⟷ (ω∈game_sem I α (selectlike X ω M))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I.∀ω.∀X. (ω∈game_sem I α X) ⟷ (ω∈game_sem I α (selectlike X ω N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I.∀ω.∀X. (ω∈game_sem I α X) ⟷ (ω∈game_sem I α (selectlike X ω (M∪N)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>selectlike_compose</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M∪N)∈Bignorabimus α"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀M. M∈S ⟹ M∈Bignorabimus α) ⟹ (⋃S)∈Bignorabimus α"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"S={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nonem</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃S∈Bignorabimus α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀M. M∈S ⟹ M∈Bignorabimus α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonemp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"S≠{}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>powerset2up_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>infinite_super</span><span> </span><span>subset_eq</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonemp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Base</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cup</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Bignorabimus_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 13 🌐‹https://doi.org/10.1007/978-3-319-94205-6_15››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>boundeffect</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω (-BVG(α))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}∈Bignorabimus α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Bignorabimus_init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-BVG α = ⋃{xx. ∃x. xx={x} ∧ x∉BVG α}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* finite *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-BVG α)∈Bignorabimus α"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base</span><span> </span><span>h</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Bignorabimus_step mem_Collect_eq)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ variable set set ⇒ variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1. (∃v2. v2 ∈ x1 ∧ v2 ∉ Bignorabimus x0) = (VV x0 x1 ∈ x1 ∧ VV x0 x1 ∉ Bignorabimus x0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"VV α {{v} |v. v ∉ BVG α} ∉ {{v} |v. v ∉ BVG α} ∨ VV α {{v} |v. v ∉ BVG α} ∈ Bignorabimus α"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃{{v} |v. v ∉ BVG α} ∈ Bignorabimus α"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Bignorabimus_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>boundeffect_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V∩BVG(α)={} ⟹ (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>selectlike_compose</span><span> </span><span>sup.absorb_iff2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Static Analysis Observations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β ⟹ BVG(α) = BVG(β)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv α β"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(α) = BVG(β)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_subst_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>union_or</span><span> </span><span class="delimiter">=</span><span> </span><span>Set.Un_iff</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_union_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x∉A∪B) = (x∉A ∧ x∉B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_self</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv ω x d ∈ selectlike X ω {x}) = (d=ω(x) ∧ ω ∈ X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_repv_self</span><span> </span><span>Vagree_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span> </span><span>repv_self</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x≠y ⟹ (repv ω x d ∈ selectlike X ω {y}) = (repv ω x d ∈ X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x≠y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{y}⊆-{x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv ω x d ∈ selectlike X ω {y}) ⟹ (repv ω x d ∈ X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>selectlike_def</span><span> </span><span>Vagree_repv</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>x</span><span> </span><span>d</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv ω x d ∈ X) ⟹ (repv ω x d ∈ selectlike X ω {y})"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-{x}›</span></span></span><span class="delimiter">]</span><span> </span><span>Vagree_repv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">=</span><span>d</span><span class="delimiter">]</span><span>
</span><span>  </span><span>selectlike_antimon</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹{y}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>W</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-{x}›</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>h</span><span class="delimiter">]</span><span> </span><span>Vagree_sym</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹repv ω x d›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-{x}›</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_other_converse</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x≠y ⟹ (repv ω x d ∈ X) = (repv ω x d ∈ selectlike X ω {y})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_other</span><span> </span><span>HOL.eq_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x≠y ⟹ y∉BVG(Assign x θ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_other_converse</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign_meta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀I ω. term_sem I θ ω = ω(x)) ⟹ BVG(Assign x θ) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I θ ω ≠ ω(x) ⟹ BVG(Assign x θ) = {x}"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using repv_selectlike_self BVG_assign_other BVG_def BVG_elem*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x θ) ⊆ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>singleton_iff</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fact</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀I ω. term_sem I θ ω = ω(x)) ⟹ BVG(Assign x θ) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I ω. term_sem I θ ω ≠ ω(x) ⟹ x ∈ BVG(Assign x θ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fact</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I θ ω ≠ ω(x) ⟹ BVG(Assign x θ) = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x θ) = (if (∀I ω. term_sem I θ ω = ω(x)) then {} else {x})"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span>repv_selectlike_other</span><span> </span><span>BVG_assign_other</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x θ) ⊆ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>singletonI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I ω. term_sem I θ ω = ω(x) ⟹ BVG(Assign x θ) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I ω. term_sem I θ ω ≠ ω(x) ⟹ x ∈ BVG(Assign x θ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I ω. term_sem I θ ω ≠ ω(x) ⟹ BVG(Assign x θ) = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c0</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_ODE_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y≠RVar x ⟹ y≠DVar x ⟹ y∉BVG(ODE x θ)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using nonBVG_rule selectlike_equal_cocond_rule solves_ODE_def*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>yx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y≠RVar x"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>yxp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y≠DVar x"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∉BVG(ODE x θ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonBVG_inc_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I (ODE x θ) X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃F T. Vagree ω (F(0)) (-{DVar x}) ∧ F(T) ∈ X ∧ solves_ODE I F x θ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>F</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω (F(0)) (-{DVar x}) ∧ F(T) ∈ X ∧ solves_ODE I F x θ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ω (F(0)) (-{DVar x}) ∧ F(T) ∈ (selectlike X ω {y}) ∧ solves_ODE I F x θ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>yx</span><span> </span><span>yxp</span><span> </span><span>solves_Vagree</span><span> </span><span>Vagree_def</span><span> </span><span>similar_selectlike_mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃F T. Vagree ω (F(0)) (-{DVar x}) ∧ F(T) ∈ (selectlike X ω {y}) ∧ solves_ODE I F x θ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I (ODE x θ) (selectlike X ω {y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This result could be strengthened to a conditional equality based on the RHS values›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_ODE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(ODE x θ) ⊆ {RVar x,DVar x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_ODE_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_test</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Test φ) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>game_sem.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_choice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Choice α β) ⊆ BVG(α) ∪ BVG(β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>game_sem.simps</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_union_or</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
  have f1: "⋀ω I X. (ω ∈ game_sem I α X ∪ game_sem I β X) = 
  (ω ∈ game_sem I α X ∨ ω ∈ game_sem I β X)" by (rule union_or)
  have f2: "⋀ω I X. (ω ∉ game_sem I α (selectlike X ω {x}) ∪ game_sem I β (selectlike X ω {x})) =
  (ω ∉ game_sem I α (selectlike X ω {x}) ∧ ω ∉ game_sem I β (selectlike X ω {x}))" by (rule not_union_or)
  let ?lhs = "{x. ∃I ω X.
           ω ∈ game_sem I α X ∪ game_sem I β X ∧
           ω ∉ game_sem I α (selectlike X ω {x}) ∪ game_sem I β (selectlike X ω {x})}"
  let ?rhs = "{x. ∃I ω X. ω ∈ game_sem I α X ∧ ω ∉ game_sem I α (selectlike X ω {x})} ∪
       {x. ∃I ω X. ω ∈ game_sem I β X ∧ ω ∉ game_sem I β (selectlike X ω {x})}"
  show "?lhs⊆?rhs" using f1 f2 by auto
qed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>select_nonBV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(α) ⟹ selectlike (game_sem I α (selectlike X ω {x})) ω {x} = selectlike (game_sem I α X) ω {x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I α (selectlike X ω {x})) ω {x} ⊆ selectlike (game_sem I α X) ω {x}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span>selectlike_shrinks</span><span> </span><span>selectlike_antimon</span><span> </span><span>Bignorabimus_single</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>selectlike_union</span><span> </span><span>sup.absorb_iff1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nonbound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}∩BVG(α)={}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I α X) ω {x} ⊆ selectlike (game_sem I α (selectlike X ω {x})) ω {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>μ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ ∈ selectlike (game_sem I α X) ω {x}"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* "V∩BVG(α)={} ⟹ (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω V))" *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ ∈ selectlike (game_sem I α (selectlike X μ {x})) ω {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>μ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹{x}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span class="delimiter">=</span><span>α</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>fact</span><span class="delimiter">]</span><span> </span><span>nonbound</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplD</span><span> </span><span>ComplI</span><span> </span><span>co_selectlike</span><span> </span><span>not_union_or</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"μ ∈ selectlike (game_sem I α (selectlike X ω {x})) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_Vagree</span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_compose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Compose α β) ⊆ BVG(α) ∪ BVG(β)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding BVG_def game_sem.simps using game_union union_or not_union_or selectlike_shrinks monotone selectlike_compose*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈BVG(Compose α β)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ BVG α ∪ BVG β"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG α ∪ BVG(β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nβ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(β)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(α)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I.∃ω.∃X. ω ∈ game_sem I (Compose α β) X ∧ ω ∉ game_sem I (Compose α β) (selectlike X ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>adef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I (Compose α β) X ∧ ω ∉ game_sem I (Compose α β) (selectlike X ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I α (game_sem I β X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∉ game_sem I α (game_sem I β (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X ω {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nα</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nαc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nβ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nβc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω X. (ω ∈ game_sem I β X) = (ω ∈ game_sem I β (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I α (selectlike (game_sem I β X) ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>nαc</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹game_sem I β X›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∉ game_sem I α (selectlike (game_sem I β ?Y) ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>nαc</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹game_sem I β ?Y›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∉ game_sem I α (selectlike (game_sem I β X) ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nβ</span><span> </span><span>selectlike_Vagree</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I β ?Y) ω {x} = selectlike (game_sem I β X) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nβ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>select_nonBV</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span>c3</span><span> </span><span>nβc</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The converse inclusion does not hold generally, because
   ‹BVG(x := x+1; x:= x-1) = {} ≠ BVG(x := x+1) ∪ BVG(x := x-1) = {x}››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Compose (Assign x (Plus (Var x) (Number 1))) (Assign x (Plus (Var x) (Number (-1))))) 
    ≠ BVG(Assign x (Plus (Var x) (Number 1))) ∪ BVG(Assign x (Plus (Var x) (Number (-1))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>selectlike_def</span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Loop α) ⊆ BVG(α)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈BVG(Loop α)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ BVG(α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x ∈ BVG(α))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG α"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nα</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nαc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω X. (ω ∈ game_sem I α X) = (ω ∈ game_sem I α (selectlike X ω {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∉BVG(Loop α)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using BVG_nonelem*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonBVG_rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λZ. X ∪ game_sem I α Z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λY. (selectlike X ω {x}) ∪ game_sem I α Y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λZ Y. selectlike Z ω {x} = selectlike Y ω {x}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R (lfp ?f) (lfp ?g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_lockstep_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?f›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?g›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?R›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monof</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monog</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A ω {x} = selectlike B ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* using selectlike_union nα select_nonBV IH by (smt insert_absorb2 insert_def selectlike_compose singleton_conv smt_solver=cvc4)  *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ∪ game_sem I α A) ω {x} = selectlike X ω {x} ∪ selectlike (game_sem I α A) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike X ω {x} ∪ selectlike (game_sem I α (selectlike A ω {x})) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nα</span><span> </span><span>select_nonBV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike X ω {x} ∪ selectlike (game_sem I α (selectlike B ω {x})) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike (selectlike X ω {x} ∪ game_sem I α B) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_union</span><span> </span><span>nα</span><span> </span><span>select_nonBV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ∪ game_sem I α A) ω {x} = selectlike (selectlike X ω {x} ∪ game_sem I α B) ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(A,B)∈M. selectlike A ω {x} = selectlike B ω {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_proj_mem</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>M</span><span class="delimiter">]</span><span> </span><span>snd_proj_mem</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>M</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>selectlike_Sup</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹{x}›</span></span></span><span class="delimiter">]</span><span> </span><span>sup_corr_eq_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
          have "selectlike (⋃fst_proj M) ω {x} = ⋃{selectlike A ω {x} | A. A∈fst_proj M}" using selectlike_Sup by simp
          also have "... = ⋃{selectlike B ω {x} | B. B∈snd_proj M}" using sup_corr_eq_chain[OF IH] by simp
          also have "... = selectlike (⋃snd_proj M) ω {x}" using selectlike_Sup by simp
          finally show "selectlike (⋃fst_proj M) ω {x} = selectlike (⋃snd_proj M) ω {x}" .
        qed*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω ∈ game_sem I (Loop α) X) = (ω ∈ game_sem I (Loop α) (selectlike X ω {x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>lfp_def</span><span> </span><span>selectlike_self</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (simp add: selectlike_self game_sem_loop_back)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Dual α) ⊆ BVG(α)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding game_sem.simps using BVG_elem selectlike_co_selectlike co_selectlike selectlike_complement selectlike_antimon*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈BVG(Dual α)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈BVG α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃I.∃ω.∃X. ω ∈ game_sem I (Dual α) X ∧ ω ∉ game_sem I (Dual α) (selectlike X ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>ω</span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>adef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I (Dual α) X ∧ ω ∉ game_sem I (Dual α) (selectlike X ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∉ game_sem I α (- X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I α (- selectlike X ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"- selectlike X ω {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ game_sem I α ?Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∉ game_sem I α (selectlike ?Y ω {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>selectlike_co_selectlike</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>selectlike_shrinks</span><span> </span><span>monotone</span><span> </span><span>dual_order.trans</span><span> </span><span>subset_Compl_singleton</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈BVG(α)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="USubst">
<div class="head"><h1>Theory USubst</h1>
<span class="command">theory</span> <span class="name">USubst</span><br/>
<span class="keyword">imports</span> <a href="Coincidence.html"><span class="name">Coincidence</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"USubst"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>          
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹uniform substitution representation as tuple of partial maps from identifiers to type-compatible replacements.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>usubst</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ⇀ trm) × (ident ⇀ trm) × (ident ⇀ fml) × (ident ⇀ game)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SConst</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ (ident ⇀ trm)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst ≡ (λ(F0, _, _, _). F0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SFuncs</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ (ident ⇀ trm)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs ≡ (λ(_, F, _, _). F)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SPreds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ (ident ⇀ fml)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds ≡ (λ(_, _, P, _). P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SGames</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ (ident ⇀ game)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames ≡ (λ(_, _, _, G). G)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹crude approximation of size which is enough for termination arguments›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usubstsize</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstsize σ = (if (dom (SFuncs σ) = {} ∧ dom (SPreds σ) = {}) then 1 else 2)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dot is some fixed constant function symbol that is reserved for the purposes of the substitution›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dot</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dot = Const (dotid)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strict Mechanism for Handling Substitution Partiality in Isabelle›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Optional terms that result from a substitution, either actually a term or just none to indicate that the substitution clashed›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>trmo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undeft</span><span class="delimiter">::</span><span> </span><span>trmo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undeft ≡ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Aterm</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trmo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Aterm ≡ Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeft_None</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"undeft=None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aterm_Some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Aterm θ=Some θ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeft_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(θ≠undeft) = (∃t. θ=Aterm t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Plus on defined terms, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Pluso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ⇒ trmo ⇒ trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Pluso (Aterm θ) (Aterm η) = Aterm(Plus θ η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pluso undeft η = undeft"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pluso θ undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Times on defined terms, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Timeso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ⇒ trmo ⇒ trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Timeso (Aterm θ) (Aterm η) = Aterm(Times θ η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Timeso undeft η = undeft"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Timeso θ undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Differentialo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ⇒ trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Differentialo (Aterm θ) = Aterm(Differential θ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Differentialo undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pluso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Pluso θ η = undeft) = (θ=undeft ∨ η=undeft)"</span></span></span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pluso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Timeso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Timeso θ η = undeft) = (θ=undeft ∨ η=undeft)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Timeso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Differentialo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Differentialo θ = undeft) = (θ=undeft)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Differentialo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fmlo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undeff</span><span class="delimiter">::</span><span> </span><span>fmlo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undeff ≡ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Afml</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ⇒ fmlo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Afml ≡ Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>gameo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"game option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undefg</span><span class="delimiter">::</span><span> </span><span>gameo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undefg ≡ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Agame</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ gameo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame ≡ Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeff_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(φ≠undeff) = (∃f. φ=Afml f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undefg_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(α≠undefg) = (∃g. α=Agame g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Geq on defined terms, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Geqo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ⇒ trmo ⇒ fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Geqo (Aterm θ) (Aterm η) = Afml(Geq θ η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geqo undeft η = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geqo θ undeft = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Not on defined formulas, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Noto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ⇒ fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Noto (Afml φ) = Afml(Not φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Noto undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹And on defined formulas, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Ando</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ⇒ fmlo ⇒ fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ando (Afml φ) (Afml ψ) = Afml(And φ ψ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ando undeff ψ = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ando φ undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Exists on defined formulas, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Existso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ⇒ fmlo ⇒ fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Existso x (Afml φ) = Afml(Exists x φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Existso x undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Diamond on defined games/formulas, strict undeft otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Diamondo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ⇒ fmlo ⇒ fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Diamondo (Agame α) (Afml φ) = Afml(Diamond α φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Diamondo undefg φ = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Diamondo α undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Geqo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Geqo θ η = undeff) = (θ=undeft ∨ η=undeft)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Geqo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Noto_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Noto φ = undeff) = (φ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Noto.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ando_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Ando φ ψ = undeff) = (φ=undeff ∨ ψ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ando.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Existso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Existso x φ = undeff) = (φ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Existso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Diamondo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Diamondo α φ = undeff) = (α=undefg ∨ φ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamondo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assign on defined terms, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Assigno</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ⇒ trmo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Assigno x (Aterm θ) = Agame(Assign x θ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Assigno x undeft = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ODEo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ⇒ trmo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ODEo x (Aterm θ) = Agame(ODE x θ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ODEo x undeft = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test on defined formulas, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Testo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Testo (Afml φ) = Agame(Test φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Testo undeff = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Choice on defined games, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Choiceo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ⇒ gameo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Choiceo (Agame α) (Agame β) = Agame(Choice α β)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Choiceo α undefg = undefg"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Choiceo undefg β = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compose on defined games, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Composeo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ⇒ gameo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Composeo (Agame α) (Agame β) = Agame(Compose α β)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Composeo α undefg = undefg"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Composeo undefg β = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Loop on defined games, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Loopo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Loopo (Agame α) = Agame(Loop α)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Loopo undefg = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Dual on defined games, strict undefg otherwise ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Dualo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ⇒ gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Dualo (Agame α) = Agame(Dual α)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Dualo undefg = undefg"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Assigno_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Assigno x θ = undefg) = (θ=undeft)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ODEo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ODEo x θ = undefg) = (θ=undeft)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Testo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Testo φ = undefg) = (φ=undeff)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Choiceo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Choiceo α β = undefg) = (α=undefg ∨ β=undefg)"</span></span></span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Composeo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Composeo α β = undefg) = (α=undefg ∨ β=undefg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Composeo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Loopo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Loopo α = undefg) = (α=undefg)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Loopo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Dualo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Dualo α = undefg) = (α=undefg)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recursive Application of One-Pass Uniform Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹dotsubstt θ› is the dot substitution ‹{. ~&gt; θ}› substituting a term for the . function symbol›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dotsubstt</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ usubst"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dotsubstt θ = (
         (λf. (if f=dotid then (Some(θ)) else None)),
         (λ_. None),
         (λ_. None),
         (λ_. None)
  )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usappconst</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ variable set ⇒ ident ⇒ (trmo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst σ U f ≡ (case SConst σ f of Some r ⇒ if FVT(r)∩U={} then Aterm(r) else undeft | None ⇒ Aterm(Const f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>usubstappt</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ variable set ⇒ (trm ⇒ trmo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Var x)     = Aterm (Var x)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Number r)  = Aterm (Number r)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f)   = usappconst σ U f"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Func f θ)  =
  (case usubstappt σ U θ of undeft   ⇒ undeft
                          | Aterm σθ ⇒ (case SFuncs σ f of Some r ⇒ if FVT(r)∩U={} then usubstappt(dotsubstt σθ) {} r else undeft | None ⇒ Aterm(Func f σθ)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Plus θ η)  = Pluso (usubstappt σ U θ) (usubstappt σ U η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Times θ η) = Timeso (usubstappt σ U θ) (usubstappt σ U η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Differential θ) = Differentialo (usubstappt σ allvars θ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measures [λ(σ,U,θ). usubstsize σ , λ(σ,U,θ). size θ]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubstsize_def</span><span> </span><span>dotsubstt_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Expand let constructs automatically *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Let_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>usubstappf</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ variable set ⇒ (fml ⇒ fmlo)"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usubstappp</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ variable set ⇒ (game ⇒ variable set × gameo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ)   = 
  (case usubstappt σ U θ of undeft   ⇒ undeff
                          | Aterm σθ ⇒ (case SPreds σ p of Some r ⇒ if FVF(r)∩U={} then usubstappf(dotsubstt σθ) {} r else undeff | None ⇒ Afml(Pred p σθ)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Geq θ η)    = Geqo (usubstappt σ U θ) (usubstappt σ U η)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Not φ)      = Noto (usubstappf σ U φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (And φ ψ)    = Ando (usubstappf σ U φ) (usubstappf σ U ψ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Exists x φ) = Existso x (usubstappf σ (U∪{x}) φ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Diamond α φ) = (let Vα = usubstappp σ U α in Diamondo (snd Vα) (usubstappf σ (fst Vα) φ))"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Game a)   =
  (case SGames σ a of Some r ⇒ (U∪BVG(r),Agame r)
                    | None   ⇒ (allvars,Agame(Game a)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Assign x θ) = (U∪{x}, Assigno x (usubstappt σ U θ))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Test φ) = (U, Testo (usubstappf σ U φ))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Choice α β) =
    (let Vα = usubstappp σ U α in
     let Wβ = usubstappp σ U β in
     (fst Vα∪fst Wβ, Choiceo (snd Vα) (snd Wβ)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Compose α β) =
    (let Vα = usubstappp σ U α in
     let Wβ = usubstappp σ (fst Vα) β in
     (fst Wβ, Composeo (snd Vα) (snd Wβ)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Loop α) =
    (let V = fst(usubstappp σ U α) in
     (V, Loopo (snd(usubstappp σ V α))))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Dual α) =
    (let Vα = usubstappp σ U α in (fst Vα, Dualo (snd Vα)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (ODE x θ) = (U∪{RVar x,DVar x}, ODEo x (usubstappt σ (U∪{RVar x,DVar x}) θ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measures [(λk. usubstsize (case k of Inl(σ,U,φ) ⇒ σ | Inr(σ,U,α) ⇒ σ)) , (λk. case k of Inl (σ,U,φ) ⇒ size φ | Inr (σ,U,α) ⇒ size α)]"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubstsize_def</span><span> </span><span>dotsubstt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Induction Principles for Uniform Substitutions›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usubstappt_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>usubstappt.induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Var</span><span> </span><span>Number</span><span> </span><span>Const</span><span> </span><span>FuncMatch</span><span> </span><span>Plus</span><span> </span><span>Times</span><span> </span><span>Differential</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usubstappfp_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>usubstappf_usubstappp.induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Pred</span><span> </span><span>Geq</span><span> </span><span>Not</span><span> </span><span>And</span><span> </span><span>Exists</span><span> </span><span>Diamond</span><span>  </span><span>Game</span><span> </span><span>Assign</span><span> </span><span>Test</span><span> </span><span>Choice</span><span> </span><span>Compose</span><span> </span><span>Loop</span><span> </span><span>Dual</span><span> </span><span>ODE</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simple Observations for Automation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹More automation for Case›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usappconst_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = Some r ⟹ FVT(r)∩U={} ⟹ usappconst σ U f = Aterm(r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = None ⟹ usappconst σ U f = Aterm(Const f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = Some r ⟹ FVT(r)∩U≠{} ⟹ usappconst σ U f = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usappconst_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst σ U f≠undeft ⟹
  SConst σ f = None ∨ (∃r. SConst σ f = Some r ∧ FVT(r)∩U={})"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if option.collapse usappconst_def)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst σ U f≠undeft"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = None ∨ (∃r. SConst σ f = Some r ∧ FVT(r)∩U={})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>usappconst_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>f</span><span class="delimiter">]</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_const</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = Some r ⟹ FVT(r)∩U={} ⟹ usubstappt σ U (Const f) = Aterm(r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = None ⟹ usubstappt σ U (Const f) = Aterm(Const f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f = Some r ⟹ FVT(r)∩U≠{} ⟹ usubstappt σ U (Const f) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_const_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f)≠undeft ⟹
  SConst σ f = None ∨ (∃r. SConst σ f = Some r ∧ FVT(r)∩U={})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usappconst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f = Some r ⟹ FVT(r)∩U={} ⟹ usubstappt σ U θ = Aterm σθ ⟹
  usubstappt σ U (Func f θ) = usubstappt (dotsubstt σθ) {} r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f=None ⟹  usubstappt σ U θ = Aterm σθ ⟹ usubstappt σ U (Func f θ) = Aterm(Func f σθ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ = undeft ⟹ usubstappt σ U (Func f θ) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f = Some r ⟹ FVT(r)∩U≠{} ⟹ usubstappt σ U (Func f θ) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Func f θ) ≠ undeft ⟹
  usubstappt σ U θ ≠ undeft ∧
    (SFuncs σ f = None ∨ (∃r. SFuncs σ f = Some r ∧ FVT(r)∩U={}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>undeft_equiv</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>usubstappt_func2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (cases "usubstappt σ U θ") (auto) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_plus_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Plus θ η) ≠ undeft ⟹
  usubstappt σ U θ ≠ undeft ∧ usubstappt σ U η ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pluso_undef</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_times_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Times θ η) ≠ undeft ⟹
  usubstappt σ U θ ≠ undeft ∧ usubstappt σ U η ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Timeso_undef</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_differential_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Differential θ) ≠ undeft ⟹
  usubstappt σ allvars θ ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Differentialo_undef</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = Some r ⟹ FVF(r)∩U={} ⟹ usubstappt σ U θ = Aterm σθ ⟹
  usubstappf σ U (Pred p θ) = usubstappf (dotsubstt σθ) {} r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = None ⟹ usubstappt σ U θ = Aterm σθ ⟹ usubstappf σ U (Pred p θ) = Afml(Pred p σθ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ = undeft ⟹ usubstappf σ U (Pred p θ) = undeff"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = Some r ⟹ FVF(r)∩U≠{} ⟹ usubstappf σ U (Pred p θ) = undeff"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ undeff ⟹
  usubstappt σ U θ ≠ undeft ∧
    (SPreds σ p = None ∨ (∃r. SPreds σ p = Some r ∧ FVF(r)∩U={}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>undeff_equiv</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft ⟹ usubstappt σ U η ≠ undeft ⟹
  usubstappf σ U (Geq θ η) = Afml(Geq (the (usubstappt σ U θ)) (the (usubstappt σ U η)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geq_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Geq θ η) ≠ undeff ⟹
  usubstappt σ U θ ≠ undeft ∧ usubstappt σ U η ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Geqo_undef</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geqr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Geq θ η) ≠ undeff ⟹
  usubstappf σ U (Geq θ η) = Afml(Geq (the (usubstappt σ U θ)) (the (usubstappt σ U η)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq</span><span> </span><span>usubstappf_geq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_exists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Exists x φ) ≠ undeff ⟹
  usubstappf σ U (Exists x φ) = Afml(Exists x (the (usubstappf σ (U∪{x}) φ)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Existso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_game</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a = Some r ⟹ usubstappp σ U (Game a) = (U∪BVG(r),Agame(r))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a = None ⟹ usubstappp σ U (Game a) = (allvars,Agame(Game a))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_choice</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Choice α β) =
  (fst(usubstappp σ U α)∪fst(usubstappp σ U β), Choiceo (snd(usubstappp σ U α)) (snd(usubstappp σ U β)))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_choice_conv</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U (Choice α β)) ≠ undefg ⟹
  snd(usubstappp σ U α) ≠ undefg ∧ snd(usubstappp σ U β) ≠ undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Compose α β) =
  (fst(usubstappp σ (fst(usubstappp σ U α)) β), Composeo (snd(usubstappp σ U α)) (snd(usubstappp σ (fst(usubstappp σ U α)) β)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Loop α) =
  (fst(usubstappp σ U α), Loopo (snd(usubstappp σ (fst(usubstappp σ U α)) α)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_dual</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp σ U (Dual α) =
  (fst(usubstappp σ U α), Dualo (snd (usubstappp σ U α)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness of Uniform Substitution›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹USubst Application is a Function of Deterministic Result›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft ⟹ usubstappt σ V θ ≠ undeft ⟹
  usubstappt σ U θ = usubstappt σ V θ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usappconst_def usubstappt.simps(3))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) = (case SConst σ f of None ⇒ Aterm (Const f) | Some t ⇒ if FVT t ∩ U = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::trm option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ (if FVT (the (SConst σ f)) ∩ U = {} then Aterm (the (SConst σ f)) else undeft) = usappconst σ U f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ FVT (the (SConst σ f)) ∩ U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ (if FVT (the (SConst σ f)) ∩ V = {} then Aterm (the (SConst σ f)) else undeft) = usappconst σ V f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ FVT (the (SConst σ f)) ∩ V = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ usubstappt σ U (Const f) = usappconst σ V f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) ≠ usubstappt σ V (Const f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) ≠ (case SConst σ f of None ⇒ Aterm (Const f) | Some t ⇒ if FVT t ∩ V = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Func</span><span> </span><span>f</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (cases "SFuncs σ f") (auto simp add: usubstappt_func)*)</span></span></span></span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usubstappt.simps(4))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ U = {} then usubstappt (dotsubstt t) {} ta else undeft)) ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::trm option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ V θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ V = {} then usubstappt (dotsubstt t) {} ta else undeft)) ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ V θ ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (trm.Func f θ) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>Func</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ (if FVT (the (SFuncs σ f)) ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) else undeft) = usubstappt σ U (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>Func</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ FVT (the (SFuncs σ f)) ∩ U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Func</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ V θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ V = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ V = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ (if FVT (the (SFuncs σ f)) ∩ V = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) else undeft) = usubstappt σ V (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ FVT (the (SFuncs σ f)) ∩ V = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Func</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (trm.Func f θ) ≠ usubstappt σ V (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ V = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft) ≠ Aterm (trm.Func f (the (usubstappt σ V θ)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span>f7</span><span> </span><span>f6</span><span> </span><span>f5</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>θ1</span><span> </span><span>θ2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>θ1</span><span> </span><span>θ2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Differentialo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U φ ≠ undeff ⟹ usubstappf σ V φ ≠ undeff ⟹ usubstappf σ U φ = usubstappf σ V φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ V α) ≠ undefg ⟹ snd(usubstappp σ U α) = snd(usubstappp σ V α)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>p</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span>usubstappf_pred</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (metis usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt t) {} f else undeff)) ≠ undeff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::fml option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ U θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ U θ))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ V θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt t) {} f else undeff)) ≠ undeff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ = usubstappt σ V θ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>usubstappt_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) = (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeff then (case za of None ⇒ z::fml option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ V θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff ⟶ usubstappf σ U (Pred p θ) = usubstappf σ V (Pred p θ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ usubstappf σ V (Pred p θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ (if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>f5</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ U θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ U θ))) {} f else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p))›</span></span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)›</span></span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p))›</span></span></span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹usubstappf σ U (Pred p θ) ≠ usubstappf σ V (Pred p θ)›</span></span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>θ</span><span> </span><span>η</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Geqo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Noto.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ando_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Existso_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamondo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Composeo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Loopo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U φ ≠ undeff ⟹ usubstappf σ V φ ≠ undeff ⟹ usubstappf σ U φ = usubstappf σ V φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ V α) ≠ undefg ⟹ snd(usubstappp σ U α) = snd(usubstappp σ V α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitutions are Antimonotone in Taboos›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α) ⊇ U"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_pair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (a,b) = a"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_pair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (a,b) = b"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ usubstappt σ U θ ≠ undeft ⟹
  usubstappt σ U θ = usubstappt σ V θ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt disjoint_iff_not_equal option.case_eq_if set_rev_mp usappconst_def usubstappt.simps(3))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) = (case SConst σ f of None ⇒ Aterm (Const f) | Some t ⇒ if FVT t ∩ U = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::trm option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ (if FVT (the (SConst σ f)) ∩ U = {} then Aterm (the (SConst σ f)) else undeft) = usappconst σ U f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ⟶ FVT (the (SConst σ f)) ∩ U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V Va. (V ∩ Va = {}) = (∀v. (v::variable) ∈ V ⟶ (∀va. va ∈ Va ⟶ v ≠ va))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) ≠ usubstappt σ V (Const f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (Const f) ≠ (case SConst σ f of None ⇒ Aterm (Const f) | Some t ⇒ if FVT t ∩ V = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f ≠ undeft ∧ FVT (the (SConst σ f)) ∩ V = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>usappconst_def</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Func</span><span> </span><span>f</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt disjoint_iff_not_equal option.case_eq_if subset_iff usubstappt.simps(4))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ U = {} then usubstappt (dotsubstt t) {} ta else undeft)) ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::trm option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ U = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ U θ))) | Some t ⇒ if FVT t ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ U θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ = undeft ∨ usubstappt σ U θ = usubstappt σ V θ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.IH</span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ (if FVT (the (SFuncs σ f)) ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) else undeft) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ (if FVT (the (SFuncs σ f)) ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) else undeft) = usubstappt σ U (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ FVT (the (SFuncs σ f)) ∩ U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ V ⊆ - FVT (the (SFuncs σ f))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ V θ of None ⇒ undeft | Some t ⇒ (case SFuncs σ f of None ⇒ Aterm (trm.Func f t) | Some ta ⇒ if FVT ta ∩ V = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ V = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) = (case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ U = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft ⟶ usubstappt (dotsubstt (the (usubstappt σ V θ))) {} (the (SFuncs σ f)) = usubstappt σ U (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U (trm.Func f θ) ≠ usubstappt σ V (trm.Func f θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SFuncs σ f of None ⇒ Aterm (trm.Func f (the (usubstappt σ V θ))) | Some t ⇒ if FVT t ∩ V = {} then usubstappt (dotsubstt (the (usubstappt σ V θ))) {} t else undeft) ≠ Aterm (trm.Func f (the (usubstappt σ V θ)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f ≠ undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span>f8</span><span> </span><span>f7</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>inf.commute</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>θ1</span><span> </span><span>θ2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>θ1</span><span> </span><span>θ2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Differentialo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitutions of Games have monotone taboo output›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_fst_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U⊆V ⟹ fst(usubstappp σ U α) ⊆ fst(usubstappp σ V α)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_choice</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_compose</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_loop</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_dual</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ usubstappf σ U φ ≠ undeff ⟹ usubstappf σ U φ = usubstappf σ V φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ U α) = snd(usubstappp σ V α)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ usubstappf σ U φ ≠ undeff ⟹ usubstappf σ V φ ≠ undeff"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ V α) ≠ undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>p</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span>usubstappf_pred</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Un_mono disjoint_eq_subset_Compl empty_subsetI inf.commute option.case_eq_if sup.absorb_iff1 sup.absorb_iff2 usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v. v ∉ V ∨ v ∈ U"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeff then (case za of None ⇒ z::fml option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt t) {} f else undeff)) ≠ undeff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z f za. if za = undeft then (case za of None ⇒ z::fml option | Some x ⇒ f x) = z else (case za of None ⇒ z | Some x ⇒ f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt σ U θ of None ⇒ undeff | Some t ⇒ (case SPreds σ p of None ⇒ Afml (Pred p t) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ U θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ U θ))) {} f else undeff)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ = usubstappt σ V θ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt_antimon</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff ⟶ usubstappf σ U (Pred p θ) = usubstappf σ V (Pred p θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ variable set ⇒ variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1. (∃v2. v2 ∈ x1 ∧ (∃v3. v3 ∈ x0 ∧ v2 = v3)) = (vv x0 x1 ∈ x1 ∧ (∃v3. v3 ∈ x0 ∧ vv x0 x1 = v3))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vva</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ⇒ variable set ⇒ variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V Va. (V ∩ Va ≠ {} ∨ (∀v. v ∉ V ∨ (∀va. va ∉ Va ∨ v ≠ va))) ∧ (V ∩ Va = {} ∨ vv Va V ∈ V ∧ vva Va V ∈ Va ∧ vv Va V = vva Va V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f10</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(FVF (the (SPreds σ p)) ∩ V ≠ {} ∨ (∀v. v ∉ FVF (the (SPreds σ p)) ∨ (∀va. va ∉ V ∨ v ≠ va))) ∧ (FVF (the (SPreds σ p)) ∩ V = {} ∨ vv V (FVF (the (SPreds σ p))) ∈ FVF (the (SPreds σ p)) ∧ vva V (FVF (the (SPreds σ p))) ∈ V ∧ vv V (FVF (the (SPreds σ p))) = vva V (FVF (the (SPreds σ p))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vv V (FVF (the (SPreds σ p))) ∉ FVF (the (SPreds σ p)) ∨ vva V (FVF (the (SPreds σ p))) ∉ V ∨ vv V (FVF (the (SPreds σ p))) ≠ vva V (FVF (the (SPreds σ p)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf σ V (Pred p θ)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(if FVF (the (SPreds σ p)) ∩ V = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ usubstappf σ V (Pred p θ)›</span></span></span><span> </span><span>calculation</span><span> </span><span>f5</span><span> </span><span>f7</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ V (Pred p θ) = undeff ⟶ SPreds σ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) ≠ usubstappf σ U (Pred p θ)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ U θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ U θ))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>f7</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) ≠ usubstappf σ U (Pred p θ)›</span></span></span><span> </span><span>f5</span><span> </span><span>f7</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds σ p)) ∩ U = {} ⟶ SPreds σ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds σ p)) ∩ U = {} ∧ usubstappf σ V (Pred p θ) = undeff ⟶ SPreds σ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f10</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds σ p)) ∩ U ≠ {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ U θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ U θ))) {} f else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff) ≠ (case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹FVF (the (SPreds σ p)) ∩ U ≠ {}›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds σ p of None ⇒ Afml (Pred p (the (usubstappt σ V θ))) | Some f ⇒ if FVF f ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} f else undeff) ≠ (if FVF (the (SPreds σ p)) ∩ U = {} then usubstappf (dotsubstt (the (usubstappt σ V θ))) {} (the (SPreds σ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹FVF (the (SPreds σ p)) ∩ U ≠ {}›</span></span></span><span> </span><span>option.discI</span><span> </span><span>option.expand</span><span> </span><span>option.sel</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ V (Pred p θ) = undeff ⟶ SPreds σ p = undeff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>θ</span><span> </span><span>η</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Geqo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Noto_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ando_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Existso_undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_mono</span><span> </span><span>subsetI</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Diamondo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span>ODEo_undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Un_mono</span><span> </span><span>order_refl</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Choiceo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_compose</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span class="delimiter">=</span><span>α</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span class="delimiter">=</span><span>β</span><span class="delimiter">]</span><span> </span><span>usubstappp_compose</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span class="delimiter">=</span><span>α</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span class="delimiter">=</span><span>β</span><span class="delimiter">]</span><span>
</span><span>          </span><span>Composeo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>α</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹snd (usubstappp σ U α)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹snd (usubstappp σ (fst (usubstappp σ U α)) β)›</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>Composeo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>α</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹snd (usubstappp σ V α)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹snd (usubstappp σ (fst (usubstappp σ V α)) β)›</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>snd_conv</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
            from Compose have ca: "snd (usubstappp σ U (α ;; β)) ≠ undefg" by simp
            have decU: "snd (usubstappp σ U (α ;; β)) = Composeo (snd(usubstappp σ U α)) (snd(usubstappp σ (fst(usubstappp σ U α)) β))" using usubstappp_compose by simp
            have decV: "snd (usubstappp σ V (α ;; β)) = Composeo (snd(usubstappp σ V α)) (snd(usubstappp σ (fst(usubstappp σ V α)) β))" using usubstappp_compose by simp
            from Compose have fact1: "snd(usubstappp σ V α) ≠ undefg" using Composeo_undef by auto 
            from Compose have fact2: "snd(usubstappp σ (fst(usubstappp σ U α)) β) ≠ undefg" using Composeo_undef by auto 
            have rel: "fst(usubstappp σ V α) ⊆ fst(usubstappp σ U α)" using ‹V⊆U› usubstappp_fst_mon by auto
            from Compose have fact3: "snd(usubstappp σ (fst(usubstappp σ V α)) β) ≠ undefg" using fact2 rel by auto 
            then show ?thesis by (simp add: Composeo_undef fact1)
          qed*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Loopo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ usubstappf σ U φ ≠ undeff ⟹ usubstappf σ U φ = usubstappf σ V φ"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ U α) = snd(usubstappp σ V α)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ usubstappf σ U φ ≠ undeff ⟹ usubstappf σ U φ = usubstappf σ V φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆U ⟹ snd(usubstappp σ U α) ≠ undefg ⟹ snd(usubstappp σ U α) = snd(usubstappp σ V α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Taboo Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (Loop α)) ≠ undefg ⟹
  snd(usubstappp σ U α) ≠ undefg ∧
  snd(usubstappp σ (fst(usubstappp σ U α)) α) ≠ undefg"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubstappp_loop Loopo_undef*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (Loop α)) ≠ undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α) ⊇ U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ (fst(usubstappp σ U α)) α) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>usubstappp_loop</span><span> </span><span>Loopo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U α) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>usubstappp_loop</span><span> </span><span>Loopo_undef</span><span> </span><span>fact</span><span> </span><span>usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 13 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_taboos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U α)≠undefg ⟹ fst(usubstappp σ U α) ⊇ U ∪ BVG(the (snd(usubstappp σ U α)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign</span><span> </span><span>Assigno_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Assigno.elims</span><span> </span><span>BVG_assign_other</span><span> </span><span>fst_pair</span><span> </span><span>option.sel</span><span> </span><span>singletonI</span><span> </span><span>snd_pair</span><span> </span><span>subsetI</span><span> </span><span>union_or</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_ODE</span><span> </span><span>ODEo_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ODEo.elims</span><span> </span><span>Un_least</span><span> </span><span>fst_pair</span><span> </span><span>option.sel</span><span> </span><span>snd_conv</span><span> </span><span>sup.coboundedI2</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_test</span><span> </span><span>Testo_undef</span><span> </span><span>usubst_taboos_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubstappp.simps Product_Type.fst_conv Product_Type.snd_conv BVG_choice*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α) ⊇ U ∪ BVG(the (snd(usubstappp σ U α)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U β) ⊇ U ∪ BVG(the (snd(usubstappp σ U β)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp σ U α))) ∪ BVG(the (snd(usubstappp σ U β))) ⊇ BVG(the (snd(usubstappp σ U (Choice α β))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_choice</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Choice.prems Choiceo.simps(1) Choiceo_undef option.collapse option.sel snd_pair usubstappp_choice)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp σ U α)) ∪∪ the (snd (usubstappp σ U β))) = Choiceo (snd (usubstappp σ U α)) (snd (usubstappp σ U β))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Choice.prems</span><span> </span><span>Choiceo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_choice</span><span> </span><span>Choice.prems</span><span> </span><span>Pair_inject</span><span> </span><span>option.collapse</span><span> </span><span>option.inject</span><span> </span><span>surjective_pairing</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IHa</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IHb</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α) ∪ fst(usubstappp σ U β) ⊇ U ∪ BVG(the (snd(usubstappp σ U α))) ∪ BVG(the (snd(usubstappp σ U β)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U (Choice α β)) ⊇ U ∪ BVG(the (snd(usubstappp σ U α))) ∪ BVG(the (snd(usubstappp σ U β)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U (Choice α β)) ⊇ U ∪ BVG(the (snd(usubstappp σ U (Choice α β))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ ?V β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ U ∪ BVG(the (snd(usubstappp σ U α)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ⊇ ?V ∪ BVG(the (snd(usubstappp σ ?V β)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp σ U α))) ∪ BVG(the (snd(usubstappp σ ?V β))) ⊇ BVG(the (snd(usubstappp σ U (Compose α β))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>BVG_compose</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Compose.prems Composeo.simps(1) Composeo_undef option.collapse option.sel snd_pair)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. z = undefg ∨ Agame (the z) = z"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>option.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp σ U α)) ;; the (snd (usubstappp σ (fst (usubstappp σ U α)) β))) = snd (usubstappp σ U (α ;; β))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compose.prems</span><span> </span><span>Composeo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_compose</span><span> </span><span>Compose.prems</span><span> </span><span>option.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ⊇ U ∪ BVG(the (snd(usubstappp σ U α))) ∪ BVG(the (snd(usubstappp σ ?V β)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span>IHa</span><span> </span><span>IHb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ⊇ U ∪ BVG(the (snd(usubstappp σ U (Compose α β))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U (Compose α β)) ⊇ U ∪ BVG(the (snd(usubstappp σ U (Compose α β))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ ?V α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>defα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp σ U α) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ U ∪ BVG(the (snd(usubstappp σ U α)))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defα</span><span> </span><span>usubstappp_loop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>σ</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span class="delimiter">=</span><span>α</span><span class="delimiter">]</span><span> </span><span>Loopo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>α</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹snd (usubstappp σ (fst (usubstappp σ U α)) α)›</span></span></span><span class="delimiter">]</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ⊇ ?V ∪ BVG(the (snd(usubstappp σ ?V α)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Loopo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Vfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ BVG(the (snd(usubstappp σ ?V α)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IHdef</span><span> </span><span>Loop.prems</span><span> </span><span>le_sup_iff</span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ U ∪ BVG(the (snd(usubstappp σ U (Loop α))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Vfix</span><span> </span><span>IHdef</span><span> </span><span>BVG_loop</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubstappp_loop_conv</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Loop.prems Loopo.simps(1) Un_mono option.collapse option.sel snd_pair sup.absorb_iff1)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. z = undefg ∨ Agame (the z) = z"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>option.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U α) ≠ undefg ∧ snd (usubstappp σ (fst (usubstappp σ U α)) α) ≠ undefg"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Loop.prems</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (Loop (the (snd (usubstappp σ (fst (usubstappp σ U α)) α)))) = snd (usubstappp σ U (Loop α))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_loop</span><span> </span><span>Loop.prems</span><span> </span><span>Vfix</span><span> </span><span>option.inject</span><span> </span><span>sup.absorb_iff1</span><span> </span><span>sup.mono</span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U (Loop α)) ⊇ U ∪ BVG(the (snd(usubstappp σ U (Loop α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using BVG_dual usubstappp.simps Let_def by auto*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ U ∪ BVG(the (snd(usubstappp σ U α)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Dualo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp σ U α))) ⊇ BVG(the (snd(usubstappp σ U (Dual α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>BVG_dual</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Dual.prems</span><span> </span><span>Dualo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Dualo.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>option.sel</span><span> </span><span>snd_pair</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ U ∪ BVG(the (snd(usubstappp σ U (Dual α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U (Dual α)) ⊇ U ∪ BVG(the (snd(usubstappp σ U (Dual α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Substitution Adjoints›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Modified interpretation ‹repI I f d› replaces the interpretation of constant function ‹f› in the interpretation ‹I› with ‹d››</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>repc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" interp ⇒ ident ⇒ real ⇒ interp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repc I f d ≡  mkinterp((λc. if c = f then d else Consts I c), Funcs I, Preds I, Games I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_consts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (repc I f d) c = (if (c=f) then d else Consts I c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_funcs</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (repc I f d) = Funcs I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_preds</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (repc I f d) = Preds I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_games</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games (repc I f d) = Games I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mon_mono</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_stays_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (case SGames σ a of None ⇒ Games I a | Some r ⇒ λX. game_sem I r X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjE_realizer2</span><span> </span><span>option.case_distrib</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof -
  have "∀z p b i f. (mono (case z of None ⇒ f | Some x ⇒ game_sem i x) ∨ ¬ (case z of None ⇒ b | Some x ⇒ p x)) ∨ ¬ mono f"
  by (metis (no_types) disjE_realizer2 game_sem_mono)
  then show ?thesis
  by (metis (no_types) game_sem.simps(1) game_sem_mono option.case_distrib)
  qed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹adjoint interpretation ‹adjoint σ I ω› to ‹σ› of interpretation ‹I› in state ‹ω››</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjoint</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ (interp ⇒ state ⇒ interp)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint σ I ω = mkinterp(
         (λf. (case SConst σ f of None ⇒ Consts I f| Some r ⇒ term_sem I r ω)),
         (λf. (case SFuncs σ f of None ⇒ Funcs I f | Some r ⇒ λd. term_sem (repc I dotid d) r ω)),
         (λp. (case SPreds σ p of None ⇒ Preds I p | Some r ⇒ λd. ω∈fml_sem (repc I dotid d) r)),
         (λa. (case SGames σ a of None ⇒ Games I a | Some r ⇒ λX. game_sem I r X))
  )"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simple Observations about Adjoints›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_consts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (adjoint σ I ω) f = term_sem I (case SConst σ f of Some r ⇒ r | None ⇒ Const f) ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f=None"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (adjoint σ I ω) f = (case SFuncs σ f of None ⇒ Funcs I f | Some r ⇒ λd. term_sem (repc I dotid d) r ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs_match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f=Some r ⟹ Funcs (adjoint σ I ω) f = (λd. term_sem (repc I dotid d) r ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f=None ⟹ Funcs (adjoint σ I ω) f = Funcs I f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (adjoint σ I ω) p = (case SPreds σ p of None ⇒ Preds I p | Some r ⇒ λd. ω∈fml_sem (repc I dotid d) r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p=None ⟹ Preds (adjoint σ I ω) p = Preds I p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds_match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p=Some r ⟹ Preds (adjoint σ I ω) p = (λd. ω∈fml_sem (repc I dotid d) r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_games</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games (adjoint σ I ω) a = (case SGames σ a of None ⇒ Games I a | Some r ⇒ λX. game_sem I r X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_stays_mon</span><span> </span><span>Games_mkinterp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt θ) I ω = repc I dotid (term_sem I θ ω)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding adjoint_def dotsubstt_def adjoint_consts adjoint_funcs_skip adjoint_preds adjoint_games*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt θ) I ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"repc I dotid (term_sem I θ ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>feq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs ?lhs = Funcs ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_funcs</span><span> </span><span>adjoint_funcs</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>peq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds ?lhs = Preds ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_preds</span><span> </span><span>adjoint_preds</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games ?lhs = Games ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_games</span><span> </span><span>adjoint_games</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ceq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts ?lhs = Consts ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_consts</span><span>  </span><span>adjoint_consts</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mkinterp_eq</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?lhs›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>J</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?rhs›</span></span></span><span class="delimiter">]</span><span> </span><span>feq</span><span> </span><span>peq</span><span> </span><span>geq</span><span> </span><span>ceq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitution for Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 15 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U ⟹ usubstappt σ U θ≠undeft ⟹
    term_sem I (the (usubstappt σ U θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vaouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>defouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ≠undeft"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ≠undeft ⟹ term_sem I (the (usubstappt σ U θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>θ</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaouter</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ν</span><span> </span><span>ω</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>usubstappt_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst σ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_consts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVT(r)∩U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Const</span><span> </span><span>usubstappt_const</span><span> </span><span>usubstappt_const_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.inject</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Const f))) ν = term_sem I r ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>varcond</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem I r ω"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Const</span><span> </span><span>coincidence_term_cor</span><span class="delimiter">[</span><span>of</span><span> </span><span>ν</span><span> </span><span>ω</span><span> </span><span>U</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Consts (adjoint σ I ω) f"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Some</span><span> </span><span>adjoint_consts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint σ I ω) (Const f) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Const f))) ν = term_sem (adjoint σ I ω) (Const f) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>FuncMatch</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>f</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs σ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubterm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FuncMatch.IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt_func_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>None</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span> </span><span>IHsubterm</span><span> </span><span>adjoint_funcs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>FuncMatch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.case_eq_if</span><span> </span><span>option.sel</span><span> </span><span>term_sem.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVT(r)∩U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FuncMatch</span><span> </span><span>usubstappt_func</span><span> </span><span>usubstappt_func2</span><span> </span><span>usubstappt_func_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubterm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω. Uvariation ν ω {} ⟹ term_sem I (the (usubstappt (dotsubstt (the (usubstappt σ U θ))) {} r)) ν = term_sem (adjoint (dotsubstt (the (usubstappt σ U θ))) I ω) r ν"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U θ)) ν"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IHsubterm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dotIa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt (the (usubstappt σ U θ))) I ν"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Func f θ))) ν = term_sem I (the (usubstappt (dotsubstt (the (usubstappt σ U θ))) {} r)) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem ?dotIa r ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ν</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span class="delimiter">]</span><span> </span><span>Uvariation_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (repc I dotid ?d) r ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>θ</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹the (usubstappt σ U θ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (repc I dotid ?d) r ω"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_term_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω'</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>θ</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹repc I dotid ?d›</span></span></span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*I.^dω⟦σf(⋅)⟧  also have "... = term_sem ?dotIa r ω" using coincidence_term_cor[of ν ω U r ?dotIa] uv varcond by simp*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Funcs (adjoint σ I ω) f)(?d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs_match</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Funcs (adjoint σ I ω) f)(term_sem (adjoint σ I ω) θ ν)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint σ I ω) (Func f θ) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Func f θ))) ν = term_sem (adjoint σ I ω) (Func f θ) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>θ</span><span> </span><span>η</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>θ</span><span> </span><span>η</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Differential</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ allvars θ ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_differential_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Differential</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. term_sem I (the (usubstappt σ allvars θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>Uvariation_univ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by auto*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Differential θ))) ν = term_sem I (Differential (the (usubstappt σ allvars θ))) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum(λx. ν(DVar x)*deriv(λX. term_sem I (the (usubstappt σ allvars θ)) (repv ν (RVar x) X))(ν(RVar x)))(allidents)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum(λx. ν(DVar x)*deriv(λX. term_sem (adjoint σ I ω) θ (repv ν (RVar x) X))(ν(RVar x)))(allidents)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint σ I ω) (Differential θ) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U (Differential θ))) ν = term_sem (adjoint σ I ω) (Differential θ) ν"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitution for Formulas and Games›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Separately Prove Crucial Ingredient for the ODE Case of ‹usubst_fml_game››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem I θ ν = term_sem J η ν)
  ⟹ solves_ODE I F x θ = solves_ODE J F x η"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span>Vagree_def</span><span> </span><span>solves_ODE_def</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt double_complement)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem I θ ν = term_sem J η ν"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem J η ν = term_sem I θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I J θ η. (⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem I θ ν = term_sem J η ν)
   ⟹ solves_ODE I F x θ ⟹ solves_ODE J F x η"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>θ</span><span> </span><span>η</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vaflow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem I θ ν = term_sem J η ν"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x θ"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vaflow</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sol</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE J F x η"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span>coincidence_term</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_complement</span><span> </span><span>solves_Vagree</span><span> </span><span>sol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x θ = solves_ODE J F x η"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>θ</span><span class="delimiter">=</span><span>θ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>η</span><span class="delimiter">=</span><span>η</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>va</span><span class="delimiter">]</span><span> </span><span>one</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>θ</span><span class="delimiter">=</span><span>η</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>η</span><span class="delimiter">=</span><span>θ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>va2</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ {RVar x,DVar x} θ ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt σ {RVar x,DVar x} θ)) = solves_ODE (adjoint σ I (F(0))) F x θ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀F θ ζ. solves_ODE I F x θ ⟹ Uvariation (F(ζ)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. Uvariation ν (F(0)) {RVar x,DVar x} ⟹ term_sem I (the (usubstappt σ {RVar x,DVar x} θ)) ν = term_sem (adjoint σ I (F(0))) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubst_term</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>vaflow</span><span> </span><span>solves_ODE_def</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>same_ODE_same_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode_ext</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>     </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) ω (U∪{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ (U∪{RVar x,DVar x}) θ ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) = solves_ODE (adjoint σ I ω) F x θ"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubst_ode usubstappt_det usubstappt_antimon Uvariation_Vagree Uvariation_mon *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀F θ ζ. solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) ⟹ Uvariation (F(ζ)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀F θ ζ. solves_ODE (adjoint σ I ω) F x θ ⟹ Uvariation (F(ζ)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν. Uvariation ν (F(0)) (U∪{RVar x,DVar x}) ⟹ term_sem I (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) ν = term_sem (adjoint σ I (F(0))) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_refl</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l2r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) ⟹ solves_ODE (adjoint σ I ω) F x θ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaflow1</span><span> </span><span>subdef</span><span> </span><span>same_ODE_same_sol</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span>uv</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt sup_commute sup_left_idem)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ interp ⇒ trm ⇒ interp ⇒ char ⇒ (real ⇒ variable ⇒ real) ⇒ variable ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1 x2 x3 x4 x5. (∃v6. Uvariation v6 (x5 0) {RVar x4, DVar x4} ∧ term_sem x3 x2 v6 ≠ term_sem x1 x0 v6) = (Uvariation (rr x0 x1 x2 x3 x4 x5) (x5 0) {RVar x4, DVar x4} ∧ term_sem x3 x2 (rr x0 x1 x2 x3 x4 x5) ≠ term_sem x1 x0 (rr x0 x1 x2 x3 x4 x5))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F 0) ω (insert (RVar x) (U ∪ {DVar x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{DVar x} ∪ {} ∪ {DVar x} = insert (DVar x) ({DVar x} ∪ {} ∪ {}) ⟶ {RVar x} ∪ {DVar x} ∪ insert (RVar x) (U ∪ {DVar x}) = insert (RVar x) (U ∪ {DVar x})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{DVar x} ∪ {} ∪ {DVar x} = insert (DVar x) ({DVar x} ∪ {} ∪ {}) ∧ Uvariation (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F) ω ({RVar x} ∪ {DVar x} ∪ insert (RVar x) (U ∪ {DVar x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Uvariation (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F) (F 0) {RVar x, DVar x} ∨ term_sem (USubst.adjoint σ I ω) θ (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F) = term_sem I (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>subdef</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Uvariation (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F) (F 0) {RVar x, DVar x} ∨ term_sem (USubst.adjoint σ I ω) θ (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F) = term_sem I (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) (rr (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I θ (USubst.adjoint σ I ω) x F)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Uvariation_trans</span><span> </span><span>insert_is_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE (adjoint σ I ω) F x θ ⟹ solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaflow2</span><span> </span><span>subdef</span><span> </span><span>same_ODE_same_sol</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span>uv</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt sup_commute sup_left_idem)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE (USubst.adjoint σ I ω) F x θ"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ interp ⇒ trm ⇒ interp ⇒ char ⇒ (real ⇒ variable ⇒ real) ⇒ variable ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀x0 x1 x2 x3 x4 x5. (∃v6. Uvariation v6 (x5 0) {RVar x4, DVar x4} ∧ term_sem x3 x2 v6 ≠ term_sem x1 x0 v6) = (Uvariation (rr x0 x1 x2 x3 x4 x5) (x5 0) {RVar x4, DVar x4} ∧ term_sem x3 x2 (rr x0 x1 x2 x3 x4 x5) ≠ term_sem x1 x0 (rr x0 x1 x2 x3 x4 x5))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f c i t ia ta. Uvariation (rr ta ia t i c f) (f 0) {RVar c, DVar c} ∧ term_sem i t (rr ta ia t i c f) ≠ term_sem ia ta (rr ta ia t i c f) ∨ solves_ODE i f c t = solves_ODE ia f c ta"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F 0) ω ({RVar x, DVar x} ∪ U)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ ({RVar x, DVar x} ∪ U) θ ≠ undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (rr θ (USubst.adjoint σ I ω) (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I x F) ω ({RVar x, DVar x} ∪ ({RVar x, DVar x} ∪ U))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Uvariation (rr θ (USubst.adjoint σ I ω) (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I x F) (F 0) {RVar x, DVar x} ∨ term_sem I (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) (rr θ (USubst.adjoint σ I ω) (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I x F) = term_sem (USubst.adjoint σ I ω) θ (rr θ (USubst.adjoint σ I ω) (the (usubstappt σ (U ∪ {RVar x, DVar x}) θ)) I x F)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>usubst_term</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Uvariation_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r2l</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode_ext2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ (U∪{RVar x,DVar x}) θ ≠ undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>     </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) ω (U∪{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) = solves_ODE (adjoint σ I ω) F x θ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_ode_ext</span><span> </span><span>subdef</span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Separately Prove the Loop Case of ‹usubst_fml_game››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A∪B=B∪A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopfpτ</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ⇒ interp ⇒ (state set ⇒ state set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpτ α I X = lfp(λZ. X ∪ game_sem I α Z)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_game_loop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>IHαrec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω X. Uvariation ν ω (fst(usubstappp σ U α)) ⟹ snd (usubstappp σ (fst(usubstappp σ U α)) α)≠undefg ⟹ 
         (ν ∈ game_sem I (the (snd (usubstappp σ (fst(usubstappp σ U α)) α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (Loop α))≠undefg ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U (Loop α)))) X) = (ν ∈ game_sem (adjoint σ I ω) (Loop α) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (Loop α))≠undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>loopfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀α I X. loopfpτ α I X = game_sem I (Loop α) X"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopfpτ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?σαloopoff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (snd (usubstappp σ U (Loop α)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?σα</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (snd(usubstappp σ (fst(usubstappp σ U α)) α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?σαloop</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Loop ?σα"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>loopform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?σαloopoff = ?σαloop"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_loop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Loopo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>def</span><span> </span><span>option.exhaust_sel</span><span> </span><span>option.inject</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?τ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpτ ?σαloop I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ρ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpτ α (adjoint σ I ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀V. snd(usubstappp σ V α)≠undefg ⟹  fst(usubstappp σ V α) ⊇ BVG(the (snd(usubstappp σ V α)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀V W. snd(usubstappp σ V α)≠undefg ⟹ snd(usubstappp σ W α)≠undefg ⟹ (fst(usubstappp σ V α) ⊇ BVG(the (snd(usubstappp σ W α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact1</span><span> </span><span>usubst_taboos</span><span> </span><span>usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VgeqBV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ⊇ BVG(?σα)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span>fact2</span><span> </span><span>def</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uvV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ν ω (-?V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>Uvariation_mon</span><span> </span><span>double_compl</span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?τ(X) = game_sem I ?σαloop X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopfix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ρeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ρ(X) = game_sem (adjoint σ I ω) (Loop α) X"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopfix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τisρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (?τ(X)) ω (-?V)= selectlike (?ρ(X)) ω (-?V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λZ. X ∪ game_sem I ?σα Z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λY. X ∪ game_sem (adjoint σ I ω) α Y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λZ Y. selectlike Z ω (-?V) = selectlike Y ω (-?V)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R (lfp ?f) (lfp ?g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_lockstep_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?f›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?g›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹?R›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monof</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monog</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A ω (-?V) = selectlike B ω (-?V)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ∪ game_sem I ?σα A) ω (-?V) = selectlike (X ∪ game_sem (adjoint σ I ω) α B) ω (-?V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*[where ν=ω and V=‹?V› and X=‹X ∪ game_sem I ?σα A› and Y=‹X ∪ game_sem (adjoint σ I ω) α B›]*)</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>μ</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ω ?V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ X ∪ game_sem I ?σα A) = (μ ∈ X ∪ game_sem I ?σα (selectlike A μ (-BVG(?σα))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ X ∪ game_sem (adjoint σ I ω) α B) = (μ ∈ X ∪ game_sem I ?σα B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHαrec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>muvar</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (μ ∈ X ∪ game_sem I ?σα (selectlike B μ (-BVG(?σα))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈  X ∪ game_sem (adjoint σ I ω) α B) =  (μ ∈ X ∪ game_sem I ?σα (selectlike B μ (-BVG(?σα))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A μ (-BVG(?σα)) = selectlike B μ (-BVG(?σα))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHfp</span><span> </span><span>selectlike_antimon</span><span> </span><span>VgeqBV</span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>selectlike_equal_cocond</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt le_iff_sup)*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree μ ω (- fst (usubstappp σ U α))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>double_complement</span><span> </span><span>muvar</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A μ (- fst (usubstappp σ U α)) = selectlike B μ (- fst (usubstappp σ U α))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHfp</span><span> </span><span>selectlike_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Compl_subset_Compl_iff</span><span> </span><span>VgeqBV</span><span> </span><span>selectlike_compose</span><span> </span><span>sup.absorb_iff2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ X ∪ game_sem I ?σα A) = (μ ∈ X ∪ game_sem (adjoint σ I ω) α B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_Sup</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹-?V›</span></span></span><span class="delimiter">]</span><span> </span><span>fst_proj_def</span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>τeq</span><span> </span><span>loopfix</span><span> </span><span>loopfpτ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>τeq</span><span> </span><span>ρeq</span><span> </span><span>τisρ</span><span> </span><span>similar_selectlike_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uvV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>loopform</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_fml_game</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vaouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U φ≠undeff ⟹ (ν ∈ fml_sem I (the (usubstappf σ U φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U α)≠undefg ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U φ≠undeff ⟹ (ν ∈ fml_sem I (the (usubstappf σ U φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U α)≠undefg ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>φ</span><span> </span><span>α</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaouter</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ν</span><span> </span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ν</span><span> </span><span>ω</span><span> </span><span>X</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>usubstappfp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>p</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds σ p"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span>va</span><span class="delimiter">]</span><span> </span><span>adjoint_preds_skip</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Pred.prems(1) fml_sem.simps(1) mem_Collect_eq option.case_eq_if option.sel usubstappf.simps(1))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p V c t. usubstappf p V (Pred c t) = (if usubstappt p V t = undeft then undeff else case SPreds p c of None ⇒ Afml (Pred c (the (usubstappt p V t))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt p V t))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p V c t. if usubstappt p V t = undeft then usubstappf p V (Pred c t) = undeff else usubstappf p V (Pred c t) = (case SPreds p c of None ⇒ Afml (Pred c (the (usubstappt p V t))) | Some f ⇒ if FVF f ∩ V = {} then usubstappf (dotsubstt (the (usubstappt p V t))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf σ U (Pred p θ) = Afml (Pred p (the (usubstappt σ U θ)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>None</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀θ σ I. usubstappt σ U θ ≠ undeft ⟹ term_sem I (the (usubstappt σ U θ)) ν = term_sem (USubst.adjoint σ I ω) θ ν›</span></span></span><span> </span><span>adjoint_preds_skip</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF(r)∩U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span> </span><span>usubstappf_pred_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Pred</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_pred_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Pred</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω. Uvariation ν ω {} ⟹ (ν ∈ fml_sem I (the (usubstappf (dotsubstt (the (usubstappt σ U θ))) {} r))) = (ν ∈ fml_sem (adjoint (dotsubstt (the (usubstappt σ U θ))) I ω) r)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ U θ)) ν"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span>va</span><span> </span><span>subdef</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dotIa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt (the (usubstappt σ U θ))) I ν"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν∈fml_sem I (the (usubstappf σ U (Pred p θ)))) = (ν∈fml_sem I (the (usubstappf (dotsubstt (the (usubstappt σ U θ))) {} r)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν∈fml_sem ?dotIa r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ν</span><span class="delimiter">=</span><span>ν</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span class="delimiter">]</span><span> </span><span>Uvariation_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν∈fml_sem (repc I dotid ?d) r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>θ</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹the (usubstappt σ U θ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ω∈fml_sem (repc I dotid ?d) r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_formula_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ω</span><span class="delimiter">=</span><span>ν</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ω'</span><span class="delimiter">=</span><span>ω</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹repc I dotid ?d›</span></span></span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*I.^dω⟦σf(⋅)⟧  also have "... = term_sem ?dotIa r ω" using coincidence_term_cor[of ν ω U r ?dotIa] uv varcond by simp*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Preds (adjoint σ I ω) p)(?d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds_match</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Preds (adjoint σ I ω) p)(term_sem (adjoint σ I ω) θ ν)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν∈fml_sem (adjoint σ I ω) (Pred p θ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν∈fml_sem I (the (usubstappf σ U (Pred p θ)))) = (ν∈fml_sem (adjoint σ I ω) (Pred p θ))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>θ</span><span> </span><span>η</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* then show ?case using usubst_term usubstappf_geq usubstappf_geq_conv
          by (smt fml_sem.simps(2) mem_Collect_eq option.sel)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U η ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq_conv</span><span> </span><span>Geq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uvariation ν ω U›</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>def1</span><span class="delimiter">]</span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uvariation ν ω U›</span></span></span><span class="delimiter">,</span><span>OF</span><span> </span><span>def2</span><span class="delimiter">]</span><span> </span><span>usubstappf_geqr</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹usubstappf σ U (Geq θ η) ≠ undeff›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Noto_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>φ</span><span> </span><span>ψ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ando_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω. Uvariation ν ω (U∪{x}) ⟹ (ν ∈ fml_sem I (the (usubstappf σ (U∪{x}) φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Exists</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*from Exists have subdef: "usubstappt σ (U∪{x}) θ ≠ undeft" by auto*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀d. Uvariation (repv ν x d) ω (U∪{x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_repv</span><span> </span><span>Uvariation_trans</span><span> </span><span>Uvariation_sym</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exists.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν∈fml_sem I (the (usubstappf σ U (Exists x φ)))) = (ν∈fml_sem I (Exists x (the (usubstappf σ (U∪{x}) φ))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_exists</span><span> </span><span>Exists.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃d. (repv ν x d)∈fml_sem I (the (usubstappf σ (U∪{x}) φ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃d. (repv ν x d)∈fml_sem (adjoint σ I ω) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>Uvar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν∈fml_sem (adjoint σ I ω) (Exists x φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν∈fml_sem I (the (usubstappf σ U (Exists x φ)))) =  (ν∈fml_sem (adjoint σ I ω) (Exists x φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>α</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. Uvariation ν ω U ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHφ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω. Uvariation ν ω (fst(usubstappp σ U α)) ⟹ (ν ∈ fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Diamondo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ fml_sem I (the (usubstappf σ U (Diamond α φ)))) = (ν ∈ fml_sem I (let Vα = usubstappp σ U α in Diamond (the (snd Vα)) (the (usubstappf σ (fst Vα) φ))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamond.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Diamondo.elims</span><span> </span><span>option.sel</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ fml_sem I (Diamond (the (snd(usubstappp σ U α))) (the (usubstappf σ (fst(usubstappp σ U α)) φ))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ))) ν (-BVG(the (snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ fml_sem I (the (usubstappf σ U (Diamond α φ)))) = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ))) ν (-BVG(the (snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ fml_sem (adjoint σ I ω) (Diamond α φ)) = (ν ∈ game_sem (adjoint σ I ω) α (fml_sem (adjoint σ I ω) φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (fml_sem (adjoint σ I ω) φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHα</span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (fml_sem (adjoint σ I ω) φ) ν (-BVG(the (snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ fml_sem (adjoint σ I ω) (Diamond α φ)) = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (fml_sem (adjoint σ I ω) φ) ν (-BVG(the (snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ))) ν (-BVG(the (snd(usubstappp σ U α)))) = selectlike (fml_sem (adjoint σ I ω) φ) ν (-BVG(the (snd(usubstappp σ U α))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>μ</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ν (BVG(the (snd(usubstappp σ U α))))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uμω</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ω ?V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>uv</span><span> </span><span>Uvariation_trans</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Diamond.prems(1) Diamondo.simps(2) usubstappf.simps(6))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uμν</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ν (BVG(the (snd(usubstappp σ U α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>muvar</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uνω</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>uv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ω (U ∪ BVG(the (snd(usubstappp σ U α))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Uμν</span><span> </span><span>Uνω</span><span class="delimiter">]</span><span> </span><span>union_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HOL.back_subst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Diamond.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Diamondo_undef</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ fml_sem (adjoint σ I ω) φ) = (μ ∈ fml_sem I (the (usubstappf σ (fst(usubstappp σ U α)) φ)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>uv</span><span> </span><span>IHφ</span><span> </span><span>boundeffect</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>Uμω</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ fml_sem I (the (usubstappf σ (fst (usubstappp σ U α)) φ))) = (μ ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ fml_sem I (the (usubstappf σ U (Diamond α φ)))) = (ν ∈ fml_sem (adjoint σ I ω) (Diamond α φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* games *)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_games</span><span> </span><span>usubstappp_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames σ a"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span> </span><span>Assigno_undef</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Assigno.elims game_sem.simps(2) mem_Collect_eq option.sel snd_pair usubstappp.simps(2))*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ U θ ≠ undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Assigno_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ν x (term_sem (USubst.adjoint σ I ω) θ ν) ∈ X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ν x (term_sem I (the (usubstappt σ U θ)) ν) ∈ X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ν x (term_sem (USubst.adjoint σ I ω) θ ν) ∈ X ⟶ (ν ∈ game_sem I (the (snd (usubstappp σ U (x := θ)))) X) = (ν ∈ game_sem (USubst.adjoint σ I ω) (x := θ) X)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ν x (term_sem (USubst.adjoint σ I ω) θ ν) ∉ X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ν x (term_sem I (the (usubstappt σ U θ)) ν) ∉ X ∧ repv ν x (term_sem (USubst.adjoint σ I ω) θ ν) ∉ X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Testo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. Uvariation ν ω U ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHβ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. Uvariation ν ω U ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U β))) X) = (ν ∈ game_sem (adjoint σ I ω) β X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHα</span><span> </span><span>IHβ</span><span> </span><span>uv</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Choice.prems(1) Choiceo.elims game_sem.simps(4) option.sel snd_pair union_or usubstappp_choice) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp σ U α))) = snd (usubstappp σ U α)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp σ U β))) = snd (usubstappp σ U β)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (α ∪∪ β)) = Agame (the (snd (usubstappp σ U α)) ∪∪ the (snd (usubstappp σ U β)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (the (snd (usubstappp σ U α))) X ∪ game_sem I (the (snd (usubstappp σ U β))) X = game_sem I (the (snd (usubstappp σ U (α ∪∪ β)))) X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν ∉ game_sem I (the (snd (usubstappp σ U β))) X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∉ game_sem I (the (snd (usubstappp σ U (α ∪∪ β)))) X) = (ν ∈ game_sem (adjoint σ I ω) (α ∪∪ β) X) ⟶ ν ∉ game_sem I (the (snd (usubstappp σ U β))) X ∧ ν ∉ game_sem (adjoint σ I ω) (α ∪∪ β) X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHα</span><span> </span><span>IHβ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∉ game_sem I (the (snd (usubstappp σ U (α ∪∪ β)))) X) ≠ (ν ∈ game_sem (adjoint σ I ω) (α ∪∪ β) X)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHα</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHβ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. Uvariation ν ω U ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHβ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω X. Uvariation ν ω ?V ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ ?V β))) X) = (ν ∈ game_sem (adjoint σ I ω) β X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the (snd (usubstappp σ U (Compose α β)))) X) = (ν ∈ game_sem I (Compose (the (snd(usubstappp σ U α))) (the (snd(usubstappp σ ?V β)))) X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Compose.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Composeo.elims</span><span> </span><span>option.sel</span><span> </span><span>snd_pair</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (game_sem I (the (snd(usubstappp σ ?V β))) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (game_sem I (the (snd(usubstappp σ ?V β))) X) ν (-BVG(the(snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the (snd (usubstappp σ U (Compose α β)))) X) = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike (game_sem I (the (snd(usubstappp σ ?V β))) X) ν (-BVG(the(snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem (adjoint σ I ω) (Compose α β) X) = (ν ∈ game_sem (adjoint σ I ω) α ((game_sem (adjoint σ I ω) β) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) ((game_sem (adjoint σ I ω) β) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHα</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike ((game_sem (adjoint σ I ω) β) X) ν (-BVG(the(snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem (adjoint σ I ω) (Compose α β) X) = (ν ∈ game_sem I (the (snd(usubstappp σ U α))) (selectlike ((game_sem (adjoint σ I ω) β) X) ν (-BVG(the(snd(usubstappp σ U α))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I (the (snd(usubstappp σ ?V β))) X) ν (-BVG(the(snd(usubstappp σ U α)))) = selectlike ((game_sem (adjoint σ I ω) β) X) ν (-BVG(the(snd(usubstappp σ U α))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>μ</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ν (BVG(the(snd(usubstappp σ U α))))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uμω</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ω ?V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>uv</span><span> </span><span>Uvariation_trans</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Compose.prems(1) Composeo_undef snd_pair usubstappp.simps(5))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation μ ω (BVG (the (snd (usubstappp σ U α))) ∪ U)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Uvariation_trans</span><span> </span><span>muvar</span><span> </span><span>uv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_mon</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Compose.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Composeo_undef</span><span> </span><span>Pair_inject</span><span> </span><span>prod.collapse</span><span> </span><span>usubstappp_compose</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (metis (no_types) Uvariation_mon union_comm usubst_taboos)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ game_sem I (the(snd(usubstappp σ ?V β))) X) = (μ ∈ game_sem (adjoint σ I ω) β X)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>uv</span><span> </span><span>IHβ</span><span> </span><span>boundeffect</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>Uμω</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(μ ∈ game_sem I (the(snd(usubstappp σ ?V β))) X) = (μ ∈ game_sem (adjoint σ I ω) β X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the(snd (usubstappp σ U (Compose α β)))) X) = (ν ∈ game_sem (adjoint σ I ω) (Compose α β) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp σ U α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>selfdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (Loop α)) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHαrec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ν ω X. Uvariation ν ω ?V ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ ?V α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the (snd (usubstappp σ U (Loop α)))) X) = (ν ∈ game_sem (adjoint σ I ω) (Loop α) X)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_game_loop</span><span> </span><span>IHαrec</span><span> </span><span>Loop.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>selfdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (rule usubst_game_loop[OF uv (*IHα*) IHαrec])*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHα</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀X. Uvariation ν ω U ⟹ (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U (α^d)) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*show ?case using IHα[OF uv]
    by (smt Compl_iff Dual.prems(1) Dualo.elims game_sem.simps(7) option.sel snd_pair usubstappp.simps(7))*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ -game_sem I (the (snd (usubstappp σ U α))) (-X)) = (ν ∈ -game_sem (adjoint σ I ω) α (-X))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHα</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I ((the (snd (usubstappp σ U α)))^d) X) = (ν ∈ game_sem (adjoint σ I ω) (α^d) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_dual</span><span> </span><span>Dualo_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ V α. snd (usubstappp σ U (α^d)) = Dualo (snd (usubstappp σ U α))"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp σ U α) ≠ undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Dualo_undef</span><span> </span><span>def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(ν ∈ game_sem I ((the (snd (usubstappp σ U α)))^d) X) = (ν ∈ game_sem (USubst.adjoint σ I ω) (α^d) X)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>σ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>θ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ODE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt σ (U∪{RVar x,DVar x}) θ ≠ undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ODEo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ODE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt σ (U∪{RVar x,DVar x}) θ)) ν = term_sem (adjoint σ I ω) θ ν"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo_undef</span><span> </span><span>fst_pair</span><span> </span><span>snd_conv</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubst_term</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>usubstappt_antimon</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the (snd (usubstappp σ U (ODE x θ)))) X) = (ν ∈ game_sem I (the (ODEo x (usubstappt σ (U∪{RVar x,DVar x}) θ))) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem I (ODE x (the (usubstappt σ (U∪{RVar x,DVar x}) θ))) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃F T. Vagree ν (F(0)) (-{DVar x}) ∧ F(T) ∈ X ∧ solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃F T. Uvariation ν (F(0)) {DVar x} ∧ F(T) ∈ X ∧ solves_ODE I F x (the (usubstappt σ (U∪{RVar x,DVar x}) θ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃F T. Uvariation ν (F(0)) {DVar x} ∧ F(T) ∈ X ∧ solves_ODE (adjoint σ I ω) F x θ)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_ode_ext2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subdef</span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>solves_Vagree_trans</span><span> </span><span>Uvariation_trans</span><span> </span><span>Uvariation_sym_rel</span><span> </span><span>Uvariation_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∃F T. Vagree ν (F(0)) (-{DVar x}) ∧ F(T) ∈ X ∧ solves_ODE (adjoint σ I ω) F x θ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ν ∈ game_sem (adjoint σ I ω) (ODE x θ) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ν ∈ game_sem I (the (snd (usubstappp σ U (ODE x θ)))) X) = (ν ∈ game_sem (adjoint σ I ω) (ODE x θ) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 16 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_fml</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U ⟹ usubstappf σ U φ ≠ undeff ⟹
    (ν ∈ fml_sem I (the (usubstappf σ U φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma 17 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_game</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ν ω U ⟹ snd (usubstappp σ U α) ≠ undefg ⟹
    (ν ∈ game_sem I (the (snd (usubstappp σ U α))) X) = (ν ∈ game_sem (adjoint σ I ω) α X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness of Uniform Substitution of Formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>usubsta</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ fml ⇒ fmlo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta σ φ ≡ usubstappf σ {} φ"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 18 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta σ φ ≠ undeff ⟹ valid φ ⟹ valid (the (usubsta σ φ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta σ φ ≠ undeff"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prem</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>premc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ω. ω ∈ fml_sem I φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (the (usubsta σ φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>ω</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω ∈ fml_sem I (the (usubsta σ φ))) = (ω ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubst_fml</span><span> </span><span>def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = True"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>premc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ω ∈ fml_sem I (the (usubsta σ φ))) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ fml_sem I (the (usubstappf σ {} φ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness of Uniform Substitution of Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Uniform Substitution applied to a rule or inference›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usubstr</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ⇒ inference ⇒ inference option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≡ if (usubstappf σ allvars (snd R) ≠ undeff ∧ (∀φ∈set (fst R). usubstappf σ allvars φ ≠ undeff)) then
    Some(map(the o (usubstappf σ allvars))(fst R), the (usubstappf σ allvars (snd R)))
  else
    None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simple observations about applying uniform substitutions to a rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None ⟹
  usubstappf σ allvars (snd R) ≠ undeff ∧
  (∀φ∈set (fst R). usubstappf σ allvars φ ≠ undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((append A B), C) ≠ None) = (usubstr σ (A, C) ≠ None ∧ usubstr σ (B, C) ≠ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((append A B), C) ≠ None) ⟹ (usubstr σ (A, C) ≠ None ∧ usubstr σ (B, C) ≠ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((Cons A B), C) ≠ None) = (usubstr σ ([A], C) ≠ None ∧ usubstr σ (B, C) ≠ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((Cons A B), C) ≠ None) ⟹ (usubstr σ ([A], C) ≠ None ∧ usubstr σ (B, C) ≠ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((Cons A B), C) ≠ None) ⟹
  the (usubstr σ ((Cons A B), C)) = (Cons (the (usubstappf σ allvars A)) (fst (the (usubstr σ (B, C)))), snd (the (usubstr σ ([A], C))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef</span><span> </span><span>map_cons</span><span> </span><span>usubstr_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((Cons A B), C) ≠ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((Cons A B), C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr σ ?R) = (map(the o (usubstappf σ allvars))(fst ?R) , the (usubstappf σ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf σ allvars A)) (map(the o (usubstappf σ allvars))(B)) , the (usubstappf σ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf σ allvars A)) (fst (the (usubstr σ (B, C)))) , the (usubstappf σ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf σ allvars A)) (fst (the (usubstr σ (B, C)))) , snd (the (usubstr σ ([A], C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr σ ((Cons A B), C)) = (Cons (the (usubstappf σ allvars A)) (fst (the (usubstr σ (B, C)))) , snd (the (usubstr σ ([A], C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((append A B), C) ≠ None) ⟹
  the (usubstr σ ((append A B), C)) = (append (fst (the (usubstr σ (A, C)))) (fst (the (usubstr σ (B, C)))), snd (the (usubstr σ (A, C))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt fst_pair map_append option.sel snd_pair usubstr_def)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr σ ((append A B), C) ≠ None)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((append A B), C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr σ ?R) = (map(the o (usubstappf σ allvars))(fst ?R) , the (usubstappf σ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (map(the o (usubstappf σ allvars))(fst ?R) , snd (the (usubstr σ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span> </span><span>sndI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (append (map(the o (usubstappf σ allvars))(A)) (map(the o (usubstappf σ allvars))(B)) , snd (the (usubstr σ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>map_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (append (fst (the (usubstr σ (A, C)))) (fst (the (usubstr σ (B, C)))), snd (the (usubstr σ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr σ ((append A B), C)) = (append (fst (the (usubstr σ (A, C)))) (fst (the (usubstr σ (B, C)))), snd (the (usubstr σ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None ⟹ length (fst (the (usubstr σ R))) = length (fst R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>length_map</span><span> </span><span>option.sel</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_nth</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None ⟹ 0≤k ⟹ k&lt;length (fst R) ⟹
   nth (fst (the (usubstr σ R))) k = the (usubstappf σ allvars (nth (fst R) k))"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding usubstr_def using usubstr_length
  by (smt comp_apply fst_pair nth_map option.sel)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0≤k"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k&lt;length (fst R)"</span></span></span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nth (fst (the (usubstr σ R))) k = the (usubstappf σ allvars (nth (fst R) k))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>R</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pair</span><span> </span><span>A</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>D</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. usubstr σ (E, C) ≠ None ⟹ 0 ≤ k ⟹ k &lt; length E ⟹ nth (fst (the (usubstr σ (E, C)))) k = the (usubstappf σ allvars (nth E k))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>usubstr_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n&lt;length E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nati</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0≤n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ (E, C) ≠ None"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nth (fst (the (usubstr σ (E, C)))) n = the (usubstappf σ allvars (nth (fst (E,C)) n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>nati</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>smaller</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>usubstr_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 19 of 🌐‹http://arxiv.org/abs/1902.07230››</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_rule_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None ⟹ locally_sound R ⟹ locally_sound (the (usubstr σ R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R ≠ None"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?σD</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr σ R"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ω</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>usubst_fml</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>substeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I ν φ. usubstappf σ allvars φ ≠ undeff ⟹ (ν ∈ fml_sem I (the (usubstappf σ allvars φ))) = (ν ∈ fml_sem (adjoint σ I ω) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_univ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>substval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀I. usubstappf σ allvars φ ≠ undeff ⟹ valid_in I (the (usubstappf σ allvars φ)) = valid_in (adjoint σ I ω) φ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound (the (usubstr σ R))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k≥0. k &lt; length (fst (the (usubstr σ R))) ⟶ valid_in I (nth (fst (the (usubstr σ R))) k)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k≥0. k &lt; length (fst R) ⟶ valid_in (adjoint σ I ω) (nth (fst R) k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>substval</span><span> </span><span>usubstr_nth</span><span> </span><span>usubstr_length</span><span> </span><span>substeq</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>def</span><span> </span><span>nth_mem</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in (adjoint σ I ω) (snd R)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prem</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (snd (the (usubstr σ R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml</span><span> </span><span>substeq</span><span> </span><span>usubstr_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>def</span><span> </span><span>option.sel</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Ids">
<div class="head"><h1>Theory Ids</h1>
<span class="command">theory</span> <span class="name">Ids</span><br/>
<span class="keyword">imports</span> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ids"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some specific identifiers used in Axioms›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgid1</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgid1 ≡ CHR ''a''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgid2</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgid2 ≡ CHR ''b''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgidc</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgidc ≡ CHR ''c''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgidd</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgidd ≡ CHR ''d''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pid1</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pid1  ≡ CHR ''p''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pid2</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pid2  ≡ CHR ''q''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fid1</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fid1  ≡ CHR ''f''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>xid1</span><span class="delimiter">::</span><span>variable</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xid1  ≡ RVar (CHR ''x'')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Axioms">
<div class="head"><h1>Theory Axioms</h1>
<span class="command">theory</span> <span class="name">Axioms</span><br/>
<span class="keyword">imports</span> <a href="Denotational_Semantics.html"><span class="name">Denotational_Semantics</span></a> <a href="Ids.html"><span class="name">Ids</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Axioms"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ids"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Axioms and Axiomatic Proof Rules of Differential Game Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Axioms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pusall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pusall ≡ ⟨Game hgidc⟩TT"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nothing</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nothing ≡ Number 0"</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>axiom_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"Axiom definitions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>box_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"box_axiom ≡ (Box (Game hgid1) pusall) ↔ Not(Diamond (Game hgid1) (Not(pusall)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assigneq_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"assigneq_axiom ≡ (Diamond (Assign xid1 (Const fid1)) pusall) ↔ Exists xid1 (Equals (Var xid1) (Const fid1) &amp;&amp; pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stutterd_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"stutterd_axiom ≡ (Diamond (Assign xid1 (Var xid1)) pusall) ↔ pusall"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"test_axiom ≡ Diamond (Test (Pred pid2 nothing)) (Pred pid1 nothing) ↔ (Pred pid2 nothing &amp;&amp; Pred pid1 nothing)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>choice_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"choice_axiom ≡ Diamond (Choice (Game hgid1) (Game hgid2)) pusall ↔ (Diamond (Game hgid1) pusall || Diamond (Game hgid2) pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compose_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"compose_axiom ≡ Diamond (Compose (Game hgid1) (Game hgid2)) pusall ↔ Diamond (Game hgid1) (Diamond (Game hgid2) pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iterate_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"iterate_axiom ≡ Diamond (Loop (Game hgid1)) pusall ↔ (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dual_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"dual_axiom ≡ Diamond (Dual (Game hgid1)) pusall ↔ !(Diamond (Game hgid1) (!pusall))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Axiomatic Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>rule_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rule definitions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mon_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mon_rule ≡ ([(⟨Game hgidc⟩TT) → (⟨Game hgidd⟩TT)], (⟨Game hgid1⟩(⟨Game hgidc⟩TT)) → (⟨Game hgid1⟩(⟨Game hgidd⟩TT)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FP_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"FP_rule ≡ ([((⟨Game hgidc⟩TT) || ⟨Game hgid1⟩⟨Game hgidd⟩TT) → ⟨Game hgidd⟩TT], (⟨Loop (Game hgid1)⟩⟨Game hgidc⟩TT) → (⟨Game hgidd⟩TT))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>MP_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"MP_rule ≡ ([Pred pid1 nothing , Pred pid1 nothing → Pred pid2 nothing], Pred pid2 nothing)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gena_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gena_rule ≡ ([pusall], Exists xid1 pusall)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness / Validity Proofs for Axioms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Because an axiom in a uniform substitution calculus is an individual formula, 
  proving the validity of that formula suffices to prove soundness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>box_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid box_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>box_axiom_def</span><span> </span><span>Box_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma assign_equal: "game_sem I (Assign x (Const f)) (fml_sem I φ) = fml_sem I (Exists x (Equals (Var x) (Const f) &amp;&amp; φ))"
  by simp*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assigneq_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid assigneq_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assigneq_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma game_sem_stutter: "game_sem I (Assign x (Var x)) X = X"
  by (auto simp add: repv_self)*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stutterd_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid stutterd_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stutterd_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid test_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>test_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>choice_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid choice_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>choice_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compose_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid compose_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compose_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dual_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid dual_axiom"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dual_axiom_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span>fml_sem_not</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iterate_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid iterate_axiom"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding iterate_axiom_def using valid_equiv fml_sem.simps(6) game_equiv_subst[OF loop_iterate_equiv]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀I. fml_sem I (Diamond (Loop (Game hgid1)) pusall) = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond (Loop (Game hgid1)) pusall) = game_sem I (Loop (Game hgid1)) (fml_sem I pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fml_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = game_sem I (Choice Skip (Compose (Game hgid1) (Loop (Game hgid1)))) (fml_sem I pusall)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_subst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹fml_sem I pusall›</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>loop_iterate_equiv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>α</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‹Game hgid1›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (Diamond (Choice Skip (Compose (Game hgid1) (Loop (Game hgid1)))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (Diamond Skip pusall || Diamond (Compose (Game hgid1) (Loop (Game hgid1))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (pusall || Diamond (Compose (Game hgid1) (Loop (Game hgid1))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond (Loop (Game hgid1)) pusall) = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid ((Diamond (Loop (Game hgid1)) pusall) ↔ (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rev_iffD2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid iterate_axiom"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iterate_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Local Soundness Proofs for Axiomatic Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mon_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound mon_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mon_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_impl</span><span> </span><span>monotone</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FP_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound FP_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FP_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_impl</span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MP_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound MP_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MP_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_implies</span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gena_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound gena_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gena_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_implies</span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Differential_Game_Logic">
<div class="head"><h1>Theory Differential_Game_Logic</h1>
<span class="command">theory</span> <span class="name">Differential_Game_Logic</span><br/>
<span class="keyword">imports</span> <a href="USubst.html"><span class="name">USubst</span></a> <a href="Axioms.html"><span class="name">Axioms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dGL Formalization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Differential_Game_Logic"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"USubst"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Axioms"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This formalization of Differential Game Logic 🌐‹http://arxiv.org/abs/1902.07230› \cite{DBLP:conf/cade/Platzer19} consists of
the syntax, denotational semantics, static semantics, uniform substitution lemmas, uniform substitution soundness proofs, and soundness proofs for axioms.›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div>