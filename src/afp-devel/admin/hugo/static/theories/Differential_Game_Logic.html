<div id="Lib">
<div class="head"><h1>Theory Lib</h1>
<span class="command">theory</span> <span class="name">Lib</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGeneric Mathematical Background Lemmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_subset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M ‚üπ finite {x‚ààM. P x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_powerset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite M ‚üπ finite {S. S‚äÜM}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fst_proj</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a*'b) set ‚áí 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst_proj M ‚â° {A. ‚àÉB. (A,B)‚ààM}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snd_proj</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a*'b) set ‚áí 'b set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd_proj M ‚â° {B. ‚àÉA. (A,B)‚ààM}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_proj_mem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ‚àà fst_proj M) = (‚àÉB. (A,B)‚ààM)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_proj_mem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(B ‚àà snd_proj M) = (‚àÉA. (A,B)‚ààM)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_proj_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààfst_proj {(A,B)| A B. P A ‚àß R A B}. P(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_proj_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààsnd_proj {(A,B) | A B. P B ‚àß R A B}. P(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map f (Cons x xs) = Cons (f x) (map f xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>List.list.map</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map f (append xs ys) = append (map f xs) (map f ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLockstep induction schema for two simultaneous least fixpoints.
  If the successor step and supremum step of two least fixpoint inflations
  preserve a relation, then that relation holds of the two respective least fixpoints.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfp_lockstep_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>monof</span><span> </span><span>monog</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::complete_lattice ‚áí 'a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::complete_lattice ‚áí 'b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monof</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>monog</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono g"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄA B. A ‚â§ lfp(f) ‚üπ B ‚â§ lfp(g) ‚üπ R A B ‚üπ R (f(A)) (g(B))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R_Union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄM::('a*'b) set. (‚àÄ(A,B)‚ààM. R A B) ‚üπ R (Sup (fst_proj M)) (Sup (snd_proj M))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R (lfp f) (lfp g)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using idea of proof of "Inductive.thy:lfp_ordinal_induct"*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(A,B). A ‚â§ lfp f ‚àß B ‚â§ lfp g ‚àß R A B}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R_Union</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>supdoes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R (Sup (fst_proj ?M)) (Sup (snd_proj ?M))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (fst_proj ?M) = lfp f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) = lfp g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>fle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (fst_proj ?M) ‚â§ lfp f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_proj_prop</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ‚â§ f (lfp f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monof</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>monoD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ‚â§ lfp f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monof</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lfp_unfold</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) ‚â§ lfp g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_proj_prop</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ‚â§ g (lfp g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monog</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>monoD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ‚â§ lfp g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monog</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lfp_unfold</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fsup</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fgsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f(Sup(fst_proj ?M)), g(Sup(snd_proj ?M))) ‚àà ?M"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R_Union</span><span> </span><span>R_step</span><span> </span><span>Sup_le_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span>fle</span><span> </span><span>gle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fgsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Sup (fst_proj ?M)) ‚â§ Sup (fst_proj ?M)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_upper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_proj_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>fge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp f ‚â§ Sup (fst_proj ?M)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) = lfp g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (snd_proj ?M) ‚â§ lfp g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gle</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fgsup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (Sup (snd_proj ?M)) ‚â§ Sup (snd_proj ?M)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_upper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>snd_proj_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>gge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp g ‚â§ Sup (snd_proj ?M)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supdoes</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_eq_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄA. (A‚ààM ‚üπ f(A)=g(A)))
  ‚üπ Sup {f(A) | A. A‚ààM} = Sup {g(A) | A. A‚ààM}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_corr_eq_chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄM::('a::complete_lattice*'a) set. (‚àÄ(A,B)‚ààM. f(A)=g(B)) ‚üπ (Sup {f(A) | A. A‚ààfst_proj M} = Sup {g(B) | B. B‚ààsnd_proj M})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prod_conv</span><span> </span><span>fst_proj_mem</span><span> </span><span>snd_proj_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Identifiers">
<div class="head"><h1>Theory Identifiers</h1>
<span class="command">theory</span> <span class="name">Identifiers</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIdentifier Namespace Configuration‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDifferent configurations are possible for the namespace of identifiers. Finite support is the only important aspect of it.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Identifiers, easiest finite case *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ident</span><span> </span><span class="delimiter">=</span><span> </span><span>char</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Identifiers, bigger finite case with longer identifiers *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
definition max_str:"MAX_STR = 1"
typedef ident = "{s::string. size s ‚â§ MAX_STR}"
  morphisms Rep_ident Abs_ident
  apply(auto)
  apply(rule exI[where x=Nil])
  by(auto simp add: max_str)

setup_lifting  ident.type_definition_ident 

lift_definition ilength::"ident ‚áí nat" is size done

lemma ident_bounded_length: "ilength x ‚â§ MAX_STR"
  apply (transfer fixing: s)
  apply (auto)
  done 

lemma finite_identifiers [simp]: "finite {x:ident . True}"
using ident_bounded_length 
  
lifting_update ident.lifting
lifting_forget ident.lifting
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe identifier used for the replacement marker in uniform substitutions‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>dotid</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dotid ‚â° CHR ''.''"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Syntax">
<div class="head"><h1>Theory Syntax</h1>
<span class="command">theory</span> <span class="name">Syntax</span><br/>
<span class="keyword">imports</span> <a href="Identifiers.html"><span class="name">Identifiers</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSyntax‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Defines the syntax of Differential Game Logic as inductively defined data types.
  üåê‚Äπhttps://doi.org/10.1145/2817824‚Ä∫ üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTerms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNumeric literals‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>lit</span><span> </span><span class="delimiter">=</span><span> </span><span>real</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all real variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allidents</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allidents ‚â° {x | x. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπVariables and differential variables‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>variable</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>RVar</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>DVar</span><span> </span><span>ident</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Var</span><span> </span><span>variable</span><span>
</span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span>lit</span><span>
</span><span class="delimiter">|</span><span> </span><span>Const</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>Func</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Plus</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Times</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Differential</span><span> </span><span>trm</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFormulas and Hybrid Games‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>fml</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Pred</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Geq</span><span> </span><span>trm</span><span> </span><span>trm</span><span>
</span><span class="delimiter">|</span><span> </span><span>Not</span><span> </span><span>fml</span><span>                 </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"!"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>And</span><span> </span><span>fml</span><span> </span><span>fml</span><span>             </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&amp;&amp;"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Exists</span><span> </span><span>variable</span><span> </span><span>fml</span><span>
</span><span class="delimiter">|</span><span> </span><span>Diamond</span><span> </span><span>game</span><span> </span><span>fml</span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(‚ü® _ ‚ü© _)"</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>game</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Game</span><span> </span><span>ident</span><span>
</span><span class="delimiter">|</span><span> </span><span>Assign</span><span> </span><span>variable</span><span> </span><span>trm</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">":="</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Test</span><span> </span><span>fml</span><span>                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"?"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Choice</span><span> </span><span>game</span><span> </span><span>game</span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚à™‚à™"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Compose</span><span> </span><span>game</span><span> </span><span>game</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";;"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Loop</span><span> </span><span>game</span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_**"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Dual</span><span> </span><span>game</span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_^d"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>ODE</span><span> </span><span>ident</span><span> </span><span>trm</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDerived operators‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Neg</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"trm ‚áí trm"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg Œ∏ = Times (Number (-1)) Œ∏"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Minus</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"trm ‚áí trm ‚áí trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Minus Œ∏ Œ∑ = Plus Œ∏ (Neg Œ∑)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí fml ‚áí fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"||"</span></span></span><span> </span><span>7</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Or P Q = Not (And (Not P) (Not Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Implies</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí fml ‚áí fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Üí"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Implies P Q = Or Q (Not P)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí fml ‚áí fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Üî"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Equiv P Q = Or (And P Q) (And (Not P) (Not Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Forall</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ‚áí fml ‚áí fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Forall x P = Not (Exists x (Not P))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Equals</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí trm ‚áí fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Equals Œ∏ Œ∏' = ((Geq Œ∏ Œ∏') &amp;&amp; (Geq Œ∏' Œ∏))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Greater</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí trm ‚áí fml"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Greater Œ∏ Œ∏' = ((Geq Œ∏ Œ∏') &amp;&amp; (Not (Geq Œ∏' Œ∏)))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπJustification: determinacy theorem justifies this equivalent syntactic abbreviation for box modalities from diamond modalities
  Theorem 3.1 üåê‚Äπhttps://doi.org/10.1145/2817824‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Box</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí fml ‚áí fml"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"([[_]]_)"</span></span></span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Box Œ± P = Not (Diamond Œ± (Not P))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>TT</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"TT = Geq (Number 0) (Number 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FF</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FF = Geq (Number 0) (Number 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Skip</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"game"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Skip = Test TT"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInference: premises, then conclusion‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>inference</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml list * fml"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>sequent</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml list * fml list"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRule: premises, then conclusion‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>rule</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sequent list * sequent"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStructural Induction‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInduction principles for hybrid games owing to their mutually recursive definition with formulas ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Game</span><span> </span><span>Assign</span><span> </span><span>ODE</span><span> </span><span>Test</span><span> </span><span>Choice</span><span> </span><span>Compose</span><span> </span><span>Loop</span><span> </span><span>Dual</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄa. P (Game a)) 
    ‚üπ (‚ãÄx Œ∏. P (Assign x Œ∏))
    ‚üπ (‚ãÄx Œ∏. P (ODE x Œ∏))
    ‚üπ (‚ãÄœÜ. P (? œÜ))
    ‚üπ (‚ãÄŒ± Œ≤. P Œ± ‚üπ P Œ≤ ‚üπ P (Œ± ‚à™‚à™ Œ≤))
    ‚üπ (‚ãÄŒ± Œ≤. P Œ± ‚üπ P Œ≤ ‚üπ P (Œ± ;; Œ≤))
    ‚üπ (‚ãÄŒ±. P Œ± ‚üπ P (Œ±**))
    ‚üπ (‚ãÄŒ±. P Œ± ‚üπ P (Œ±^d))
    ‚üπ P Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Pred</span><span> </span><span>Geq</span><span> </span><span>Not</span><span> </span><span>And</span><span> </span><span>Exists</span><span> </span><span>Diamond</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄx Œ∏. P (Pred x Œ∏))
  ‚üπ (‚ãÄŒ∏ Œ∑. P (Geq Œ∏ Œ∑))
  ‚üπ (‚ãÄœÜ. P œÜ ‚üπ P (Not œÜ))
  ‚üπ (‚ãÄœÜ œà. P œÜ ‚üπ P œà ‚üπ P (And œÜ œà))
  ‚üπ (‚ãÄx œÜ. P œÜ ‚üπ P (Exists x œÜ))
  ‚üπ (‚ãÄŒ± œÜ. P œÜ ‚üπ P (Diamond Œ± œÜ))
  ‚üπ P œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>fml.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars ‚â° {x::variable. True}"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Denotational_Semantics">
<div class="head"><h1>Theory Denotational_Semantics</h1>
<span class="command">theory</span> <span class="name">Denotational_Semantics</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Derivative.html"><span class="name">Derivative</span></a> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Derivative"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>         
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDenotational Semantics‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefines the denotational semantics of Differential Game Logic. üåê‚Äπhttps://doi.org/10.1145/2817824‚Ä∫ üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStates‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπVector of reals over ident‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>Rvec</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ‚áí real"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rvec"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all worlds‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>worlds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"worlds = {ŒΩ. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars ‚â° {x::variable. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all real variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>allrvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"allrvars ‚â° {RVar x | x. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe set of all differential variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>alldvars</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alldvars ‚â° {DVar x | x. True}"</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ident_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite({x::ident. True})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>allvar_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"allvars = allrvars ‚à™ alldvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>variable.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rvar_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite allrvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ident_finite</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπŒªx. RVar x‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dvar_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite alldvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ident_finite</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπŒªx. DVar x‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>allvars_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(allvars)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvar_cases</span><span> </span><span>dvar_finite</span><span> </span><span>rvar_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_Un</span><span class="delimiter">)</span><span> 
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Vagree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ‚áí state ‚áí variable set ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚â° (‚àÄi. i‚ààV ‚ü∂ ŒΩ(i) = ŒΩ'(i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Uvariation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ‚áí state ‚áí variable set ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ ŒΩ' U ‚â° (‚àÄi. ~(i‚ààU) ‚ü∂ ŒΩ(i) = ŒΩ'(i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ ŒΩ' (-V) = Vagree ŒΩ ŒΩ' V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Vagree_def</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V = Vagree ŒΩ' ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚üπ Vagree ŒΩ' ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_union</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚üπ Vagree ŒΩ ŒΩ' W ‚üπ Vagree ŒΩ ŒΩ' (V‚à™W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚üπ Vagree  ŒΩ' ŒΩ'' W ‚üπ Vagree ŒΩ ŒΩ'' (V‚à©W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚àß W‚äÜV ‚ü∂ Vagree ŒΩ ŒΩ' W"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ ŒΩ' {} = (ŒΩ=ŒΩ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_univ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' allvars = (ŒΩ=ŒΩ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_univ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ ŒΩ' allvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_and</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚àß Vagree ŒΩ ŒΩ' W ‚ü∑ Vagree ŒΩ ŒΩ' (V‚à™W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' V ‚à® Vagree ŒΩ ŒΩ' W ‚ü∂ Vagree ŒΩ ŒΩ' (V‚à©W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Uvariation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ ŒΩ U = Uvariation ŒΩ œâ U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_sym_rel</span><span> </span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ ŒΩ U ‚üπ Uvariation ŒΩ œâ U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ ŒΩ U ‚üπ Uvariation ŒΩ Œº V ‚üπ Uvariation œâ Œº (U‚à™V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_mon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ‚äá U ‚üπ Uvariation œâ ŒΩ U ‚üπ Uvariation œâ ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Interpretations</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mon_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono r = ((‚àÄX Y. (X‚äÜY ‚ü∂ r(X)‚äÜr(Y))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπinterpretations of symbols in ident‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>interp_rep</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ‚áí real) √ó (ident ‚áí (real ‚áí real)) √ó (ident ‚áí (real ‚áí bool)) √ó (ident ‚áí (state set ‚áí state set))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_interp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp_rep ‚áí bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_interp I ‚â° case I of (_, _, _, G) ‚áí (‚àÄa. mono (G a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>interp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{I:: interp_rep. is_interp I}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>raw_interp</span><span> </span><span>well_interp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œªf. 0, Œªf x. 0, Œªp x. True, Œªa. ŒªX. X) ‚àà {I. is_interp I}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_interp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Consts</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"interp ‚áí ident ‚áí (real)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œª(F0, _, _, _). F0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Funcs</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí ident ‚áí (real ‚áí real)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œª(_, F, _, _). F"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Preds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí ident ‚áí (real ‚áí bool)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œª(_, _, P, _). P"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Games</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí ident ‚áí (state set ‚áí state set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œª(_, _, _, G). G"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπmake interpretations‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>mkinterp</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ‚áí real) √ó (ident ‚áí (real ‚áí real)) √ó (ident ‚áí (real ‚áí bool)) √ó (ident ‚áí (state set ‚áí state set))
‚áí interp"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œª(C, F, P, G). if ‚àÄa. mono (G a) then (C, F, P, G) else (C, F, P, Œª_ _. {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span> </span><span>is_interp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Consts_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (mkinterp(C,F,P,G)) = C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Funcs_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (mkinterp(C,F,P,G)) = F"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Preds_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (mkinterp(C,F,P,G)) = P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Games_mkinterp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄa. mono (G a) ) ‚üπ Games (mkinterp(C,F,P,G)) = G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mkinterp_eq</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Consts I = Consts J ‚àß Funcs I = Funcs J ‚àß Preds I = Preds J ‚àß Games I = Games J) = (I=J)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>F</span><span> </span><span>P</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X‚äÜY ‚üπ (Games I a)(X)‚äÜ(Games I a)(Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>X</span><span> </span><span>Y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_interp_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lifting_update</span></span><span> </span><span>interp.lifting</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>interp.lifting</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Semantics</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantic modification ‚Äπrepv œâ x r‚Ä∫ replaces the value of variable ‚Äπx‚Ä∫ in the state ‚Äπœâ‚Ä∫ with r‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>repv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ‚áí variable ‚áí real ‚áí state"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv œâ x r = fun_upd œâ x r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_def_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"repv œâ x r = (Œªy. if x = y then r else œâ(y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_access</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv œâ x r)(y) = (if (x=y) then r else œâ(y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"repv œâ x (œâ(x)) = œâ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_repv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ (repv œâ x d) (-{x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_repv_self</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ (repv œâ x d) {x} = (d=œâ(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uvariation_repv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ (repv œâ x d) {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repv_def</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantics of Terms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>term_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí trm ‚áí (state ‚áí real)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Var x) = (Œªœâ. œâ(x))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Number r) = (Œªœâ. r)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Const f) = (Œªœâ. (Consts I f))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Func f Œ∏) = (Œªœâ. (Funcs I f)(term_sem I Œ∏ œâ))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Plus Œ∏ Œ∑) = (Œªœâ. term_sem I Œ∏ œâ + term_sem I Œ∑ œâ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Times Œ∏ Œ∑) = (Œªœâ. term_sem I Œ∏ œâ * term_sem I Œ∑ œâ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (Differential Œ∏) = (Œªœâ. sum(Œªx. œâ(DVar x)*deriv(ŒªX. term_sem I Œ∏ (repv œâ (RVar x) X))(œâ(RVar x)))(allidents))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSolutions of Differential Equations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*@note For simplicity, solutions are not limited to a smaller interval of existence*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>solution</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ‚áí state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>solves_ODE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí solution ‚áí ident ‚áí trm ‚áí bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x Œ∏ ‚â° (‚àÄŒ∂::real.
     Vagree (F(0)) (F(Œ∂)) (-{RVar x, DVar x})
   ‚àß F(Œ∂)(DVar x) = deriv(Œªt. F(t)(RVar x))(Œ∂)
   ‚àß F(Œ∂)(DVar x) = term_sem I Œ∏ (F(Œ∂)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantics of Formulas and Games‚Ä∫</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>fml_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí fml ‚áí (state set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>game_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí game ‚áí (state set ‚áí state set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Pred p Œ∏) = {œâ. (Preds I p)(term_sem I Œ∏ œâ)}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Geq Œ∏ Œ∑) = {œâ. term_sem I Œ∏ œâ ‚â• term_sem I Œ∑ œâ}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not œÜ) = {œâ. œâ ‚àâ fml_sem I œÜ}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (And œÜ œà) = fml_sem I œÜ ‚à© fml_sem I œà"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Exists x œÜ) = {œâ. ‚àÉr. (repv œâ x r) ‚àà fml_sem I œÜ}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond Œ± œÜ) = game_sem I Œ± (fml_sem I œÜ)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Game a) = (ŒªX. (Games I a)(X))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Assign x Œ∏) = (ŒªX. {œâ. (repv œâ x (term_sem I Œ∏ œâ)) ‚àà X})"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Test œÜ) = (ŒªX. fml_sem I œÜ ‚à© X)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Choice Œ± Œ≤) = (ŒªX. game_sem I Œ± X ‚à™ game_sem I Œ≤ X)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Compose Œ± Œ≤) = (ŒªX. game_sem I Œ± (game_sem I Œ≤ X))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop Œ±) = (ŒªX. ‚ãÇ{Z. X ‚à™ game_sem I Œ± Z ‚äÜ Z})"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Dual Œ±) = (ŒªX. -(game_sem I Œ± (-X)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (ODE x Œ∏) = (ŒªX. {œâ. ‚àÉF T. Vagree œâ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà X ‚àß solves_ODE I F x Œ∏})"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπValidity‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interp ‚áí fml ‚áí bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I œÜ ‚â° (‚àÄœâ. œâ ‚àà fml_sem I œÜ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid œÜ ‚â° (‚àÄI.‚àÄœâ. œâ ‚àà fml_sem I œÜ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_is_valid_in_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid œÜ = (‚àÄI. valid_in I œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>locally_sound</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R ‚â°
  (‚àÄI. (‚àÄk. 0‚â§k ‚ü∂ k&lt;length (fst R) ‚ü∂ valid_in I (nth (fst R) k)) ‚ü∂ valid_in I (snd R))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sound</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound R ‚â°
  (‚àÄk. 0‚â§k ‚ü∂ k&lt;length (fst R) ‚ü∂ valid (nth (fst R) k)) ‚ü∂ valid (snd R)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>locally_sound_is_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R ‚üπ sound R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span> </span><span>sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_is_valid_in_all</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMonotone Semantics‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone_Test</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X‚äÜY ‚üπ game_sem I (Test œÜ) X ‚äÜ game_sem I (Test œÜ) Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monotone</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X‚äÜY ‚üπ game_sem I Œ± X ‚äÜ game_sem I Œ± Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±1</span><span> </span><span>Œ±2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±1</span><span> </span><span>Œ±2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_mono</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (ŒªX. game_sem I Œ± X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mon_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I Œ± (X‚à™Y) ‚äá game_sem I Œ± X ‚à™ game_sem I Œ± Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>game_sem_union</span><span> </span><span class="delimiter">=</span><span> </span><span>game_union</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFixpoint Semantics Alternative for Loops‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (ŒªZ. X ‚à™ game_sem I Œ± Z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>mon_mono</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπConsequence of Knaster-Tarski Theorem 3.5 of üåê‚Äπhttps://doi.org/10.1145/2817824‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_sem_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop Œ±) = (ŒªX. lfp(ŒªZ. X ‚à™ game_sem I Œ± Z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÇ{Z. X ‚à™ game_sem I Œ± Z ‚äÜ Z} = lfp(ŒªZ. X ‚à™ game_sem I Œ± Z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_back</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒªX. lfp(ŒªZ. X ‚à™ game_sem I Œ± Z)) = game_sem I (Loop Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_iterate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop Œ±) = (ŒªX. X ‚à™ game_sem I Œ± (game_sem I (Loop Œ±) X))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>game_sem_loop</span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span>lfp_fixpoint</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_unwind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop Œ±) = (ŒªX. X ‚à™ game_sem I (Compose Œ± (Loop Œ±)) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_iterate</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>game_sem_loop_unwind_reduce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒªX. X ‚à™ game_sem I (Compose Œ± (Loop Œ±)) X) = game_sem I (Loop Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_unwind</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lfp_ordinal_induct_set_cases</span><span> </span><span class="delimiter">=</span><span> </span><span>lfp_ordinal_induct_set</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>mono</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Read off a fixpoint induction scheme from the fact that loops have a least fixpoint semantics *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_loop_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>step</span><span> </span><span>union</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄZ. Z ‚äÜ game_sem I (Loop Œ±) X ‚üπ P(Z) ‚üπ P(X ‚à™ game_sem I Œ± Z))
  ‚üπ (‚ãÄM. (‚àÄZ‚ààM. P(Z)) ‚üπ P(Sup M))
  ‚üπ P(game_sem I (Loop Œ±) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loopstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄZ. Z ‚äÜ game_sem I (Loop Œ±) X ‚üπ P(Z) ‚üπ  P(X ‚à™ game_sem I Œ± Z)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loopsup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄM. (‚àÄZ‚ààM. P(Z)) ‚üπ P(Sup M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(lfp(ŒªZ. X ‚à™ game_sem I Œ± Z))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_ordinal_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπŒªZ. X ‚à™ game_sem I Œ± Z‚Ä∫</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>mono</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopstep</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Z</span><span class="delimiter">=</span><span>S</span><span class="delimiter">]</span><span> </span><span>game_sem_loop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span>Œ±</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>loopstep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopsup</span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(game_sem I (Loop Œ±) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof (induction rule: lfp_ordinal_induct_set_cases[where f=‚ÄπŒªZ. X ‚à™ game_sem I Œ± Z‚Ä∫])
    case mono
    then show ?case using game_sem_loop_fixpoint_mono by simp
  next
    case (step S)
    then show ?case using loopstep by auto
  next
    case (union M)
    then show ?case using loopsup game_sem_loop by auto
  qed*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSome Simple Obvious Observations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not œÜ) = -fml_sem I œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_not_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Not (Not œÜ)) = fml_sem I œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_or</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Or œÜ œà) = fml_sem I œÜ ‚à™ fml_sem I œà"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_implies</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Implies œÜ œà) = (-fml_sem I œÜ) ‚à™ fml_sem I œà"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Implies_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TT_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid TT"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>TT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantic equivalence of formulas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fml_equiv</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml =&gt; fml =&gt; bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv œÜ œà ‚â° (‚àÄI. fml_sem I œÜ = fml_sem I œà)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSubstitutionality for Equivalent Formulas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_equiv_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv œÜ œà ‚üπ P (fml_sem I œÜ) ‚üπ P (fml_sem I œà)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv œÜ œà"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fml_sem I œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I œÜ = fml_sem I œà"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forw_subst</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_fml_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (œÜ ‚Üî œà) = fml_equiv œÜ œà"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_in_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (œÜ ‚Üî œà) = ((fml_sem I œÜ) = (fml_sem I œà))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_in_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (œÜ ‚Üí œà) = ((fml_sem I œÜ) ‚äÜ (fml_sem I œà))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_in_def</span><span> </span><span>Implies_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (œÜ ‚Üî œà) = (‚àÄI. fml_sem I œÜ = fml_sem I œà)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_fml_equiv</span><span> </span><span>fml_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (œÜ ‚Üí œà) = (‚àÄI. (fml_sem I œÜ) ‚äÜ (fml_sem I œà))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Implies_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_sem_equals</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ ‚àà fml_sem I (Equals Œ∏ Œ∑)) = (term_sem I Œ∏ œâ = term_sem I Œ∑ œâ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equals_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_refl_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (œÜ ‚Üî œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equiv_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equal_refl_valid</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (Equals Œ∏ Œ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span>Equals_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_ODE_alt</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x Œ∏ ‚â° (‚àÄŒ∂::real.
     Vagree (F(0)) (F(Œ∂)) (-{RVar x, DVar x})
   ‚àß F(Œ∂)(DVar x) = deriv(Œªt. F(t)(RVar x))(Œ∂)
   ‚àß F(Œ∂) ‚àà fml_sem I (Equals (Var (DVar x)) Œ∏))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_equals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantic equivalence of games‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_equiv</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game =&gt; game =&gt; bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤ ‚â° (‚àÄI X. game_sem I Œ± X = game_sem I Œ≤ X)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSubstitutionality for Equivalent Games‚Ä∫</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_equiv_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤ ‚üπ P (game_sem I Œ± X) ‚üπ P (game_sem I Œ≤ X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (game_sem I Œ± X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I Œ± X = game_sem I Œ≤ X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forw_subst</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game_equiv_subst_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤ ‚üπ P (game_sem I Œ± X) == P (game_sem I Œ≤ X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_equiv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_id</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I Skip X = X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Skip_def</span><span> </span><span>TT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_iterate_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv (Loop Œ±) (Choice Skip (Compose Œ± (Loop Œ±)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_equiv_def</span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>X</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>game_sem_loop_unwind_reduce</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ‚à™ game_sem I (Compose Œ± (Loop Œ±)) X = game_sem I (Loop Œ±) X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (Loop Œ±) X = game_sem I (Choice Skip (Compose Œ± (Loop Œ±))) X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skip_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fml_equiv_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_equiv œÜ œà ‚üπ valid œÜ = valid œà"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_equiv_subst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_Vagree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x Œ∏ ‚üπ (‚ãÄŒ∂. Vagree (F(Œ∂)) (F(0)) (-{RVar x,DVar x}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_ODE_def</span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>solves_Vagree_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) œâ U ‚üπ solves_ODE I F x Œ∏ ‚üπ Uvariation (F(Œ∂)) œâ (U‚à™{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>solves_ODE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_sym_rel</span><span> </span><span>Uvariation_trans</span><span> </span><span>double_complement</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Static_Semantics">
<div class="head"><h1>Theory Static_Semantics</h1>
<span class="command">theory</span> <span class="name">Static_Semantics</span><br/>
<span class="keyword">imports</span> <a href="Denotational_Semantics.html"><span class="name">Denotational_Semantics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStatic Semantics‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSemantically-defined Static Semantics‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAuxiliary notions of projection of winning conditions‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπupward projection: ‚Äπrestrictto X V‚Ä∫ is extends X to the states that agree on V with some state in X,
so variables outside V can assume arbitrary values.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>restrictto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set ‚áí variable set ‚áí state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"restrictto X V = {ŒΩ. ‚àÉœâ. œâ‚ààX ‚àß Vagree œâ ŒΩ V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπdownward projection: ‚Äπselectlike X ŒΩ V‚Ä∫ selects state ‚ÄπŒΩ‚Ä∫ on V in X,
so all variables of V are required to remain constant‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>selectlike</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set ‚áí state ‚áí variable set ‚áí state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"selectlike X ŒΩ V = {œâ‚ààX. Vagree œâ ŒΩ V}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFree variables, semantically characterized.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFree variables of a term‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVT t = {x. ‚àÉI.‚àÉŒΩ.‚àÉœâ. Vagree ŒΩ œâ (-{x}) ‚àß ¬¨(term_sem I t ŒΩ = term_sem I t œâ)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFree variables of a formula‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVF œÜ = {x. ‚àÉI.‚àÉŒΩ.‚àÉœâ. Vagree ŒΩ œâ (-{x}) ‚àß ŒΩ ‚àà fml_sem I œÜ ‚àß œâ ‚àâ fml_sem I œÜ}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFree variables of a hybrid game‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FVG Œ± = {x. ‚àÉI.‚àÉŒΩ.‚àÉœâ.‚àÉX. Vagree ŒΩ œâ (-{x}) ‚àß ŒΩ ‚àà game_sem I Œ± (restrictto X (-{x})) ‚àß œâ ‚àâ game_sem I Œ± (restrictto X (-{x}))}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBound variables, semantically characterized.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBound variables of a hybrid game‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>BVG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí variable set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BVG Œ± = {x. ‚àÉI.‚àÉœâ.‚àÉX. œâ ‚àà game_sem I Œ± X ‚àß œâ ‚àâ game_sem I Œ± (selectlike X œâ {x})}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple Observations‚Ä∫</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_elem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x‚ààBVG Œ±) = (‚àÉI œâ X. œâ ‚àà game_sem I Œ± X ‚àß œâ ‚àâ game_sem I Œ± (selectlike X œâ {x}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonBVG_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ {x})))
  ‚üπ x‚àâBVG Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonBVG_inc_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄI œâ X. (œâ ‚àà game_sem I Œ± X) ‚üπ (œâ ‚àà game_sem I Œ± (selectlike X œâ {x})))
  ‚üπ x‚àâBVG Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVT_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVT t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVF_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVF e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVG_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(FVG a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_subset</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Coincidence">
<div class="head"><h1>Theory Coincidence</h1>
<span class="command">theory</span> <span class="name">Coincidence</span><br/>
<span class="keyword">imports</span> <a href="Lib.html"><span class="name">Lib</span></a> <a href="Static_Semantics.html"><span class="name">Static_Semantics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL.Finite_Set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStatic Semantics Properties‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span>Auxiliaries</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe state interpolating ‚Äπstateinterpol ŒΩ œâ S‚Ä∫ between ‚ÄπŒΩ‚Ä∫ and ‚Äπœâ‚Ä∫ that is ‚ÄπŒΩ‚Ä∫ on ‚ÄπS‚Ä∫ and ‚Äπœâ‚Ä∫ elsewhere‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stateinterpol</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ‚áí state ‚áí variable set ‚áí state"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ŒΩ œâ S = (Œªx. if (x‚ààS) then ŒΩ(x) else œâ(x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>statediff</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ‚áí state ‚áí variable set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff ŒΩ œâ = {x. ŒΩ(x)‚â†œâ(x)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nostatediff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâstatediff ŒΩ œâ ‚üπ ŒΩ(x)=œâ(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>statediff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ŒΩ œâ {} = œâ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. ¬¨(x‚àà{})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. stateinterpol ŒΩ œâ {} x = œâ x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààS ‚üπ (stateinterpol ŒΩ œâ S)(x)=ŒΩ(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâS ‚üπ (stateinterpol ŒΩ œâ S)(x)=œâ(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_stateinterpol</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol ŒΩ œâ S) ŒΩ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol ŒΩ œâ S) œâ (-S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_ror</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' (V‚à©W) ‚üπ (‚àÉœâ. (Vagree ŒΩ œâ V ‚àß Vagree œâ ŒΩ' W))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ŒΩ' (V‚à©W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx. x‚ààV‚à©W ‚ü∂ ŒΩ(x)=ŒΩ'(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?w</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"stateinterpol ŒΩ ŒΩ' V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ?w V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ?w ŒΩ' W ‚àß Vagree ?w ŒΩ' W"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚àÄx. x‚ààV‚à©W ‚ü∂ ŒΩ x = ŒΩ' x‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ ?w V ‚àß Vagree ?w ŒΩ' W"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRemark 8 üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫ about simple properties of projections‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_extends</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V ‚äá X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto (restrictto X V) W = restrictto X (V‚à©W)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto (restrictto X V) W ‚äÜ restrictto X (V‚à©W)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X (V‚à©W) ‚äÜ restrictto (restrictto X V) W"</span></span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Vagree_ror mem_Collect_eq restrictto_def subsetI)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sledgehammer *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable ‚áí real) set ‚áí (variable ‚áí real) set ‚áí variable ‚áí real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1. (‚àÉv2. v2 ‚àà x1 ‚àß v2 ‚àâ x0) = (rr x0 x1 ‚àà x1 ‚àß rr x0 x1 ‚àâ x0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄF Fa. rr Fa F ‚àà F ‚àß rr Fa F ‚àâ Fa ‚à® F ‚äÜ Fa"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable ‚áí real) ‚áí variable set ‚áí (variable ‚áí real) set ‚áí variable ‚áí real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1 x2. (‚àÉv3. v3 ‚àà x2 ‚àß Vagree v3 x0 x1) = (rra x0 x1 x2 ‚àà x2 ‚àß Vagree (rra x0 x1 x2) x0 x1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄF V f. (f ‚àâ {f. ‚àÉfa. fa ‚àà F ‚àß Vagree fa f V} ‚à® rra f V F ‚àà F ‚àß Vagree (rra f V F) f V) ‚àß (f ‚àà {f. ‚àÉfa. fa ‚àà F ‚àß Vagree fa f V} ‚à® (‚àÄfa. fa ‚àâ F ‚à® ¬¨ Vagree fa f V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉf. f ‚àà X ‚àß Vagree f (v4_1 W V (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (rra (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (V ‚à© W) X)) V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉf. f ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree f (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) W"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚àâ {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚à® rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚àà {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚äÜ {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬¨ Vagree (rra (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (V ‚à© W) X) (v4_1 W V (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (rra (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (V ‚à© W) X)) V ‚à® ¬¨ Vagree (v4_1 W V (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (rra (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) (V ‚à© W) X)) (rr {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W} {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)}) W) ‚à® {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚äÜ {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f (V ‚à© W)} ‚äÜ {f. ‚àÉfa. fa ‚àà {f. ‚àÉfa. fa ‚àà X ‚àß Vagree fa f V} ‚àß Vagree fa f W}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Vagree_ror</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrictto_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W‚äáV ‚üπ restrictto X W ‚äÜ restrictto X V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W‚äáV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉU. V=W‚à©U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V=W‚à©U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V = restrictto (restrictto X W) U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrictto X V ‚äá restrictto X W"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrictto_extends</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrictto_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X‚â†{} ‚üπ restrictto X {} = worlds"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrictto_def</span><span> </span><span>worlds_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_shrinks</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X ŒΩ V ‚äÜ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (selectlike X ŒΩ V) ŒΩ W = selectlike X ŒΩ (V‚à™W)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W‚äáV ‚üπ selectlike X ŒΩ W ‚äÜ selectlike X ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X ŒΩ {} = X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà selectlike X ŒΩ V) = (ŒΩ‚ààX)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_complement</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (-X) ŒΩ V ‚äÜ -selectlike X ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X‚à™Y) ŒΩ V = selectlike X ŒΩ V ‚à™ selectlike Y ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>selectlike_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_Sup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (Sup M) ŒΩ V = Sup {selectlike X ŒΩ V | X. X‚ààM}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(selectlike X ŒΩ V = selectlike Y ŒΩ V) = (‚àÄŒº. Uvariation Œº ŒΩ (-V) ‚ü∂ (Œº‚ààX) = (Œº‚ààY))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(selectlike X ŒΩ (-V) = selectlike Y ŒΩ (-V)) = (‚àÄŒº. Uvariation Œº ŒΩ V ‚ü∂ (Œº‚ààX) = (Œº‚ààY))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-V‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄŒº. Uvariation Œº ŒΩ (-V) ‚üπ (Œº‚ààX) = (Œº‚ààY))
  ‚üπ (selectlike X ŒΩ V = selectlike Y ŒΩ V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπV‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄŒº. Uvariation Œº ŒΩ V ‚üπ (Œº‚ààX) = (Œº‚ààY))
  ‚üπ (selectlike X ŒΩ (-V) = selectlike Y ŒΩ (-V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_equal_cond</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-V‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>co_selectlike</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-(selectlike X ŒΩ V) = (-X) ‚à™ {œâ. ¬¨Vagree œâ ŒΩ V}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_co_selectlike</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (-(selectlike X ŒΩ V)) ŒΩ V = selectlike (-X) ŒΩ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>selectlike_Vagree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ œâ V ‚üπ selectlike X ŒΩ V = selectlike X œâ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_def</span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>similar_selectlike_mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ œâ V ‚üπ (ŒΩ‚ààselectlike X œâ V) = (ŒΩ‚ààX)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* also see nonBVG_rule *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x‚àâBVG Œ±) = (‚àÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ {x})))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span>monotone</span><span> </span><span>selectlike_shrinks</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚Äπstatediff‚Ä∫ interoperability‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' S ‚üπ statediff œâ œâ' ‚äÜ -S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>statediff_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_diff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol ŒΩ œâ (statediff ŒΩ œâ) = ŒΩ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>sp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(stateinterpol ŒΩ œâ (statediff ŒΩ œâ))(x) = ŒΩ(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààstatediff ŒΩ œâ"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_def</span><span> </span><span>nostatediff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol v w S) (stateinterpol v w (insert z S)) (-{z})"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_FVT</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z‚àâFVT(t) ‚üπ term_sem I t (stateinterpol œâ œâ' S) = term_sem I t (stateinterpol œâ œâ' (insert z S))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z‚àâFVT(t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄv. ‚ãÄw. Vagree v w (-{z}) ‚üπ (term_sem I t v = term_sem I t w)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FVT_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I t (stateinterpol œâ œâ' S) = term_sem I t (stateinterpol œâ œâ' (insert z S))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fvc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stateinterpol_insert</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCoincidence Lemmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCoincidence for Terms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 10 üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (FVT Œ∏) ‚üπ term_sem I Œ∏ œâ = term_sem I Œ∏ œâ'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (FVT Œ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff œâ œâ' ‚äÜ -FVT(Œ∏)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S‚äÜ-FVT(Œ∏) ‚üπ (term_sem I Œ∏ œâ' = term_sem I Œ∏ (stateinterpol œâ œâ' S))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>z</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (statediff œâ œâ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FVT_finite</span><span> </span><span>UNIV_def</span><span> </span><span>finite_compl</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπstatediff œâ œâ'‚Ä∫</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>finS</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>isS</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_term_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ œâ' U ‚üπ (FVT Œ∏)‚à©U={} ‚üπ term_sem I Œ∏ œâ = term_sem I Œ∏ œâ'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_term</span><span> </span><span>Uvariation_Vagree</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vagree_antimon</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stateinterpol_FVF</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z‚àâFVF(e) ‚üπ 
  ((stateinterpol œâ œâ' S) ‚àà fml_sem I e ‚ü∑ (stateinterpol œâ œâ' (insert z S)) ‚àà fml_sem I e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z‚àâFVF(e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>agr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree (stateinterpol œâ œâ' S) (stateinterpol œâ œâ' (insert z S)) (-{z})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span> </span><span>stateinterpol_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄv. ‚ãÄw. (Vagree v w (-{z}) ‚üπ (v‚ààfml_sem I e ‚üπ w‚ààfml_sem I e))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FVF_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fvce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄv. ‚ãÄw. (Vagree v w (-{z}) ‚üπ ((v‚ààfml_sem I e) = (w‚ààfml_sem I e)))"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_sym_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(stateinterpol œâ œâ' S) ‚àà fml_sem I e ‚ü∑ (stateinterpol œâ œâ' (insert z S)) ‚àà fml_sem I e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCoincidence for Formulas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 11 üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_formula</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (FVF œÜ) ‚üπ (œâ ‚àà fml_sem I œÜ ‚ü∑ œâ' ‚àà fml_sem I œÜ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (FVF œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"statediff œâ œâ' ‚äÜ -FVF(œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Vagree_statediff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S‚äÜ-FVF(œÜ) ‚üπ (œâ' ‚àà fml_sem I œÜ ‚ü∑ (stateinterpol œâ œâ' S) ‚àà fml_sem I œÜ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stateinterpol_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>z</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (statediff œâ œâ')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allvars_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FVF_finite</span><span> </span><span>UNIV_def</span><span> </span><span>finite_compl</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gen</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπstatediff œâ œâ'‚Ä∫</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>finS</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>isS</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_formula_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ œâ' U ‚üπ (FVF œÜ)‚à©U={} ‚üπ (œâ ‚àà fml_sem I œÜ ‚ü∑ œâ' ‚àà fml_sem I œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_formula</span><span> </span><span>Uvariation_Vagree</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_def</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>inf.commute</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCoincidence for Games‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚ÄπCignorabimus Œ± V‚Ä∫ is the set of all sets of variables that can be ignored for the coincidence game lemma‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Cignorabimus</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí variable set ‚áí variable set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Cignorabimus Œ± V = {M. ‚àÄI.‚àÄœâ.‚àÄœâ'.‚àÄX. (Vagree œâ œâ' (-M) ‚ü∂ (œâ‚ààgame_sem I Œ± (restrictto X V)) ‚ü∂ (œâ'‚ààgame_sem I Œ± (restrictto X V)))}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Cignorabimus Œ± V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_powerset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>allvars_finite</span><span class="delimiter">]</span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Set.finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_equiv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cignorabimus Œ± V = {M. ‚àÄI.‚àÄœâ.‚àÄœâ'.‚àÄX. (Vagree œâ œâ' (-M) ‚ü∂ (œâ‚ààgame_sem I Œ± (restrictto X V)) = (œâ'‚ààgame_sem I Œ± (restrictto X V)))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Vagree_sym_rel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_antimon</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ‚àà Cignorabimus Œ± V ‚àß N‚äÜM ‚üπ N ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-{}=allvars"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coempty</span><span> </span><span>Vagree_univ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCignorabimus contains nonfree variables‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äáFVG(Œ±) ‚üπ x‚àâV ‚üπ {x}‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äáFVG(Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâFVG(Œ±)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFVG Œ± ‚äÜ V‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI v w. Vagree v w (-{x}) ‚üπ (v ‚àà game_sem I Œ± (restrictto X (-{x})) ‚ü∑ w ‚àà game_sem I Œ± (restrictto X (-{x})))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>FVG_def</span><span> </span><span>Vagree_sym_rel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>œâ'</span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (-{x}) ‚ü∂ (œâ‚ààgame_sem I Œ± (restrictto X V)) ‚ü∂ (œâ'‚ààgame_sem I Œ± (restrictto X V))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (-{x})"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ‚ààgame_sem I Œ± (restrictto X V)) ‚ü∂ (œâ'‚ààgame_sem I Œ± (restrictto X V))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ‚ààgame_sem I Œ± (restrictto X V)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ‚ààgame_sem I Œ± (restrictto (restrictto X V) (-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Int_absorb2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπx‚àâV‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ'‚ààgame_sem I Œ± (restrictto (restrictto X V) (-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVG_def</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ'‚ààgame_sem I Œ± (restrictto X (V‚à©-{x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ'‚ààgame_sem I Œ± (restrictto X V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_absorb2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπœâ' ‚àà game_sem I Œ± (restrictto X (V ‚à© - {x}))‚Ä∫</span></span></span><span> </span><span>subset_Compl_singleton</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCignorabimus is closed under union‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M‚ààCignorabimus Œ± V ‚üπ N‚ààCignorabimus Œ± V ‚üπ (M‚à™N)‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M‚à™N)‚ààCignorabimus Œ± V"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using a1 a2 unfolding Cignorabimus_def *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>œâ'</span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' (-(M‚à™N))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ œâ'.‚ãÄX. (Vagree œâ œâ' (-M) ‚üπ  (œâ‚ààgame_sem I Œ± (restrictto X V)) ‚üπ (œâ'‚ààgame_sem I Œ± (restrictto X V)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ œâ'.‚ãÄX. (Vagree œâ œâ' (-N) ‚üπ  (œâ‚ààgame_sem I Œ± (restrictto X V)) ‚üπ (œâ'‚ààgame_sem I Œ± (restrictto X V)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateinterpol œâ' œâ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ ?s (-(M‚à™N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ?s œâ' (-(M‚à™N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vagree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ‚ààgame_sem I Œ± (restrictto X V) ‚üπ ?s‚ààgame_sem I Œ± (restrictto X V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplD</span><span> </span><span>Vagree_def</span><span> </span><span>h1</span><span> </span><span>stateinterpol_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?s‚ààgame_sem I Œ± (restrictto X V) ‚üπ œâ'‚ààgame_sem I Œ± (restrictto X V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vagree_ror</span><span> </span><span>compl_sup</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>v2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ‚ààgame_sem I Œ± (restrictto X V) ‚üπ œâ'‚ààgame_sem I Œ± (restrictto X V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cignorabimus_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powersetup_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Base</span><span> </span><span>Cup</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"‚ãÄC. (‚ãÄM. M‚ààC ‚üπ P M) ‚üπ
    (‚ãÄS. (‚ãÄM. M‚ààS ‚üπ P M) ‚üπ P (‚ãÉS)) ‚üπ
     P (‚ãÉC)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Union_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉ(insert x S) = x‚à™‚ãÉS"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powerset2up_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Finite</span><span> </span><span>Nonempty</span><span> </span><span>Base</span><span> </span><span>Cup</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(finite C) ‚üπ (C‚â†{}) ‚üπ (‚ãÄM. M‚ààC ‚üπ P M) ‚üπ
    (‚ãÄM N. P M ‚üπ P N ‚üπ P (M‚à™N)) ‚üπ
     P (‚ãÉC)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cignorabimus_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄM. M‚ààS ‚üπ M‚ààCignorabimus Œ± V) ‚üπ (‚ãÉS)‚ààCignorabimus Œ± V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"S={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nonem</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉS‚ààCignorabimus Œ± V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄM. M‚ààS ‚üπ M‚ààCignorabimus Œ± V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonemp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"S‚â†{}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>powerset2up_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Finite</span><span>                                                   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>infinite_super</span><span> </span><span>subset_eq</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonemp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Base</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cup</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Cignorabimus_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 12 üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coincidence_game</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' V ‚üπ V‚äáFVG(Œ±) ‚üπ (œâ ‚àà game_sem I Œ± (restrictto X V)) = (œâ' ‚àà game_sem I Œ± (restrictto X V))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ œâ' V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ‚äá FVG Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}‚ààCignorabimus Œ± V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâV"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ‚äá FVG Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cignorabimus_init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-V = ‚ãÉ{xx. ‚àÉx. xx={x} ‚àß x‚àâV}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* finite *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-V)‚ààCignorabimus Œ± V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>base</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cignorabimus_step</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Cignorabimus_step mem_Collect_eq)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄv V. v ‚àà V ‚à® ¬¨ FVG Œ± ‚äÜ V ‚à® {v} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí game ‚áí variable set set ‚áí variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1 x2. (‚àÉv3. v3 ‚àà x2 ‚àß v3 ‚àâ Cignorabimus x1 x0) = (VV x0 x1 x2 ‚àà x2 ‚àß VV x0 x1 x2 ‚àâ Cignorabimus x1 x0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((‚àÑv. VV V Œ± {{v} |v. v ‚àâ V} = {v} ‚àß v ‚àâ V) ‚à® VV V Œ± {{v} |v. v ‚àâ V} = {vv (VV V Œ± {{v} |v. v ‚àâ V})} ‚àß vv (VV V Œ± {{v} |v. v ‚àâ V}) ‚àâ V) ‚àß ((‚àÉv. VV V Œ± {{v} |v. v ‚àâ V} = {v} ‚àß v ‚àâ V) ‚à® (‚àÄv. VV V Œ± {{v} |v. v ‚àâ V} ‚â† {v} ‚à® v ‚àà V))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{vv (VV V Œ± {{v} |v. v ‚àâ V})} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(VV V Œ± {{v} |v. v ‚àâ V} ‚â† {vv (VV V Œ± {{v} |v. v ‚àâ V})} ‚à® vv (VV V Œ± {{v} |v. v ‚àâ V}) ‚àà V) ‚à® VV V Œ± {{v} |v. v ‚àâ V} ‚àâ {{v} |v. v ‚àâ V} ‚à® VV V Œ± {{v} |v. v ‚àâ V} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚àÉv. VV V Œ± {{v} |v. v ‚àâ V} = {v} ‚àß v ‚àâ V) ‚ü∂ VV V Œ± {{v} |v. v ‚àâ V} ‚àâ {{v} |v. v ‚àâ V} ‚à® VV V Œ± {{v} |v. v ‚àâ V} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"VV V Œ± {{v} |v. v ‚àâ V} ‚àâ {{v} |v. v ‚àâ V} ‚à® VV V Œ± {{v} |v. v ‚àâ V} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉ{{v} |v. v ‚àâ V} ‚àà Cignorabimus Œ± V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Cignorabimus_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>coincidence_game_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation œâ œâ' U ‚üπ U‚à©FVG(Œ±)={} ‚üπ (œâ ‚àà game_sem I Œ± (restrictto X (-U))) = (œâ' ‚àà game_sem I Œ± (restrictto X (-U)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_game</span><span> </span><span>Uvariation_Vagree</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>coincidence_game</span><span> </span><span>compl_le_swap1</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBound Effect Lemmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚ÄπBignorabimus Œ± V‚Ä∫ is the set of all sets of variables that can be ignored for boundeffect‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Bignorabimus</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí variable set set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Bignorabimus Œ± = {M. ‚àÄI.‚àÄœâ.‚àÄX. œâ‚ààgame_sem I Œ± X ‚ü∑ œâ‚ààgame_sem I Œ± (selectlike X œâ M)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_finite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Bignorabimus Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_powerset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>allvars_finite</span><span class="delimiter">]</span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Set.finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I Œ± (selectlike X œâ M) ‚äÜ game_sem I Œ± X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>monotone</span><span> </span><span>selectlike_shrinks</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Bignorabimus Œ± = {M. ‚àÄI.‚àÄœâ.‚àÄX. (œâ‚ààgame_sem I Œ± X ‚ü∂ œâ‚ààgame_sem I Œ± (selectlike X œâ M))}"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Bignorabimus_def Bignorabimus_single Collect_cong subsetCE)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer transformed*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable set ‚áí bool) ‚áí (variable set ‚áí bool) ‚áí variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄp pa. (¬¨ p (VV pa p)) = pa (VV pa p) ‚à® Collect p = Collect pa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Collect_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí game ‚áí variable ‚áí real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ii</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí game ‚áí interp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí game ‚áí (variable ‚áí real) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1. (‚àÉv2 v3 v4. (v3 ‚àà game_sem v2 x1 v4) ‚â† (v3 ‚àà game_sem v2 x1 (selectlike v4 v3 x0))) = ((rr x0 x1 ‚àà game_sem (ii x0 x1) x1 (FF x0 x1)) ‚â† (rr x0 x1 ‚àà game_sem (ii x0 x1) x1 (selectlike (FF x0 x1) (rr x0 x1) x0)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))} = {V. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Bignorabimus_single</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àâ game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (selectlike (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))) ‚à® rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àà game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬¨ (‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))) ‚à® (‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))))) ‚àß ((‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))) ‚à® (rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àâ game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±)) = (rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àà game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (selectlike (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àà game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) ‚ü∂ (‚àÉi f F. f ‚àà game_sem i Œ± F ‚àß f ‚àâ game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))) ‚à® rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ± ‚àà game_sem (ii (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) Œ± (selectlike (FF (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (rr (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))) Œ±) (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉi f F. f ‚àà game_sem i Œ± F ‚àß f ‚àâ game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ (‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬¨ (‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))) ‚â† (‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))} = {V. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))) ‚à® {V. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))} = {V. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬¨ (‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)))))) ‚â† (‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f (VV (ŒªV. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))) (ŒªV. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V))))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))} = {V. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{V. ‚àÄi f F. (f ‚àà game_sem i Œ± F) = (f ‚àà game_sem i Œ± (selectlike F f V))} = {V. ‚àÄi f F. f ‚àà game_sem i Œ± F ‚ü∂ f ‚àà game_sem i Œ± (selectlike F f V)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{} ‚àà Bignorabimus Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coempty</span><span> </span><span>selectlike_empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Œ±) ‚üπ {x}‚ààBignorabimus Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span>BVG_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àâ {x. ‚àÉI œâ X. œâ ‚àà game_sem I Œ± X ‚àß œâ ‚àâ game_sem I Œ± (selectlike X œâ {x})}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨(‚àÉI œâ X. œâ ‚àà game_sem I Œ± X ‚àß œâ ‚àâ game_sem I Œ± (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x} ‚àà {M. ‚àÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ M))}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBignorabimus is closed under union‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M‚ààBignorabimus Œ± ‚üπ N‚ààBignorabimus Œ± ‚üπ (M‚à™N)‚ààBignorabimus Œ±"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M‚ààBignorabimus Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N‚ààBignorabimus Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI.‚àÄœâ.‚àÄX. (œâ‚ààgame_sem I Œ± X) ‚ü∑ (œâ‚ààgame_sem I Œ± (selectlike X œâ M))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI.‚àÄœâ.‚àÄX. (œâ‚ààgame_sem I Œ± X) ‚ü∑ (œâ‚ààgame_sem I Œ± (selectlike X œâ N))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_equiv</span><span> </span><span>Bignorabimus_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI.‚àÄœâ.‚àÄX. (œâ‚ààgame_sem I Œ± X) ‚ü∑ (œâ‚ààgame_sem I Œ± (selectlike X œâ (M‚à™N)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>selectlike_compose</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M‚à™N)‚ààBignorabimus Œ±"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bignorabimus_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄM. M‚ààS ‚üπ M‚ààBignorabimus Œ±) ‚üπ (‚ãÉS)‚ààBignorabimus Œ±"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"S={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nonem</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉS‚ààBignorabimus Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄM. M‚ààS ‚üπ M‚ààBignorabimus Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonemp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"S‚â†{}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>powerset2up_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>infinite_super</span><span> </span><span>subset_eq</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonemp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Base</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cup</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Bignorabimus_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 13 üåê‚Äπhttps://doi.org/10.1007/978-3-319-94205-6_15‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>boundeffect</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ (-BVG(Œ±))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}‚ààBignorabimus Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Bignorabimus_init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-BVG Œ± = ‚ãÉ{xx. ‚àÉx. xx={x} ‚àß x‚àâBVG Œ±}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* finite *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-BVG Œ±)‚ààBignorabimus Œ±"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base</span><span> </span><span>h</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Bignorabimus_step mem_Collect_eq)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>VV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí variable set set ‚áí variable set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1. (‚àÉv2. v2 ‚àà x1 ‚àß v2 ‚àâ Bignorabimus x0) = (VV x0 x1 ‚àà x1 ‚àß VV x0 x1 ‚àâ Bignorabimus x0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"VV Œ± {{v} |v. v ‚àâ BVG Œ±} ‚àâ {{v} |v. v ‚àâ BVG Œ±} ‚à® VV Œ± {{v} |v. v ‚àâ BVG Œ±} ‚àà Bignorabimus Œ±"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉ{{v} |v. v ‚àâ BVG Œ±} ‚àà Bignorabimus Œ±"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Bignorabimus_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Bignorabimus_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>boundeffect_cor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚à©BVG(Œ±)={} ‚üπ (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ V))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>selectlike_compose</span><span> </span><span>sup.absorb_iff2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStatic Analysis Observations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤ ‚üπ BVG(Œ±) = BVG(Œ≤)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_equiv Œ± Œ≤"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Œ±) = BVG(Œ≤)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_subst_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>union_or</span><span> </span><span class="delimiter">=</span><span> </span><span>Set.Un_iff</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_union_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x‚àâA‚à™B) = (x‚àâA ‚àß x‚àâB)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_self</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv œâ x d ‚àà selectlike X œâ {x}) = (d=œâ(x) ‚àß œâ ‚àà X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vagree_repv_self</span><span> </span><span>Vagree_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span> </span><span>repv_self</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚â†y ‚üπ (repv œâ x d ‚àà selectlike X œâ {y}) = (repv œâ x d ‚àà X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚â†y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{y}‚äÜ-{x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv œâ x d ‚àà selectlike X œâ {y}) ‚üπ (repv œâ x d ‚àà X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>selectlike_def</span><span> </span><span>Vagree_repv</span><span class="delimiter">[</span><span>of</span><span> </span><span>œâ</span><span> </span><span>x</span><span> </span><span>d</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(repv œâ x d ‚àà X) ‚üπ (repv œâ x d ‚àà selectlike X œâ {y})"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-{x}‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>Vagree_repv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">=</span><span>d</span><span class="delimiter">]</span><span>
</span><span>  </span><span>selectlike_antimon</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span>X</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ{y}‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>W</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-{x}‚Ä∫</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>h</span><span class="delimiter">]</span><span> </span><span>Vagree_sym</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπrepv œâ x d‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-{x}‚Ä∫</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repv_selectlike_other_converse</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚â†y ‚üπ (repv œâ x d ‚àà X) = (repv œâ x d ‚àà selectlike X œâ {y})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_other</span><span> </span><span>HOL.eq_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚â†y ‚üπ y‚àâBVG(Assign x Œ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_other_converse</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign_meta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄI œâ. term_sem I Œ∏ œâ = œâ(x)) ‚üπ BVG(Assign x Œ∏) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I Œ∏ œâ ‚â† œâ(x) ‚üπ BVG(Assign x Œ∏) = {x}"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using repv_selectlike_self BVG_assign_other BVG_def BVG_elem*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x Œ∏) ‚äÜ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>singleton_iff</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fact</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄI œâ. term_sem I Œ∏ œâ = œâ(x)) ‚üπ BVG(Assign x Œ∏) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉI œâ. term_sem I Œ∏ œâ ‚â† œâ(x) ‚üπ x ‚àà BVG(Assign x Œ∏)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fact</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I Œ∏ œâ ‚â† œâ(x) ‚üπ BVG(Assign x Œ∏) = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_elem</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x Œ∏) = (if (‚àÄI œâ. term_sem I Œ∏ œâ = œâ(x)) then {} else {x})"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span>repv_selectlike_other</span><span> </span><span>BVG_assign_other</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Assign x Œ∏) ‚äÜ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>singletonI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI œâ. term_sem I Œ∏ œâ = œâ(x) ‚üπ BVG(Assign x Œ∏) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉI œâ. term_sem I Œ∏ œâ ‚â† œâ(x) ‚üπ x ‚àà BVG(Assign x Œ∏)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repv_selectlike_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉI œâ. term_sem I Œ∏ œâ ‚â† œâ(x) ‚üπ BVG(Assign x Œ∏) = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c0</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_ODE_other</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y‚â†RVar x ‚üπ y‚â†DVar x ‚üπ y‚àâBVG(ODE x Œ∏)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using nonBVG_rule selectlike_equal_cocond_rule solves_ODE_def*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>yx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y‚â†RVar x"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>yxp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y‚â†DVar x"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y‚àâBVG(ODE x Œ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonBVG_inc_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I (ODE x Œ∏) X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉF T. Vagree œâ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà X ‚àß solves_ODE I F x Œ∏"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>F</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà X ‚àß solves_ODE I F x Œ∏"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree œâ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà (selectlike X œâ {y}) ‚àß solves_ODE I F x Œ∏"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>yx</span><span> </span><span>yxp</span><span> </span><span>solves_Vagree</span><span> </span><span>Vagree_def</span><span> </span><span>similar_selectlike_mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉF T. Vagree œâ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà (selectlike X œâ {y}) ‚àß solves_ODE I F x Œ∏"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I (ODE x Œ∏) (selectlike X œâ {y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThis result could be strengthened to a conditional equality based on the RHS values‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_ODE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(ODE x Œ∏) ‚äÜ {RVar x,DVar x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_ODE_other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_test</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Test œÜ) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>game_sem.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_choice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Choice Œ± Œ≤) ‚äÜ BVG(Œ±) ‚à™ BVG(Œ≤)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>game_sem.simps</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_union_or</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
  have f1: "‚ãÄœâ I X. (œâ ‚àà game_sem I Œ± X ‚à™ game_sem I Œ≤ X) = 
  (œâ ‚àà game_sem I Œ± X ‚à® œâ ‚àà game_sem I Œ≤ X)" by (rule union_or)
  have f2: "‚ãÄœâ I X. (œâ ‚àâ game_sem I Œ± (selectlike X œâ {x}) ‚à™ game_sem I Œ≤ (selectlike X œâ {x})) =
  (œâ ‚àâ game_sem I Œ± (selectlike X œâ {x}) ‚àß œâ ‚àâ game_sem I Œ≤ (selectlike X œâ {x}))" by (rule not_union_or)
  let ?lhs = "{x. ‚àÉI œâ X.
           œâ ‚àà game_sem I Œ± X ‚à™ game_sem I Œ≤ X ‚àß
           œâ ‚àâ game_sem I Œ± (selectlike X œâ {x}) ‚à™ game_sem I Œ≤ (selectlike X œâ {x})}"
  let ?rhs = "{x. ‚àÉI œâ X. œâ ‚àà game_sem I Œ± X ‚àß œâ ‚àâ game_sem I Œ± (selectlike X œâ {x})} ‚à™
       {x. ‚àÉI œâ X. œâ ‚àà game_sem I Œ≤ X ‚àß œâ ‚àâ game_sem I Œ≤ (selectlike X œâ {x})}"
  show "?lhs‚äÜ?rhs" using f1 f2 by auto
qed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>select_nonBV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Œ±) ‚üπ selectlike (game_sem I Œ± (selectlike X œâ {x})) œâ {x} = selectlike (game_sem I Œ± X) œâ {x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I Œ± (selectlike X œâ {x})) œâ {x} ‚äÜ selectlike (game_sem I Œ± X) œâ {x}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span>selectlike_shrinks</span><span> </span><span>selectlike_antimon</span><span> </span><span>Bignorabimus_single</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>selectlike_union</span><span> </span><span>sup.absorb_iff1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nonbound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}‚à©BVG(Œ±)={}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I Œ± X) œâ {x} ‚äÜ selectlike (game_sem I Œ± (selectlike X œâ {x})) œâ {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Œº</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œº ‚àà selectlike (game_sem I Œ± X) œâ {x}"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* "V‚à©BVG(Œ±)={} ‚üπ (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ V))" *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œº ‚àà selectlike (game_sem I Œ± (selectlike X Œº {x})) œâ {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>Œº</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ{x}‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span>Œ±</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>fact</span><span class="delimiter">]</span><span> </span><span>nonbound</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ComplD</span><span> </span><span>ComplI</span><span> </span><span>co_selectlike</span><span> </span><span>not_union_or</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œº ‚àà selectlike (game_sem I Œ± (selectlike X œâ {x})) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_Vagree</span><span> </span><span>selectlike_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_compose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Compose Œ± Œ≤) ‚äÜ BVG(Œ±) ‚à™ BVG(Œ≤)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding BVG_def game_sem.simps using game_union union_or not_union_or selectlike_shrinks monotone selectlike_compose*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààBVG(Compose Œ± Œ≤)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà BVG Œ± ‚à™ BVG Œ≤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG Œ± ‚à™ BVG(Œ≤)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nŒ≤</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Œ≤)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Œ±)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉI.‚àÉœâ.‚àÉX. œâ ‚àà game_sem I (Compose Œ± Œ≤) X ‚àß œâ ‚àâ game_sem I (Compose Œ± Œ≤) (selectlike X œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>adef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I (Compose Œ± Œ≤) X ‚àß œâ ‚àâ game_sem I (Compose Œ± Œ≤) (selectlike X œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I Œ± (game_sem I Œ≤ X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àâ game_sem I Œ± (game_sem I Œ≤ (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike X œâ {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nŒ±</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nŒ±c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nŒ≤</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nŒ≤c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ X. (œâ ‚àà game_sem I Œ≤ X) = (œâ ‚àà game_sem I Œ≤ (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I Œ± (selectlike (game_sem I Œ≤ X) œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>nŒ±c</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπgame_sem I Œ≤ X‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àâ game_sem I Œ± (selectlike (game_sem I Œ≤ ?Y) œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>nŒ±c</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπgame_sem I Œ≤ ?Y‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àâ game_sem I Œ± (selectlike (game_sem I Œ≤ X) œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nŒ≤</span><span> </span><span>selectlike_Vagree</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I Œ≤ ?Y) œâ {x} = selectlike (game_sem I Œ≤ X) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nŒ≤</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>select_nonBV</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span>c3</span><span> </span><span>nŒ≤c</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe converse inclusion does not hold generally, because
   ‚ÄπBVG(x := x+1; x:= x-1) = {} ‚â† BVG(x := x+1) ‚à™ BVG(x := x-1) = {x}‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Compose (Assign x (Plus (Var x) (Number 1))) (Assign x (Plus (Var x) (Number (-1))))) 
    ‚â† BVG(Assign x (Plus (Var x) (Number 1))) ‚à™ BVG(Assign x (Plus (Var x) (Number (-1))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>BVG_def</span><span> </span><span>selectlike_def</span><span> </span><span>repv_def</span><span> </span><span>Vagree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Loop Œ±) ‚äÜ BVG(Œ±)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààBVG(Loop Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà BVG(Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ (x ‚àà BVG(Œ±))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG Œ±"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nŒ±</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nŒ±c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ X. (œâ ‚àà game_sem I Œ± X) = (œâ ‚àà game_sem I Œ± (selectlike X œâ {x}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_nonelem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚àâBVG(Loop Œ±)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using BVG_nonelem*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonBVG_rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªZ. X ‚à™ game_sem I Œ± Z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªY. (selectlike X œâ {x}) ‚à™ game_sem I Œ± Y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªZ Y. selectlike Z œâ {x} = selectlike Y œâ {x}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R (lfp ?f) (lfp ?g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_lockstep_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?f‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?g‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?R‚Ä∫</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monof</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monog</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A œâ {x} = selectlike B œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* using selectlike_union nŒ± select_nonBV IH by (smt insert_absorb2 insert_def selectlike_compose singleton_conv smt_solver=cvc4)  *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ‚à™ game_sem I Œ± A) œâ {x} = selectlike X œâ {x} ‚à™ selectlike (game_sem I Œ± A) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike X œâ {x} ‚à™ selectlike (game_sem I Œ± (selectlike A œâ {x})) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nŒ±</span><span> </span><span>select_nonBV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike X œâ {x} ‚à™ selectlike (game_sem I Œ± (selectlike B œâ {x})) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = selectlike (selectlike X œâ {x} ‚à™ game_sem I Œ± B) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_union</span><span> </span><span>nŒ±</span><span> </span><span>select_nonBV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ‚à™ game_sem I Œ± A) œâ {x} = selectlike (selectlike X œâ {x} ‚à™ game_sem I Œ± B) œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ(A,B)‚ààM. selectlike A œâ {x} = selectlike B œâ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_proj_mem</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>M</span><span class="delimiter">]</span><span> </span><span>snd_proj_mem</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>M</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>selectlike_Sup</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ{x}‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>sup_corr_eq_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
          have "selectlike (‚ãÉfst_proj M) œâ {x} = ‚ãÉ{selectlike A œâ {x} | A. A‚ààfst_proj M}" using selectlike_Sup by simp
          also have "... = ‚ãÉ{selectlike B œâ {x} | B. B‚ààsnd_proj M}" using sup_corr_eq_chain[OF IH] by simp
          also have "... = selectlike (‚ãÉsnd_proj M) œâ {x}" using selectlike_Sup by simp
          finally show "selectlike (‚ãÉfst_proj M) œâ {x} = selectlike (‚ãÉsnd_proj M) œâ {x}" .
        qed*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ ‚àà game_sem I (Loop Œ±) X) = (œâ ‚àà game_sem I (Loop Œ±) (selectlike X œâ {x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>lfp_def</span><span> </span><span>selectlike_self</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (simp add: selectlike_self game_sem_loop_back)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BVG_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(Dual Œ±) ‚äÜ BVG(Œ±)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding game_sem.simps using BVG_elem selectlike_co_selectlike co_selectlike selectlike_complement selectlike_antimon*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààBVG(Dual Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààBVG Œ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉI.‚àÉœâ.‚àÉX. œâ ‚àà game_sem I (Dual Œ±) X ‚àß œâ ‚àâ game_sem I (Dual Œ±) (selectlike X œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>adef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I (Dual Œ±) X ‚àß œâ ‚àâ game_sem I (Dual Œ±) (selectlike X œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àâ game_sem I Œ± (- X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I Œ± (- selectlike X œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"- selectlike X œâ {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà game_sem I Œ± ?Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àâ game_sem I Œ± (selectlike ?Y œâ {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>selectlike_co_selectlike</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>selectlike_shrinks</span><span> </span><span>monotone</span><span> </span><span>dual_order.trans</span><span> </span><span>subset_Compl_singleton</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x‚ààBVG(Œ±)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="USubst">
<div class="head"><h1>Theory USubst</h1>
<span class="command">theory</span> <span class="name">USubst</span><br/>
<span class="keyword">imports</span> <a href="Coincidence.html"><span class="name">Coincidence</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"USubst"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>          
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitution‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπuniform substitution representation as tuple of partial maps from identifiers to type-compatible replacements.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>usubst</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ident ‚áÄ trm) √ó (ident ‚áÄ trm) √ó (ident ‚áÄ fml) √ó (ident ‚áÄ game)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SConst</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí (ident ‚áÄ trm)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst ‚â° (Œª(F0, _, _, _). F0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SFuncs</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí (ident ‚áÄ trm)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs ‚â° (Œª(_, F, _, _). F)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SPreds</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí (ident ‚áÄ fml)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds ‚â° (Œª(_, _, P, _). P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SGames</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí (ident ‚áÄ game)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames ‚â° (Œª(_, _, _, G). G)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcrude approximation of size which is enough for termination arguments‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usubstsize</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstsize œÉ = (if (dom (SFuncs œÉ) = {} ‚àß dom (SPreds œÉ) = {}) then 1 else 2)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπdot is some fixed constant function symbol that is reserved for the purposes of the substitution‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dot</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dot = Const (dotid)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStrict Mechanism for Handling Substitution Partiality in Isabelle‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπOptional terms that result from a substitution, either actually a term or just none to indicate that the substitution clashed‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>trmo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undeft</span><span class="delimiter">::</span><span> </span><span>trmo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undeft ‚â° None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Aterm</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí trmo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Aterm ‚â° Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeft_None</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"undeft=None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aterm_Some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Aterm Œ∏=Some Œ∏"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeft_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œ∏‚â†undeft) = (‚àÉt. Œ∏=Aterm t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPlus on defined terms, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Pluso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ‚áí trmo ‚áí trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Pluso (Aterm Œ∏) (Aterm Œ∑) = Aterm(Plus Œ∏ Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pluso undeft Œ∑ = undeft"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pluso Œ∏ undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTimes on defined terms, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Timeso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ‚áí trmo ‚áí trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Timeso (Aterm Œ∏) (Aterm Œ∑) = Aterm(Times Œ∏ Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Timeso undeft Œ∑ = undeft"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Timeso Œ∏ undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Differentialo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ‚áí trmo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Differentialo (Aterm Œ∏) = Aterm(Differential Œ∏)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Differentialo undeft = undeft"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pluso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Pluso Œ∏ Œ∑ = undeft) = (Œ∏=undeft ‚à® Œ∑=undeft)"</span></span></span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pluso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Timeso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Timeso Œ∏ Œ∑ = undeft) = (Œ∏=undeft ‚à® Œ∑=undeft)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Timeso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Differentialo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Differentialo Œ∏ = undeft) = (Œ∏=undeft)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Differentialo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fmlo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undeff</span><span class="delimiter">::</span><span> </span><span>fmlo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undeff ‚â° None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Afml</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml ‚áí fmlo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Afml ‚â° Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>gameo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"game option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undefg</span><span class="delimiter">::</span><span> </span><span>gameo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undefg ‚â° None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Agame</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí gameo"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame ‚â° Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undeff_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(œÜ‚â†undeff) = (‚àÉf. œÜ=Afml f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undefg_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œ±‚â†undefg) = (‚àÉg. Œ±=Agame g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGeq on defined terms, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Geqo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trmo ‚áí trmo ‚áí fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Geqo (Aterm Œ∏) (Aterm Œ∑) = Afml(Geq Œ∏ Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geqo undeft Œ∑ = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geqo Œ∏ undeft = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNot on defined formulas, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Noto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ‚áí fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Noto (Afml œÜ) = Afml(Not œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Noto undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnd on defined formulas, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Ando</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ‚áí fmlo ‚áí fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ando (Afml œÜ) (Afml œà) = Afml(And œÜ œà)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ando undeff œà = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ando œÜ undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExists on defined formulas, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Existso</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ‚áí fmlo ‚áí fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Existso x (Afml œÜ) = Afml(Exists x œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Existso x undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDiamond on defined games/formulas, strict undeft otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Diamondo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ‚áí fmlo ‚áí fmlo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Diamondo (Agame Œ±) (Afml œÜ) = Afml(Diamond Œ± œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Diamondo undefg œÜ = undeff"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Diamondo Œ± undeff = undeff"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Geqo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Geqo Œ∏ Œ∑ = undeff) = (Œ∏=undeft ‚à® Œ∑=undeft)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Geqo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Noto_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Noto œÜ = undeff) = (œÜ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Noto.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ando_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Ando œÜ œà = undeff) = (œÜ=undeff ‚à® œà=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ando.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Existso_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Existso x œÜ = undeff) = (œÜ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Existso.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Diamondo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Diamondo Œ± œÜ = undeff) = (Œ±=undefg ‚à® œÜ=undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamondo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAssign on defined terms, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Assigno</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ‚áí trmo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Assigno x (Aterm Œ∏) = Agame(Assign x Œ∏)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Assigno x undeft = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ODEo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ident ‚áí trmo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ODEo x (Aterm Œ∏) = Agame(ODE x Œ∏)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ODEo x undeft = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTest on defined formulas, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Testo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fmlo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Testo (Afml œÜ) = Agame(Test œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Testo undeff = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπChoice on defined games, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Choiceo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ‚áí gameo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Choiceo (Agame Œ±) (Agame Œ≤) = Agame(Choice Œ± Œ≤)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Choiceo Œ± undefg = undefg"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Choiceo undefg Œ≤ = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCompose on defined games, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Composeo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ‚áí gameo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Composeo (Agame Œ±) (Agame Œ≤) = Agame(Compose Œ± Œ≤)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Composeo Œ± undefg = undefg"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Composeo undefg Œ≤ = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLoop on defined games, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Loopo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Loopo (Agame Œ±) = Agame(Loop Œ±)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Loopo undefg = undefg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDual on defined games, strict undefg otherwise ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>Dualo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gameo ‚áí gameo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Dualo (Agame Œ±) = Agame(Dual Œ±)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"Dualo undefg = undefg"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Assigno_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Assigno x Œ∏ = undefg) = (Œ∏=undeft)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ODEo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ODEo x Œ∏ = undefg) = (Œ∏=undeft)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Testo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Testo œÜ = undefg) = (œÜ=undeff)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Choiceo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Choiceo Œ± Œ≤ = undefg) = (Œ±=undefg ‚à® Œ≤=undefg)"</span></span></span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Composeo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Composeo Œ± Œ≤ = undefg) = (Œ±=undefg ‚à® Œ≤=undefg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Composeo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Loopo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Loopo Œ± = undefg) = (Œ±=undefg)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Loopo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Dualo_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Dualo Œ± = undefg) = (Œ±=undefg)"</span></span></span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo.elims</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRecursive Application of One-Pass Uniform Substitution‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚Äπdotsubstt Œ∏‚Ä∫ is the dot substitution ‚Äπ{. ~&gt; Œ∏}‚Ä∫ substituting a term for the . function symbol‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dotsubstt</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí usubst"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dotsubstt Œ∏ = (
         (Œªf. (if f=dotid then (Some(Œ∏)) else None)),
         (Œª_. None),
         (Œª_. None),
         (Œª_. None)
  )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usappconst</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí variable set ‚áí ident ‚áí (trmo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst œÉ U f ‚â° (case SConst œÉ f of Some r ‚áí if FVT(r)‚à©U={} then Aterm(r) else undeft | None ‚áí Aterm(Const f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>usubstappt</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí variable set ‚áí (trm ‚áí trmo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Var x)     = Aterm (Var x)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Number r)  = Aterm (Number r)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f)   = usappconst œÉ U f"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Func f Œ∏)  =
  (case usubstappt œÉ U Œ∏ of undeft   ‚áí undeft
                          | Aterm œÉŒ∏ ‚áí (case SFuncs œÉ f of Some r ‚áí if FVT(r)‚à©U={} then usubstappt(dotsubstt œÉŒ∏) {} r else undeft | None ‚áí Aterm(Func f œÉŒ∏)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Plus Œ∏ Œ∑)  = Pluso (usubstappt œÉ U Œ∏) (usubstappt œÉ U Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Times Œ∏ Œ∑) = Timeso (usubstappt œÉ U Œ∏) (usubstappt œÉ U Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Differential Œ∏) = Differentialo (usubstappt œÉ allvars Œ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measures [Œª(œÉ,U,Œ∏). usubstsize œÉ , Œª(œÉ,U,Œ∏). size Œ∏]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubstsize_def</span><span> </span><span>dotsubstt_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Expand let constructs automatically *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Let_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>usubstappf</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí variable set ‚áí (fml ‚áí fmlo)"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usubstappp</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí variable set ‚áí (game ‚áí variable set √ó gameo)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏)   = 
  (case usubstappt œÉ U Œ∏ of undeft   ‚áí undeff
                          | Aterm œÉŒ∏ ‚áí (case SPreds œÉ p of Some r ‚áí if FVF(r)‚à©U={} then usubstappf(dotsubstt œÉŒ∏) {} r else undeff | None ‚áí Afml(Pred p œÉŒ∏)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Geq Œ∏ Œ∑)    = Geqo (usubstappt œÉ U Œ∏) (usubstappt œÉ U Œ∑)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Not œÜ)      = Noto (usubstappf œÉ U œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (And œÜ œà)    = Ando (usubstappf œÉ U œÜ) (usubstappf œÉ U œà)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Exists x œÜ) = Existso x (usubstappf œÉ (U‚à™{x}) œÜ)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Diamond Œ± œÜ) = (let VŒ± = usubstappp œÉ U Œ± in Diamondo (snd VŒ±) (usubstappf œÉ (fst VŒ±) œÜ))"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Game a)   =
  (case SGames œÉ a of Some r ‚áí (U‚à™BVG(r),Agame r)
                    | None   ‚áí (allvars,Agame(Game a)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Assign x Œ∏) = (U‚à™{x}, Assigno x (usubstappt œÉ U Œ∏))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Test œÜ) = (U, Testo (usubstappf œÉ U œÜ))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Choice Œ± Œ≤) =
    (let VŒ± = usubstappp œÉ U Œ± in
     let WŒ≤ = usubstappp œÉ U Œ≤ in
     (fst VŒ±‚à™fst WŒ≤, Choiceo (snd VŒ±) (snd WŒ≤)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Compose Œ± Œ≤) =
    (let VŒ± = usubstappp œÉ U Œ± in
     let WŒ≤ = usubstappp œÉ (fst VŒ±) Œ≤ in
     (fst WŒ≤, Composeo (snd VŒ±) (snd WŒ≤)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Loop Œ±) =
    (let V = fst(usubstappp œÉ U Œ±) in
     (V, Loopo (snd(usubstappp œÉ V Œ±))))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Dual Œ±) =
    (let VŒ± = usubstappp œÉ U Œ± in (fst VŒ±, Dualo (snd VŒ±)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (ODE x Œ∏) = (U‚à™{RVar x,DVar x}, ODEo x (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measures [(Œªk. usubstsize (case k of Inl(œÉ,U,œÜ) ‚áí œÉ | Inr(œÉ,U,Œ±) ‚áí œÉ)) , (Œªk. case k of Inl (œÉ,U,œÜ) ‚áí size œÜ | Inr (œÉ,U,Œ±) ‚áí size Œ±)]"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubstsize_def</span><span> </span><span>dotsubstt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInduction Principles for Uniform Substitutions‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usubstappt_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>usubstappt.induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Var</span><span> </span><span>Number</span><span> </span><span>Const</span><span> </span><span>FuncMatch</span><span> </span><span>Plus</span><span> </span><span>Times</span><span> </span><span>Differential</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usubstappfp_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>usubstappf_usubstappp.induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Pred</span><span> </span><span>Geq</span><span> </span><span>Not</span><span> </span><span>And</span><span> </span><span>Exists</span><span> </span><span>Diamond</span><span>  </span><span>Game</span><span> </span><span>Assign</span><span> </span><span>Test</span><span> </span><span>Choice</span><span> </span><span>Compose</span><span> </span><span>Loop</span><span> </span><span>Dual</span><span> </span><span>ODE</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple Observations for Automation‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMore automation for Case‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usappconst_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = Some r ‚üπ FVT(r)‚à©U={} ‚üπ usappconst œÉ U f = Aterm(r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = None ‚üπ usappconst œÉ U f = Aterm(Const f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = Some r ‚üπ FVT(r)‚à©U‚â†{} ‚üπ usappconst œÉ U f = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usappconst_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst œÉ U f‚â†undeft ‚üπ
  SConst œÉ f = None ‚à® (‚àÉr. SConst œÉ f = Some r ‚àß FVT(r)‚à©U={})"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if option.collapse usappconst_def)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usappconst œÉ U f‚â†undeft"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = None ‚à® (‚àÉr. SConst œÉ f = Some r ‚àß FVT(r)‚à©U={})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>usappconst_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œÉ</span><span class="delimiter">=</span><span>œÉ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>f</span><span class="delimiter">]</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_const</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = Some r ‚üπ FVT(r)‚à©U={} ‚üπ usubstappt œÉ U (Const f) = Aterm(r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = None ‚üπ usubstappt œÉ U (Const f) = Aterm(Const f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f = Some r ‚üπ FVT(r)‚à©U‚â†{} ‚üπ usubstappt œÉ U (Const f) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_const_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f)‚â†undeft ‚üπ
  SConst œÉ f = None ‚à® (‚àÉr. SConst œÉ f = Some r ‚àß FVT(r)‚à©U={})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usappconst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f = Some r ‚üπ FVT(r)‚à©U={} ‚üπ usubstappt œÉ U Œ∏ = Aterm œÉŒ∏ ‚üπ
  usubstappt œÉ U (Func f Œ∏) = usubstappt (dotsubstt œÉŒ∏) {} r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f=None ‚üπ  usubstappt œÉ U Œ∏ = Aterm œÉŒ∏ ‚üπ usubstappt œÉ U (Func f Œ∏) = Aterm(Func f œÉŒ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ = undeft ‚üπ usubstappt œÉ U (Func f Œ∏) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f = Some r ‚üπ FVT(r)‚à©U‚â†{} ‚üπ usubstappt œÉ U (Func f Œ∏) = undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_func_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Func f Œ∏) ‚â† undeft ‚üπ
  usubstappt œÉ U Œ∏ ‚â† undeft ‚àß
    (SFuncs œÉ f = None ‚à® (‚àÉr. SFuncs œÉ f = Some r ‚àß FVT(r)‚à©U={}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>undeft_equiv</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>usubstappt_func2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (cases "usubstappt œÉ U Œ∏") (auto) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_plus_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Plus Œ∏ Œ∑) ‚â† undeft ‚üπ
  usubstappt œÉ U Œ∏ ‚â† undeft ‚àß usubstappt œÉ U Œ∑ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pluso_undef</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_times_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Times Œ∏ Œ∑) ‚â† undeft ‚üπ
  usubstappt œÉ U Œ∏ ‚â† undeft ‚àß usubstappt œÉ U Œ∑ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Timeso_undef</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_differential_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Differential Œ∏) ‚â† undeft ‚üπ
  usubstappt œÉ allvars Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Differentialo_undef</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = Some r ‚üπ FVF(r)‚à©U={} ‚üπ usubstappt œÉ U Œ∏ = Aterm œÉŒ∏ ‚üπ
  usubstappf œÉ U (Pred p Œ∏) = usubstappf (dotsubstt œÉŒ∏) {} r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = None ‚üπ usubstappt œÉ U Œ∏ = Aterm œÉŒ∏ ‚üπ usubstappf œÉ U (Pred p Œ∏) = Afml(Pred p œÉŒ∏)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ = undeft ‚üπ usubstappf œÉ U (Pred p Œ∏) = undeff"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = Some r ‚üπ FVF(r)‚à©U‚â†{} ‚üπ usubstappf œÉ U (Pred p Œ∏) = undeff"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† undeff ‚üπ
  usubstappt œÉ U Œ∏ ‚â† undeft ‚àß
    (SPreds œÉ p = None ‚à® (‚àÉr. SPreds œÉ p = Some r ‚àß FVF(r)‚à©U={}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>undeff_equiv</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft ‚üπ usubstappt œÉ U Œ∑ ‚â† undeft ‚üπ
  usubstappf œÉ U (Geq Œ∏ Œ∑) = Afml(Geq (the (usubstappt œÉ U Œ∏)) (the (usubstappt œÉ U Œ∑)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geq_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Geq Œ∏ Œ∑) ‚â† undeff ‚üπ
  usubstappt œÉ U Œ∏ ‚â† undeft ‚àß usubstappt œÉ U Œ∑ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Geqo_undef</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_geqr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Geq Œ∏ Œ∑) ‚â† undeff ‚üπ
  usubstappf œÉ U (Geq Œ∏ Œ∑) = Afml(Geq (the (usubstappt œÉ U Œ∏)) (the (usubstappt œÉ U Œ∑)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq</span><span> </span><span>usubstappf_geq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_exists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Exists x œÜ) ‚â† undeff ‚üπ
  usubstappf œÉ U (Exists x œÜ) = Afml(Exists x (the (usubstappf œÉ (U‚à™{x}) œÜ)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Existso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_game</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a = Some r ‚üπ usubstappp œÉ U (Game a) = (U‚à™BVG(r),Agame(r))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a = None ‚üπ usubstappp œÉ U (Game a) = (allvars,Agame(Game a))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_choice</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Choice Œ± Œ≤) =
  (fst(usubstappp œÉ U Œ±)‚à™fst(usubstappp œÉ U Œ≤), Choiceo (snd(usubstappp œÉ U Œ±)) (snd(usubstappp œÉ U Œ≤)))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_choice_conv</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U (Choice Œ± Œ≤)) ‚â† undefg ‚üπ
  snd(usubstappp œÉ U Œ±) ‚â† undefg ‚àß snd(usubstappp œÉ U Œ≤) ‚â† undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Compose Œ± Œ≤) =
  (fst(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ≤), Composeo (snd(usubstappp œÉ U Œ±)) (snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ≤)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Loop Œ±) =
  (fst(usubstappp œÉ U Œ±), Loopo (snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_dual</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappp œÉ U (Dual Œ±) =
  (fst(usubstappp œÉ U Œ±), Dualo (snd (usubstappp œÉ U Œ±)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSoundness of Uniform Substitution‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUSubst Application is a Function of Deterministic Result‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft ‚üπ usubstappt œÉ V Œ∏ ‚â† undeft ‚üπ
  usubstappt œÉ U Œ∏ = usubstappt œÉ V Œ∏"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usappconst_def usubstappt.simps(3))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) = (case SConst œÉ f of None ‚áí Aterm (Const f) | Some t ‚áí if FVT t ‚à© U = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::trm option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SConst œÉ f)) ‚à© U = {} then Aterm (the (SConst œÉ f)) else undeft) = usappconst œÉ U f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ FVT (the (SConst œÉ f)) ‚à© U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SConst œÉ f)) ‚à© V = {} then Aterm (the (SConst œÉ f)) else undeft) = usappconst œÉ V f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ FVT (the (SConst œÉ f)) ‚à© V = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ usubstappt œÉ U (Const f) = usappconst œÉ V f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) ‚â† usubstappt œÉ V (Const f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) ‚â† (case SConst œÉ f of None ‚áí Aterm (Const f) | Some t ‚áí if FVT t ‚à© V = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Func</span><span> </span><span>f</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (cases "SFuncs œÉ f") (auto simp add: usubstappt_func)*)</span></span></span></span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usubstappt.simps(4))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© U = {} then usubstappt (dotsubstt t) {} ta else undeft)) ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::trm option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ V Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© V = {} then usubstappt (dotsubstt t) {} ta else undeft)) ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ V Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (trm.Func f Œ∏) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>Func</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SFuncs œÉ f)) ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) else undeft) = usubstappt œÉ U (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>Func</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ FVT (the (SFuncs œÉ f)) ‚à© U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Func</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ V Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© V = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© V = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SFuncs œÉ f)) ‚à© V = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) else undeft) = usubstappt œÉ V (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ FVT (the (SFuncs œÉ f)) ‚à© V = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Func</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (trm.Func f Œ∏) ‚â† usubstappt œÉ V (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© V = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft) ‚â† Aterm (trm.Func f (the (usubstappt œÉ V Œ∏)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span>f7</span><span> </span><span>f6</span><span> </span><span>f5</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>Œ∏1</span><span> </span><span>Œ∏2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>Œ∏1</span><span> </span><span>Œ∏2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Differentialo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ V œÜ ‚â† undeff ‚üπ usubstappf œÉ U œÜ = usubstappf œÉ V œÜ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ V Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ U Œ±) = snd(usubstappp œÉ V Œ±)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>p</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span>usubstappf_pred</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (metis usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt option.case_eq_if usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt t) {} f else undeff)) ‚â† undeff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::fml option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ U Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ V Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt t) {} f else undeff)) ‚â† undeff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ = usubstappt œÉ V Œ∏"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>usubstappt_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) = (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeff then (case za of None ‚áí z::fml option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ V Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff ‚ü∂ usubstappf œÉ U (Pred p Œ∏) = usubstappf œÉ V (Pred p Œ∏)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† usubstappf œÉ V (Pred p Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>f5</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ U Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p))‚Ä∫</span></span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)‚Ä∫</span></span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ(if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p))‚Ä∫</span></span></span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπusubstappf œÉ U (Pred p Œ∏) ‚â† usubstappf œÉ V (Pred p Œ∏)‚Ä∫</span></span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred_conv</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Geqo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Noto.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ando_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Existso_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamondo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Composeo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Loopo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ V œÜ ‚â† undeff ‚üπ usubstappf œÉ U œÜ = usubstappf œÉ V œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ V Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ U Œ±) = snd(usubstappp œÉ V Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitutions are Antimonotone in Taboos‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±) ‚äá U"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_pair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (a,b) = a"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_pair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (a,b) = b"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappt_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ usubstappt œÉ U Œ∏ ‚â† undeft ‚üπ
  usubstappt œÉ U Œ∏ = usubstappt œÉ V Œ∏"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt disjoint_iff_not_equal option.case_eq_if set_rev_mp usappconst_def usubstappt.simps(3))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) = (case SConst œÉ f of None ‚áí Aterm (Const f) | Some t ‚áí if FVT t ‚à© U = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::trm option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SConst œÉ f)) ‚à© U = {} then Aterm (the (SConst œÉ f)) else undeft) = usappconst œÉ U f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usappconst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚ü∂ FVT (the (SConst œÉ f)) ‚à© U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄV Va. (V ‚à© Va = {}) = (‚àÄv. (v::variable) ‚àà V ‚ü∂ (‚àÄva. va ‚àà Va ‚ü∂ v ‚â† va))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) ‚â† usubstappt œÉ V (Const f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (Const f) ‚â† (case SConst œÉ f of None ‚áí Aterm (Const f) | Some t ‚áí if FVT t ‚à© V = {} then Aterm t else undeft)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f ‚â† undeft ‚àß FVT (the (SConst œÉ f)) ‚à© V = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Const.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>usappconst_def</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Func</span><span> </span><span>f</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt disjoint_iff_not_equal option.case_eq_if subset_iff usubstappt.simps(4))*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© U = {} then usubstappt (dotsubstt t) {} ta else undeft)) ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::trm option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© U = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ U Œ∏))) | Some t ‚áí if FVT t ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ U Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ = undeft ‚à® usubstappt œÉ U Œ∏ = usubstappt œÉ V Œ∏"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.IH</span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SFuncs œÉ f)) ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) else undeft) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ (if FVT (the (SFuncs œÉ f)) ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) else undeft) = usubstappt œÉ U (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ FVT (the (SFuncs œÉ f)) ‚à© U = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ V ‚äÜ - FVT (the (SFuncs œÉ f))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Func.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ V Œ∏ of None ‚áí undeft | Some t ‚áí (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f t) | Some ta ‚áí if FVT ta ‚à© V = {} then usubstappt (dotsubstt t) {} ta else undeft)) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© V = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) = (case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© U = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft ‚ü∂ usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SFuncs œÉ f)) = usubstappt œÉ U (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U (trm.Func f Œ∏) ‚â† usubstappt œÉ V (trm.Func f Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SFuncs œÉ f of None ‚áí Aterm (trm.Func f (the (usubstappt œÉ V Œ∏))) | Some t ‚áí if FVT t ‚à© V = {} then usubstappt (dotsubstt (the (usubstappt œÉ V Œ∏))) {} t else undeft) ‚â† Aterm (trm.Func f (the (usubstappt œÉ V Œ∏)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f ‚â† undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span>f8</span><span> </span><span>f7</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_eq_subset_Compl</span><span> </span><span>inf.commute</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>Œ∏1</span><span> </span><span>Œ∏2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>Œ∏1</span><span> </span><span>Œ∏2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Differentialo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitutions of Games have monotone taboo output‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_fst_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U‚äÜV ‚üπ fst(usubstappp œÉ U Œ±) ‚äÜ fst(usubstappp œÉ V Œ±)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_choice</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_compose</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_loop</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>usubstappp_dual</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ U œÜ = usubstappf œÉ V œÜ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ U Œ±) = snd(usubstappp œÉ V Œ±)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ V œÜ ‚â† undeff"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ V Œ±) ‚â† undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>p</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span>usubstappf_pred</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Un_mono disjoint_eq_subset_Compl empty_subsetI inf.commute option.case_eq_if sup.absorb_iff1 sup.absorb_iff2 usubstappf.simps(1)) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄv. v ‚àâ V ‚à® v ‚àà U"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeff then (case za of None ‚áí z::fml option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt t) {} f else undeff)) ‚â† undeff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz f za. if za = undeft then (case za of None ‚áí z::fml option | Some x ‚áí f x) = z else (case za of None ‚áí z | Some x ‚áí f x) = f (the za)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case usubstappt œÉ U Œ∏ of None ‚áí undeff | Some t ‚áí (case SPreds œÉ p of None ‚áí Afml (Pred p t) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt t) {} f else undeff)) = (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ U Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ = usubstappt œÉ V Œ∏"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt_antimon</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff ‚ü∂ usubstappf œÉ U (Pred p Œ∏) = usubstappf œÉ V (Pred p Œ∏)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí variable set ‚áí variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1. (‚àÉv2. v2 ‚àà x1 ‚àß (‚àÉv3. v3 ‚àà x0 ‚àß v2 = v3)) = (vv x0 x1 ‚àà x1 ‚àß (‚àÉv3. v3 ‚àà x0 ‚àß vv x0 x1 = v3))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vva</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable set ‚áí variable set ‚áí variable"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄV Va. (V ‚à© Va ‚â† {} ‚à® (‚àÄv. v ‚àâ V ‚à® (‚àÄva. va ‚àâ Va ‚à® v ‚â† va))) ‚àß (V ‚à© Va = {} ‚à® vv Va V ‚àà V ‚àß vva Va V ‚àà Va ‚àß vv Va V = vva Va V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f10</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(FVF (the (SPreds œÉ p)) ‚à© V ‚â† {} ‚à® (‚àÄv. v ‚àâ FVF (the (SPreds œÉ p)) ‚à® (‚àÄva. va ‚àâ V ‚à® v ‚â† va))) ‚àß (FVF (the (SPreds œÉ p)) ‚à© V = {} ‚à® vv V (FVF (the (SPreds œÉ p))) ‚àà FVF (the (SPreds œÉ p)) ‚àß vva V (FVF (the (SPreds œÉ p))) ‚àà V ‚àß vv V (FVF (the (SPreds œÉ p))) = vva V (FVF (the (SPreds œÉ p))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vv V (FVF (the (SPreds œÉ p))) ‚àâ FVF (the (SPreds œÉ p)) ‚à® vva V (FVF (the (SPreds œÉ p))) ‚àâ V ‚à® vv V (FVF (the (SPreds œÉ p))) ‚â† vva V (FVF (the (SPreds œÉ p)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf œÉ V (Pred p Œ∏)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ(if FVF (the (SPreds œÉ p)) ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† usubstappf œÉ V (Pred p Œ∏)‚Ä∫</span></span></span><span> </span><span>calculation</span><span> </span><span>f5</span><span> </span><span>f7</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ V (Pred p Œ∏) = undeff ‚ü∂ SPreds œÉ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) ‚â† usubstappf œÉ U (Pred p Œ∏)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ U Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>f7</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπusubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) ‚â† usubstappf œÉ U (Pred p Œ∏)‚Ä∫</span></span></span><span> </span><span>f5</span><span> </span><span>f7</span><span> </span><span>option.collapse</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds œÉ p)) ‚à© U = {} ‚ü∂ SPreds œÉ p = undeff"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds œÉ p)) ‚à© U = {} ‚àß usubstappf œÉ V (Pred p Œ∏) = undeff ‚ü∂ SPreds œÉ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f10</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF (the (SPreds œÉ p)) ‚à© U ‚â† {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ U Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff) ‚â† (case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFVF (the (SPreds œÉ p)) ‚à© U ‚â† {}‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case SPreds œÉ p of None ‚áí Afml (Pred p (the (usubstappt œÉ V Œ∏))) | Some f ‚áí if FVF f ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} f else undeff) ‚â† (if FVF (the (SPreds œÉ p)) ‚à© U = {} then usubstappf (dotsubstt (the (usubstappt œÉ V Œ∏))) {} (the (SPreds œÉ p)) else undeff)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p = undeff"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFVF (the (SPreds œÉ p)) ‚à© U ‚â† {}‚Ä∫</span></span></span><span> </span><span>option.discI</span><span> </span><span>option.expand</span><span> </span><span>option.sel</span><span> </span><span>usubstappf_pred2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ V (Pred p Œ∏) = undeff ‚ü∂ SPreds œÉ p = undeff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f9</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Geqo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Noto_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ando_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Existso_undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_mono</span><span> </span><span>subsetI</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>x1</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Diamondo_undef</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assigno_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_antimon</span><span> </span><span>ODEo_undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Un_mono</span><span> </span><span>order_refl</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Testo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Choiceo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_compose</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œÉ</span><span class="delimiter">=</span><span>œÉ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span>Œ±</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ≤</span><span class="delimiter">=</span><span>Œ≤</span><span class="delimiter">]</span><span> </span><span>usubstappp_compose</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œÉ</span><span class="delimiter">=</span><span>œÉ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span>Œ±</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ≤</span><span class="delimiter">=</span><span>Œ≤</span><span class="delimiter">]</span><span>
</span><span>          </span><span>Composeo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsnd (usubstappp œÉ U Œ±)‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ≤</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsnd (usubstappp œÉ (fst (usubstappp œÉ U Œ±)) Œ≤)‚Ä∫</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>Composeo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsnd (usubstappp œÉ V Œ±)‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ≤</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsnd (usubstappp œÉ (fst (usubstappp œÉ V Œ±)) Œ≤)‚Ä∫</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>snd_conv</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof-
            from Compose have ca: "snd (usubstappp œÉ U (Œ± ;; Œ≤)) ‚â† undefg" by simp
            have decU: "snd (usubstappp œÉ U (Œ± ;; Œ≤)) = Composeo (snd(usubstappp œÉ U Œ±)) (snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ≤))" using usubstappp_compose by simp
            have decV: "snd (usubstappp œÉ V (Œ± ;; Œ≤)) = Composeo (snd(usubstappp œÉ V Œ±)) (snd(usubstappp œÉ (fst(usubstappp œÉ V Œ±)) Œ≤))" using usubstappp_compose by simp
            from Compose have fact1: "snd(usubstappp œÉ V Œ±) ‚â† undefg" using Composeo_undef by auto 
            from Compose have fact2: "snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ≤) ‚â† undefg" using Composeo_undef by auto 
            have rel: "fst(usubstappp œÉ V Œ±) ‚äÜ fst(usubstappp œÉ U Œ±)" using ‚ÄπV‚äÜU‚Ä∫ usubstappp_fst_mon by auto
            from Compose have fact3: "snd(usubstappp œÉ (fst(usubstappp œÉ V Œ±)) Œ≤) ‚â† undefg" using fact2 rel by auto 
            then show ?thesis by (simp add: Composeo_undef fact1)
          qed*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Loopo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>usubstappp_fst_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Dualo_undef</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ U œÜ = usubstappf œÉ V œÜ"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ U Œ±) = snd(usubstappp œÉ V Œ±)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappf_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ usubstappf œÉ U œÜ ‚â† undeff ‚üπ usubstappf œÉ U œÜ = usubstappf œÉ V œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_antimon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V‚äÜU ‚üπ snd(usubstappp œÉ U Œ±) ‚â† undefg ‚üπ snd(usubstappp œÉ U Œ±) = snd(usubstappp œÉ V Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_and_usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTaboo Lemmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Loop Œ±)) ‚â† undefg ‚üπ
  snd(usubstappp œÉ U Œ±) ‚â† undefg ‚àß
  snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±) ‚â† undefg"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubstappp_loop Loopo_undef*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Loop Œ±)) ‚â† undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±) ‚äá U"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>usubstappp_loop</span><span> </span><span>Loopo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U Œ±) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>usubstappp_loop</span><span> </span><span>Loopo_undef</span><span> </span><span>fact</span><span> </span><span>usubstappp_antimon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 13 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_taboos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U Œ±)‚â†undefg ‚üπ fst(usubstappp œÉ U Œ±) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>game_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_assign</span><span> </span><span>Assigno_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Assigno.elims</span><span> </span><span>BVG_assign_other</span><span> </span><span>fst_pair</span><span> </span><span>option.sel</span><span> </span><span>singletonI</span><span> </span><span>snd_pair</span><span> </span><span>subsetI</span><span> </span><span>union_or</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_ODE</span><span> </span><span>ODEo_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ODEo.elims</span><span> </span><span>Un_least</span><span> </span><span>fst_pair</span><span> </span><span>option.sel</span><span> </span><span>snd_conv</span><span> </span><span>sup.coboundedI2</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_test</span><span> </span><span>Testo_undef</span><span> </span><span>usubst_taboos_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubstappp.simps Product_Type.fst_conv Product_Type.snd_conv BVG_choice*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ≤) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ≤)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp œÉ U Œ±))) ‚à™ BVG(the (snd(usubstappp œÉ U Œ≤))) ‚äá BVG(the (snd(usubstappp œÉ U (Choice Œ± Œ≤))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BVG_choice</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Choice.prems Choiceo.simps(1) Choiceo_undef option.collapse option.sel snd_pair usubstappp_choice)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp œÉ U Œ±)) ‚à™‚à™ the (snd (usubstappp œÉ U Œ≤))) = Choiceo (snd (usubstappp œÉ U Œ±)) (snd (usubstappp œÉ U Œ≤))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Choice.prems</span><span> </span><span>Choiceo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_choice</span><span> </span><span>Choice.prems</span><span> </span><span>Pair_inject</span><span> </span><span>option.collapse</span><span> </span><span>option.inject</span><span> </span><span>surjective_pairing</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IHa</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IHb</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±) ‚à™ fst(usubstappp œÉ U Œ≤) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±))) ‚à™ BVG(the (snd(usubstappp œÉ U Œ≤)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U (Choice Œ± Œ≤)) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±))) ‚à™ BVG(the (snd(usubstappp œÉ U Œ≤)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U (Choice Œ± Œ≤)) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Choice Œ± Œ≤))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ ?V Œ≤)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ‚äá ?V ‚à™ BVG(the (snd(usubstappp œÉ ?V Œ≤)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp œÉ U Œ±))) ‚à™ BVG(the (snd(usubstappp œÉ ?V Œ≤))) ‚äá BVG(the (snd(usubstappp œÉ U (Compose Œ± Œ≤))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>BVG_compose</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Compose.prems Composeo.simps(1) Composeo_undef option.collapse option.sel snd_pair)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz. z = undefg ‚à® Agame (the z) = z"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>option.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp œÉ U Œ±)) ;; the (snd (usubstappp œÉ (fst (usubstappp œÉ U Œ±)) Œ≤))) = snd (usubstappp œÉ U (Œ± ;; Œ≤))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compose.prems</span><span> </span><span>Composeo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_compose</span><span> </span><span>Compose.prems</span><span> </span><span>option.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±))) ‚à™ BVG(the (snd(usubstappp œÉ ?V Œ≤)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span>IHa</span><span> </span><span>IHb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Compose Œ± Œ≤))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U (Compose Œ± Œ≤)) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Compose Œ± Œ≤))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ ?V Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>defŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(usubstappp œÉ U Œ±) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±)))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defŒ±</span><span> </span><span>usubstappp_loop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œÉ</span><span class="delimiter">=</span><span>œÉ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span>Œ±</span><span class="delimiter">]</span><span> </span><span>Loopo_undef</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsnd (usubstappp œÉ (fst (usubstappp œÉ U Œ±)) Œ±)‚Ä∫</span></span></span><span class="delimiter">]</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?W ‚äá ?V ‚à™ BVG(the (snd(usubstappp œÉ ?V Œ±)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Loopo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Vfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá BVG(the (snd(usubstappp œÉ ?V Œ±)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IHdef</span><span> </span><span>Loop.prems</span><span> </span><span>le_sup_iff</span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Loop Œ±))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Vfix</span><span> </span><span>IHdef</span><span> </span><span>BVG_loop</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubstappp_loop_conv</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Loop.prems Loopo.simps(1) Un_mono option.collapse option.sel snd_pair sup.absorb_iff1)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄz. z = undefg ‚à® Agame (the z) = z"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>option.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U Œ±) ‚â† undefg ‚àß snd (usubstappp œÉ (fst (usubstappp œÉ U Œ±)) Œ±) ‚â† undefg"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Loop.prems</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (Loop (the (snd (usubstappp œÉ (fst (usubstappp œÉ U Œ±)) Œ±)))) = snd (usubstappp œÉ U (Loop Œ±))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>BVG_loop</span><span> </span><span>Loop.prems</span><span> </span><span>Vfix</span><span> </span><span>option.inject</span><span> </span><span>sup.absorb_iff1</span><span> </span><span>sup.mono</span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U (Loop Œ±)) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Loop Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using BVG_dual usubstappp.simps Let_def by auto*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Dualo_undef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BVG(the (snd(usubstappp œÉ U Œ±))) ‚äá BVG(the (snd(usubstappp œÉ U (Dual Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>BVG_dual</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Dual.prems</span><span> </span><span>Dualo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Dualo.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>option.sel</span><span> </span><span>snd_pair</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Dual Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>fact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U (Dual Œ±)) ‚äá U ‚à™ BVG(the (snd(usubstappp œÉ U (Dual Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp.simps</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSubstitution Adjoints‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπModified interpretation ‚ÄπrepI I f d‚Ä∫ replaces the interpretation of constant function ‚Äπf‚Ä∫ in the interpretation ‚ÄπI‚Ä∫ with ‚Äπd‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>repc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" interp ‚áí ident ‚áí real ‚áí interp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repc I f d ‚â°  mkinterp((Œªc. if c = f then d else Consts I c), Funcs I, Preds I, Games I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_consts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (repc I f d) c = (if (c=f) then d else Consts I c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_funcs</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (repc I f d) = Funcs I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_preds</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (repc I f d) = Preds I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repc_games</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games (repc I f d) = Games I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>repc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mon_mono</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_stays_mon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (case SGames œÉ a of None ‚áí Games I a | Some r ‚áí ŒªX. game_sem I r X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_mono</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjE_realizer2</span><span> </span><span>option.case_distrib</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*proof -
  have "‚àÄz p b i f. (mono (case z of None ‚áí f | Some x ‚áí game_sem i x) ‚à® ¬¨ (case z of None ‚áí b | Some x ‚áí p x)) ‚à® ¬¨ mono f"
  by (metis (no_types) disjE_realizer2 game_sem_mono)
  then show ?thesis
  by (metis (no_types) game_sem.simps(1) game_sem_mono option.case_distrib)
  qed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπadjoint interpretation ‚Äπadjoint œÉ I œâ‚Ä∫ to ‚ÄπœÉ‚Ä∫ of interpretation ‚ÄπI‚Ä∫ in state ‚Äπœâ‚Ä∫‚Ä∫</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjoint</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí (interp ‚áí state ‚áí interp)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint œÉ I œâ = mkinterp(
         (Œªf. (case SConst œÉ f of None ‚áí Consts I f| Some r ‚áí term_sem I r œâ)),
         (Œªf. (case SFuncs œÉ f of None ‚áí Funcs I f | Some r ‚áí Œªd. term_sem (repc I dotid d) r œâ)),
         (Œªp. (case SPreds œÉ p of None ‚áí Preds I p | Some r ‚áí Œªd. œâ‚ààfml_sem (repc I dotid d) r)),
         (Œªa. (case SGames œÉ a of None ‚áí Games I a | Some r ‚áí ŒªX. game_sem I r X))
  )"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple Observations about Adjoints‚Ä∫</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_consts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts (adjoint œÉ I œâ) f = term_sem I (case SConst œÉ f of Some r ‚áí r | None ‚áí Const f) œâ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f=None"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs (adjoint œÉ I œâ) f = (case SFuncs œÉ f of None ‚áí Funcs I f | Some r ‚áí Œªd. term_sem (repc I dotid d) r œâ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs_match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f=Some r ‚üπ Funcs (adjoint œÉ I œâ) f = (Œªd. term_sem (repc I dotid d) r œâ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_funcs_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f=None ‚üπ Funcs (adjoint œÉ I œâ) f = Funcs I f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds (adjoint œÉ I œâ) p = (case SPreds œÉ p of None ‚áí Preds I p | Some r ‚áí Œªd. œâ‚ààfml_sem (repc I dotid d) r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p=None ‚üπ Preds (adjoint œÉ I œâ) p = Preds I p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_preds_match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p=Some r ‚üπ Preds (adjoint œÉ I œâ) p = (Œªd. œâ‚ààfml_sem (repc I dotid d) r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_games</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games (adjoint œÉ I œâ) a = (case SGames œÉ a of None ‚áí Games I a | Some r ‚áí ŒªX. game_sem I r X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjoint_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_stays_mon</span><span> </span><span>Games_mkinterp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt Œ∏) I œâ = repc I dotid (term_sem I Œ∏ œâ)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding adjoint_def dotsubstt_def adjoint_consts adjoint_funcs_skip adjoint_preds adjoint_games*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt Œ∏) I œâ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"repc I dotid (term_sem I Œ∏ œâ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>feq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Funcs ?lhs = Funcs ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_funcs</span><span> </span><span>adjoint_funcs</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>peq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preds ?lhs = Preds ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_preds</span><span> </span><span>adjoint_preds</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Games ?lhs = Games ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_games</span><span> </span><span>adjoint_games</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ceq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Consts ?lhs = Consts ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>repc_consts</span><span>  </span><span>adjoint_consts</span><span> </span><span>dotsubstt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mkinterp_eq</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?lhs‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>J</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?rhs‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>feq</span><span> </span><span>peq</span><span> </span><span>geq</span><span> </span><span>ceq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitution for Terms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 15 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U ‚üπ usubstappt œÉ U Œ∏‚â†undeft ‚üπ
    term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vaouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>defouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏‚â†undeft"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏‚â†undeft ‚üπ term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>œÉ</span><span> </span><span>Œ∏</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaouter</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ŒΩ</span><span> </span><span>œâ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>usubstappt_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Number</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Const</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SConst œÉ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_consts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usappconst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVT(r)‚à©U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Const</span><span> </span><span>usubstappt_const</span><span> </span><span>usubstappt_const_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.inject</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Const f))) ŒΩ = term_sem I r ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>varcond</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem I r œâ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Const</span><span> </span><span>coincidence_term_cor</span><span class="delimiter">[</span><span>of</span><span> </span><span>ŒΩ</span><span> </span><span>œâ</span><span> </span><span>U</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Consts (adjoint œÉ I œâ) f"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Some</span><span> </span><span>adjoint_consts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint œÉ I œâ) (Const f) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Const f))) ŒΩ = term_sem (adjoint œÉ I œâ) (Const f) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>FuncMatch</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>f</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SFuncs œÉ f"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubterm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FuncMatch.IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>usubstappt_func_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>None</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func</span><span> </span><span>IHsubterm</span><span> </span><span>adjoint_funcs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>FuncMatch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.case_eq_if</span><span> </span><span>option.sel</span><span> </span><span>term_sem.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>usubstappt.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVT(r)‚à©U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FuncMatch</span><span> </span><span>usubstappt_func</span><span> </span><span>usubstappt_func2</span><span> </span><span>usubstappt_func_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_func_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubterm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FuncMatch</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ. Uvariation ŒΩ œâ {} ‚üπ term_sem I (the (usubstappt (dotsubstt (the (usubstappt œÉ U Œ∏))) {} r)) ŒΩ = term_sem (adjoint (dotsubstt (the (usubstappt œÉ U Œ∏))) I œâ) r ŒΩ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IHsubterm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dotIa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt (the (usubstappt œÉ U Œ∏))) I ŒΩ"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Func f Œ∏))) ŒΩ = term_sem I (the (usubstappt (dotsubstt (the (usubstappt œÉ U Œ∏))) {} r)) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem ?dotIa r ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>ŒΩ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span class="delimiter">]</span><span> </span><span>Uvariation_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (repc I dotid ?d) r ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ∏</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe (usubstappt œÉ U Œ∏)‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (repc I dotid ?d) r œâ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_term_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ'</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ∏</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπrepc I dotid ?d‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*I.^dœâ‚ü¶œÉf(‚ãÖ)‚üß  also have "... = term_sem ?dotIa r œâ" using coincidence_term_cor[of ŒΩ œâ U r ?dotIa] uv varcond by simp*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Funcs (adjoint œÉ I œâ) f)(?d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_funcs_match</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Funcs (adjoint œÉ I œâ) f)(term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint œÉ I œâ) (Func f Œ∏) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Func f Œ∏))) ŒΩ = term_sem (adjoint œÉ I œâ) (Func f Œ∏) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Plus</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pluso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Times</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Timeso_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Differential</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Differential</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ allvars Œ∏ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappt_differential_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Differential</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. term_sem I (the (usubstappt œÉ allvars Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>Uvariation_univ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by auto*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Differential Œ∏))) ŒΩ = term_sem I (Differential (the (usubstappt œÉ allvars Œ∏))) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum(Œªx. ŒΩ(DVar x)*deriv(ŒªX. term_sem I (the (usubstappt œÉ allvars Œ∏)) (repv ŒΩ (RVar x) X))(ŒΩ(RVar x)))(allidents)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = sum(Œªx. ŒΩ(DVar x)*deriv(ŒªX. term_sem (adjoint œÉ I œâ) Œ∏ (repv ŒΩ (RVar x) X))(ŒΩ(RVar x)))(allidents)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = term_sem (adjoint œÉ I œâ) (Differential Œ∏) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U (Differential Œ∏))) ŒΩ = term_sem (adjoint œÉ I œâ) (Differential Œ∏) ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitution for Formulas and Games‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSeparately Prove Crucial Ingredient for the ODE Case of ‚Äπusubst_fml_game‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem I Œ∏ ŒΩ = term_sem J Œ∑ ŒΩ)
  ‚üπ solves_ODE I F x Œ∏ = solves_ODE J F x Œ∑"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span>Vagree_def</span><span> </span><span>solves_ODE_def</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt double_complement)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem I Œ∏ ŒΩ = term_sem J Œ∑ ŒΩ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem J Œ∑ ŒΩ = term_sem I Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI J Œ∏ Œ∑. (‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem I Œ∏ ŒΩ = term_sem J Œ∑ ŒΩ)
   ‚üπ solves_ODE I F x Œ∏ ‚üπ solves_ODE J F x Œ∑"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vaflow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem I Œ∏ ŒΩ = term_sem J Œ∑ ŒΩ"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x Œ∏"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vaflow</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sol</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE J F x Œ∑"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span>coincidence_term</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_complement</span><span> </span><span>solves_Vagree</span><span> </span><span>sol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x Œ∏ = solves_ODE J F x Œ∑"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ∏</span><span class="delimiter">=</span><span>Œ∏</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ∑</span><span class="delimiter">=</span><span>Œ∑</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>va</span><span class="delimiter">]</span><span> </span><span>one</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ∏</span><span class="delimiter">=</span><span>Œ∑</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ∑</span><span class="delimiter">=</span><span>Œ∏</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>va2</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ {RVar x,DVar x} Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt œÉ {RVar x,DVar x} Œ∏)) = solves_ODE (adjoint œÉ I (F(0))) F x Œ∏"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄF Œ∏ Œ∂. solves_ODE I F x Œ∏ ‚üπ Uvariation (F(Œ∂)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. Uvariation ŒΩ (F(0)) {RVar x,DVar x} ‚üπ term_sem I (the (usubstappt œÉ {RVar x,DVar x} Œ∏)) ŒΩ = term_sem (adjoint œÉ I (F(0))) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubst_term</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>vaflow</span><span> </span><span>solves_ODE_def</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>same_ODE_same_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode_ext</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>     </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) œâ (U‚à™{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) = solves_ODE (adjoint œÉ I œâ) F x Œ∏"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using usubst_ode usubstappt_det usubstappt_antimon Uvariation_Vagree Uvariation_mon *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄF Œ∏ Œ∂. solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) ‚üπ Uvariation (F(Œ∂)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vaflow2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄF Œ∏ Œ∂. solves_ODE (adjoint œÉ I œâ) F x Œ∏ ‚üπ Uvariation (F(Œ∂)) (F(0)) {RVar x,DVar x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_Vagree_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ. Uvariation ŒΩ (F(0)) (U‚à™{RVar x,DVar x}) ‚üπ term_sem I (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) ŒΩ = term_sem (adjoint œÉ I (F(0))) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_refl</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l2r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) ‚üπ solves_ODE (adjoint œÉ I œâ) F x Œ∏"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaflow1</span><span> </span><span>subdef</span><span> </span><span>same_ODE_same_sol</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span>uv</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt sup_commute sup_left_idem)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí interp ‚áí trm ‚áí interp ‚áí char ‚áí (real ‚áí variable ‚áí real) ‚áí variable ‚áí real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1 x2 x3 x4 x5. (‚àÉv6. Uvariation v6 (x5 0) {RVar x4, DVar x4} ‚àß term_sem x3 x2 v6 ‚â† term_sem x1 x0 v6) = (Uvariation (rr x0 x1 x2 x3 x4 x5) (x5 0) {RVar x4, DVar x4} ‚àß term_sem x3 x2 (rr x0 x1 x2 x3 x4 x5) ‚â† term_sem x1 x0 (rr x0 x1 x2 x3 x4 x5))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F 0) œâ (insert (RVar x) (U ‚à™ {DVar x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{DVar x} ‚à™ {} ‚à™ {DVar x} = insert (DVar x) ({DVar x} ‚à™ {} ‚à™ {}) ‚ü∂ {RVar x} ‚à™ {DVar x} ‚à™ insert (RVar x) (U ‚à™ {DVar x}) = insert (RVar x) (U ‚à™ {DVar x})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{DVar x} ‚à™ {} ‚à™ {DVar x} = insert (DVar x) ({DVar x} ‚à™ {} ‚à™ {}) ‚àß Uvariation (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F) œâ ({RVar x} ‚à™ {DVar x} ‚à™ insert (RVar x) (U ‚à™ {DVar x}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ Uvariation (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F) (F 0) {RVar x, DVar x} ‚à® term_sem (USubst.adjoint œÉ I œâ) Œ∏ (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F) = term_sem I (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>subdef</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ Uvariation (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F) (F 0) {RVar x, DVar x} ‚à® term_sem (USubst.adjoint œÉ I œâ) Œ∏ (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F) = term_sem I (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) (rr (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I Œ∏ (USubst.adjoint œÉ I œâ) x F)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Uvariation_trans</span><span> </span><span>insert_is_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE (adjoint œÉ I œâ) F x Œ∏ ‚üπ solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaflow2</span><span> </span><span>subdef</span><span> </span><span>same_ODE_same_sol</span><span> </span><span>Uvariation_trans</span><span> </span><span>usubst_term</span><span> </span><span>uv</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt sup_commute sup_left_idem)*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE (USubst.adjoint œÉ I œâ) F x Œ∏"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ‚áí interp ‚áí trm ‚áí interp ‚áí char ‚áí (real ‚áí variable ‚áí real) ‚áí variable ‚áí real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"‚àÄx0 x1 x2 x3 x4 x5. (‚àÉv6. Uvariation v6 (x5 0) {RVar x4, DVar x4} ‚àß term_sem x3 x2 v6 ‚â† term_sem x1 x0 v6) = (Uvariation (rr x0 x1 x2 x3 x4 x5) (x5 0) {RVar x4, DVar x4} ‚àß term_sem x3 x2 (rr x0 x1 x2 x3 x4 x5) ‚â† term_sem x1 x0 (rr x0 x1 x2 x3 x4 x5))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄf c i t ia ta. Uvariation (rr ta ia t i c f) (f 0) {RVar c, DVar c} ‚àß term_sem i t (rr ta ia t i c f) ‚â† term_sem ia ta (rr ta ia t i c f) ‚à® solves_ODE i f c t = solves_ODE ia f c ta"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>same_ODE_same_sol</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F 0) œâ ({RVar x, DVar x} ‚à™ U)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ ({RVar x, DVar x} ‚à™ U) Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (rr Œ∏ (USubst.adjoint œÉ I œâ) (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I x F) œâ ({RVar x, DVar x} ‚à™ ({RVar x, DVar x} ‚à™ U))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ Uvariation (rr Œ∏ (USubst.adjoint œÉ I œâ) (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I x F) (F 0) {RVar x, DVar x} ‚à® term_sem I (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) (rr Œ∏ (USubst.adjoint œÉ I œâ) (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I x F) = term_sem (USubst.adjoint œÉ I œâ) Œ∏ (rr Œ∏ (USubst.adjoint œÉ I œâ) (the (usubstappt œÉ (U ‚à™ {RVar x, DVar x}) Œ∏)) I x F)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>usubst_term</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Uvariation_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r2l</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_ode_ext2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>     </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation (F(0)) œâ (U‚à™{RVar x,DVar x})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) = solves_ODE (adjoint œÉ I œâ) F x Œ∏"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_ode_ext</span><span> </span><span>subdef</span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSeparately Prove the Loop Case of ‚Äπusubst_fml_game‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A‚à™B=B‚à™A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>loopfpœÑ</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"game ‚áí interp ‚áí (state set ‚áí state set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpœÑ Œ± I X = lfp(ŒªZ. X ‚à™ game_sem I Œ± Z)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_game_loop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>IHŒ±rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ X. Uvariation ŒΩ œâ (fst(usubstappp œÉ U Œ±)) ‚üπ snd (usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±)‚â†undefg ‚üπ 
         (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Loop Œ±))‚â†undefg ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (Loop Œ±)))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Loop Œ±) X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Loop Œ±))‚â†undefg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>loopfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒ± I X. loopfpœÑ Œ± I X = game_sem I (Loop Œ±) X"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loopfpœÑ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÉŒ±loopoff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (snd (usubstappp œÉ U (Loop Œ±)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÉŒ±</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (snd(usubstappp œÉ (fst(usubstappp œÉ U Œ±)) Œ±))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÉŒ±loop</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Loop ?œÉŒ±"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>loopform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?œÉŒ±loopoff = ?œÉŒ±loop"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_loop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Loopo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>def</span><span> </span><span>option.exhaust_sel</span><span> </span><span>option.inject</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp_loop_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÑ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpœÑ ?œÉŒ±loop I"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÅ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"loopfpœÑ Œ± (adjoint œÉ I œâ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄV. snd(usubstappp œÉ V Œ±)‚â†undefg ‚üπ  fst(usubstappp œÉ V Œ±) ‚äá BVG(the (snd(usubstappp œÉ V Œ±)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fact2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄV W. snd(usubstappp œÉ V Œ±)‚â†undefg ‚üπ snd(usubstappp œÉ W Œ±)‚â†undefg ‚üπ (fst(usubstappp œÉ V Œ±) ‚äá BVG(the (snd(usubstappp œÉ W Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact1</span><span> </span><span>usubst_taboos</span><span> </span><span>usubstappp_det</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VgeqBV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?V ‚äá BVG(?œÉŒ±)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span>fact2</span><span> </span><span>def</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uvV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree ŒΩ œâ (-?V)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>Uvariation_mon</span><span> </span><span>double_compl</span><span> </span><span>usubst_taboos_mon</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>œÑeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?œÑ(X) = game_sem I ?œÉŒ±loop X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopfix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>œÅeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?œÅ(X) = game_sem (adjoint œÉ I œâ) (Loop Œ±) X"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loopfix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>œÑisœÅ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (?œÑ(X)) œâ (-?V)= selectlike (?œÅ(X)) œâ (-?V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªZ. X ‚à™ game_sem I ?œÉŒ± Z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªY. X ‚à™ game_sem (adjoint œÉ I œâ) Œ± Y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒªZ Y. selectlike Z œâ (-?V) = selectlike Y œâ (-?V)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R (lfp ?f) (lfp ?g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfp_lockstep_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?f‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?g‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ?R‚Ä∫</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monof</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>monog</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem_loop_fixpoint_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHfp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A œâ (-?V) = selectlike B œâ (-?V)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (X ‚à™ game_sem I ?œÉŒ± A) œâ (-?V) = selectlike (X ‚à™ game_sem (adjoint œÉ I œâ) Œ± B) œâ (-?V)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*[where ŒΩ=œâ and V=‚Äπ?V‚Ä∫ and X=‚ÄπX ‚à™ game_sem I ?œÉŒ± A‚Ä∫ and Y=‚ÄπX ‚à™ game_sem (adjoint œÉ I œâ) Œ± B‚Ä∫]*)</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Œº</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº œâ ?V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà X ‚à™ game_sem I ?œÉŒ± A) = (Œº ‚àà X ‚à™ game_sem I ?œÉŒ± (selectlike A Œº (-BVG(?œÉŒ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà X ‚à™ game_sem (adjoint œÉ I œâ) Œ± B) = (Œº ‚àà X ‚à™ game_sem I ?œÉŒ± B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHŒ±rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>muvar</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstappp_loop_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Œº ‚àà X ‚à™ game_sem I ?œÉŒ± (selectlike B Œº (-BVG(?œÉŒ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà  X ‚à™ game_sem (adjoint œÉ I œâ) Œ± B) =  (Œº ‚àà X ‚à™ game_sem I ?œÉŒ± (selectlike B Œº (-BVG(?œÉŒ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A Œº (-BVG(?œÉŒ±)) = selectlike B Œº (-BVG(?œÉŒ±))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHfp</span><span> </span><span>selectlike_antimon</span><span> </span><span>VgeqBV</span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>selectlike_equal_cocond</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt le_iff_sup)*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vagree Œº œâ (- fst (usubstappp œÉ U Œ±))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Uvariation_Vagree</span><span> </span><span>double_complement</span><span> </span><span>muvar</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike A Œº (- fst (usubstappp œÉ U Œ±)) = selectlike B Œº (- fst (usubstappp œÉ U Œ±))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHfp</span><span> </span><span>selectlike_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Compl_subset_Compl_iff</span><span> </span><span>VgeqBV</span><span> </span><span>selectlike_compose</span><span> </span><span>sup.absorb_iff2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà X ‚à™ game_sem I ?œÉŒ± A) = (Œº ‚àà X ‚à™ game_sem (adjoint œÉ I œâ) Œ± B)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>union</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>selectlike_Sup</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ-?V‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>fst_proj_def</span><span> </span><span>snd_proj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÑeq</span><span> </span><span>loopfix</span><span> </span><span>loopfpœÑ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÑeq</span><span> </span><span>œÅeq</span><span> </span><span>œÑisœÅ</span><span> </span><span>similar_selectlike_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uvV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>loopform</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubst_fml_game</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vaouter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U œÜ‚â†undeff ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U Œ±)‚â†undefg ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U œÜ‚â†undeff ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U Œ±)‚â†undefg ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>œÉ</span><span> </span><span>œÜ</span><span> </span><span>Œ±</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vaouter</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Œ±</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ŒΩ</span><span> </span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ŒΩ</span><span> </span><span>œâ</span><span> </span><span>X</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>usubstappfp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pred</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>p</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SPreds œÉ p"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span>va</span><span class="delimiter">]</span><span> </span><span>adjoint_preds_skip</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Pred.prems(1) fml_sem.simps(1) mem_Collect_eq option.case_eq_if option.sel usubstappf.simps(1))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄp V c t. usubstappf p V (Pred c t) = (if usubstappt p V t = undeft then undeff else case SPreds p c of None ‚áí Afml (Pred c (the (usubstappt p V t))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt p V t))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄp V c t. if usubstappt p V t = undeft then usubstappf p V (Pred c t) = undeff else usubstappf p V (Pred c t) = (case SPreds p c of None ‚áí Afml (Pred c (the (usubstappt p V t))) | Some f ‚áí if FVF f ‚à© V = {} then usubstappf (dotsubstt (the (usubstappt p V t))) {} f else undeff)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappf œÉ U (Pred p Œ∏) = Afml (Pred p (the (usubstappt œÉ U Œ∏)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pred.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>None</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚ãÄŒ∏ œÉ I. usubstappt œÉ U Œ∏ ‚â† undeft ‚üπ term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ = term_sem (USubst.adjoint œÉ I œâ) Œ∏ ŒΩ‚Ä∫</span></span></span><span> </span><span>adjoint_preds_skip</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>varcond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FVF(r)‚à©U={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pred</span><span> </span><span>usubstappf_pred</span><span> </span><span>usubstappf_pred2</span><span> </span><span>usubstappf_pred_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Pred</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_pred_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Pred</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ. Uvariation ŒΩ œâ {} ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} r))) = (ŒΩ ‚àà fml_sem (adjoint (dotsubstt (the (usubstappt œÉ U Œ∏))) I œâ) r)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span>va</span><span> </span><span>subdef</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dotIa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (dotsubstt (the (usubstappt œÉ U Œ∏))) I ŒΩ"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ‚ààfml_sem I (the (usubstappf œÉ U (Pred p Œ∏)))) = (ŒΩ‚ààfml_sem I (the (usubstappf (dotsubstt (the (usubstappt œÉ U Œ∏))) {} r)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ‚ààfml_sem ?dotIa r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHsubsubst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ŒΩ</span><span class="delimiter">=</span><span>ŒΩ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span class="delimiter">]</span><span> </span><span>Uvariation_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ‚ààfml_sem (repc I dotid ?d) r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_dotsubstt</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ∏</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπthe (usubstappt œÉ U Œ∏)‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (œâ‚ààfml_sem (repc I dotid ?d) r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coincidence_formula_cor</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œâ</span><span class="delimiter">=</span><span>ŒΩ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œâ'</span><span class="delimiter">=</span><span>œâ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">=</span><span>U</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>œÜ</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπrepc I dotid ?d‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>varcond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*I.^dœâ‚ü¶œÉf(‚ãÖ)‚üß  also have "... = term_sem ?dotIa r œâ" using coincidence_term_cor[of ŒΩ œâ U r ?dotIa] uv varcond by simp*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Preds (adjoint œÉ I œâ) p)(?d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_preds_match</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Preds (adjoint œÉ I œâ) p)(term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ‚ààfml_sem (adjoint œÉ I œâ) (Pred p Œ∏))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ‚ààfml_sem I (the (usubstappf œÉ U (Pred p Œ∏)))) = (ŒΩ‚ààfml_sem (adjoint œÉ I œâ) (Pred p Œ∏))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ∏</span><span> </span><span>Œ∑</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* then show ?case using usubst_term usubstappf_geq usubstappf_geq_conv
          by (smt fml_sem.simps(2) mem_Collect_eq option.sel)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∑ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_geq_conv</span><span> </span><span>Geq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUvariation ŒΩ œâ U‚Ä∫</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>def1</span><span class="delimiter">]</span><span> </span><span>usubst_term</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUvariation ŒΩ œâ U‚Ä∫</span></span></span><span class="delimiter">,</span><span>OF</span><span> </span><span>def2</span><span class="delimiter">]</span><span> </span><span>usubstappf_geqr</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπusubstappf œÉ U (Geq Œ∏ Œ∑) ‚â† undeff‚Ä∫</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Not</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Noto_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>And</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>œÜ</span><span> </span><span>œà</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ando_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ. Uvariation ŒΩ œâ (U‚à™{x}) ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ (U‚à™{x}) œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Exists</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*from Exists have subdef: "usubstappt œÉ (U‚à™{x}) Œ∏ ‚â† undeft" by auto*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Uvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄd. Uvariation (repv ŒΩ x d) œâ (U‚à™{x})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_repv</span><span> </span><span>Uvariation_trans</span><span> </span><span>Uvariation_sym</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exists.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Uvariation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ‚ààfml_sem I (the (usubstappf œÉ U (Exists x œÜ)))) = (ŒΩ‚ààfml_sem I (Exists x (the (usubstappf œÉ (U‚à™{x}) œÜ))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappf_exists</span><span> </span><span>Exists.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉd. (repv ŒΩ x d)‚ààfml_sem I (the (usubstappf œÉ (U‚à™{x}) œÜ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉd. (repv ŒΩ x d)‚ààfml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>Uvar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ‚ààfml_sem (adjoint œÉ I œâ) (Exists x œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ‚ààfml_sem I (the (usubstappf œÉ U (Exists x œÜ)))) =  (ŒΩ‚ààfml_sem (adjoint œÉ I œâ) (Exists x œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Diamond</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ±</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. Uvariation ŒΩ œâ U ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHœÜ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ. Uvariation ŒΩ œâ (fst(usubstappp œÉ U Œ±)) ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Diamondo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Diamond</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U (Diamond Œ± œÜ)))) = (ŒΩ ‚àà fml_sem I (let VŒ± = usubstappp œÉ U Œ± in Diamond (the (snd VŒ±)) (the (usubstappf œÉ (fst VŒ±) œÜ))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diamond.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Diamondo.elims</span><span> </span><span>option.sel</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà fml_sem I (Diamond (the (snd(usubstappp œÉ U Œ±))) (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U (Diamond Œ± œÜ)))) = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) (Diamond Œ± œÜ)) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± (fml_sem (adjoint œÉ I œâ) œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (fml_sem (adjoint œÉ I œâ) œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHŒ±</span><span> </span><span>uv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (fml_sem (adjoint œÉ I œâ) œÜ) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) (Diamond Œ± œÜ)) = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (fml_sem (adjoint œÉ I œâ) œÜ) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ))) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±)))) = selectlike (fml_sem (adjoint œÉ I œâ) œÜ) ŒΩ (-BVG(the (snd(usubstappp œÉ U Œ±))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Œº</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº ŒΩ (BVG(the (snd(usubstappp œÉ U Œ±))))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UŒºœâ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº œâ ?V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>uv</span><span> </span><span>Uvariation_trans</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Diamond.prems(1) Diamondo.simps(2) usubstappf.simps(6))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UŒºŒΩ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº ŒΩ (BVG(the (snd(usubstappp œÉ U Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>muvar</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UŒΩœâ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>uv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº œâ (U ‚à™ BVG(the (snd(usubstappp œÉ U Œ±))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>UŒºŒΩ</span><span> </span><span>UŒΩœâ</span><span class="delimiter">]</span><span> </span><span>union_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HOL.back_subst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Diamond.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Diamondo_undef</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>usubstappf.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà fml_sem (adjoint œÉ I œâ) œÜ) = (Œº ‚àà fml_sem I (the (usubstappf œÉ (fst(usubstappp œÉ U Œ±)) œÜ)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>uv</span><span> </span><span>IHœÜ</span><span> </span><span>boundeffect</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>UŒºœâ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà fml_sem I (the (usubstappf œÉ (fst (usubstappp œÉ U Œ±)) œÜ))) = (Œº ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U (Diamond Œ± œÜ)))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) (Diamond Œ± œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* games *)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Game</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint_games</span><span> </span><span>usubstappp_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"SGames œÉ a"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Assign</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_term</span><span> </span><span>Assigno_undef</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Assigno.elims game_sem.simps(2) mem_Collect_eq option.sel snd_pair usubstappp.simps(2))*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ U Œ∏ ‚â† undeft"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Assigno_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ŒΩ x (term_sem (USubst.adjoint œÉ I œâ) Œ∏ ŒΩ) ‚àà X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ŒΩ x (term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ) ‚àà X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ŒΩ x (term_sem (USubst.adjoint œÉ I œâ) Œ∏ ŒΩ) ‚àà X ‚ü∂ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (x := Œ∏)))) X) = (ŒΩ ‚àà game_sem (USubst.adjoint œÉ I œâ) (x := Œ∏) X)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ŒΩ x (term_sem (USubst.adjoint œÉ I œâ) Œ∏ ŒΩ) ‚àâ X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"repv ŒΩ x (term_sem I (the (usubstappt œÉ U Œ∏)) ŒΩ) ‚àâ X ‚àß repv ŒΩ x (term_sem (USubst.adjoint œÉ I œâ) Œ∏ ŒΩ) ‚àâ X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>Assign.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>usubst_term</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Test</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>œÜ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Testo_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Choice</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. Uvariation ŒΩ œâ U ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ≤</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. Uvariation ŒΩ œâ U ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ≤))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ≤ X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Choiceo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Choice</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHŒ±</span><span> </span><span>IHŒ≤</span><span> </span><span>uv</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Choice.prems(1) Choiceo.elims game_sem.simps(4) option.sel snd_pair union_or usubstappp_choice) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp œÉ U Œ±))) = snd (usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agame (the (snd (usubstappp œÉ U Œ≤))) = snd (usubstappp œÉ U Œ≤)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>option.collapse</span><span> </span><span>usubstappp_choice_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Œ± ‚à™‚à™ Œ≤)) = Agame (the (snd (usubstappp œÉ U Œ±)) ‚à™‚à™ the (snd (usubstappp œÉ U Œ≤)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Choiceo.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_sem I (the (snd (usubstappp œÉ U Œ±))) X ‚à™ game_sem I (the (snd (usubstappp œÉ U Œ≤))) X = game_sem I (the (snd (usubstappp œÉ U (Œ± ‚à™‚à™ Œ≤)))) X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ŒΩ ‚àâ game_sem I (the (snd (usubstappp œÉ U Œ≤))) X"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àâ game_sem I (the (snd (usubstappp œÉ U (Œ± ‚à™‚à™ Œ≤)))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Œ± ‚à™‚à™ Œ≤) X) ‚ü∂ ŒΩ ‚àâ game_sem I (the (snd (usubstappp œÉ U Œ≤))) X ‚àß ŒΩ ‚àâ game_sem (adjoint œÉ I œâ) (Œ± ‚à™‚à™ Œ≤) X"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHŒ±</span><span> </span><span>IHŒ≤</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àâ game_sem I (the (snd (usubstappp œÉ U (Œ± ‚à™‚à™ Œ≤)))) X) ‚â† (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Œ± ‚à™‚à™ Œ≤) X)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHŒ±</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Choice</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>IHŒ≤</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Compose</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ±</span><span> </span><span>Œ≤</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. Uvariation ŒΩ œâ U ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ≤</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ X. Uvariation ŒΩ œâ ?V ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ ?V Œ≤))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ≤ X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Composeo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Compose</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (Compose Œ± Œ≤)))) X) = (ŒΩ ‚àà game_sem I (Compose (the (snd(usubstappp œÉ U Œ±))) (the (snd(usubstappp œÉ ?V Œ≤)))) X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Compose.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Composeo.elims</span><span> </span><span>option.sel</span><span> </span><span>snd_pair</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (game_sem I (the (snd(usubstappp œÉ ?V Œ≤))) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (game_sem I (the (snd(usubstappp œÉ ?V Œ≤))) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>forw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (Compose Œ± Œ≤)))) X) = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike (game_sem I (the (snd(usubstappp œÉ ?V Œ≤))) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Compose Œ± Œ≤) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± ((game_sem (adjoint œÉ I œâ) Œ≤) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) ((game_sem (adjoint œÉ I œâ) Œ≤) X))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHŒ±</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike ((game_sem (adjoint œÉ I œâ) Œ≤) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>boundeffect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>backw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Compose Œ± Œ≤) X) = (ŒΩ ‚àà game_sem I (the (snd(usubstappp œÉ U Œ±))) (selectlike ((game_sem (adjoint œÉ I œâ) Œ≤) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>samewin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"selectlike (game_sem I (the (snd(usubstappp œÉ ?V Œ≤))) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±)))) = selectlike ((game_sem (adjoint œÉ I œâ) Œ≤) X) ŒΩ (-BVG(the(snd(usubstappp œÉ U Œ±))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>selectlike_equal_cocond_corule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Œº</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>muvar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº ŒΩ (BVG(the(snd(usubstappp œÉ U Œ±))))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>UŒºœâ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº œâ ?V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>uv</span><span> </span><span>Uvariation_trans</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span> </span><span>Uvariation_mon</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt Compose.prems(1) Composeo_undef snd_pair usubstappp.simps(5))*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation Œº œâ (BVG (the (snd (usubstappp œÉ U Œ±))) ‚à™ U)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Uvariation_trans</span><span> </span><span>muvar</span><span> </span><span>uv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_mon</span><span> </span><span>union_comm</span><span> </span><span>usubst_taboos</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Compose.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Composeo_undef</span><span> </span><span>Pair_inject</span><span> </span><span>prod.collapse</span><span> </span><span>usubstappp_compose</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (metis (no_types) Uvariation_mon union_comm usubst_taboos)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà game_sem I (the(snd(usubstappp œÉ ?V Œ≤))) X) = (Œº ‚àà game_sem (adjoint œÉ I œâ) Œ≤ X)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>muvar</span><span> </span><span>Uvariation_trans</span><span> </span><span>uv</span><span> </span><span>IHŒ≤</span><span> </span><span>boundeffect</span><span> </span><span>Uvariation_mon</span><span> </span><span>usubst_taboos</span><span> </span><span>UŒºœâ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œº ‚àà game_sem I (the(snd(usubstappp œÉ ?V Œ≤))) X) = (Œº ‚àà game_sem (adjoint œÉ I œâ) Œ≤ X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>forw</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>backw</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the(snd (usubstappp œÉ U (Compose Œ± Œ≤)))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Compose Œ± Œ≤) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>samewin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst(usubstappp œÉ U Œ±)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>selfdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Loop Œ±)) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ±rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄŒΩ œâ X. Uvariation ŒΩ œâ ?V ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ ?V Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (Loop Œ±)))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Loop Œ±) X)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_game_loop</span><span> </span><span>IHŒ±rec</span><span> </span><span>Loop.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>selfdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (rule usubst_game_loop[OF uv (*IHŒ±*) IHŒ±rec])*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Dual</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>Œ±</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IHŒ±</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. Uvariation ŒΩ œâ U ‚üπ (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Dual</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U (Œ±^d)) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*show ?case using IHŒ±[OF uv]
    by (smt Compl_iff Dual.prems(1) Dualo.elims game_sem.simps(7) option.sel snd_pair usubstappp.simps(7))*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà -game_sem I (the (snd (usubstappp œÉ U Œ±))) (-X)) = (ŒΩ ‚àà -game_sem (adjoint œÉ I œâ) Œ± (-X))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHŒ±</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I ((the (snd (usubstappp œÉ U Œ±)))^d) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (Œ±^d) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstappp_dual</span><span> </span><span>Dualo_undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄœÉ V Œ±. snd (usubstappp œÉ U (Œ±^d)) = Dualo (snd (usubstappp œÉ U Œ±))"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (usubstappp œÉ U Œ±) ‚â† undefg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Dualo_undef</span><span> </span><span>def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ(ŒΩ ‚àà game_sem I ((the (snd (usubstappp œÉ U Œ±)))^d) X) = (ŒΩ ‚àà game_sem (USubst.adjoint œÉ I œâ) (Œ±^d) X)‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ODE</span><span> </span><span>œÉ</span><span> </span><span>U</span><span> </span><span>x</span><span> </span><span>Œ∏</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ODE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subdef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏ ‚â† undeft"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ODEo_undef</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ODE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_sem I (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)) ŒΩ = term_sem (adjoint œÉ I œâ) Œ∏ ŒΩ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>va</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ODEo_undef</span><span> </span><span>fst_pair</span><span> </span><span>snd_conv</span><span> </span><span>usubst_taboos_mon</span><span> </span><span>usubst_term</span><span> </span><span>usubstappp.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>usubstappt_antimon</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (ODE x Œ∏)))) X) = (ŒΩ ‚àà game_sem I (the (ODEo x (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏))) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem I (ODE x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏))) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subdef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉF T. Vagree ŒΩ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà X ‚àß solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉF T. Uvariation ŒΩ (F(0)) {DVar x} ‚àß F(T) ‚àà X ‚àß solves_ODE I F x (the (usubstappt œÉ (U‚à™{RVar x,DVar x}) Œ∏)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉF T. Uvariation ŒΩ (F(0)) {DVar x} ‚àß F(T) ‚àà X ‚àß solves_ODE (adjoint œÉ I œâ) F x Œ∏)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_ode_ext2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subdef</span><span class="delimiter">]</span><span> </span><span>va</span><span> </span><span>solves_Vagree_trans</span><span> </span><span>Uvariation_trans</span><span> </span><span>Uvariation_sym_rel</span><span> </span><span>Uvariation_mon</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (‚àÉF T. Vagree ŒΩ (F(0)) (-{DVar x}) ‚àß F(T) ‚àà X ‚àß solves_ODE (adjoint œÉ I œâ) F x Œ∏)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_Vagree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_compl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (ODE x Œ∏) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>solves_ODE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U (ODE x Œ∏)))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) (ODE x Œ∏) X)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 16 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_fml</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U ‚üπ usubstappf œÉ U œÜ ‚â† undeff ‚üπ
    (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ U œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLemma 17 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_game</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Uvariation ŒΩ œâ U ‚üπ snd (usubstappp œÉ U Œ±) ‚â† undefg ‚üπ
    (ŒΩ ‚àà game_sem I (the (snd (usubstappp œÉ U Œ±))) X) = (ŒΩ ‚àà game_sem (adjoint œÉ I œâ) Œ± X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml_game</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSoundness of Uniform Substitution of Formulas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>usubsta</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí fml ‚áí fmlo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta œÉ œÜ ‚â° usubstappf œÉ {} œÜ"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTheorem 18 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta œÉ œÜ ‚â† undeff ‚üπ valid œÜ ‚üπ valid (the (usubsta œÉ œÜ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubsta œÉ œÜ ‚â† undeff"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prem</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>premc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI œâ. œâ ‚àà fml_sem I œÜ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (the (usubsta œÉ œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>œâ</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ ‚àà fml_sem I (the (usubsta œÉ œÜ))) = (œâ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>usubst_fml</span><span> </span><span>def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = True"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>premc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œâ ‚àà fml_sem I (the (usubsta œÉ œÜ))) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œâ ‚àà fml_sem I (the (usubstappf œÉ {} œÜ))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSoundness of Uniform Substitution of Rules‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUniform Substitution applied to a rule or inference‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>usubstr</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubst ‚áí inference ‚áí inference option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â° if (usubstappf œÉ allvars (snd R) ‚â† undeff ‚àß (‚àÄœÜ‚ààset (fst R). usubstappf œÉ allvars œÜ ‚â† undeff)) then
    Some(map(the o (usubstappf œÉ allvars))(fst R), the (usubstappf œÉ allvars (snd R)))
  else
    None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple observations about applying uniform substitutions to a rule‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None ‚üπ
  usubstappf œÉ allvars (snd R) ‚â† undeff ‚àß
  (‚àÄœÜ‚ààset (fst R). usubstappf œÉ allvars œÜ ‚â† undeff)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((append A B), C) ‚â† None) = (usubstr œÉ (A, C) ‚â† None ‚àß usubstr œÉ (B, C) ‚â† None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((append A B), C) ‚â† None) ‚üπ (usubstr œÉ (A, C) ‚â† None ‚àß usubstr œÉ (B, C) ‚â† None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons_undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((Cons A B), C) ‚â† None) = (usubstr œÉ ([A], C) ‚â† None ‚àß usubstr œÉ (B, C) ‚â† None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((Cons A B), C) ‚â† None) ‚üπ (usubstr œÉ ([A], C) ‚â† None ‚àß usubstr œÉ (B, C) ‚â† None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((Cons A B), C) ‚â† None) ‚üπ
  the (usubstr œÉ ((Cons A B), C)) = (Cons (the (usubstappf œÉ allvars A)) (fst (the (usubstr œÉ (B, C)))), snd (the (usubstr œÉ ([A], C))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef</span><span> </span><span>map_cons</span><span> </span><span>usubstr_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((Cons A B), C) ‚â† None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((Cons A B), C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr œÉ ?R) = (map(the o (usubstappf œÉ allvars))(fst ?R) , the (usubstappf œÉ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf œÉ allvars A)) (map(the o (usubstappf œÉ allvars))(B)) , the (usubstappf œÉ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf œÉ allvars A)) (fst (the (usubstr œÉ (B, C)))) , the (usubstappf œÉ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Cons (the (usubstappf œÉ allvars A)) (fst (the (usubstr œÉ (B, C)))) , snd (the (usubstr œÉ ([A], C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr œÉ ((Cons A B), C)) = (Cons (the (usubstappf œÉ allvars A)) (fst (the (usubstr œÉ (B, C)))) , snd (the (usubstr œÉ ([A], C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((append A B), C) ‚â† None) ‚üπ
  the (usubstr œÉ ((append A B), C)) = (append (fst (the (usubstr œÉ (A, C)))) (fst (the (usubstr œÉ (B, C)))), snd (the (usubstr œÉ (A, C))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by (smt fst_pair map_append option.sel snd_pair usubstr_def)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(usubstr œÉ ((append A B), C) ‚â† None)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((append A B), C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr œÉ ?R) = (map(the o (usubstappf œÉ allvars))(fst ?R) , the (usubstappf œÉ allvars (snd ?R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (map(the o (usubstappf œÉ allvars))(fst ?R) , snd (the (usubstr œÉ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span> </span><span>sndI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (append (map(the o (usubstappf œÉ allvars))(A)) (map(the o (usubstappf œÉ allvars))(B)) , snd (the (usubstr œÉ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>map_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (append (fst (the (usubstr œÉ (A, C)))) (fst (the (usubstr œÉ (B, C)))), snd (the (usubstr œÉ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_union_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">]</span><span> </span><span>usubstr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the (usubstr œÉ ((append A B), C)) = (append (fst (the (usubstr œÉ (A, C)))) (fst (the (usubstr œÉ (B, C)))), snd (the (usubstr œÉ (A, C))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None ‚üπ length (fst (the (usubstr œÉ R))) = length (fst R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_pair</span><span> </span><span>length_map</span><span> </span><span>option.sel</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>usubstr_nth</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None ‚üπ 0‚â§k ‚üπ k&lt;length (fst R) ‚üπ
   nth (fst (the (usubstr œÉ R))) k = the (usubstappf œÉ allvars (nth (fst R) k))"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding usubstr_def using usubstr_length
  by (smt comp_apply fst_pair nth_map option.sel)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0‚â§k"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k&lt;length (fst R)"</span></span></span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nth (fst (the (usubstr œÉ R))) k = the (usubstappf œÉ allvars (nth (fst R) k))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>R</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pair</span><span> </span><span>A</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>D</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄk. usubstr œÉ (E, C) ‚â† None ‚üπ 0 ‚â§ k ‚üπ k &lt; length E ‚üπ nth (fst (the (usubstr œÉ (E, C)))) k = the (usubstappf œÉ allvars (nth E k))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>usubstr_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n&lt;length E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nati</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0‚â§n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ (E, C) ‚â† None"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubstr_cons_undef2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nth (fst (the (usubstr œÉ (E, C)))) n = the (usubstappf œÉ allvars (nth (fst (E,C)) n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>def</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>nati</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>smaller</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>usubstr_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTheorem 19 of üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>usubst_rule_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None ‚üπ locally_sound R ‚üπ locally_sound (the (usubstr œÉ R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R ‚â† None"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?œÉD</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"usubstr œÉ R"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>œâ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>usubst_fml</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>substeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI ŒΩ œÜ. usubstappf œÉ allvars œÜ ‚â† undeff ‚üπ (ŒΩ ‚àà fml_sem I (the (usubstappf œÉ allvars œÜ))) = (ŒΩ ‚àà fml_sem (adjoint œÉ I œâ) œÜ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Uvariation_univ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>substval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄI. usubstappf œÉ allvars œÜ ‚â† undeff ‚üπ valid_in I (the (usubstappf œÉ allvars œÜ)) = valid_in (adjoint œÉ I œâ) œÜ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound (the (usubstr œÉ R))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄk‚â•0. k &lt; length (fst (the (usubstr œÉ R))) ‚ü∂ valid_in I (nth (fst (the (usubstr œÉ R))) k)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄk‚â•0. k &lt; length (fst R) ‚ü∂ valid_in (adjoint œÉ I œâ) (nth (fst R) k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>substval</span><span> </span><span>usubstr_nth</span><span> </span><span>usubstr_length</span><span> </span><span>substeq</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>def</span><span> </span><span>nth_mem</span><span> </span><span>usubstr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in (adjoint œÉ I œâ) (snd R)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prem</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_in I (snd (the (usubstr œÉ R)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>usubst_fml</span><span> </span><span>substeq</span><span> </span><span>usubstr_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>def</span><span> </span><span>option.sel</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Ids">
<div class="head"><h1>Theory Ids</h1>
<span class="command">theory</span> <span class="name">Ids</span><br/>
<span class="keyword">imports</span> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ids"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSome specific identifiers used in Axioms‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgid1</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgid1 ‚â° CHR ''a''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgid2</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgid2 ‚â° CHR ''b''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgidc</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgidc ‚â° CHR ''c''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hgidd</span><span class="delimiter">::</span><span>ident</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hgidd ‚â° CHR ''d''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pid1</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pid1  ‚â° CHR ''p''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pid2</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pid2  ‚â° CHR ''q''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fid1</span><span class="delimiter">::</span><span>ident</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fid1  ‚â° CHR ''f''"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>xid1</span><span class="delimiter">::</span><span>variable</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xid1  ‚â° RVar (CHR ''x'')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Axioms">
<div class="head"><h1>Theory Axioms</h1>
<span class="command">theory</span> <span class="name">Axioms</span><br/>
<span class="keyword">imports</span> <a href="Denotational_Semantics.html"><span class="name">Denotational_Semantics</span></a> <a href="Ids.html"><span class="name">Ids</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Axioms"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ids"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAxioms and Axiomatic Proof Rules of Differential Game Logic‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAxioms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pusall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pusall ‚â° ‚ü®Game hgidc‚ü©TT"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nothing</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nothing ‚â° Number 0"</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>axiom_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"Axiom definitions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>box_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"box_axiom ‚â° (Box (Game hgid1) pusall) ‚Üî Not(Diamond (Game hgid1) (Not(pusall)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assigneq_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"assigneq_axiom ‚â° (Diamond (Assign xid1 (Const fid1)) pusall) ‚Üî Exists xid1 (Equals (Var xid1) (Const fid1) &amp;&amp; pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stutterd_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"stutterd_axiom ‚â° (Diamond (Assign xid1 (Var xid1)) pusall) ‚Üî pusall"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"test_axiom ‚â° Diamond (Test (Pred pid2 nothing)) (Pred pid1 nothing) ‚Üî (Pred pid2 nothing &amp;&amp; Pred pid1 nothing)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>choice_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"choice_axiom ‚â° Diamond (Choice (Game hgid1) (Game hgid2)) pusall ‚Üî (Diamond (Game hgid1) pusall || Diamond (Game hgid2) pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compose_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"compose_axiom ‚â° Diamond (Compose (Game hgid1) (Game hgid2)) pusall ‚Üî Diamond (Game hgid1) (Diamond (Game hgid2) pusall)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iterate_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"iterate_axiom ‚â° Diamond (Loop (Game hgid1)) pusall ‚Üî (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dual_axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fml"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>axiom_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"dual_axiom ‚â° Diamond (Dual (Game hgid1)) pusall ‚Üî !(Diamond (Game hgid1) (!pusall))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAxiomatic Rules‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>rule_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rule definitions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mon_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mon_rule ‚â° ([(‚ü®Game hgidc‚ü©TT) ‚Üí (‚ü®Game hgidd‚ü©TT)], (‚ü®Game hgid1‚ü©(‚ü®Game hgidc‚ü©TT)) ‚Üí (‚ü®Game hgid1‚ü©(‚ü®Game hgidd‚ü©TT)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FP_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"FP_rule ‚â° ([((‚ü®Game hgidc‚ü©TT) || ‚ü®Game hgid1‚ü©‚ü®Game hgidd‚ü©TT) ‚Üí ‚ü®Game hgidd‚ü©TT], (‚ü®Loop (Game hgid1)‚ü©‚ü®Game hgidc‚ü©TT) ‚Üí (‚ü®Game hgidd‚ü©TT))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>MP_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"MP_rule ‚â° ([Pred pid1 nothing , Pred pid1 nothing ‚Üí Pred pid2 nothing], Pred pid2 nothing)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gena_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rule_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gena_rule ‚â° ([pusall], Exists xid1 pusall)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSoundness / Validity Proofs for Axioms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBecause an axiom in a uniform substitution calculus is an individual formula, 
  proving the validity of that formula suffices to prove soundness‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>box_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid box_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>box_axiom_def</span><span> </span><span>Box_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma assign_equal: "game_sem I (Assign x (Const f)) (fml_sem I œÜ) = fml_sem I (Exists x (Equals (Var x) (Const f) &amp;&amp; œÜ))"
  by simp*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assigneq_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid assigneq_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assigneq_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma game_sem_stutter: "game_sem I (Assign x (Var x)) X = X"
  by (auto simp add: repv_self)*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stutterd_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid stutterd_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stutterd_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid test_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>test_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>choice_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid choice_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>choice_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compose_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid compose_axiom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compose_axiom_def</span><span> </span><span>Or_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dual_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid dual_axiom"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dual_axiom_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span>fml_sem_not</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>game_sem.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iterate_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid iterate_axiom"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding iterate_axiom_def using valid_equiv fml_sem.simps(6) game_equiv_subst[OF loop_iterate_equiv]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄI. fml_sem I (Diamond (Loop (Game hgid1)) pusall) = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond (Loop (Game hgid1)) pusall) = game_sem I (Loop (Game hgid1)) (fml_sem I pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fml_sem.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = game_sem I (Choice Skip (Compose (Game hgid1) (Loop (Game hgid1)))) (fml_sem I pusall)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_equiv_subst</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span>I</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπfml_sem I pusall‚Ä∫</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>loop_iterate_equiv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Œ±</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGame hgid1‚Ä∫</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (Diamond (Choice Skip (Compose (Game hgid1) (Loop (Game hgid1)))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (Diamond Skip pusall || Diamond (Compose (Game hgid1) (Loop (Game hgid1))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (pusall || Diamond (Compose (Game hgid1) (Loop (Game hgid1))) pusall)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fml_sem I (Diamond (Loop (Game hgid1)) pusall) = fml_sem I (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid ((Diamond (Loop (Game hgid1)) pusall) ‚Üî (pusall || Diamond (Game hgid1) (Diamond (Loop (Game hgid1)) pusall)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rev_iffD2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid iterate_axiom"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iterate_axiom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLocal Soundness Proofs for Axiomatic Rules‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mon_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound mon_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mon_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_impl</span><span> </span><span>monotone</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FP_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound FP_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FP_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_in_impl</span><span> </span><span>game_sem_loop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MP_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound MP_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MP_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_implies</span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gena_locsound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"locally_sound gena_rule"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gena_rule_def</span><span> </span><span>locally_sound_def</span><span> </span><span>valid_in_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fml_sem_implies</span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Differential_Game_Logic">
<div class="head"><h1>Theory Differential_Game_Logic</h1>
<span class="command">theory</span> <span class="name">Differential_Game_Logic</span><br/>
<span class="keyword">imports</span> <a href="USubst.html"><span class="name">USubst</span></a> <a href="Axioms.html"><span class="name">Axioms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπdGL Formalization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Differential_Game_Logic"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Identifiers"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Syntax"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Denotational_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Static_Semantics"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Coincidence"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"USubst"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Axioms"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThis formalization of Differential Game Logic üåê‚Äπhttp://arxiv.org/abs/1902.07230‚Ä∫ \cite{DBLP:conf/cade/Platzer19} consists of
the syntax, denotational semantics, static semantics, uniform substitution lemmas, uniform substitution soundness proofs, and soundness proofs for axioms.‚Ä∫</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div>