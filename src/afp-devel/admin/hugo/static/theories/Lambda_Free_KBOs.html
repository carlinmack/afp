<div id="Lambda_Free_KBO_Util">
<div class="head"><h1>Theory Lambda_Free_KBO_Util</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_KBO_Util</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_Term.html"><span class="name">Lambda_Free_Term</span></a> <a href="Extension_Orders.html"><span class="name">Extension_Orders</span></a> <a href="Polynomials.html"><span class="name">Polynomials</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Utilities for Knuth-Bendix Orders for Lambda-Free Higher-Order Terms
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Utilities for Knuth--Bendix Orders for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_KBO_Util</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_RPOs.Lambda_Free_Term</span><span> </span><span>Lambda_Free_RPOs.Extension_Orders</span><span> </span><span>Polynomials.Polynomials</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_basic_basis</span><span> </span><span class="delimiter">=</span><span> </span><span>gt_sym</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>gt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ε</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ground_heads_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 's set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ (('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm list ⇒ ('s, 'v) tm list ⇒
      bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ε_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ε &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_sym_ge_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f ≥ ε"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ground_heads_var_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_heads_var x ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_irrefl_before_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_irrefl_before_trans (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_compat_list_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_list_strong (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_hd_or_tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_hd_or_tl (extf f)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_sym_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ε_gt_0</span><span> </span><span>wt_sym_ge_ε</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_std_basis</span><span> </span><span class="delimiter">=</span><span> </span><span>ground_heads</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>      </span><span>gt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>arity_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>arity_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ enat"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 'n::{ord,semiring_1}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ε</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ (('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm list ⇒ ('s, 'v) tm list ⇒
      bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ε_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ε &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>δ_le_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ ≤ ε"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0 ⟹ arity_hd ζ ≠ ∞"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_sym_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f ≥ of_nat (ε - the_enat (of_nat δ * arity_sym f))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unary_wt_sym_0_gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f = 1 ⟹ wt_sym f = 0 ⟹ f &gt;<span class="hidden">⇩</span><sub>s</sub> g ∨ g = f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unary_wt_sym_0_imp_δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f = 1 ⟹ wt_sym f = 0 ⟹ δ = ε"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_irrefl_before_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_irrefl_before_trans (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_compat_list_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_list_strong (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_hd_or_tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_hd_or_tl (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>extf_ext_snoc_if_δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε ⟹ ext_snoc (extf f)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0 ⟹ arity_sym f ≠ ∞"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_hd.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_var_ne_infinity_if_δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0 ⟹ arity_var x ≠ ∞"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_hd.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_ne_infinity_if_δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0 ⟹ arity s ≠ ∞"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arity_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_induct_apps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span> </span><span>enat.distinct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>enat.exhaust</span><span> </span><span>idiff_enat_enat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_irrefl (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_irrefl_before_trans.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_irrefl_before_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_irrefl.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_irrefl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>extf_ext_compat_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_cons (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>extf_ext_compat_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_snoc (extf f)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>extf_ext_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_singleton (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext_compat_list_strong.axioms</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_list_strong</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext_compat_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_list (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_ext_compat_list_strong</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ext_compat_list_axioms_def</span><span> </span><span>ext_compat_list_def</span><span> </span><span>ext_compat_list_strong.compat_list</span><span>
</span><span>    </span><span>ext_compat_list_strong_def</span><span> </span><span>ext_singleton.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_ext_wf_bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_wf_bounded (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ext_wf_bounded_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_ext_irrefl_before_trans</span><span> </span><span>extf_ext_hd_or_tl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_mono_strong</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.mono_strong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_mono</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">,</span><span> </span><span>mono</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_map</span><span> </span><span class="delimiter">=</span><span> </span><span>ext.map</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_irrefl</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_irrefl.irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_irrefl</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_trans_from_irrefl</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>ext_irrefl_before_trans.trans_from_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_irrefl_before_trans</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_cons</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_cons.compat_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_cons</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_append_left</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_cons.compat_append_left</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_cons</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_append_right</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_snoc.compat_append_right</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_snoc</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_compat_list</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_compat_list.compat_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_compat_list</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_singleton</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_singleton.singleton</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_singleton</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_wf_bounded</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_wf_bounded.wf_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_wf_bounded</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_snoc_if_δ_eq_ε</span><span> </span><span class="delimiter">=</span><span> </span><span>ext_snoc.snoc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_snoc_if_δ_eq_ε</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extf_singleton_nil_if_δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε ⟹ extf f gt [s] []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_snoc_if_δ_eq_ε</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kbo_basic_basis</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>kbo_std_basis</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. ∞"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. ∞"</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kbo_std_basis_def</span><span> </span><span>kbo_std_basis_axioms_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wt_sym_gt_0</span><span> </span><span>ε_gt_0</span><span> </span><span>wt_sym_ge_ε</span><span> </span><span>less_not_refl2</span><span> </span><span>ground_heads_var_nonempty</span><span>
</span><span>    </span><span>gt_sym_axioms</span><span> </span><span>ground_heads_def</span><span> </span><span>ground_heads_axioms_def</span><span> </span><span>extf_ext_irrefl_before_trans</span><span>
</span><span>    </span><span>extf_ext_compat_list_strong</span><span> </span><span>extf_ext_hd_or_tl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Free_KBO_App">
<div class="head"><h1>Theory Lambda_Free_KBO_App</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_KBO_App</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_KBO_Util.html"><span class="name">Lambda_Free_KBO_Util</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Applicative Knuth-Bendix Order for Lambda-Free Higher-Order Terms
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Applicative Knuth--Bendix Order for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_KBO_App</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_KBO_Util</span><span>
</span><span class="keyword2"><span class="keyword">abbrevs</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory defines the applicative Knuth--Bendix order, a variant of KBO for ‹λ›-free
higher-order terms. It corresponds to the order obtained by applying the standard first-order KBO on
the applicative encoding of higher-order terms and assigning the lowest precedence to the
application symbol.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_app</span><span> </span><span class="delimiter">=</span><span> </span><span>gt_sym</span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>gt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ε</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool) ⇒ ('s, 'v) tm list ⇒ ('s, 'v) tm list ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ε_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ε &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_sym_ge_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f ≥ ε"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ext_ext_irrefl_before_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_irrefl_before_trans ext"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ext_ext_compat_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_compat_list ext"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ext_ext_hd_or_tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ext_hd_or_tl ext"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_mono</span><span class="delimiter">[</span><span>mono</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt ≤ gt' ⟹ ext gt ≤ ext gt'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ext.mono</span><span> </span><span>ext_ext_compat_list</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ext_compat_list_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt (Hd (Var x)) = ε"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd (Sym f)) = wt_sym f"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = wt s + wt t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t &gt; wt s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_sym_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym g = wt_sym f ⟹ g &gt;<span class="hidden">⇩</span><sub>s</sub> f ⟹ Hd (Sym g) &gt;<span class="hidden">⇩</span><sub>t</sub> Hd (Sym f)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_sym_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars s = {} ⟹ wt t = wt s ⟹ t = Hd (Sym g) ⟹ is_App s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_app_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ t = App t1 t2 ⟹ s = App s1 s2 ⟹
    ext (&gt;<span class="hidden">⇩</span><sub>t</sub>) [t1, t2] [s1, s2] ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≥<span class="hidden">⇩</span><sub>t</sub> s ≡ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ t = s"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Free_KBO_Std">
<div class="head"><h1>Theory Lambda_Free_KBO_Std</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_KBO_Std</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_KBO_Util.html"><span class="name">Lambda_Free_KBO_Util</span></a> <a href="../Nested_Multisets_Ordinals/Multiset_More.html"><span class="name">Multiset_More</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Graceful Standard Knuth-Bendix Order for Lambda-Free Higher-Order Terms
    Author:      Heiko Becker &lt;heikobecker92@gmail.com&gt;, 2016
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Author:      Uwe Waldmann &lt;waldmann at mpi-inf.mpg.de&gt;, 2016
    Author:      Daniel Wand &lt;dwand at mpi-inf.mpg.de&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Graceful Standard Knuth--Bendix Order for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_KBO_Std</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_KBO_Util</span><span> </span><span>Nested_Multisets_Ordinals.Multiset_More</span><span>
</span><span class="keyword2"><span class="keyword">abbrevs</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory defines the standard version of the graceful Knuth--Bendix order for ‹λ›-free
higher-order terms. Standard means that one symbol is allowed to have a weight of 0.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_std</span><span> </span><span class="delimiter">=</span><span> </span><span>kbo_std_basis</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span> </span><span>wt_sym</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>arity_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>arity_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weights›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ζ) = (LEAST w. ∃f ∈ ground_heads ζ. w = wt_sym f + the_enat (δ * arity_sym f))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = (wt s - δ) + wt t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_Hd_Sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd (Sym f)) = wt_sym f + the_enat (δ * arity_sym f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_wt_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f ∈ ground_heads ζ. wt (Hd ζ) = wt_sym f + the_enat (δ * arity_sym f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Least_in_nonempty_set_imp_ex</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_le_wt_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads ζ ⟹ wt (Hd ζ) ≤ wt_sym f + the_enat (δ * arity_sym f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_le_imp_less</span><span> </span><span>not_less_Least</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enat_the_enat_δ_times_arity_sym</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enat (the_enat (δ * arity_sym f)) = δ * arity_sym f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span> </span><span>imult_is_infinity</span><span> </span><span>zero_enat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_arg_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (arg s) ≤ wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s ≥ ε"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>exists_wt_sym</span><span> </span><span>of_nat_eq_enat</span><span> </span><span>le_diff_conv</span><span> </span><span>of_nat_id</span><span> </span><span>wt_sym_ge</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_increasing</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s ≥ δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>δ_le_ε</span><span> </span><span>order.trans</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wt_ge_ε</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_gt_δ_if_superunary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd (head s) &gt; 1 ⟹ wt s &gt; δ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>g_in_grs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ ground_heads ζ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ζ) = wt_sym g + the_enat (δ * arity_sym g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_wt_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd ζ &gt; 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ary_g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym g &gt; 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_heads_arity</span><span class="delimiter">[</span><span>OF</span><span> </span><span>g_in_grs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ε_gt_0</span><span> </span><span>gr0I</span><span> </span><span>leD</span><span> </span><span>wt_ge_ε</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>δ_ne_0</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ary_g_ninf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym g ≠ ∞"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &lt; the_enat (enat δ * arity_sym g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ_ne_0</span><span> </span><span>ary_g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym g"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ge_δ</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = wt t ⟹ wt s = δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>order.antisym</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_ge_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) ≥ wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_le_mono2</span><span> </span><span>wt_ge_δ</span><span> </span><span>le_diff_conv</span><span> </span><span>wt.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_hd_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd (head s)) ≤ wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>head_App</span><span> </span><span>leD</span><span> </span><span>le_less_trans</span><span> </span><span>not_le_imp_less</span><span> </span><span>wt_App_ge_fun</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_δ_imp_δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s = δ ⟹ δ = ε"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>δ_le_ε</span><span> </span><span>le_antisym</span><span> </span><span>wt_ge_ε</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_arity_head_if_δ_gt_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s ≥ arity_hd (head s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f_in_ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads ζ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ζ) = wt_sym f + the_enat (δ * arity_sym f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_wt_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f ≥ arity_hd ζ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ground_heads_arity</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_in_ζ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the_enat (δ * arity_sym f) ≥ arity_hd ζ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ_gt_0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_ile_eq</span><span> </span><span>dual_order.trans</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span>enat_the_enat_δ_times_arity_sym</span><span> </span><span>i0_lb</span><span> </span><span>mult.commute</span><span> </span><span>mult.right_neutral</span><span> </span><span>mult_left_mono</span><span>
</span><span>      </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.left_neutral</span><span> </span><span>add_mono</span><span> </span><span>le_iff_add</span><span> </span><span>plus_enat_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>App</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.trans</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>head_App</span><span> </span><span>wt_App_ge_fun</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_num_args_if_δ_eq_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>δ_eq_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s ≥ num_args s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span>
</span><span>    </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>δ_eq_0</span><span> </span><span>ε_gt_0</span><span> </span><span>wt_δ_imp_δ_eq_ε</span><span> </span><span>add_le_same_cancel1</span><span> </span><span>le_0_eq</span><span> </span><span>le_trans</span><span>
</span><span>      </span><span>minus_nat.diff_0</span><span> </span><span>not_gr_zero</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_num_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ wt s ≥ num_args s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ge_arity_head_if_δ_gt_0</span><span> </span><span>wt_ge_num_args_if_δ_eq_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>order.trans</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>neq0_conv</span><span> </span><span>wary_num_args_le_arity_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t &gt; wt s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_unary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t = wt s ⟹ ¬ head t ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ num_args t = 1 ⟹
    (∃f ∈ ground_heads (head t). arity_sym f = 1 ∧ wt_sym f = 0) ⟹ arg t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ arg t = s ⟹
    t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t = head s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≥<span class="hidden">⇩</span><sub>t</sub> s ≡ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ t = s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wtI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t &gt; wt s ⟹ gt_wt t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_diff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_diffI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ gt_diff t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_unary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_unaryI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t = wt s ⟹ ¬ head t ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ num_args t = 1 ⟹
    (∃f ∈ ground_heads (head t). arity_sym f = 1 ∧ wt_sym f = 0) ⟹ arg t ≥<span class="hidden">⇩</span><sub>t</sub> s ⟹ gt_unary t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_same</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_sameI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t = head s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ gt_same t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟷ gt_wt t s ∨ gt_unary t s ∨ gt_diff t s ∨ gt_same t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>gt.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_unary.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ vars_mset t ⊇# vars_mset s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>gt.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>subset_mset.order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ vars t ⊇ vars s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Irreflexivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ ¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"size s"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_gt_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>gt.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s) (args s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_s</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wary_args</span><span> </span><span>extf_irrefl</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_hd_def</span><span> </span><span>gt_hd_irrefl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_wt_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ wt t ≥ wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>gt.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_extf_gt_nil_singleton_if_δ_eq_ε</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] [s]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nil_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] [s]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s_gt_nil</span><span> </span><span class="delimiter">=</span><span> </span><span>extf_singleton_nil_if_δ_eq_ε</span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_eq_ε</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>gt</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_irrefl</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_trans_from_irrefl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s}"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>nil_gt_s</span><span> </span><span>s_gt_nil</span><span class="delimiter">]</span><span> </span><span>gt_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_sub_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App s t) ⟹ App s t &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>size</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>wt_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = wt t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_App_δ</span><span> </span><span>wt_δ_imp_δ_eq_ε</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ε_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s = δ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt_App_δ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>nargs_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args s &lt; arity_hd (head s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_st</span><span> </span><span>wary.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd (head s) = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>arity.wary_AppE</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>eSuc_enat</span><span> </span><span>enat_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span>enat_defs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ileI1</span><span> </span><span>linorder_not_le</span><span> </span><span>not_iless0</span><span> </span><span>wary_st</span><span> </span><span>wt_gt_δ_if_superunary</span><span> </span><span>wt_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args s = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>less_one</span><span> </span><span>nargs_lt</span><span> </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Hd (head s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Hd_head_id</span><span> </span><span>nargs_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wt_f_etc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f + the_enat (δ * arity_sym f) = δ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_wt_sym</span><span> </span><span>wt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ary_f_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ary_f_ge_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f ≥ 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_hd_s</span><span> </span><span>f_in</span><span> </span><span>ground_heads_arity</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat δ * arity_sym f = δ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_f_etc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>enat_the_enat_δ_times_arity_sym</span><span> </span><span>le_add2</span><span>
</span><span>          </span><span>le_antisym</span><span> </span><span>mult.right_neutral</span><span> </span><span>mult_left_mono</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_f_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_f_etc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_s_ncmp_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head s ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_s_ncmp_t</span><span> </span><span>nargs_s</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>f_in</span><span> </span><span>ary_f_1</span><span> </span><span>wt_f_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_s_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_s_gt_t</span><span> </span><span>wt_s</span><span class="delimiter">[</span><span>folded</span><span> </span><span>δ_eq_ε</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_f_1</span><span> </span><span>exists_wt_sym</span><span> </span><span>f_in</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_sym_antisym</span><span> </span><span>unary_wt_sym_0_gt</span><span> </span><span>wt_f_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_t_eq_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_t_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t ≤ 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_hd_s</span><span> </span><span>wary_num_args_le_arity_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [t] (args t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf_singleton_nil_if_δ_eq_ε</span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_eq_ε</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>args_t</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ta</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = []"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hd_t_eq_s</span><span class="delimiter">]</span><span> </span><span>wary_num_args_le_arity_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span>
</span><span>            </span><span>nargs_t_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta = arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_t</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App (fun t) ta"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>args_t</span><span> </span><span>not_Cons_self2</span><span> </span><span>tm.exhaust_sel</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> ta"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>ta</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ta</span><span> </span><span>size_arg_lt</span><span> </span><span>t</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>args_t</span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span> </span><span>gt_irrefl</span><span> </span><span>wary_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_t_eq_s</span><span> </span><span>wt_s</span><span class="delimiter">[</span><span>folded</span><span> </span><span>δ_eq_ε</span><span class="delimiter">]</span><span> </span><span>length_0_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>nargs_s</span><span class="delimiter">]</span><span> </span><span>extf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_wt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ is_App s ⟹ s &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_sub_arg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary u ⟹ wary t ⟹ wary s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). {#size u, size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). wary u ⟶ wary t ⟶ wary s ⟶ u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, t, s)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ua ta sa. {#size ua, size ta, size sa#} &lt; {#size u, size t, size s#} ⟹
      wary ua ⟹ wary ta ⟹ wary sa ⟹ ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>u_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset u ⊇# vars_mset t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span> </span><span>t_gt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vars_u_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset u ⊇# vars_mset s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_u_ge_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u ≥ wt t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥ wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_imp_wt_ge</span><span> </span><span>u_gt_t</span><span> </span><span>t_gt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>wt_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t = wt s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_u_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u = wt t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_u_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u = wt s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg u)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_imp_δ_eq_ε</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (arg u) &lt; size t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>arg_u_gt_s</span><span> </span><span>gt_arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u_app</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_u</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (arg t) &lt; size s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_arg</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>u_gt_t</span><span> </span><span>wary_t</span><span> </span><span>wary_u</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_t</span><span>
</span><span>              </span><span>wary_s</span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sz_u_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size u &gt; size t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sz_t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size t &gt; size s"</span></span></span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_fun_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (fun u) = δ"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>gt_imp_wt_ge</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u_app</span><span> </span><span>wt_App_δ</span><span> </span><span>wt_arg_le</span><span>
</span><span>              </span><span>wt_t_s</span><span> </span><span>wt_u_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nargs_fun_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun u) = 0"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>one_arg_imp_Hd</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>              </span><span>u_app</span><span class="delimiter">)</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_u_eq_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd (head s) = 1"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_heads_arity</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>hd_u_eq_s</span><span> </span><span>one_enat_def</span><span>
</span><span>                </span><span>wary_num_args_le_arity_head</span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Hd_head_id</span><span> </span><span>δ_eq_ε</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>extf_singleton_nil_if_δ_eq_ε</span><span>
</span><span>                  </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>head_fun</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_irrefl_nat</span><span> </span><span>nargs_fun_u</span><span>
</span><span>                  </span><span>tm.exhaust_sel</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>args_s</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>sa</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = []"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>antisym_conv</span><span> </span><span>ary_hd_s</span><span> </span><span>diff_Suc_1</span><span>
</span><span>                  </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_add2</span><span> </span><span>length_0_conv</span><span> </span><span>length_Cons</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>one_enat_def</span><span>
</span><span>                  </span><span>wary_num_args_le_arity_head</span><span> </span><span>wary_s</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa = arg s"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_s</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>args_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"args u = [arg u]"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_0_conv</span><span>
</span><span>                  </span><span>nargs_fun_u</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max_sz_u_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {size s, size t, size u} = size u"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sz_t_gt_s</span><span> </span><span>sz_u_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max_sz_arg_u_t_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {size (arg t), size t, size (arg u)} &lt; size u"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_arg_lt</span><span> </span><span>sz_u_gt_t</span><span> </span><span>t_app</span><span> </span><span>u_app</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg u), size t, size (arg t)#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_sz_arg_u_t_arg_t</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>insert_commute</span><span> </span><span>max_sz_u_t_s</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_gt_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_t</span><span> </span><span>wary_arg_t</span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_arg</span><span>
</span><span>                  </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>wary_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max_sz_arg_s_s_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {size (arg s), size s, size (arg t)} &lt; size u"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_app</span><span> </span><span>t_app</span><span> </span><span>size_arg_lt</span><span> </span><span>sz_t_gt_s</span><span> </span><span>sz_u_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg t), size s, size (arg s)#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add_mset_lt_lt_lt</span><span> </span><span>less_trans</span><span> </span><span>mset_lt_single_iff</span><span> </span><span>s_app</span><span> </span><span>size_arg_lt</span><span>
</span><span>                  </span><span>sz_t_gt_s</span><span> </span><span>sz_u_gt_t</span><span> </span><span>t_app</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_t_gt_arg_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_t</span><span> </span><span>wary_s</span><span> </span><span>wary_arg_s</span><span class="delimiter">]</span><span>
</span><span>                  </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>gt_arg</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_s</span><span> </span><span>wary_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg s"</span></span></span><span class="delimiter">]</span><span> </span><span>arg_u_gt_arg_t</span><span> </span><span>arg_t_gt_arg_s</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_lt_le_lt</span><span> </span><span>less_imp_le_nat</span><span> </span><span>s_app</span><span> </span><span>size_arg_lt</span><span> </span><span>t_app</span><span> </span><span>u_app</span><span>
</span><span>                  </span><span>wary_arg_s</span><span> </span><span>wary_arg_t</span><span> </span><span>wary_arg_u</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>args_u</span><span> </span><span>args_s</span><span> </span><span>ss</span><span> </span><span>sa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span> </span><span>gt_irrefl</span><span> </span><span>wary_arg_u</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span> </span><span>hd_u_eq_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head u"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>dual_order.strict_trans2</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>            </span><span>length_0_conv</span><span> </span><span>not_le_imp_less</span><span> </span><span>size_arg_lt</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>            </span><span>unary_wt_sym_0_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_u_ncomp_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>folded</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args u ≤ 1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ground_heads_arity</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>one_enat_def</span><span>
</span><span>            </span><span>order_trans</span><span> </span><span>wary_num_args_le_arity_head</span><span> </span><span>wary_u</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args u = 1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args u"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>metis</span><span> </span><span>Hd_head_id</span><span> </span><span>δ_eq_ε</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>              </span><span>head_fun</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_extf_gt_nil_singleton_if_δ_eq_ε</span><span> </span><span>one_arg_imp_Hd</span><span>
</span><span>              </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t_app</span><span class="delimiter">]</span><span> </span><span>wary_arg_t</span><span class="delimiter">,</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span> </span><span>args_Nil_iff_is_Hd</span><span>
</span><span>            </span><span>comp_hd_def</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_irrefl</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>head_fun</span><span>
</span><span>            </span><span>length_0_conv</span><span> </span><span>nargs_u</span><span> </span><span>one_arg_imp_Hd</span><span> </span><span>t_app</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u_gt_t</span><span> </span><span>wary_u</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_arg_t</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_lt_left_lt</span><span> </span><span>add_mset_lt_lt_lt</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nargs_u</span><span>
</span><span>            </span><span>size_arg_lt</span><span> </span><span>t_app</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_s</span><span> </span><span>hd_u_ncomp_s</span><span> </span><span>nargs_u</span><span> </span><span>_</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_u_t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_hd_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_u_t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_u_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args u) ∪ set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_trans_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ua ∈ ?S. ∀ta ∈ ?S. ∀sa ∈ ?S. ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟶ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟶ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>ta</span><span> </span><span>ua</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>            </span><span>ua_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sa_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span>ua_gt_ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_gt_sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary ta"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_ua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary ua"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_args</span><span> </span><span>ua_in</span><span> </span><span>ta_in</span><span> </span><span>sa_in</span><span> </span><span>wary_u</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>wary_ua</span><span> </span><span>wary_ta</span><span> </span><span>wary_sa</span><span> </span><span>ua_gt_ta</span><span> </span><span>ta_gt_sa</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ua_in</span><span> </span><span>ta_in</span><span> </span><span>sa_in</span><span> </span><span>Un_iff</span><span> </span><span>max.strict_coboundedI1</span><span> </span><span>max.strict_coboundedI2</span><span>
</span><span>                 </span><span>size_in_args</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head u). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>extf_trans_from_irrefl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>gt_trans_args</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>wary_args</span><span> </span><span>wary_u</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>gt_irrefl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_u_s</span><span> </span><span>wt_u_s</span><span> </span><span>hd_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_u_t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_t_s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_u_s</span><span> </span><span>wt_t_ge_s</span><span> </span><span>wt_u_ge_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_antisym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ wary t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ ¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterm Property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_sub_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) &gt; wt s"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_wt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>order.antisym</span><span> </span><span>not_le_imp_less</span><span> </span><span>wt_App_ge_fun</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ = ε"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>diff_diff_cancel</span><span> </span><span>wt_δ_imp_δ_eq_ε</span><span> </span><span>wt_ge_δ</span><span> </span><span>wt.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (App s t) ⊇# vars_mset s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s t) = head s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (App s t)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s t)) (args s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>δ_eq_ε</span><span> </span><span>extf_snoc_if_δ_eq_ε</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_st</span><span> </span><span>wt_st</span><span> </span><span>hd_st</span><span> </span><span>extf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_proper_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t ⟹ proper_sub s t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_sub_fun</span><span> </span><span>gt_sub_arg</span><span> </span><span>gt_trans</span><span> </span><span>sub.intros</span><span> </span><span>wary_sub</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility with Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>t'_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_st'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (App s t') ⊇# vars_mset (App s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t'_gt_t</span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t' &gt; wt t"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_st'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t') &gt; wt (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wt.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_st'</span><span> </span><span>wt_st'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t' = wt t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_gt_t</span><span> </span><span>gt_imp_wt_ge</span><span> </span><span>order.not_eq_order_implies_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_st'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t') = wt (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wt.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>head_st'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s t') = head (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s @ [t']) (args s @ [t])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_compat_list</span><span> </span><span>gt_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_st'</span><span> </span><span>wt_st'</span><span> </span><span>head_st'</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility with Arguments›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_arg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App s' t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s'_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' t &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (App s' t) ⊇# vars_mset (App s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s'_gt_s</span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s'_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s' t) &gt; wt (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_assoc</span><span> </span><span>add_less_cancel_right</span><span> </span><span>gt_wt_s'_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s't</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_heads_arity</span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>one_enat_def</span><span> </span><span>wary_AppE</span><span>
</span><span>        </span><span>wary_s't</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s' t) = wt (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_same_s'_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s' t) = head (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_same_s'_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (App s' t)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s' t)) (args (App s t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_s'_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extf_compat_append_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s't</span><span> </span><span>wt_s't</span><span> </span><span>hd_s't</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stability under Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extra_wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v ⇒ ('s, 'v) tm) ⇒ ('s, 'v) tm ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ s = (∑x ∈# vars_mset s. wt (ρ x) - wt (Hd (Var x)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>extra_wt_Var</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ (Hd (Var x)) = wt (ρ x) - wt (Hd (Var x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>extra_wt_Sym</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ (Hd (Sym f)) = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>extra_wt_App</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ (App s t) = extra_wt ρ s + extra_wt ρ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extra_wt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extra_wt_subseteq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vars_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ t ≥ extra_wt ρ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>extra_wt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?diff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λv. wt (ρ v) - wt (Hd (Var v))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset s + (vars_mset t - vars_mset s) = vars_mset t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subset_mset.add_diff_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#?diff v. v ∈# vars_mset t#} =
    {#?diff v. v ∈# vars_mset s#} + {#?diff v. v ∈# vars_mset t - vars_mset s#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_mset_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑v ∈# vars_mset t. ?diff v) ≥ (∑v ∈# vars_mset s. ?diff v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_ρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst ρ s) = wt s + extra_wt ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_s</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ξ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (ρ x)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>g_in_grs_ξ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ ground_heads ?ξ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wt_ξ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ?ξ) = wt_sym g + the_enat (δ * arity_sym g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_wt_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ ground_heads ζ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>g_in_grs_ξ</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_ρx_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (ρ x) ≥ wt (Hd ζ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>dual_order.trans</span><span> </span><span>wt_le_wt_sym</span><span> </span><span>wt_ξ</span><span> </span><span>wt_hd_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extra_wt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ih_t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>wary_AppE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n. extra_wt ρ s + (wt s - δ + n) = wt (subst ρ s) - δ + n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>add_diff_assoc2</span><span> </span><span>ab_semigroup_add_class.add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span>add.left_commute</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extra_wt ρ s + (wt s + wt t - δ + extra_wt ρ t) = wt (subst ρ s) + wt (subst ρ t) - δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih_t</span><span> </span><span>wary_st</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add_diff_assoc2</span><span> </span><span>ab_semigroup_add_class.add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wary_AppE</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_ge_δ</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_ρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t ⟹ wary s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). {#size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). wary t ⟶ wary s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. {#size ta, size sa#} &lt; {#size t, size s#} ⟹ wary ta ⟹ wary sa ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹
      subst ρ ta &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst ρ t) = wt (subst ρ s)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wt_ρt_ne_ρs</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t_gt_s</span><span> </span><span>gt_imp_vars_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (subst ρ t) ⊇# vars_mset (subst ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vars_mset_subst_subseteq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥ wt s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_imp_wt_ge</span><span> </span><span>t_gt_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst ρ t) &gt; wt (subst ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ρt_ne_ρs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_ρ</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span> </span><span>wt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_ρ</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_le_cancel_left</span><span> </span><span>add_less_le_mono</span><span> </span><span>extra_wt_subseteq</span><span>
</span><span>        </span><span>order.not_eq_order_implies_strict</span><span> </span><span>vars_s</span><span> </span><span>wt_t_ge_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wt_ρt_eq_ρs</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ρt_eq_ρs</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>diff_le_mono2</span><span> </span><span>extra_wt_subseteq</span><span> </span><span>wt_subst</span><span> </span><span>leD</span><span> </span><span>wary_ρ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_ρt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (subst ρ t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wary_subst_wary</span><span> </span><span>wary_t</span><span> </span><span>wary_ρ</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Hd</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wary_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = s"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ t2"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sub_arg</span><span> </span><span>wary_ρt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t2_ne_s</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t2_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t2 &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_t2</span><span> </span><span>wary_s</span><span> </span><span>t2_gt_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gt_sub_arg</span><span> </span><span>gt_trans</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>t</span><span> </span><span>wary_ρ</span><span> </span><span>wary_ρt</span><span> </span><span>wary_s</span><span> </span><span>wary_subst_wary</span><span>
</span><span>              </span><span>wary_t2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vars_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (subst ρ t) ⊇# vars_mset (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vars_mset_subst_subseteq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span>wary_subst_ground_heads</span><span> </span><span>gt_hd_def</span><span> </span><span>rev_subsetD</span><span> </span><span>wary_ρ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span> </span><span>wt_ρt_eq_ρs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vars_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (subst ρ t) ⊇# vars_mset (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vars_mset_subst_subseteq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_ρt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) = head (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_s_eq_hd_t</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_in_grs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head (subst ρ t))"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf_args_s_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf</span><span> </span><span>f_in_grs</span><span> </span><span>wary_subst_ground_heads</span><span> </span><span>wary_ρ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (map (subst ρ) (args t)) (map (subst ρ) (args s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_map</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>extf_args_s_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ ?S. ¬ subst ρ x &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z ∈ ?S. ∀y ∈ ?S. ∀x ∈ ?S. subst ρ z &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ y ⟶ subst ρ y &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x ⟶
            subst ρ z &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ta ∈ ?S. ∀sa ∈ ?S. {#size ta, size sa#} &lt; {#size t, size s#}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ ?S. ∀x ∈ ?S. y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ subst ρ y &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>sz_a</span><span> </span><span>size_in_args</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (subst ρ t)) (args (subst ρ s))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extf_compat_append_left</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (subst ρ t)).
        extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (subst ρ t)) (args (subst ρ s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span> </span><span>wt_ρt_eq_ρs</span><span> </span><span>hd_ρt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Totality on Ground Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_total_ground</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. ext_total (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t ⟹ ground s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). {# size t, size s #}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). ground t ⟶ ground s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. {# size ta, size sa #} &lt; {# size t, size s #} ⟹ ground ta ⟹ ground sa ⟹
      ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ∨ sa &gt;<span class="hidden">⇩</span><sub>t</sub> ta ∨ ta = sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>vars_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>vars_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset s ⊇# vars_mset t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>vars_mset_empty_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span>
</span><span>      </span><span>vars_mset_empty_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>gr_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t = wt s"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t &gt; wt s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s &gt; wt t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wt_t</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wt_s</span><span> </span><span class="delimiter">=</span><span> </span><span>wt_t</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ξ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = Sym g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_t</span><span class="delimiter">]</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s = Sym f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_gt_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &gt;<span class="hidden">⇩</span><sub>s</sub> f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_t</span><span> </span><span>wt_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>g_gt_f</span><span> </span><span>gt_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_gt_g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f &gt;<span class="hidden">⇩</span><sub>s</sub> g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s</span><span> </span><span>wt_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>f_gt_g</span><span> </span><span>gt_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_eq_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g = f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hd_s</span><span> </span><span class="delimiter">=</span><span> </span><span>hd_t</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t ∈ set (args t). ground t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>ground_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s ∈ set (args s). ground s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_s</span><span> </span><span>ground_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ts = ?ss"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ts_eq_ss</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>g_eq_f</span><span> </span><span>ts_eq_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tm_expand_apps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) ?ss ∨ extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ss ?ts"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>gr_ss</span><span> </span><span>gr_ts</span><span>
</span><span>            </span><span>ext_total.total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_total</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ?ts ∪ set ?ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span class="var">?ts</span><span> </span><span class="var">?ss</span><span> </span><span>g</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>Un_iff</span><span> </span><span>in_lists_iff_set</span><span> </span><span>less_multiset_doubletons</span><span> </span><span>size_in_args</span><span> </span><span>sup_ge2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ts ?ss"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_t</span><span> </span><span>wt_t</span><span> </span><span>hd_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span> </span><span>ξ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ss ?ts"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_s</span><span> </span><span>wt_s</span><span> </span><span>hd_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>g_eq_f</span><span class="delimiter">]</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-foundedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gtw</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub>) ≡ λt s. wary t ∧ wary s ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gtwg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) ≡ λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_gt_unary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ gt_unary t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_unary t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>gt_imp_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ngr_t_or_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ground t ∨ ¬ ground s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary_t_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ground_head</span><span> </span><span>not_comp_hd_imp_Var</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>gr_s</span><span> </span><span>ngr_t_or_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ground_wfP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub> s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>bad_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"worst_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) (λt s. size t &gt; size s)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wf_sz</span><span> </span><span class="delimiter">=</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wellorder_class.wf</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>size</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ffi_ground</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ground (?ff i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ffi_wary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. wary (?ff i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inf_chain_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) ?ff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>worst_chain_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bad_wt_diff_same</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ (gt_wt t s ∨ gt_diff t s ∨ gt_same t s)) ?ff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span>ground_gt_unary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground t ∧ gt_wt t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>wt</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf_less</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_wt.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_O_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_wt t s}
      O {(s, t). ground t ∧ (gt_diff t s ∨ gt_same t s)} ⊆ {(s, t). ground t ∧ gt_wt t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_diff_same_as_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ (gt_wt t s ∨ gt_diff t s ∨ gt_same t s)} =
      {(s, t). ground t ∧ gt_wt t s} ∪ {(s, t). ground t ∧ (gt_diff t s ∨ gt_same t s)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bad_diff_same</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ (gt_diff t s ∨ gt_same t s)) (λi. ?ff (i + k1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_infinite_down_chain_compatible</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_wt</span><span> </span><span>_</span><span> </span><span>wt_O_diff_same</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?ff</span><span class="delimiter">]</span><span> </span><span>bad_wt_diff_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>wt_diff_same_as_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground s ∧ ground t ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_def</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_diff t s}
      ⊆ {(s, t). ground s ∧ ground t ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_diff t s"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span>gt_imp_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_hd_def</span><span> </span><span>gr_s</span><span> </span><span>gr_t</span><span> </span><span>ground_hd_in_ground_heads</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground t ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_O_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_diff t s} O {(s, t). ground t ∧ gt_same t s}
      ⊆ {(s, t). ground t ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_same_as_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ (gt_diff t s ∨ gt_same t s)} =
      {(s, t). ground t ∧ gt_diff t s} ∪ {(s, t). ground t ∧ gt_same t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bad_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ gt_same t s) (λi. ?ff (i + k2))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_infinite_down_chain_compatible</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_diff</span><span> </span><span>_</span><span> </span><span>diff_O_same</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. ?ff (i + k1)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>bad_diff_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>diff_same_as_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. is_Sym (head (?ff (i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = sym (head (?ff k2))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_eq_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (?ff (i + k2)) = Sym f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hd_sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>ia</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>max_args</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_args = wt (?ff k2)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_eq_max_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (?ff (i + k2)) = max_args"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_args_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>ia</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nargs_le_max_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (?ff (i + k2)) ≤ max_args"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_eq_max_args</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt_ge_num_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ffi_wary</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U_of</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. set (args (?ff (i + k2)))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = (⋃i. ?U_of i)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ground u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ground_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ffi_ground</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ wary u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wary_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ffi_wary</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>u_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ ?U_of i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size u &lt; size (?ff (i + k2))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_in_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u_in</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + k2"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2 - 1) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> ?ff (i + k2)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt</span><span> </span><span>gt_proper_sub</span><span> </span><span>sub_args</span><span> </span><span>sz_u</span><span> </span><span>u_in</span><span> </span><span>wary_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2 - 1) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_Suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span>ffi_ground</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>u_good</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gtwu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt s. t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gtwu_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ¬ ?gtwu x x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i j. ∀t ∈ set (args (?ff (i + k2))). ∀s ∈ set (args (?ff (j + k2))). t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶
      t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (?ff (i + k2))) (args (?ff (Suc i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span>hd_eq_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f ?gtwu (args (?ff (i + k2))) (args (?ff (Suc i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_mono_strong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (extf f ?gtwu) (λi. args (?ff (i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nwf_ext</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"¬ wfP (λxs ys. length ys ≤ max_args ∧ length xs ≤ max_args ∧ extf f ?gtwu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>wfP_def</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nargs_le_max_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gtwu_le_gtwg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?gtwu ≤ (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gr_u</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?gtwu t s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bad_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain ?gtwu f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bad_f0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad ?gtwu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inf_chain_bad</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f 0 ∈ U"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_good</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad ?gtwu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f</span><span> </span><span>inf_chain_bad</span><span> </span><span>inf_chain_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>gtwu_le_gtwg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λxs ys. length ys ≤ max_args ∧ length xs ≤ max_args ∧ extf f ?gtwu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_wf_bounded</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?gtwu</span><span class="delimiter">]</span><span> </span><span>gtwu_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nwf_ext</span><span> </span><span>wf_ext</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?subst</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst grounding_ρ"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfP_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ground_wfP</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_grounding_ρ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wfP_subset</span><span> </span><span>wary_subst_wary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_grounding_ρ</span><span class="delimiter">]</span><span> </span><span>gt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_grounding_ρ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Free_KBO_Basic">
<div class="head"><h1>Theory Lambda_Free_KBO_Basic</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_KBO_Basic</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_KBO_Std.html"><span class="name">Lambda_Free_KBO_Std</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Graceful Basic Knuth-Bendix Order for Lambda-Free Higher-Order Terms
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Graceful Basic Knuth--Bendix Order for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_KBO_Basic</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_KBO_Std</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory defines the basic version of the graceful Knuth--Bendix order (KBO) for
‹λ›-free higher-order terms. Basic means that all symbols must have a
positive weight. The results are lifted from the standard KBO.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_basic</span><span> </span><span class="delimiter">=</span><span> </span><span>kbo_basic_basis</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ground_heads_var</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ground_heads_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ 's set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kbo_std</span><span class="delimiter">:</span><span> </span><span>kbo_std</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. ∞"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. ∞"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ε_gt_0</span><span> </span><span>kbo_std_def</span><span> </span><span>kbo_std_basis_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ζ) = (LEAST w. ∃f ∈ ground_heads ζ. w = wt_sym f)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) = wt s + wt t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t &gt; wt s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s ⟹ wt t = wt s ⟹ head t = head s ⟹
    (∀f ∈ ground_heads (head s). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_hd_eq_inf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd ζ = ∞"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>waryI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wary_inf_ary</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s = kbo_std.wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>basic_gt_and_gt_le_gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∧ local.kbo_std.gt t s) ≤ kbo_std.gt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>gt_and_basic_gt_le_basic_gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λt s. local.kbo_std.gt t s ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s) ≤ (&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>basic_gt_iff_gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟷ kbo_std.gt t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kbo_std.gt t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>kbo_std.gt_wt</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>kbo_std.gt_diff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>basic_gt_and_gt_le_gt</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>kbo_std.gt_same</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kbo_std.gt t s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_t_s</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>gt_unary</span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_nat_zero_code</span><span> </span><span>wt_sym_gt_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>satx</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gt_and_basic_gt_le_basic_gt</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>basic_wt_eq_wt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_irrefl</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_trans</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_proper_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"proper_sub s t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_proper_sub</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_compat_fun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ App s' t &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_compat_arg</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ ⟹ wt (subst ρ s) = wt s + kbo_std.extra_wt ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span>basic_wt_eq_wt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.wt_subst</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_subst</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub> s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>basic_gt_iff_gt</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>kbo_std.gt_wf</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Free_TKBO_Coefs">
<div class="head"><h1>Theory Lambda_Free_TKBO_Coefs</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_TKBO_Coefs</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_KBO_Util.html"><span class="name">Lambda_Free_KBO_Util</span></a> <a href="../Nested_Multisets_Ordinals/Signed_Syntactic_Ordinal.html"><span class="name">Signed_Syntactic_Ordinal</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       The Graceful Transfinite Knuth-Bendix Order with Subterm Coefficients for Lambda-Free Higher-Order Terms
    Author:      Heiko Becker &lt;heikobecker92@gmail.com&gt;, 2016
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Author:      Uwe Waldmann &lt;waldmann at mpi-inf.mpg.de&gt;, 2016
    Author:      Daniel Wand &lt;dwand at mpi-inf.mpg.de&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Graceful Transfinite Knuth--Bendix Order with Subterm Coefficients for
  Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_TKBO_Coefs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_KBO_Util</span><span> </span><span>Nested_Multisets_Ordinals.Signed_Syntactic_Ordinal</span><span>
</span><span class="keyword2"><span class="keyword">abbrevs</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"=p"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"=<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;p"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥p"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥t"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!h"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory defines the graceful transfinite Knuth--Bendix order (KBO) with
subterm coefficients for ‹λ›-free higher-order terms. The proof was
developed by copying that of the standard KBO and generalizing it along two
axes:\ subterm coefficients and ordinals. Both features complicate the
definitions and proofs substantially.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>Complex.arg</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>tkbo_coefs</span><span> </span><span class="delimiter">=</span><span> </span><span>kbo_std_basis</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span> </span><span>wt_sym</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>      </span><span>arity_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>arity_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ hmultiset"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>coef_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ nat ⇒ hmultiset"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>coef_sym_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef_sym f i &gt; 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span>hmultiset</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> ≡ of_nat δ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span>hmultiset</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ε<span class="hidden">⇩</span><sub>h</sub> ≡ of_nat ε"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity_sym<span class="hidden">⇩</span><sub>h</sub> f ≡ hmset_of_enat (arity_sym f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>arity_var<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity_var<span class="hidden">⇩</span><sub>h</sub> f ≡ hmset_of_enat (arity_var f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>arity_hd<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) hd ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity_hd<span class="hidden">⇩</span><sub>h</sub> f ≡ hmset_of_enat (arity_hd f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity<span class="hidden">⇩</span><sub>h</sub> s ≡ hmset_of_enat (arity s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity<span class="hidden">⇩</span><sub>h</sub>_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity<span class="hidden">⇩</span><sub>h</sub> s = arity_hd<span class="hidden">⇩</span><sub>h</sub> (head s) - of_nat (num_args s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arity_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity<span class="hidden">⇩</span><sub>h</sub>_App</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity<span class="hidden">⇩</span><sub>h</sub> (App s t) = arity<span class="hidden">⇩</span><sub>h</sub> s - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_enat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wary_App<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>wary_App</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_lt_hmset_of_enat_iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>wary_AppE</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_lt_hmset_of_enat_iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wary_num_args_le_arity_head<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>wary_num_args_le_arity_head</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_le_hmset_of_enat_iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wary_apps<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>wary_apps</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_le_hmset_of_enat_iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wary_cases_apps<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>apps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>wary_cases_apps</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_le_hmset_of_enat_iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>ground_heads_arity</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hmset_of_enat_le</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>some_ground_head_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>some_ground_head_arity</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hmset_of_enat_le</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="delimiter">=</span><span> </span><span>ε_gt_0</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_less_hmset</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub>_le_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>δ_le_ε</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_le_hmset</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>arity_hd<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="delimiter">=</span><span> </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span>
</span><span>  </span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_less_hmset</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>hmset_of_enat_lt_iff_ne_infinity</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_sym_ge<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f ≥ ε<span class="hidden">⇩</span><sub>h</sub> - δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat (the_enat (of_nat δ * arity_sym f)) = δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>of_nat_eq_enat</span><span class="delimiter">,</span><span>
</span><span>    </span><span>metis</span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span> </span><span>gr_zeroI</span><span> </span><span>mult_eq_0_iff</span><span> </span><span>of_nat_0</span><span> </span><span>the_enat_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_sym_ge</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>of_nat_minus_hmset</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>unary_wt_sym_0_gt<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>unary_wt_sym_0_gt</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hmset_of_enat_inject</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>hmset_of_enat_1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>unary_wt_sym_0_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>unary_wt_sym_0_imp_δ_eq_ε</span><span>
</span><span>  </span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_inject_hmset</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_ext_snoc_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>extf_ext_snoc_if_δ_eq_ε</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_inject_hmset</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_snoc_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>ext_snoc.snoc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_ext_snoc_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="delimiter">=</span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span>
</span><span>  </span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_less_hmset</span><span> </span><span>hmset_of_enat_lt_iff_ne_infinity</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>arity_var<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="delimiter">=</span><span> </span><span>arity_var_ne_infinity_if_δ_gt_0</span><span>
</span><span>  </span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_less_hmset</span><span> </span><span>hmset_of_enat_lt_iff_ne_infinity</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>arity<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="delimiter">=</span><span> </span><span>arity_ne_infinity_if_δ_gt_0</span><span>
</span><span>  </span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_less_hmset</span><span> </span><span>hmset_of_enat_lt_iff_ne_infinity</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>of_nat_0</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>warywary_subst_subst<span class="hidden">⇩</span><sub>h</sub>_conv</span><span> </span><span class="delimiter">=</span><span> </span><span>wary_subst_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hmset_of_enat_le</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extf_singleton_nil_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>extf_singleton_nil_if_δ_eq_ε</span><span class="delimiter">[</span><span>folded</span><span> </span><span>of_nat_inject_hmset</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym<span class="hidden">⇩</span><sub>h</sub> f = of_nat n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span>assms</span><span> </span><span>lt_ω_imp_ex_of_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arity_var<span class="hidden">⇩</span><sub>h</sub>_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_var<span class="hidden">⇩</span><sub>h</sub> f = of_nat n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arity_var<span class="hidden">⇩</span><sub>h</sub>_lt_ω_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span>assms</span><span> </span><span>lt_ω_imp_ex_of_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weights and Subterm Coefficients›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>zhmset_of_tpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, hmultiset) tpoly ⇒ ('a, zhmultiset) tpoly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zhmset_of_tpoly ≡ map_tpoly (λx. x) zhmset_of"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>eval_ztpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ zhmultiset) ⇒ ('a, hmultiset) tpoly ⇒ zhmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A p ≡ eval_tpoly A (zhmset_of_tpoly p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_tpoly_eq_eval_ztpoly</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (eval_tpoly A p) = eval_ztpoly (λv. zhmset_of (A v)) p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_sum_list</span><span> </span><span>zhmset_of_prod_list</span><span> </span><span>o_def</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp_all</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>min_ground_head</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) hd ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_ground_head ζ =
   (SOME f. f ∈ ground_heads ζ ∧
      (∀g ∈ ground_heads ζ. wt_sym g + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> g ≥ wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'va</span><span> </span><span>pvar</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>PWt</span><span> </span><span class="tfree">'va</span><span>
</span><span class="delimiter">|</span><span> </span><span>PCoef</span><span> </span><span class="tfree">'va</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>min_passign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v pvar ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_passign (PWt x) = wt_sym (min_ground_head (Var x))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_passign (PCoef _ _) = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>min_zpassign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v pvar ⇒ zhmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_zpassign v ≡ zhmset_of (min_passign v)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_zpassign_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_zpassign (PWt x) = zhmset_of (wt_sym (min_ground_head (Var x)))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_zpassign (PCoef x i) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>legal_passign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v pvar ⇒ hmultiset) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"legal_passign A ⟷ (∀x. A x ≥ min_passign x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>legal_zpassign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v pvar ⇒ zhmultiset) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟷ (∀x. A x ≥ min_zpassign x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>legal_min_passign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_passign min_passign"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_passign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>legal_min_zpassign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign min_zpassign"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_zpassign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_ge_0</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ A x ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_zpassign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>eq_tpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v pvar, hmultiset) tpoly ⇒ ('v pvar, hmultiset) tpoly ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"=<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q =<span class="hidden">⇩</span><sub>p</sub> p ⟷ (∀A. legal_zpassign A ⟶ eval_ztpoly A q = eval_ztpoly A p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>ge_tpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v pvar, hmultiset) tpoly ⇒ ('v pvar, hmultiset) tpoly ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q ≥<span class="hidden">⇩</span><sub>p</sub> p ⟷ (∀A. legal_zpassign A ⟶ eval_ztpoly A q ≥ eval_ztpoly A p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>gt_tpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v pvar, hmultiset) tpoly ⇒ ('v pvar, hmultiset) tpoly ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q &gt;<span class="hidden">⇩</span><sub>p</sub> p ⟷ (∀A. legal_zpassign A ⟶ eval_ztpoly A q &gt; eval_ztpoly A p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_tpoly_imp_ge</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q &gt;<span class="hidden">⇩</span><sub>p</sub> p ⟹ q ≥<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span> </span><span>gt_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_tpoly_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p =<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ge_tpoly_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≥<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_tpoly_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_tpoly_def</span><span> </span><span>legal_zpassign_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>eq_eq_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r =<span class="hidden">⇩</span><sub>p</sub> q ⟹ q =<span class="hidden">⇩</span><sub>p</sub> p ⟹ r =<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>eq_ge_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r =<span class="hidden">⇩</span><sub>p</sub> q ⟹ q ≥<span class="hidden">⇩</span><sub>p</sub> p ⟹ r ≥<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>eq_gt_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r =<span class="hidden">⇩</span><sub>p</sub> q ⟹ q &gt;<span class="hidden">⇩</span><sub>p</sub> p ⟹ r &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ge_eq_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≥<span class="hidden">⇩</span><sub>p</sub> q ⟹ q =<span class="hidden">⇩</span><sub>p</sub> p ⟹ r ≥<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ge_ge_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≥<span class="hidden">⇩</span><sub>p</sub> q ⟹ q ≥<span class="hidden">⇩</span><sub>p</sub> p ⟹ r ≥<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ge_gt_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≥<span class="hidden">⇩</span><sub>p</sub> q ⟹ q &gt;<span class="hidden">⇩</span><sub>p</sub> p ⟹ r &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>gt_eq_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt;<span class="hidden">⇩</span><sub>p</sub> q ⟹ q =<span class="hidden">⇩</span><sub>p</sub> p ⟹ r &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>gt_ge_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt;<span class="hidden">⇩</span><sub>p</sub> q ⟹ q ≥<span class="hidden">⇩</span><sub>p</sub> p ⟹ r &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>gt_gt_tpoly_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r &gt;<span class="hidden">⇩</span><sub>p</sub> q ⟹ q &gt;<span class="hidden">⇩</span><sub>p</sub> p ⟹ r &gt;<span class="hidden">⇩</span><sub>p</sub> p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_tpoly_def</span><span> </span><span>ge_tpoly_def</span><span> </span><span>gt_tpoly_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>order.trans</span><span> </span><span>less_trans</span><span> </span><span>less_le_trans</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>coef_hd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) hd ⇒ nat ⇒ ('v pvar, hmultiset) tpoly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"coef_hd (Var x) i = PVar (PCoef x i)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef_hd (Sym f) i = PNum (coef_sym f i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coef_hd_gt_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef_hd ζ i) &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_zpassign_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>legal_zpassign_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PCoef x i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>coef_sym_gt_0</span><span> </span><span>zhmset_of_1</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dual_order.strict_trans1</span><span> </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>legal_zpassign_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PWt x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coef_sym_gt_0</span><span> </span><span>zhmset_of_0</span><span> </span><span>zhmset_of_less</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>coef</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ nat ⇒ ('v pvar, hmultiset) tpoly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"coef (Hd ζ) i = coef_hd ζ i"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef (App s _) i = coef s (i + 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coef_apps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef (apps s ss) i = coef s (i + length ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coef_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ eval_ztpoly A (coef s i) &gt; 0"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>coef_hd_gt_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_min_ground_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ ground_heads ζ ∧
     (∀g ∈ ground_heads ζ. wt_sym g + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> g ≥ wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(f, g). f ∈ ground_heads ζ ∧ g ∈ ground_heads ζ ∧
    wt_sym g + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> g &gt; wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf ?R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(M, N). M &lt; N}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ ground_heads ζ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ground_heads_nonempty</span><span> </span><span>subsetI</span><span> </span><span>subset_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_eq_minimal</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf_R</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_ground_head_Sym</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_ground_head (Sym f) = f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_ground_head_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_ground_head_in_ground_heads</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_ground_head ζ ∈ ground_heads ζ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_ground_head_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exists_min_ground_head</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_ground_head_min</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads ζ ⟹
   wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f ≥ wt_sym (min_ground_head ζ) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_ground_head_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exists_min_ground_head</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_ground_head_antimono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground_heads ζ ⊆ ground_heads ξ ⟹
   wt_sym (min_ground_head ζ) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)
   ≥ wt_sym (min_ground_head ξ) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_ground_head_in_ground_heads</span><span> </span><span>min_ground_head_min</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>wt0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) hd ⇒ ('v pvar, hmultiset) tpoly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt0 (Var x) = PVar (PWt x)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt0 (Sym f) = PNum (wt_sym f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt0_ge_min_ground_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ eval_ztpoly A (wt0 ζ) ≥ zhmset_of (wt_sym (min_ground_head ζ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>legal_zpassign_def</span><span> </span><span>min_zpassign_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_ztpoly_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ eval_ztpoly A p ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>map_cong</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_list_nonneg</span><span> </span><span>prod_list_nonneg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_zip_imp_size_lt_apps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, y) ∈ set (zip ss ys) ⟹ size s &lt; size (apps (Hd ζ) ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('v pvar, hmultiset) tpoly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt (apps (Hd ζ) ss) =
   PSum ([wt0 ζ, PNum (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss)))] @
     map (λ(s, i). PMult [coef_hd ζ i, wt s]) (zip ss [0..&lt;length ss]))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>lexicographic_order</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_zip_imp_size_lt_apps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>wt_args</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('v pvar ⇒ zhmultiset) ⇒ ('s, 'v) hd ⇒ ('s, 'v) tm list ⇒ zhmultiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt_args i A ζ ss = sum_list
     (map (eval_ztpoly A ∘ (λ(s, i). PMult [coef_hd ζ i, wt s])) (zip ss [i..&lt;i + length ss]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_Hd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (Hd ζ) = PSum [wt0 ζ, PNum (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coef_hd_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀x ∈ vars_hd ζ. ∀i. A (PCoef x i) = B (PCoef x i)) ⟹
   eval_ztpoly A (coef_hd ζ i) = eval_ztpoly B (coef_hd ζ i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt0_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pwt_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ vars_hd ζ. A (PWt x) = B (PWt x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt0 ζ) = eval_ztpoly B (wt0 ζ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pwt_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ vars s. A (PWt x) = B (PWt x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ vars s. ∀i. A (PCoef x i) = B (PCoef x i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) = eval_ztpoly B (wt s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_induct_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pwt_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pcoef_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) = eval_ztpoly B (wt s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>s_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s_in</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ vars s. A (PWt x) = B (PWt x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pwt_eq</span><span> </span><span>s_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ vars s. ∀i. A (PCoef x i) = B (PCoef x i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pcoef_eq</span><span> </span><span>s_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt0_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt0 ζ) = eval_ztpoly B (wt0 ζ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt0_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pwt_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>coef_ζ_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef_hd ζ i) = eval_ztpoly B (coef_hd ζ i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>coef_hd_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pcoef_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih'</span><span> </span><span>wt0_eq</span><span> </span><span>coef_ζ_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_eval_ztpoly_wt_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s ⟹ eval_ztpoly A (wt s) = eval_ztpoly B (wt s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_wt_sym</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f ∈ ground_heads ζ. eval_ztpoly A (wt (Hd ζ)) ≥ zhmset_of (wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_tpoly_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Var</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>legal_zpassign_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_le_cancel_right</span><span> </span><span>ground_heads.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_ground_head_in_ground_heads</span><span>
</span><span>      </span><span>min_zpassign_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Sym</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) ≥ zhmset_of ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_induct_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ss_eq_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = []"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ε<span class="hidden">⇩</span><sub>h</sub> ≤ wt_sym (min_ground_head ζ) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_sym_ge<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_ground_head ζ"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>leD</span><span> </span><span>leI</span><span> </span><span>le_imp_minus_plus_hmset</span><span> </span><span>le_minus_plus_same_hmset</span><span>
</span><span>        </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of ε<span class="hidden">⇩</span><sub>h</sub>
      ≤ zhmset_of (wt_sym (min_ground_head ζ)) + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zhmset_of_le</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"…
      ≤ eval_tpoly A (map_tpoly (λx. x) zhmset_of (wt0 ζ))
        + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt0_ge_min_ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss_eq_nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?arg_wt</span><span> </span><span class="delimiter">=</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly A ∘ (map_tpoly (λx. x) zhmset_of ∘ (λ(s, i). PMult [coef_hd ζ i, wt s]))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ss_ne_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of ε<span class="hidden">⇩</span><sub>h</sub>
      ≤ eval_tpoly A (map_tpoly (λx. x) zhmset_of (PMult [coef_hd ζ 0, wt (hd ss)]))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ih</span><span> </span><span>coef_hd_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span>nonneg_le_mult_right_mono_zhmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = hd (map ?arg_wt (zip ss [0..&lt;length ss]))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss_ne_nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_map</span><span> </span><span>zip_nth_conv</span><span> </span><span>hd_conv_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ sum_list (map ?arg_wt (zip ss [0..&lt;length ss]))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hd_le_sum_list</span><span class="delimiter">,</span><span>
</span><span>        </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.collapse</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>          </span><span>ss_ne_nil</span><span> </span><span>upt_conv_Cons</span><span> </span><span>zip_Cons_Cons</span><span class="delimiter">,</span><span>
</span><span>        </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_ztpoly_nonneg</span><span> </span><span>legal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"…
      ≤ eval_tpoly A (map_tpoly (λx. x) zhmset_of (wt0 ζ)) +
        (zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss))) +
         sum_list (map ?arg_wt (zip ss [0..&lt;length ss])))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ eval_tpoly A (map_tpoly (λp. p) zhmset_of (wt0 ζ))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span> </span><span>eval_ztpoly_nonneg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>leD</span><span> </span><span>leI</span><span> </span><span>le_add_same_cancel2</span><span> </span><span>less_le_trans</span><span> </span><span>zhmset_of_nonneg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_args_ge_length_times_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_args i A ζ ss ≥ of_nat (length ss) * zhmset_of ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_args_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_ge_length_times</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>wt_args_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (eval_ztpoly A ∘ (λ(s, i). PMult [coef_hd ζ i, wt s])) (zip ss [i..&lt;i + length ss])"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_le_mono_hmset</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>nonneg_le_mult_right_mono_zhmset</span><span> </span><span>coef_hd_gt_0</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>legal</span><span> </span><span>zero_less_iff_1_le_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>coef_hd_gt_0</span><span> </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ eval_ztpoly A (wt s) ≥ zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub>_le_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>folded</span><span> </span><span>zhmset_of_le</span><span class="delimiter">]</span><span> </span><span>order.trans</span><span> </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>zhmset_of_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A ⟹ eval_ztpoly A (wt s) &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span class="delimiter">[</span><span>folded</span><span> </span><span>zhmset_of_less</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>zhmset_of_0</span><span class="delimiter">]</span><span> </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_gt_δ<span class="hidden">⇩</span><sub>h</sub>_if_superunary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>superunary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd<span class="hidden">⇩</span><sub>h</sub> (head s) &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) &gt; zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>δ_ne_ε</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order.not_eq_order_implies_strict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_ne_ε</span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub>_le_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>zhmset_of_less</span><span class="delimiter">]</span><span>
</span><span>      </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>superunary</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_induct_apps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd<span class="hidden">⇩</span><sub>h</sub> ζ &gt; 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>min_gr_ary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) &gt; 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>less_le_trans</span><span> </span><span>min_ground_head_in_ground_heads</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of δ<span class="hidden">⇩</span><sub>h</sub> &lt; eval_ztpoly A (wt0 ζ) + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>δ_eq_ε</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_strict_increasing2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>eval_ztpoly_nonneg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>zhmset_of_less</span><span class="delimiter">,</span><span>
</span><span>        </span><span>rule</span><span> </span><span>gt_0_lt_mult_gt_1_hmset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span>min_gr_ary</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt0 ζ)
      + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss)))
        + zhmset_of (of_nat (length ss) * ε<span class="hidden">⇩</span><sub>h</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span>δ_eq_ε</span><span> </span><span>zmset_of_le</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>algebra_simps</span><span>
</span><span>            </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ring_distribs</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ring_distribs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>le_minus_plus_same_hmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt0 ζ)
      + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss))) + wt_args 0 A ζ ss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_args_ge_length_times_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_times</span><span> </span><span>of_nat_zhmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_plus_δ<span class="hidden">⇩</span><sub>h</sub>_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) + zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>
   ≥ eval_ztpoly A (wt s) + eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) = ω"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ary_eq_ω</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ary_eq_ω</span><span> </span><span>s</span><span> </span><span>App_apps</span><span> </span><span>wt.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>diff_diff_add_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span>App_apps</span><span> </span><span>wt.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zmset_of_le</span><span class="delimiter">,</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>diff_diff_add_hmset</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>le_minus_plus_same_hmset</span><span>
</span><span>          </span><span>distrib_left</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 :: hmultiset"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>mult.right_neutral</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>diff_diff_add_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_fun_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) = zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_s_t_le_δ_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) + eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)
     ≤ zhmset_of δ<span class="hidden">⇩</span><sub>h</sub> + eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_App_plus_δ<span class="hidden">⇩</span><sub>h</sub>_ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt s) + eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t) ≤ eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef s 0) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_ztpoly_nonneg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>coef_gt_0</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>leD</span><span> </span><span>legal</span><span> </span><span>mult_cancel_right1</span><span>
</span><span>      </span><span>nonneg_le_mult_right_mono_zhmset</span><span> </span><span>wt_gt_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_s_t_le_δ_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>antisym</span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_arg_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt t) = zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) + zhmset_of δ<span class="hidden">⇩</span><sub>h</sub> = eval_ztpoly A (wt s) + zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t) ≤ zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?k * ?w ≤ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_le_cancel_left</span><span> </span><span>wt_App_plus_δ<span class="hidden">⇩</span><sub>h</sub>_ge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?k * ?w = zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span>coef_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>zero_less_iff_1_le_hmset</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>antisym</span><span> </span><span>nonneg_le_mult_right_mono_zhmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?w ≤ zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coef_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>eval_ztpoly_nonneg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span>
</span><span>      </span><span>nonneg_le_mult_right_mono_zhmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>antisym</span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_ge_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of δ<span class="hidden">⇩</span><sub>h</sub> ≤ eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coef_gt_0</span><span> </span><span>legal</span><span> </span><span>nonneg_le_mult_right_mono_zhmset</span><span> </span><span>wt_ge_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) + zhmset_of δ<span class="hidden">⇩</span><sub>h</sub> ≤ eval_ztpoly A (wt (App s t)) + zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_le_cancel_right</span><span> </span><span>add_less_le_mono</span><span> </span><span>not_le</span><span> </span><span>wt_App_plus_δ<span class="hidden">⇩</span><sub>h</sub>_ge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) ≤ eval_ztpoly A (wt (App s t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_App_ge_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) ≥<span class="hidden">⇩</span><sub>p</sub> wt t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>App_apps</span><span> </span><span>wt.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span> </span><span>coef_hd_gt_0</span><span> </span><span>eval_ztpoly_nonneg</span><span> </span><span>nonneg_le_mult_right_mono_zhmset</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_list_nonneg</span><span> </span><span>eval_ztpoly_nonneg</span><span> </span><span>add_increasing</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_δ<span class="hidden">⇩</span><sub>h</sub>_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_s_eq_δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) = zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub>_le_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>wt_ge_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>wt_s_eq_δ</span><span> </span><span>zhmset_of_le</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_ge_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ vars t ⊇ vars s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wt_ge_ζ</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>z_ni_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ vars t"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span>min_zpassign</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λv. if v = PWt x then eval_ztpoly ?A (wt t) + ?A v + 1 else ?A v"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>legal_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign ?B"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_zpassign_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>legal_min_zpassign</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_increasing</span><span> </span><span>eval_ztpoly_nonneg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eval_B_eq_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly ?B (wt t) = eval_ztpoly ?A (wt t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>z_ni_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly ?B (wt (Hd (Var x))) &gt; eval_ztpoly ?B (wt t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eval_B_eq_A</span><span> </span><span>zero_less_iff_1_le_zhmset</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ge_ζ</span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>leD</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>legal_B</span><span> </span><span>legal_min_zpassign</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ih2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_t_ge_wt_s1s2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars s1 ⊆ vars t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih1</span><span> </span><span>wt_t_ge_wt_s1s2</span><span> </span><span>wt_App_ge_fun</span><span> </span><span>order_trans</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars s2 ⊆ vars t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih2</span><span> </span><span>wt_t_ge_wt_s1s2</span><span> </span><span>wt_App_ge_arg</span><span> </span><span>order_trans</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ge_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_coefs_ge_num_args_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_passign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>δ_eq_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_coefs (eval_tpoly A (wt s)) ≥ num_args s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>sa</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Az</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λv. zhmset_of (A v)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>legalz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign ?Az"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_passign_def</span><span> </span><span>legal_zpassign_def</span><span> </span><span>zhmset_of_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly ?Az (coef_hd ζ (length ss)) &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span> </span><span>coef_hd_gt_0</span><span> </span><span>eval_tpoly_eq_eval_ztpoly</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coef_hd_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legalz</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly A (coef_hd ζ (length ss)) &gt; 0"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?k &gt; _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eval_tpoly_eq_eval_ztpoly</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zhmset_of_less</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zhmset_of_0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly ?Az (wt sa) &gt; 0"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?w &gt; _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legalz</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly A (wt sa) &gt; 0"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?w &gt; _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eval_tpoly_eq_eval_ztpoly</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zhmset_of_less</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zhmset_of_0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?k * ?w &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_coefs (?k * ?w) &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_coefs_gt_0</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>δ_eq_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t &gt;<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_unary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ ¬ head t ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ num_args t = 1 ⟹
    (∃f ∈ ground_heads (head t). arity_sym f = 1 ∧ wt_sym f = 0) ⟹ arg t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ arg t = s ⟹
    t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>gt_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ head t = head s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≥<span class="hidden">⇩</span><sub>t</sub> s ≡ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ t = s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_wt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_wtI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t &gt;<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ gt_wt t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_unary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_unaryI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ ¬ head t ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ num_args t = 1 ⟹
    (∃f ∈ ground_heads (head t). arity_sym f = 1 ∧ wt_sym f = 0) ⟹ arg t ≥<span class="hidden">⇩</span><sub>t</sub> s ⟹ gt_unary t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_diff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_diffI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s ⟹ gt_diff t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>gt_same</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>gt_sameI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s ⟹ head t = head s ⟹
    (∀f ∈ ground_heads (head t). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)) ⟹ gt_same t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟷ gt_wt t s ∨ gt_unary t s ∨ gt_diff t s ∨ gt_same t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>gt.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_unary.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>gt.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_imp_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ vars t ⊇ vars s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>wt_ge_vars</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gt_imp_wt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Irreflexivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ ¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"size s"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_gt_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>gt.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s) (args s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_s</span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wary_args</span><span> </span><span>extf_irrefl</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_hd_def</span><span> </span><span>gt_tpoly_irrefl</span><span> </span><span>gt_hd_irrefl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_extf_gt_nil_singleton_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] [s]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nil_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] [s]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s_gt_nil</span><span> </span><span class="delimiter">=</span><span> </span><span>extf_singleton_nil_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_eq_ε</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>gt</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_irrefl</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [] []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_trans_from_irrefl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s}"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>nil_gt_s</span><span> </span><span>s_gt_nil</span><span class="delimiter">]</span><span> </span><span>gt_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_sub_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App s t) ⟹ App s t &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>size</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wt_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_App_fun_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span>wt_δ<span class="hidden">⇩</span><sub>h</sub>_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span>wt_st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ε<span class="hidden">⇩</span><sub>h</sub>_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (wt s) = zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wt_App_fun_δ<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span> </span><span>wt_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nargs_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat (num_args s) &lt; arity_hd<span class="hidden">⇩</span><sub>h</sub> (head s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd<span class="hidden">⇩</span><sub>h</sub> (head s) = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gr_implies_not_zero_hmset</span><span> </span><span>legal</span><span> </span><span>lt_1_iff_eq_0_hmset</span><span> </span><span>nargs_lt</span><span> </span><span>neq_iff</span><span>
</span><span>        </span><span>wt_gt_δ<span class="hidden">⇩</span><sub>h</sub>_if_superunary</span><span> </span><span>wt_s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args s = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_one</span><span> </span><span>nargs_lt</span><span> </span><span>of_nat_1</span><span> </span><span>of_nat_less_hmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>s_eq_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Hd (head s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Hd_head_id</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wt_f_etc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f = δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. ⟦f ∈ local.ground_heads (head s); wt_sym f + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f = δ<span class="hidden">⇩</span><sub>h</sub>⟧ ⟹ thesis"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. δ<span class="hidden">⇩</span><sub>h</sub> - δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> f ≤ wt_sym f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>legal</span><span> </span><span>wt_δ<span class="hidden">⇩</span><sub>h</sub>_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>wt_sym_ge<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. ¬ δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> s + wt_sym s &lt; δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>le_imp_minus_plus_hmset</span><span> </span><span>leD</span><span> </span><span>le_minus_plus_same_hmset</span><span>
</span><span>            </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>wt_s</span><span> </span><span>s_eq_hd</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exists_wt_sym</span><span> </span><span>legal</span><span> </span><span>add.commute</span><span> </span><span>order.not_eq_order_implies_strict</span><span> </span><span>zhmset_of_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ary_f_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>δ_gt_0</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>ary_hd_s</span><span> </span><span>diff_le_self_hmset</span><span> </span><span>dual_order.order_iff_strict</span><span>
</span><span>        </span><span>f_in</span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>gt_0_lt_mult_gt_1_hmset</span><span> </span><span>hmset_of_enat_1</span><span> </span><span>hmset_of_enat_inject</span><span> </span><span>leD</span><span>
</span><span>        </span><span>wt_f_etc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_f_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym f = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_f_etc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_s_ncmp_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head s ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_App_ge_arg</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_s_ncmp_t</span><span> </span><span>nargs_s</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>f_in</span><span> </span><span>ary_f_1</span><span> </span><span>wt_f_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_s_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_App_ge_arg</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_s_gt_t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head t &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_f_1</span><span> </span><span>wt_f_0</span><span> </span><span>f_in</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>unary_wt_sym_0_gt<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>hmset_of_enat_1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_t_eq_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_t_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args t ≤ 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_hd_s</span><span> </span><span>wary_num_args_le_arity_head<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span> </span><span>of_nat_le_hmset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) [t] (args t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf_singleton_nil_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_eq_ε</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>args_t</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ta</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = []"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hd_t_eq_s</span><span class="delimiter">]</span><span> </span><span>wary_num_args_le_arity_head<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span> </span><span>of_nat_le_hmset</span><span>
</span><span>            </span><span>nargs_t_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta = arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_t</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = App (fun t) ta"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>args_t</span><span> </span><span>not_Cons_self2</span><span> </span><span>tm.exhaust_sel</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> ta"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>ta</span><span> </span><span class="string"><span class="delete"><span class="delete">"fun t"</span></span></span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ta</span><span> </span><span>size_arg_lt</span><span> </span><span>t</span><span> </span><span>tm.disc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>args_t</span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span> </span><span>gt_irrefl</span><span> </span><span>wary_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_App_ge_arg</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_t_eq_s</span><span> </span><span>length_0_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>nargs_s</span><span class="delimiter">]</span><span> </span><span>extf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_wt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ge_tpoly_def</span><span> </span><span>gt_tpoly_def</span><span> </span><span>wt_App_ge_arg</span><span> </span><span>order.not_eq_order_implies_strict</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_arg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ is_App s ⟹ s &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_sub_arg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary u ⟹ wary t ⟹ wary s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). {#size u, size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(u, t, s). wary u ⟶ wary t ⟶ wary s ⟶ u &gt;<span class="hidden">⇩</span><sub>t</sub> t ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, t, s)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ua ta sa. {#size ua, size ta, size sa#} &lt; {#size u, size t, size s#} ⟹
      wary ua ⟹ wary ta ⟹ wary sa ⟹ ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>u_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_u_ge_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u ≥<span class="hidden">⇩</span><sub>p</sub> wt t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_imp_wt</span><span> </span><span>u_gt_t</span><span> </span><span>t_gt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ge_ge_tpoly_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_arg_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (arg s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wary_arg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_t_s</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_u_ge_t</span><span> </span><span>ge_gt_tpoly_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_fun_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun t) &lt; arity_hd (head (fun t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wary_AppE</span><span> </span><span>wary_t</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_u_t</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_t_ge_s</span><span> </span><span>gt_ge_tpoly_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_fun_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (fun u) = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>one_arg_imp_Hd</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>arg_u_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>u_app</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (arg u) &lt; size t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size u, size (arg u), size s#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>arg_u_gt_s</span><span> </span><span>gt_arg</span><span> </span><span>u_app</span><span> </span><span>wary_s</span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (arg t) &lt; size s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_arg</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>u_gt_t</span><span> </span><span>wary_t</span><span> </span><span>wary_u</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_t</span><span>
</span><span>            </span><span>wary_s</span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sz_u_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size u &gt; size t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sz_t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size t &gt; size s"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hd_u_eq_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ary_hd_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd (head s) = 1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_heads_arity</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>hd_u_eq_s</span><span> </span><span>one_enat_def</span><span>
</span><span>              </span><span>wary_num_args_le_arity_head</span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>δ_eq_ε</span><span> </span><span>args.elims</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>extf_snoc_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>length_0_conv</span><span>
</span><span>                </span><span>nargs_fun_u</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>u_app</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>args_s</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>sa</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = []"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>antisym_conv</span><span> </span><span>ary_hd_s</span><span> </span><span>diff_Suc_1</span><span>
</span><span>                </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_add2</span><span> </span><span>length_0_conv</span><span> </span><span>length_Cons</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>one_enat_def</span><span>
</span><span>                </span><span>wary_num_args_le_arity_head</span><span> </span><span>wary_s</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa = arg s"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>apps.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_s</span><span> </span><span>tm.sel</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App s"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>args_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"args u = [arg u]"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_0_conv</span><span>
</span><span>                </span><span>nargs_fun_u</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max_sz_arg_u_t_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {size (arg t), size t, size (arg u)} &lt; size u"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_arg_lt</span><span> </span><span>sz_u_gt_t</span><span> </span><span>t_app</span><span> </span><span>u_app</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg u), size t, size (arg t)#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_sz_arg_u_t_arg_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_gt_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_t</span><span> </span><span>wary_arg_t</span><span class="delimiter">]</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_arg</span><span>
</span><span>                </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>wary_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max_sz_arg_s_s_arg_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {size (arg s), size s, size (arg t)} &lt; size u"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_app</span><span> </span><span>t_app</span><span> </span><span>size_arg_lt</span><span> </span><span>sz_t_gt_s</span><span> </span><span>sz_u_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg t), size s, size (arg s)#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_sz_arg_s_s_arg_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_t_gt_arg_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_t</span><span> </span><span>wary_s</span><span> </span><span>wary_arg_s</span><span class="delimiter">]</span><span>
</span><span>                </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>gt_arg</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>args_s</span><span> </span><span>wary_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg u), size (arg t), size (arg s)#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_mset_lt_lt_lt</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_arg_lt</span><span> </span><span>u_app</span><span> </span><span>t_app</span><span> </span><span>s_app</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg s"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg s"</span></span></span><span class="delimiter">]</span><span> </span><span>arg_u_gt_arg_t</span><span> </span><span>arg_t_gt_arg_s</span><span> </span><span>wary_arg_s</span><span>
</span><span>                </span><span>wary_arg_t</span><span> </span><span>wary_arg_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>args_u</span><span> </span><span>args_s</span><span> </span><span>ss</span><span> </span><span>sa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span> </span><span>gt_irrefl</span><span> </span><span>wary_arg_u</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>hd_u_eq_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_le_trans</span><span> </span><span>linorder_not_le</span><span> </span><span>size_arg_lt</span><span> </span><span>t_app</span><span> </span><span>u_app</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_gt</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_u_ncomp_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>folded</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f ∈ ground_heads (head u). arity_sym f = 1 ∧ wt_sym f = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>folded</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd (head u) = 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>gr_implies_not_zero_hmset</span><span> </span><span>ground_heads_arity</span><span>
</span><span>          </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>head_fun</span><span> </span><span>hmset_of_enat_1</span><span> </span><span>hmset_of_enat_less</span><span> </span><span>lt_1_iff_eq_0_hmset</span><span>
</span><span>          </span><span>nargs_fun_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args u ≤ 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_nat_le_hmset</span><span> </span><span>wary_num_args_le_arity_head<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nargs_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args u = 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"args u"</span></span></span><span class="delimiter">,</span><span>
</span><span>          </span><span>metis</span><span> </span><span>Hd_head_id</span><span> </span><span>δ_eq_ε</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>            </span><span>ex_in_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>ground_heads_nonempty</span><span class="delimiter">]</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>            </span><span>head_fun</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_extf_gt_nil_singleton_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>one_arg_imp_Hd</span><span>
</span><span>            </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t_app</span><span class="delimiter">]</span><span> </span><span>wary_arg_t</span><span class="delimiter">,</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>u_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> arg t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_singleton</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span>append_Nil</span><span> </span><span>args.simps</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>comp_hd_def</span><span>
</span><span>          </span><span>gt_hd_def</span><span> </span><span>gt_irrefl</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>head_fun</span><span> </span><span>length_0_conv</span><span> </span><span>nargs_u</span><span>
</span><span>          </span><span>one_arg_imp_Hd</span><span> </span><span>t_app</span><span> </span><span>tm.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u_gt_t</span><span> </span><span>wary_u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#size (arg u), size (arg t), size s#} &lt; {#size u, size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_mset_lt_lt_lt</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_arg_lt</span><span> </span><span>u_app</span><span> </span><span>t_app</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_arg_t</span><span> </span><span>wary_s</span><span class="delimiter">]</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>hd_u_ncomp_s</span><span> </span><span>nargs_u</span><span> </span><span>_</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_unary_t_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_u_t</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_t_ge_s</span><span> </span><span>gt_ge_tpoly_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head s &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_hd_def</span><span> </span><span>gt_hd_irrefl</span><span> </span><span>gt_sym_antisym</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>unary_wt_sym_0_gt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_hd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_hd_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_gt_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_u_t</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt u &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_t_ge_s</span><span> </span><span>gt_ge_tpoly_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_u_t</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_App u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_Nil_iff_is_Hd</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u"</span></span></span><span> </span><span>t</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t_gt_s</span><span> </span><span>size_arg_lt</span><span> </span><span>wary_arg_u</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>arg_u_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arg u ≥<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ head u ≤≥<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_unary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>_</span><span> </span><span>gt_unary_u_t</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head u &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_u_t</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_u_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head u = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args u) ∪ set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt_trans_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ua ∈ ?S. ∀ta ∈ ?S. ∀sa ∈ ?S. ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta ⟶ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟶ ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>ta</span><span> </span><span>ua</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>          </span><span>ua_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sa_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ∈ ?S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>ua_gt_ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> ta"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ta_gt_sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_sa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary ta"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_ua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary ua"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_args</span><span> </span><span>ua_in</span><span> </span><span>ta_in</span><span> </span><span>sa_in</span><span> </span><span>wary_u</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ua &gt;<span class="hidden">⇩</span><sub>t</sub> sa"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>wary_ua</span><span> </span><span>wary_ta</span><span> </span><span>wary_sa</span><span> </span><span>ua_gt_ta</span><span> </span><span>ta_gt_sa</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ua_in</span><span> </span><span>ta_in</span><span> </span><span>sa_in</span><span> </span><span>Un_iff</span><span> </span><span>max.strict_coboundedI1</span><span> </span><span>max.strict_coboundedI2</span><span>
</span><span>               </span><span>size_in_args</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head u). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args u) (args s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>extf_trans_from_irrefl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>gt_trans_args</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_same_u_t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_same_t_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>wary_args</span><span> </span><span>wary_u</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>gt_irrefl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_u_ge_s</span><span> </span><span>hd_u_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_antisym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ wary t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ ¬ s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterm Property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_sub_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t) &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_wt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>δ_eq_ε</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = ε<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_App_ge_fun</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>wt_App_arg_δ<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>wt_δ<span class="hidden">⇩</span><sub>h</sub>_imp_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_tpoly_def</span><span> </span><span>ge_tpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s t) = head s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (App s t)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s t)) (args s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>δ_eq_ε</span><span> </span><span>extf_snoc_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_App_ge_fun</span><span> </span><span>hd_st</span><span> </span><span>extf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_proper_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t ⟹ proper_sub s t ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_sub_fun</span><span> </span><span>gt_sub_arg</span><span> </span><span>gt_trans</span><span> </span><span>sub.intros</span><span> </span><span>wary_sub</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility with Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_compat_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>t'_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s t' &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">;</span><span> </span><span>clarify</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s t') ≥<span class="hidden">⇩</span><sub>p</sub> wt (App s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_imp_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t'_gt_t</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>ge_tpoly_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">,</span><span>
</span><span>      </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ge_tpoly_def</span><span> </span><span>App_apps</span><span> </span><span>eval_ztpoly_nonneg</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ordered_comm_semiring_class.comm_mult_left_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args s @ [t']) (args s @ [t])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extf_compat_list</span><span> </span><span>gt_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s t')) (args (App s t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_fun_strong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>t'_gt_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apps s (t' # us) &gt;<span class="hidden">⇩</span><sub>t</sub> apps s (t # us)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t'_gt_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gt_compat_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>u</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>snoc</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?v'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"apps s (t' # us @ [u])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?v</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"apps s (t # us @ [u])"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt ?v' ≥<span class="hidden">⇩</span><sub>p</sub> wt ?v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_imp_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ih</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>App_apps</span><span> </span><span>apps_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ge_tpoly_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>zip_eq_butlast_last</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head ?v' = head ?v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head ?v'). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args ?v') (args ?v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>args_apps</span><span> </span><span>extf_compat_list</span><span> </span><span>gt_irrefl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_t</span><span class="delimiter">]</span><span> </span><span>t'_gt_t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility with Arguments›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_compat_arg_weak</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>wary_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App s t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App s' t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>coef_s'_0_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef s' 0 ≥<span class="hidden">⇩</span><sub>p</sub> coef s 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>s'_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' t &gt;<span class="hidden">⇩</span><sub>t</sub> App s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ζ</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = apps (Hd ζ) ss"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ζ'</span><span> </span><span>ss'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = apps (Hd ζ') ss'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_ss_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat (length ss) &lt; arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_st</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>less_le_trans</span><span> </span><span>min_ground_head_in_ground_heads</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>tm_collapse_apps</span><span> </span><span>tm_inject_apps</span><span> </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>δ_etc</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> + δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss) - 1) =
     δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>wary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (App (apps (Hd ζ) ss) t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ζ</span><span> </span><span>ss</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> &gt; 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat n = arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0_E</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat (length ss) &lt; arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>le_less_trans</span><span>
</span><span>        </span><span>min_ground_head_in_ground_heads</span><span> </span><span>not_le</span><span> </span><span>tm_collapse_apps</span><span> </span><span>tm_inject_apps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>of_nat_1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>of_nat_minus_hmset</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span>
</span><span>        </span><span>metis</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>mult_Suc_right</span><span> </span><span>of_nat_add</span><span> </span><span>of_nat_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>coef_ζ'_ge_ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coef_hd ζ' (length ss') ≥<span class="hidden">⇩</span><sub>p</sub> coef_hd ζ (length ss)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>coef_s'_0_ge_s</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_s'_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s' ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_imp_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s'_gt_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ζ_tms_len_ss_tms_wt_t_le</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eval_ztpoly A (coef_hd ζ (length ss)) * eval_ztpoly A (wt t)
     ≤ eval_ztpoly A (coef_hd ζ' (length ss')) * eval_ztpoly A (wt t)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>legal</span><span> </span><span>coef_ζ'_ge_ζ</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ge_tpoly_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_ztpoly_nonneg</span><span> </span><span>mult_right_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_s't_ge_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s' t) ≥<span class="hidden">⇩</span><sub>p</sub> wt (App s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>App_apps</span><span> </span><span>ge_tpoly_def</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ζ_tms_len_ss_tms_wt_t_le</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>add_le_imp_le_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfold</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>diff_diff_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>ac_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>δ_etc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_st</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>δ_etc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s't</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s'</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span>wt_s'_ge_s</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>ge_tpoly_def</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s'_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (App s' t) &gt;<span class="hidden">⇩</span><sub>p</sub> wt (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>App_apps</span><span> </span><span>gt_tpoly_def</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_less_le_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ζ_tms_len_ss_tms_wt_t_le</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>rule</span><span> </span><span>add_less_imp_less_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of δ<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>unfold</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>diff_diff_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>ac_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>        </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>δ_etc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_st</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>δ_etc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_s't</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s'</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>          </span><span>gt_wt_s'_s</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>gt_tpoly_def</span><span> </span><span>add_ac</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_unary</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>gt_unary_s'_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>hmset_of_enat_1</span><span> </span><span>leD</span><span> </span><span>of_nat_1</span><span>
</span><span>        </span><span>wary_AppE<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>wary_s't</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_diff_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_s't_ge_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_diff_s'_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_same_s'_s</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_s't</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (App s' t) = head (App s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_same_s'_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (App s' t)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (App s' t)) (args (App s t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_same_s'_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extf_compat_append_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_s't_ge_st</span><span> </span><span>hd_s't</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stability under Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>subst_zpassign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v ⇒ ('s, 'v) tm) ⇒ ('v pvar ⇒ zhmultiset) ⇒ 'v pvar ⇒ zhmultiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subst_zpassign ρ A (PWt x) =
   eval_ztpoly A (wt (ρ x)) - zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_zpassign ρ A (PCoef x i) = eval_ztpoly A (coef (ρ x) i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>legal_subst_zpassign</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_ρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign (subst_zpassign ρ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>legal_zpassign_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_zpassign ρ A v ≥ min_zpassign v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>PWt</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ζ</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ρx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ x = apps (Hd ζ) ss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ghd_ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_heads ζ ⊆ ground_heads_var x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ρ</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>wary_subst_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>ρx</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (wt_sym (min_ground_head (Var x)) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)))
      ≤ eval_ztpoly A (wt0 ζ) + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mgh_x_min</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (wt_sym (min_ground_head (Var x)) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)))
         ≤ zhmset_of (wt_sym (min_ground_head ζ) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zmset_of_le</span><span> </span><span>zhmset_of_le</span><span> </span><span>ghd_ζ</span><span> </span><span>min_ground_head_antimono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_mgh_le_wt0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (wt_sym (min_ground_head ζ)) ≤ eval_ztpoly A (wt0 ζ)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt0_ge_min_ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mgh_x_min</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_plus</span><span> </span><span>wt_mgh_le_wt0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt0 ζ)
      + zhmset_of ((δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss)))
        + of_nat (length ss) * δ<span class="hidden">⇩</span><sub>h</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ))
        ≤ zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (of_nat (length ss)
          + (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss))))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>le_minus_plus_same_hmset</span><span> </span><span>mult_le_mono2_hmset</span><span> </span><span>zhmset_of_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>distrib_left</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt0 ζ)
      + zhmset_of ((δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss)))
        + of_nat (length ss) * ε<span class="hidden">⇩</span><sub>h</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>δ<span class="hidden">⇩</span><sub>h</sub>_le_ε<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>zhmset_of_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ eval_ztpoly A (wt0 ζ)
      + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss))) + wt_args 0 A ζ ss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_args_ge_length_times_ε<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>zhmset_of_plus</span><span> </span><span>zhmset_of_times</span><span> </span><span>of_nat_zhmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_x_le_ζssts</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"zhmset_of (wt_sym (min_ground_head (Var x)) + δ<span class="hidden">⇩</span><sub>h</sub> * arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)))
       ≤ eval_ztpoly A (wt0 ζ)
         + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ζ) - of_nat (length ss)))
         + wt_args 0 A ζ ss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_x_le_ζssts</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>wt_args_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>ρx</span><span> </span><span>comp_def</span><span> </span><span>le_diff_eq</span><span> </span><span>add.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ZHMSet_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>zmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>hmsetmset_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zmset_of_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>PCoef</span><span> </span><span>x</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coef_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>zero_less_iff_1_le_hmset</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zhmset_of_1</span><span> </span><span>zero_less_iff_1_le_zhmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>legal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"legal_zpassign A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_ρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s ⟹ eval_ztpoly A (wt (subst ρ s)) = eval_ztpoly (subst_zpassign ρ A) (wt s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_induct_apps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ζ</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_ζss</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_nth_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; length ss ⟹ wary (ss ! i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_ζss</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ x"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tm_exhaust_apps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ρx</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>apps</span><span> </span><span>ξ</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_ρx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (ρ x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>coef_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. eval_tpoly A (zhmset_of_tpoly (coef_hd ξ (i + length ts))) =
        eval_tpoly (subst_zpassign ρ A) (zhmset_of_tpoly (coef_hd (Var x) i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ρx</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tedious_ary_arith</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x))
         + (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ) - (of_nat (length ss) + of_nat (length ts))) =
         arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ) - of_nat (length ts)
         + (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)) - of_nat (length ss))"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>δ_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat m = arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0_E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_gt_0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat n = arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arity_sym<span class="hidden">⇩</span><sub>h</sub>_if_δ<span class="hidden">⇩</span><sub>h</sub>_gt_0_E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>δ_gt_0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≥ length ss"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_nat_le_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ζss</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ζ</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wary_cases_apps<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span>
</span><span>            </span><span>metis</span><span> </span><span>arity_hd.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>enat_ile</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ground_heads_arity</span><span>
</span><span>              </span><span>hmset_of_enat_inject</span><span> </span><span>hmset_of_enat_of_nat</span><span> </span><span>le_trans</span><span> </span><span>m</span><span> </span><span>min_ground_head_in_ground_heads</span><span>
</span><span>              </span><span>of_nat_eq_enat</span><span> </span><span>of_nat_le_hmset_of_enat_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_ge_len_ss_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ length ss + length ts"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat (length ss) + of_nat (length ts) ≤ arity_hd<span class="hidden">⇩</span><sub>h</sub> ζ + of_nat (length ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ζss</span><span> </span><span>wary_cases_apps<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = arity_var<span class="hidden">⇩</span><sub>h</sub> x + of_nat (length ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ arity<span class="hidden">⇩</span><sub>h</sub> (ρ x) + of_nat (length ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = arity<span class="hidden">⇩</span><sub>h</sub> (apps (Hd ξ) ts) + of_nat (length ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ρx</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = arity_hd<span class="hidden">⇩</span><sub>h</sub> ξ"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_ρx</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ρx</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wary_cases_apps<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_hd ξ"</span></span></span><span class="delimiter">,</span><span>
</span><span>              </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>of_nat_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>of_nat_minus_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>              </span><span>metis</span><span> </span><span>δ_gt_0</span><span> </span><span>arity_hd_ne_infinity_if_δ_gt_0</span><span> </span><span>of_nat_0</span><span> </span><span>of_nat_less_hmset</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_heads_arity<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>min_ground_head_in_ground_heads</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_nat_le_hmset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ length ts"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_ge_len_ss_ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>of_nat_add</span><span> </span><span>of_nat_minus_hmset</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>of_nat_inject_hmset</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly A (zhmset_of_tpoly (wt (subst ρ (apps (Hd (Var x)) ss)))) =
        eval_tpoly A (zhmset_of_tpoly (wt0 ξ))
        + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)
          - (of_nat (length ts) + of_nat (length ss))))
        + wt_args 0 A ξ (ts @ map (subst ρ) ss)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>apps_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ρx</span><span> </span><span>wt_args_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = eval_tpoly A (zhmset_of_tpoly (wt0 ξ))
        + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)
          - (of_nat (length ts) + of_nat (length ss))))
        + wt_args 0 A ξ ts + wt_args (length ts) A ξ (map (subst ρ) ss)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>zip_append_0_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span>ts</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (subst ρ) ss"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = eval_tpoly A (zhmset_of_tpoly (wt0 ξ))
        + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head ξ)
          - (of_nat (length ts) + of_nat (length ss))))
        + wt_args 0 A ξ ts + wt_args 0 (subst_zpassign ρ A) (Var x) ss"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span> </span><span>nth_map_conv</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>coef_subst</span><span> </span><span>add.commute</span><span> </span><span>zhmset_of_times</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nth_mem</span><span> </span><span>wary_nth_ss</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = eval_tpoly (subst_zpassign ρ A) (zhmset_of_tpoly (wt0 (Var x)))
        + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> (min_ground_head (Var x)) - of_nat (length ss)))
        + wt_args 0 (subst_zpassign ρ A) (Var x) ss"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ρx</span><span> </span><span>wt_args_def</span><span> </span><span>comp_def</span><span> </span><span>algebra_simps</span><span> </span><span>ring_distribs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>              </span><span>zhmset_of_times</span><span> </span><span>zhmset_of_plus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zhmset_of_0</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>tedious_ary_arith</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = eval_tpoly (subst_zpassign ρ A) (zhmset_of_tpoly (wt (apps (Hd (Var x)) ss)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Sym</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly A (zhmset_of_tpoly (wt (subst ρ (apps (Hd (Sym f)) ss)))) =
      zhmset_of (wt_sym f) + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> f - of_nat (length ss)))
      + wt_args 0 A (Sym f) (map (subst ρ) ss)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = zhmset_of (wt_sym f) + zhmset_of (δ<span class="hidden">⇩</span><sub>h</sub> * (arity_sym<span class="hidden">⇩</span><sub>h</sub> f - of_nat (length ss)))
      + wt_args 0 (subst_zpassign ρ A) (Sym f) ss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_nth_ss</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span>
</span><span>        </span><span>nth_map_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = eval_tpoly (subst_zpassign ρ A) (zhmset_of_tpoly (wt (apps (Hd (Sym f)) ss)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wt_args_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wary_ρ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst ρ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t ⟹ wary s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). {#size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). wary t ⟶ wary s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. {#size ta, size sa#} &lt; {#size t, size s#} ⟹ wary ta ⟹ wary sa ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹
      subst ρ ta &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wary_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wary_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt_t_s</span><span class="delimiter">:</span><span> </span><span>gt_wt</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst ρ t) &gt;<span class="hidden">⇩</span><sub>p</sub> wt (subst ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_tpoly_def</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span> </span><span>wt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_ρ</span><span class="delimiter">]</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_wt_t_s</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>gt_tpoly_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">:</span><span> </span><span>legal_subst_zpassign</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_ρ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_ρt_ge_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst ρ t) ≥<span class="hidden">⇩</span><sub>p</sub> wt (subst ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ge_tpoly_def</span><span> </span><span>wary_s</span><span> </span><span>wary_t</span><span> </span><span>wt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_ρ</span><span class="delimiter">]</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wt_t_ge_s</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ge_tpoly_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">:</span><span> </span><span>legal_subst_zpassign</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_ρ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_unary</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_ρt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary (subst ρ t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wary_subst_wary</span><span> </span><span>wary_t</span><span> </span><span>wary_ρ</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Hd</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = arg t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wary_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary t2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = s"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ t2"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sub_arg</span><span> </span><span>wary_ρt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t2_ne_s</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t2_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst ρ t2 &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wary_t2</span><span> </span><span>wary_s</span><span> </span><span>t2_gt_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gt_sub_arg</span><span> </span><span>gt_trans</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>t</span><span> </span><span>wary_ρ</span><span> </span><span>wary_ρt</span><span> </span><span>wary_s</span><span> </span><span>wary_subst_wary</span><span>
</span><span>              </span><span>wary_t2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span>wary_subst_ground_heads</span><span> </span><span>gt_hd_def</span><span> </span><span>rev_subsetD</span><span> </span><span>wary_ρ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_ρt_ge_ρs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_ρt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (subst ρ t) = head (subst ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_s_eq_hd_t</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_in_grs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head (subst ρ t))"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf_args_s_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf</span><span> </span><span>f_in_grs</span><span> </span><span>wary_subst_ground_heads</span><span> </span><span>wary_ρ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (map (subst ρ) (args t)) (map (subst ρ) (args s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_map</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>extf_args_s_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ ?S. ¬ subst ρ x &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z ∈ ?S. ∀y ∈ ?S. ∀x ∈ ?S. subst ρ z &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ y ⟶ subst ρ y &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x ⟶
            subst ρ z &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ta ∈ ?S. ∀sa ∈ ?S. {#size ta, size sa#} &lt; {#size t, size s#}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ ?S. ∀x ∈ ?S. y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ subst ρ y &gt;<span class="hidden">⇩</span><sub>t</sub> subst ρ x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>sz_a</span><span> </span><span>size_in_args</span><span> </span><span>wary_t</span><span> </span><span>wary_s</span><span> </span><span>wary_args</span><span> </span><span>wary_ρ</span><span> </span><span>wary_subst_wary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (subst ρ t)) (args (subst ρ s))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extf_compat_append_left</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (subst ρ t)).
        extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (subst ρ t)) (args (subst ρ s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_ρt_ge_ρs</span><span> </span><span>hd_ρt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Totality on Ground Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_total_ground</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t &gt;<span class="hidden">⇩</span><sub>p</sub> wt s ∨ wt s &gt;<span class="hidden">⇩</span><sub>p</sub> wt t ∨ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_tpoly_def</span><span> </span><span>eq_tpoly_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>ground_eval_ztpoly_wt_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_t</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>undefined</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">)</span><span> </span><span>ground_eval_ztpoly_wt_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_s</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>undefined</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_total_ground</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extf_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f. ext_total (extf f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t ⟹ ground s ⟹ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). {# size t, size s #}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(t, s). ground t ⟶ ground s ⟶ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa. {# size ta, size sa #} &lt; {# size t, size s #} ⟹ ground ta ⟹ ground sa ⟹
      ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ∨ sa &gt;<span class="hidden">⇩</span><sub>t</sub> ta ∨ ta = sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ s &gt;<span class="hidden">⇩</span><sub>t</sub> t ∨ t = s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t &gt;<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s &gt;<span class="hidden">⇩</span><sub>p</sub> wt t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t =<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥<span class="hidden">⇩</span><sub>p</sub> wt s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_s_ge_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt s ≥<span class="hidden">⇩</span><sub>p</sub> wt t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_tpoly_def</span><span> </span><span>ge_tpoly_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ξ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = Sym g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_t</span><span class="delimiter">]</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ζ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head s = Sym f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ground_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_gt_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g &gt;<span class="hidden">⇩</span><sub>s</sub> f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_t_ge_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>g_gt_f</span><span> </span><span>gt_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_gt_g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f &gt;<span class="hidden">⇩</span><sub>s</sub> g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_s_ge_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>f_gt_g</span><span> </span><span>gt_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g_eq_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g = f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = head s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hd_s</span><span> </span><span class="delimiter">=</span><span> </span><span>hd_t</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"args s"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t ∈ set ?ts. ground t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>ground_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s ∈ set ?ss. ground s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_s</span><span> </span><span>ground_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ts = ?ss"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ts_eq_ss</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ξ</span><span> </span><span>ζ</span><span> </span><span>g_eq_f</span><span> </span><span>ts_eq_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tm_expand_apps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ts ?ss ∨ extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ss ?ts"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>gr_ss</span><span> </span><span>gr_ts</span><span> </span><span>less_multiset_doubletons</span><span>
</span><span>            </span><span>ext_total.total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>extf_total</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ?ts ∪ set ?ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub>)"</span></span></span><span> </span><span class="var">?ts</span><span> </span><span class="var">?ss</span><span> </span><span>g</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>Un_iff</span><span> </span><span>in_lists_iff_set</span><span> </span><span>size_in_args</span><span> </span><span>sup_ge2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ts ?ss"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_t_ge_s</span><span> </span><span>hd_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span> </span><span>ξ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>extf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf g (&gt;<span class="hidden">⇩</span><sub>t</sub>) ?ss ?ts"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt;<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wt_s_ge_t</span><span> </span><span>hd_s</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extf</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>g_eq_f</span><span class="delimiter">]</span><span> </span><span>ζ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_total_ground</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gr_t</span><span> </span><span>gr_s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-foundedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gtw</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub>) ≡ λt s. wary t ∧ wary s ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gtwg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) ≡ λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_gt_unary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ gt_unary t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gt_unary_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_unary t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>gt_imp_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ngr_t_or_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ground t ∨ ¬ ground s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_unary_t_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ground_head</span><span> </span><span>not_comp_hd_imp_Var</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_t</span><span> </span><span>gr_s</span><span> </span><span>ngr_t_or_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gt_wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ground_wfP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub> s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>bad_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ff</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"worst_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) (λt s. size t &gt; size s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span>min_passign</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wf_sz</span><span> </span><span class="delimiter">=</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wellorder_class.wf</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>size</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ffi_ground</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ground (?ff i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ffi_wary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. wary (?ff i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inf_chain_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) ?ff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>worst_chain_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bad_wt_diff_same</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ (gt_wt t s ∨ gt_diff t s ∨ gt_same t s)) ?ff"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span>ground_gt_unary</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground t ∧ gt_wt t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_tpoly ?A ∘ wt"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf_less_hmultiset</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_tpoly_def</span><span class="delimiter">,</span><span> </span><span>fold</span><span> </span><span>zhmset_of_less</span><span class="delimiter">,</span><span>
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>legal_min_zpassign</span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_tpoly_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_O_diff_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ gt_wt t s}
        O {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧  (gt_diff t s ∨ gt_same t s)}
      ⊆ {(s, t). ground t ∧ gt_wt t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ge_gt_tpoly_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_diff_same_as_union</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ (gt_wt t s ∨ gt_diff t s ∨ gt_same t s)} =
       {(s, t). ground t ∧ gt_wt t s}
       ∪ {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ (gt_diff t s ∨ gt_same t s)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_ge_tpoly_trans</span><span> </span><span>gt_tpoly_irrefl</span><span> </span><span>wt_ge_vars</span><span> </span><span>wt_total_ground</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_wt.simps</span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bad_diff_same</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ (gt_diff t s ∨ gt_same t s)) (λi. ?ff (i + k1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_infinite_down_chain_compatible</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_wt</span><span> </span><span>_</span><span> </span><span>wt_O_diff_same</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?ff</span><span class="delimiter">]</span><span> </span><span>bad_wt_diff_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>wt_diff_same_as_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground s ∧ ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_sym_wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_def</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_diff t s}
      ⊆ {(s, t). ground s ∧ ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gr_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gt_diff_t_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gt_diff t s"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>gr_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_iff_wt_unary_diff_same</span><span> </span><span>gt_imp_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym (head t) &gt;<span class="hidden">⇩</span><sub>s</sub> sym (head s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_diff_t_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gt_hd_def</span><span> </span><span>gr_s</span><span> </span><span>gr_t</span><span> </span><span>ground_hd_in_ground_heads</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_O_same</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_diff t s}
         O {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_same t s}
       ⊆ {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_diff t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gt_diff.simps</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ge_ge_tpoly_trans</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_tpoly_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff_same_as_union</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"{(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ (gt_diff t s ∨ gt_same t s)} =
       {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_diff t s}
       ∪ {(s, t). ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_same t s}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>bad_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (λt s. ground t ∧ wt t =<span class="hidden">⇩</span><sub>p</sub> wt s ∧ gt_same t s) (λi. ?ff (i + k2))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_infinite_down_chain_compatible</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_diff</span><span> </span><span>_</span><span> </span><span>diff_O_same</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. ?ff (i + k1)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>bad_diff_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>diff_same_as_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hd_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. is_Sym (head (?ff (i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = sym (head (?ff k2))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w = eval_tpoly ?A (wt (?ff k2))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (?ff (i + k2)) = Sym f ∧ eval_tpoly ?A (wt (?ff (i + k2))) = w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>w_def</span><span> </span><span>hd.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hd_sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>ia</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span>zhmset_of_inject</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_tpoly_def</span><span> </span><span>legal_min_zpassign</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hd_eq_f</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wt_eq_w</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>max_args</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"max_args = (if δ<span class="hidden">⇩</span><sub>h</sub> = 0 then sum_coefs w else the_enat (arity_sym f))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nargs_le_max_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"num_args (?ff (i + k2)) ≤ max_args"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ<span class="hidden">⇩</span><sub>h</sub> = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>δ_ne_0</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ary_f_ne_inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arity_sym f ≠ ∞"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arity_sym_ne_infinity_if_δ_gt_0</span><span> </span><span>of_nat_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat (num_args (worst_chain (λt s. ground t ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s) (λt s. size s &lt; size t) (i + k2))) ≤ arity_sym f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_num_args_le_arity_head</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ffi_wary</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + k2"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_eq_f</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>δ_ne_0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>enat_ord_simps</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_args_def</span><span>  </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>enat_the_enat_iden</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ary_f_ne_inf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>δ_eq_0</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_coefs_ge_num_args_if_δ<span class="hidden">⇩</span><sub>h</sub>_eq_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>legal_min_passign</span><span> </span><span>δ_eq_0</span><span> </span><span>ffi_wary</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + k2"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_args_def</span><span> </span><span>δ_eq_0</span><span> </span><span>wt_eq_w</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U_of</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. set (args (?ff (i + k2)))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = (⋃i. ?U_of i)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ground u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ground_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ffi_ground</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wary_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ wary u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wary_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ffi_wary</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>u_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ ?U_of i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size u &lt; size (?ff (i + k2))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_in_args</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u_in</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + k2"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2 - 1) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> ?ff (i + k2)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>worst_chain_pred</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>t_bad</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt</span><span> </span><span>gt_proper_sub</span><span> </span><span>sub_args</span><span> </span><span>sz_u</span><span> </span><span>u_in</span><span> </span><span>wary_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ff (i + k2 - 1) &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>sz_u</span><span> </span><span>min_worst_chain_Suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_sz</span><span> </span><span>u_bad</span><span class="delimiter">]</span><span> </span><span>ffi_ground</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>u_good</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. u ∈ U ⟹ ¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gtwu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt s. t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gtwu_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ¬ ?gtwu x x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i j. ∀t ∈ set (args (?ff (i + k2))). ∀s ∈ set (args (?ff (j + k2))). t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶
      t ∈ U ∧ t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wary_u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>U_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (?ff (i + k2))) (args (?ff (Suc i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_same</span><span> </span><span>hd_eq_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>gt_same.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. extf f ?gtwu (args (?ff (i + k2))) (args (?ff (Suc i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_mono_strong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain (extf f ?gtwu) (λi. args (?ff (i + k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nwf_ext</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"¬ wfP (λxs ys. length ys ≤ max_args ∧ length xs ≤ max_args ∧ extf f ?gtwu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span>wfP_def</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nargs_le_max_args</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gtwu_le_gtwg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?gtwu ≤ (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gr_u</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?gtwu t s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_iff_no_inf_chain</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bad_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf_chain ?gtwu f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bad_f0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bad ?gtwu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inf_chain_bad</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f 0 ∈ U"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inf_chain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad (&gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub>) (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_good</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bad ?gtwu (f 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f</span><span> </span><span>inf_chain_bad</span><span> </span><span>inf_chain_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>gtwu_le_gtwg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad_f0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λxs ys. length ys ≤ max_args ∧ length xs ≤ max_args ∧ extf f ?gtwu ys xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf_wf_bounded</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?gtwu</span><span class="delimiter">]</span><span> </span><span>gtwu_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nwf_ext</span><span> </span><span>wf_ext</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?subst</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst grounding_ρ"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>g</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfP_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ground_wfP</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λs t. ?subst t &gt;<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>w</sub> ?subst s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_grounding_ρ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wfP_subset</span><span> </span><span>wary_subst_wary</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_grounding_ρ</span><span class="delimiter">]</span><span> </span><span>gt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wary_grounding_ρ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Encoding_KBO">
<div class="head"><h1>Theory Lambda_Encoding_KBO</h1>
<span class="command">theory</span> <span class="name">Lambda_Encoding_KBO</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Encoding.html"><span class="name">Lambda_Encoding</span></a> <a href="Lambda_Free_KBO_Basic.html"><span class="name">Lambda_Free_KBO_Basic</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Properties of Lambda-Free KBO on the Lambda Encoding
    Author:      Jasmin Blanchette &lt;j.c.blanchette at vu.nl&gt;, 2019
    Maintainer:  Jasmin Blanchette &lt;j.c.blanchette at vu.nl&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of Lambda-Free KBO on the Lambda Encoding›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Encoding_KBO</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_RPOs.Lambda_Encoding</span><span> </span><span>Lambda_Free_KBO_Basic</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory explores the properties of the ‹λ›-free KBO on the proposed encoding of ‹λ›-expressions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo_lambda_encoding</span><span> </span><span class="delimiter">=</span><span> </span><span>kbo_basic</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_ :: 'v. UNIV :: 's set"</span></span></span><span> </span><span class="delimiter">+</span><span> </span><span>lambda_encoding</span><span> </span><span>lam</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>lam</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>gt_db_db</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &gt; i ⟹ db j &gt;<span class="hidden">⇩</span><sub>s</sub> db i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wt_db_db</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt_sym (db j) = wt_sym (db i)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>gt</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>gt_hd</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm ⇒ ('s, 'v) tm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≥<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ≥<span class="hidden">⇩</span><sub>t</sub> s ≡ t &gt;<span class="hidden">⇩</span><sub>t</sub> s ∨ t = s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wary_raw_db_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wary_subst (raw_db_subst i x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wary_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>arity_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wt_subst_db</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (subst_db i x s) = wt (subst (raw_db_subst j x) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>raw_db_subst_def</span><span> </span><span>wt_db_db</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>hd.splits</span><span class="delimiter">,</span><span>
</span><span>      </span><span>metis</span><span> </span><span>lambda_encoding.subst_db.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subst.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wt.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_db_Suc_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_db (Suc i) x s ≥<span class="hidden">⇩</span><sub>t</sub> subst_db i x s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hd</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wt_db_db</span><span> </span><span>gt_db_db</span><span> </span><span>gt_sym_imp_hd</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>App.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>App.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>gt_compat_arg</span><span> </span><span>gt_compat_fun</span><span> </span><span>gt_trans</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gt_subst_db</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟹ subst_db i x t &gt;<span class="hidden">⇩</span><sub>t</sub> subst_db i x s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>atomize_imp</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t, s, i). {#size t, size s#}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ(t, s, i). t &gt;<span class="hidden">⇩</span><sub>t</sub> s ⟶ subst_db i x t &gt;<span class="hidden">⇩</span><sub>t</sub> subst_db i x s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, s, i)"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span> </span><span>prod.case</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split_paired_all</span><span> </span><span>prod.case</span><span> </span><span>atomize_imp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>atomize_all</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'v) tm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ta sa i. {#size ta, size sa#} &lt; {#size t, size s#} ⟹ ta &gt;<span class="hidden">⇩</span><sub>t</sub> sa ⟹
      subst_db i x ta &gt;<span class="hidden">⇩</span><sub>t</sub> subst_db i x sa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>t_gt_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t &gt;<span class="hidden">⇩</span><sub>t</sub> s"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ρ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_db i x"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ρ t &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (?ρ t) = wt (?ρ s)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wt_ρt_ne_ρs</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset t ⊇# vars_mset s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt.cases</span><span> </span><span>t_gt_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (?ρ t) ⊇# vars_mset (?ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>var_mset_subst_db_subseteq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt_t_ge_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wt t ≥ wt s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.strict_implies_order</span><span> </span><span>eq_imp_le</span><span> </span><span>gt.cases</span><span> </span><span>t_gt_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wt (?ρ t) &gt; wt (?ρ s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ρt_ne_ρs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wt_subst_db</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>gt.simps</span><span> </span><span>gt_subst</span><span> </span><span>t_gt_s</span><span> </span><span>wary_raw_db_subst</span><span> </span><span>wt_subst_db</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_wt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wt_ρt_eq_ρs</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_gt_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt_wt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wt_ρt_eq_ρs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_less_le_mono</span><span> </span><span>kbo_std.extra_wt_subseteq</span><span> </span><span>nat_less_le</span><span> </span><span>wary_raw_db_subst</span><span> </span><span>wt_subst</span><span>
</span><span>            </span><span>wt_subst_db</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_diff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vars_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (?ρ t) ⊇# vars_mset (?ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>var_mset_subst_db_subseteq</span><span> </span><span>vars_s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>gt_hd</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head (?ρ t) &gt;<span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>d</sub> head (?ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Set.set_insert</span><span> </span><span>gt_hd_def</span><span> </span><span>hd_t_gt_hd_s</span><span> </span><span>head_subst_db</span><span> </span><span>insert_subset</span><span> </span><span>wary_raw_db_subst</span><span>
</span><span>            </span><span>wary_subst_ground_heads</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_diff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span> </span><span>wt_ρt_eq_ρs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>_</span><span class="delimiter">:</span><span> </span><span>gt_same</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vars_s</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_mset (?ρ t) ⊇# vars_mset (?ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>var_mset_subst_db_subseteq</span><span> </span><span>vars_s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_ρt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head (?ρ t) = head (?ρ s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span>head_subst_db</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f_in_grs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ground_heads (head (?ρ s))"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ρa</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_db (if head s = Sym lam then i + 1 else i) x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (args t) ∪ set (args s)"</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extf_args_s_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args t) (args s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extf</span><span> </span><span>f_in_grs</span><span> </span><span>hd_s_eq_hd_t</span><span> </span><span>head_subst_db</span><span> </span><span>wary_raw_db_subst</span><span> </span><span>wary_subst_ground_heads</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>insert_subset</span><span> </span><span>mk_disjoint_insert</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (map ?ρa (args t)) (map ?ρa (args s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extf_map</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>extf_args_s_t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ ?S. ¬ ?ρa x &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρa x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z ∈ ?S. ∀y ∈ ?S. ∀x ∈ ?S. ?ρa z &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρa y ⟶ ?ρa y &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρa x ⟶ ?ρa z &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρa x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gt_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sz_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ta ∈ ?S. ∀sa ∈ ?S. {#size ta, size sa#} &lt; {#size t, size s#}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_lt_imp_lt_mset</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>size_in_args</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ ?S. ∀x ∈ ?S. y &gt;<span class="hidden">⇩</span><sub>t</sub> x ⟶ ?ρa y &gt;<span class="hidden">⇩</span><sub>t</sub> ?ρa x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>sz_a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (?ρ t)) (args (?ρ s))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>args_subst_db</span><span> </span><span>hd_s_eq_hd_t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f ∈ ground_heads (head (?ρ s)). extf f (&gt;<span class="hidden">⇩</span><sub>t</sub>) (args (?ρ t)) (args (?ρ s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gt_same</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_ρs</span><span> </span><span>wt_ρt_eq_ρs</span><span> </span><span>hd_ρt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lambda_Free_KBOs">
<div class="head"><h1>Theory Lambda_Free_KBOs</h1>
<span class="command">theory</span> <span class="name">Lambda_Free_KBOs</span><br/>
<span class="keyword">imports</span> <a href="Lambda_Free_KBO_App.html"><span class="name">Lambda_Free_KBO_App</span></a> <a href="Lambda_Free_TKBO_Coefs.html"><span class="name">Lambda_Free_TKBO_Coefs</span></a> <a href="Lambda_Encoding_KBO.html"><span class="name">Lambda_Encoding_KBO</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Knuth-Bendix Orders for Lambda-Free Higher-Order Terms
    Author:      Heiko Becker &lt;heikobecker92@gmail.com&gt;, 2016
    Author:      Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;, 2016
    Author:      Uwe Waldmann &lt;waldmann at mpi-inf.mpg.de&gt;, 2016
    Author:      Daniel Wand &lt;dwand at mpi-inf.mpg.de&gt;, 2016
    Maintainer:  Jasmin Blanchette &lt;jasmin.blanchette at inria.fr&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Knuth--Bendix Orders for Lambda-Free Higher-Order Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lambda_Free_KBOs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lambda_Free_KBO_App</span><span> </span><span>Lambda_Free_KBO_Basic</span><span> </span><span>Lambda_Free_TKBO_Coefs</span><span> </span><span>Lambda_Encoding_KBO</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>simple_kbo_instances</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arity_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity_sym n = ∞"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arity_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ enat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"arity_var n = ∞"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ground_head_var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground_head_var x = UNIV"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gt_sym g f ⟷ g &gt; f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ε</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ε = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"δ = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wt_sym</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt_sym n = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wt_sym<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wt_sym<span class="hidden">⇩</span><sub>h</sub> n = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>coef_sym<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ hmultiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"coef_sym<span class="hidden">⇩</span><sub>h</sub> n i = 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kbo_app</span><span class="delimiter">:</span><span> </span><span>kbo_app</span><span> </span><span>gt_sym</span><span> </span><span>wt_sym</span><span> </span><span>ε</span><span> </span><span>len_lexext</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gt_sym_def</span><span> </span><span>ε_def</span><span> </span><span>wt_sym_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wf_less</span><span class="delimiter">[</span><span>folded</span><span> </span><span>wfP_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kbo_basic</span><span class="delimiter">:</span><span> </span><span>kbo_basic</span><span> </span><span>gt_sym</span><span> </span><span>wt_sym</span><span> </span><span>ε</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. len_lexext"</span></span></span><span> </span><span>ground_head_var</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ground_head_var_def</span><span> </span><span>gt_sym_def</span><span> </span><span>ε_def</span><span> </span><span>wt_sym_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kbo_std</span><span class="delimiter">:</span><span> </span><span>kbo_std</span><span> </span><span>ground_head_var</span><span> </span><span>gt_sym</span><span> </span><span>ε</span><span> </span><span>δ</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. len_lexext"</span></span></span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span> </span><span>wt_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arity_sym_def</span><span> </span><span>arity_var_def</span><span> </span><span>ground_head_var_def</span><span> </span><span>ε_def</span><span> </span><span>δ_def</span><span> </span><span>wt_sym_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>tkbo_coefs</span><span class="delimiter">:</span><span> </span><span>tkbo_coefs</span><span> </span><span>ground_head_var</span><span> </span><span>gt_sym</span><span> </span><span>ε</span><span> </span><span>δ</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. len_lexext"</span></span></span><span> </span><span>arity_sym</span><span> </span><span>arity_var</span><span>
</span><span>    </span><span>wt_sym<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>coef_sym<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ε_def</span><span> </span><span>δ_def</span><span> </span><span>wt_sym<span class="hidden">⇩</span><sub>h</sub>_def</span><span> </span><span>coef_sym<span class="hidden">⇩</span><sub>h</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>