<div id="C_Lexer_Language">
<div class="head"><h1>Theory C_Lexer_Language</h1>
<span class="command">theory</span> <span class="name">C_Lexer_Language</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCore Language: Lexing Support, with Filtered Annotations (without Annotation Lexing)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Lexer_Language</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
The part implementing the C lexer might resemble to the implementation of the ML one, but the C
syntax is much complex: for example, the preprocessing of directives is implemented with several
parsing layers. Also, we will see that the way antiquotations are handled in C is slightly different
than in ML (especially in the execution part).

Overall, the next ML structures presented here in this theory are all aligned with
üóè‚Äπ~~/src/Pure/ROOT.ML‚Ä∫, and are thus accordingly sorted in the same order
(except for üóè‚Äπ~~/src/Pure/ML/ml_options.ML‚Ä∫ which is early included in the boot
process).

This theory will stop at üóè‚Äπ~~/src/Pure/ML/ml_lex.ML‚Ä∫. It is basically situated
in the phase 1 of the bootstrap process (of üóè‚Äπ~~/src/Pure/ROOT.ML‚Ä∫), i.e., the
part dealing with how to get some C tokens from a raw string:
\&lt;^ML_text&gt;‚ÄπPosition.T -&gt; string -&gt; token list‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/General/scan.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Scan =
struct
datatype ('a, 'b) either = Left of 'a | Right of 'b

fun opt x = Scan.optional x [];
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/General/symbol.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/General/symbol.ML
    Author:     Makarius

Generalized characters with infinitely many named symbols.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Symbol =
struct
fun is_ascii_quasi "_" = true
  | is_ascii_quasi "$" = true
  | is_ascii_quasi _ = false;

fun is_identletter s =
  Symbol.is_ascii_letter s orelse is_ascii_quasi s

fun is_ascii_oct s =
  Symbol.is_char s andalso Char.ord #"0" &lt;= ord s andalso ord s &lt;= Char.ord #"7";

fun is_ascii_digit1 s =
  Symbol.is_char s andalso Char.ord #"1" &lt;= ord s andalso ord s &lt;= Char.ord #"9";

fun is_ascii_letdig s =
  Symbol.is_ascii_letter s orelse Symbol.is_ascii_digit s orelse is_ascii_quasi s;

fun is_ascii_identifier s =
  size s &gt; 0 andalso forall_string is_ascii_letdig s;

val is_ascii_blank_no_line =
  fn " " =&gt; true | "\t" =&gt; true | "\^K" =&gt; true | "\f" =&gt; true
    | _ =&gt; false;
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/General/position.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Position =
struct
type reports_text = Position.report_text list
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/General/symbol_pos.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/General/symbol_pos.ML
    Author:     Makarius

Symbols with explicit position information.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Basic_Symbol_Pos =   (*not open by default*)
struct
open Basic_Symbol_Pos;

fun one f = Scan.one (f o Symbol_Pos.symbol)
fun many f = Scan.many (f o Symbol_Pos.symbol)
fun many1 f = Scan.many1 (f o Symbol_Pos.symbol)
val one' = Scan.single o one
fun scan_full !!! mem msg scan =
  scan --| (Scan.ahead (one' (not o mem)) || !!! msg Scan.fail)
fun this_string s =
  (fold (fn s0 =&gt; uncurry (fn acc =&gt; one (fn s1 =&gt; s0 = s1) &gt;&gt; (fn x =&gt; x :: acc)))
        (Symbol.explode s)
   o pair [])
  &gt;&gt; rev
val one_not_eof = Scan.one (Symbol.not_eof o #1)
fun unless_eof scan = Scan.unless scan one_not_eof &gt;&gt; single
val repeats_one_not_eof = Scan.repeats o unless_eof
val newline =   $$$ "\n"
             || $$$ "\^M" @@@ $$$ "\n"
             || $$$ "\^M"
val repeats_until_nl = repeats_one_not_eof newline
end

structure C_Symbol_Pos =
struct

(* basic scanners *)

val !!! = Symbol_Pos.!!!

fun !!!! text scan =
  let
    fun get_pos [] = " (end-of-input)"
      | get_pos ((_, pos) :: _) = Position.here pos;

    fun err ((_, syms), msg) = fn () =&gt;
      text () ^ get_pos syms ^
      Markup.markup Markup.no_report (" at " ^ Symbol.beginning 10 (map Symbol_Pos.symbol syms)) ^
      (case msg of NONE =&gt; "" | SOME m =&gt; "\n" ^ m ());
  in Scan.!! err scan end;

val $$ = Symbol_Pos.$$

val $$$ = Symbol_Pos.$$$

val ~$$$ = Symbol_Pos.~$$$


(* scan string literals *)

local

val char_code =
  Scan.one (Symbol.is_ascii_digit o Symbol_Pos.symbol) --
  Scan.one (Symbol.is_ascii_digit o Symbol_Pos.symbol) --
  Scan.one (Symbol.is_ascii_digit o Symbol_Pos.symbol) :|--
  (fn (((a, pos), (b, _)), (c, _)) =&gt;
    let val (n, _) = Library.read_int [a, b, c]
    in if n &lt;= 255 then Scan.succeed [(chr n, pos)] else Scan.fail end);

fun scan_str q err_prefix stop =
  $$$ "\\" |-- !!! (fn () =&gt; err_prefix ^ "bad escape character in string")
    ($$$ q || $$$ "\\" || char_code) ||
  Scan.unless stop
              (Scan.one (fn (s, _) =&gt; s &lt;&gt; q andalso s &lt;&gt; "\\" andalso Symbol.not_eof s)) &gt;&gt; single;

fun scan_strs q err_prefix err_suffix stop =
  Scan.ahead ($$ q) |--
    !!! (fn () =&gt; err_prefix ^ "unclosed string literal within " ^ err_suffix)
      ((Symbol_Pos.scan_pos --| $$$ q)
       -- (Scan.repeats (scan_str q err_prefix stop) -- ($$$ q |-- Symbol_Pos.scan_pos)));

in

fun scan_string_qq_multi err_prefix stop = scan_strs "\"" err_prefix "the comment delimiter" stop;
fun scan_string_bq_multi err_prefix stop = scan_strs "`" err_prefix "the comment delimiter" stop;
fun scan_string_qq_inline err_prefix =
  scan_strs "\"" err_prefix "the same line" C_Basic_Symbol_Pos.newline;
fun scan_string_bq_inline err_prefix =
  scan_strs "`" err_prefix "the same line" C_Basic_Symbol_Pos.newline;

end;


(* nested text cartouches *)

fun scan_cartouche_depth stop =
  Scan.repeat1 (Scan.depend (fn (depth: int option) =&gt;
    (case depth of
      SOME d =&gt;
        $$ Symbol.open_ &gt;&gt; pair (SOME (d + 1)) ||
          (if d &gt; 0 then
            Scan.unless stop
                        (Scan.one (fn (s, _) =&gt; s &lt;&gt; Symbol.close andalso Symbol.not_eof s))
            &gt;&gt; pair depth ||
            $$ Symbol.close &gt;&gt; pair (if d = 1 then NONE else SOME (d - 1))
          else Scan.fail)
    | NONE =&gt; Scan.fail)));

fun scan_cartouche err_prefix err_suffix stop =
  Scan.ahead ($$ Symbol.open_) |--
    !!! (fn () =&gt; err_prefix ^ "unclosed text cartouche within " ^ err_suffix)
      (Scan.provide is_none (SOME 0) (scan_cartouche_depth stop));

fun scan_cartouche_multi err_prefix stop =
  scan_cartouche err_prefix "the comment delimiter" stop;
fun scan_cartouche_inline err_prefix =
  scan_cartouche err_prefix "the same line" C_Basic_Symbol_Pos.newline;


(* C-style comments *)

local
val par_l = "/"
val par_r = "/"

val scan_body1 = $$$ "*" --| Scan.ahead (~$$$ par_r)
val scan_body2 = Scan.one (fn (s, _) =&gt; s &lt;&gt; "*" andalso Symbol.not_eof s) &gt;&gt; single
val scan_cmt =
  Scan.depend (fn (d: int) =&gt; $$$ par_l @@@ $$$ "*" &gt;&gt; pair (d + 1)) ||
  Scan.depend (fn 0 =&gt; Scan.fail | d =&gt; $$$ "*" @@@ $$$ par_r &gt;&gt; pair (d - 1)) ||
  Scan.lift scan_body1 ||
  Scan.lift scan_body2;

val scan_cmts = Scan.pass 0 (Scan.repeats scan_cmt);

in

fun scan_comment err_prefix =
  Scan.ahead ($$ par_l -- $$ "*") |--
    !!! (fn () =&gt; err_prefix ^ "unclosed comment")
      ($$$ par_l @@@ $$$ "*" @@@ scan_cmts @@@ $$$ "*" @@@ $$$ par_r)
  || $$$ "/" @@@ $$$ "/" @@@ C_Basic_Symbol_Pos.repeats_until_nl;

fun scan_comment_no_nest err_prefix =
  Scan.ahead ($$ par_l -- $$ "*") |--
    !!! (fn () =&gt; err_prefix ^ "unclosed comment")
      ($$$ par_l @@@ $$$ "*" @@@ Scan.repeats (scan_body1 || scan_body2) @@@ $$$ "*" @@@ $$$ par_r)
  || $$$ "/" @@@ $$$ "/" @@@ C_Basic_Symbol_Pos.repeats_until_nl;

val recover_comment =
  $$$ par_l @@@ $$$ "*" @@@ Scan.repeats (scan_body1 || scan_body2);

end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/General/antiquote.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/General/antiquote.ML
    Author:     Makarius

Antiquotations within plain text.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Antiquote =
struct

(* datatype antiquote *)

type antiq = { explicit: bool
             , start: Position.T
             , stop: Position.T option
             , range: Position.range
             , body: Symbol_Pos.T list
             , body_begin: Symbol_Pos.T list
             , body_end: Symbol_Pos.T list }

(* scan *)

open C_Basic_Symbol_Pos;

local

val err_prefix = "Antiquotation lexical error: ";

val par_l = "/"
val par_r = "/"

val scan_body1 = $$$ "*" --| Scan.ahead (~$$$ par_r)
val scan_body1' = $$$ "*" @@@ $$$ par_r
val scan_body2 = Scan.one (fn (s, _) =&gt; s &lt;&gt; "*" andalso Symbol.not_eof s) &gt;&gt; single

val scan_antiq_body_multi =
  Scan.trace (C_Symbol_Pos.scan_string_qq_multi err_prefix scan_body1' ||
              C_Symbol_Pos.scan_string_bq_multi err_prefix scan_body1') &gt;&gt; #2 ||
  C_Symbol_Pos.scan_cartouche_multi err_prefix scan_body1' ||
  scan_body1 ||
  scan_body2;

val scan_antiq_body_multi_recover =
  scan_body1 ||
  scan_body2;

val scan_antiq_body_inline =
  Scan.trace (C_Symbol_Pos.scan_string_qq_inline err_prefix ||
              C_Symbol_Pos.scan_string_bq_inline err_prefix) &gt;&gt; #2 ||
  C_Symbol_Pos.scan_cartouche_inline err_prefix ||
  unless_eof newline;

val scan_antiq_body_inline_recover =
  unless_eof newline;

fun control_name sym = (case Symbol.decode sym of Symbol.Control name =&gt; name);

fun scan_antiq_multi scan =
  Symbol_Pos.scan_pos
  -- (Scan.trace ($$ par_l |-- $$ "*" |-- scan)
      -- Symbol_Pos.scan_pos
      -- Symbol_Pos.!!! (fn () =&gt; err_prefix ^ "missing closing antiquotation")
                        (Scan.repeats scan_antiq_body_multi
                         -- Symbol_Pos.scan_pos
                         -- ($$$ "*" @@@ $$$ par_r)
                         -- Symbol_Pos.scan_pos))

fun scan_antiq_multi_recover scan =
  Symbol_Pos.scan_pos
  -- ($$ par_l |-- $$ "*" |-- scan -- Symbol_Pos.scan_pos --
      (Scan.repeats scan_antiq_body_multi_recover
       -- Symbol_Pos.scan_pos -- ($$ "*" |-- $$ par_r |-- Symbol_Pos.scan_pos)))

fun scan_antiq_inline scan =
  (Symbol_Pos.scan_pos -- Scan.trace ($$ "/" |-- $$ "/" |-- scan)
  -- Symbol_Pos.scan_pos
  -- Scan.repeats scan_antiq_body_inline -- Symbol_Pos.scan_pos)

fun scan_antiq_inline_recover scan =
  (Symbol_Pos.scan_pos --| $$ "/" --| $$ "/" -- scan
  -- Symbol_Pos.scan_pos
  -- Scan.repeats scan_antiq_body_inline_recover -- Symbol_Pos.scan_pos)

in

val scan_control =
  Scan.option (Scan.one (Symbol.is_control o Symbol_Pos.symbol)) --
  Symbol_Pos.scan_cartouche err_prefix &gt;&gt;
    (fn (opt_control, body) =&gt;
      let
        val (name, range) =
          (case opt_control of
            SOME (sym, pos) =&gt; ((control_name sym, pos), Symbol_Pos.range ((sym, pos) :: body))
          | NONE =&gt; (("cartouche", #2 (hd body)), Symbol_Pos.range body));
      in {name = name, range = range, body = body} end) ||
  Scan.one (Symbol.is_control o Symbol_Pos.symbol) &gt;&gt;
    (fn (sym, pos) =&gt;
      {name = (control_name sym, pos), range = Symbol_Pos.range [(sym, pos)], body = []});

val scan_antiq =
  scan_antiq_multi ($$$ "@" &gt;&gt; K true || scan_body1 &gt;&gt; K false)
  &gt;&gt; (fn (pos1, (((explicit, body_begin), pos2), (((body, pos3), body_end), pos4))) =&gt;
      {explicit = explicit,
       start = Position.range_position (pos1, pos2),
       stop = SOME (Position.range_position (pos3, pos4)),
       range = Position.range (pos1, pos4),
       body = body,
       body_begin = body_begin,
       body_end = body_end}) ||
  scan_antiq_inline ($$$ "@" &gt;&gt; K true || $$$ "*" &gt;&gt; K false)
  &gt;&gt; (fn ((((pos1, (explicit, body_begin)), pos2), body), pos3) =&gt; 
      {explicit = explicit,
       start = Position.range_position (pos1, pos2),
       stop = NONE,
       range = Position.range (pos1, pos3),
       body = body,
       body_begin = body_begin,
       body_end = []})

val scan_antiq_recover =
  scan_antiq_multi_recover ($$$ "@" &gt;&gt; K true || scan_body1 &gt;&gt; K false)
    &gt;&gt; (fn (_, ((explicit, _), _)) =&gt; explicit)
  ||
  scan_antiq_inline_recover ($$$ "@" &gt;&gt; K true || $$$ "*" &gt;&gt; K false)
   &gt;&gt; (fn ((((_, explicit), _), _), _) =&gt; explicit)

end;

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_options.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/ML/ml_options.ML
    Author:     Makarius

ML configuration options.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Options =
struct

(* source trace *)

val lexer_trace = Attrib.setup_config_bool @{binding C_lexer_trace} (K false);
val parser_trace = Attrib.setup_config_bool @{binding C_parser_trace} (K false);
val ML_verbose = Attrib.setup_config_bool @{binding C_ML_verbose} (K true);
val starting_env = Attrib.setup_config_string @{binding C_starting_env} (K "empty");
val starting_rule = Attrib.setup_config_string @{binding C_starting_rule} (K "translation_unit");

end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_lex.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/ML/ml_lex.ML
    Author:     Makarius

Lexical syntax for Isabelle/ML and Standard ML.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Lex =
struct

open C_Scan;
open C_Basic_Symbol_Pos;


(** keywords **)

val keywords =
 ["(",
  ")",
  "[",
  "]",
  "-&gt;",
  ".",
  "!",
  "~",
  "++",
  "--",
  "+",
  "-",
  "*",
  "/",
  "%",
  "&amp;",
  "&lt;&lt;",
  "&gt;&gt;",
  "&lt;",
  "&lt;=",
  "&gt;",
  "&gt;=",
  "==",
  "!=",
  "^",
  "|",
  "&amp;&amp;",
  "||",
  "?",
  ":",
  "=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "&amp;=",
  "^=",
  "|=",
  "&lt;&lt;=",
  "&gt;&gt;=",
  ",",
  ";",
  "{",
  "}",
  "...",
  (**)
  "_Alignas",
  "_Alignof",
  "__alignof",
  "alignof",
  "__alignof__",
  "__asm",
  "asm",
  "__asm__",
  "_Atomic",
  "__attribute",
  "__attribute__",
  "auto",
  "_Bool",
  "break",
  "__builtin_offsetof",
  "__builtin_types_compatible_p",
  "__builtin_va_arg",
  "case",
  "char",
  "_Complex",
  "__complex__",
  "__const",
  "const",
  "__const__",
  "continue",
  "default",
  "do",
  "double",
  "else",
  "enum",
  "__extension__",
  "extern",
  "float",
  "for",
  "_Generic",
  "goto",
  "if",
  "__imag",
  "__imag__",
  "__inline",
  "inline",
  "__inline__",
  "int",
  "__int128",
  "__label__",
  "long",
  "_Nonnull",
  "__nonnull",
  "_Noreturn",
  "_Nullable",
  "__nullable",
  "__real",
  "__real__",
  "register",
  "__restrict",
  "restrict",
  "__restrict__",
  "return",
  "short",
  "__signed",
  "signed",
  "__signed__",
  "sizeof",
  "static",
  "_Static_assert",
  "struct",
  "switch",
  "__thread",
  "_Thread_local",
  "typedef",
  "__typeof",
  "typeof",
  "__typeof__",
  "union",
  "unsigned",
  "void",
  "__volatile",
  "volatile",
  "__volatile__",
  "while"];

val keywords2 =
 ["__asm",
  "asm",
  "__asm__",
  "extern"];

val keywords3 =
 ["_Bool",
  "char",
  "double",
  "float",
  "int",
  "__int128",
  "long",
  "short",
  "__signed",
  "signed",
  "__signed__",
  "unsigned",
  "void"];

val lexicon = Scan.make_lexicon (map raw_explode keywords);



(** tokens **)

(* datatype token *)

datatype token_kind_comment =
   Comment_formal of C_Antiquote.antiq
 | Comment_suspicious of (bool * string * ((Position.T * Markup.T) * string) list) option

datatype token_kind_encoding =
   Encoding_L
 | Encoding_default
 | Encoding_file of string (* error message *) option

type token_kind_string =
  token_kind_encoding
  * (Symbol.symbol, Position.range * int ‚Äï ‚Äπexceeding \&lt;^ML&gt;‚ÄπChar.maxOrd‚Ä∫‚Ä∫) either list

datatype token_kind_int_repr = Repr_decimal
                             | Repr_hexadecimal
                             | Repr_octal

datatype token_kind_int_flag = Flag_unsigned
                             | Flag_long
                             | Flag_long_long
                             | Flag_imag

datatype token_kind =
  Keyword | Ident | Type_ident | GnuC | ClangC |
  (**)
  Char of token_kind_string |
  Integer of int * token_kind_int_repr * token_kind_int_flag list |
  Float of Symbol_Pos.T list |
  String of token_kind_string |
  File of token_kind_string |
  (**)
  Space | Comment of token_kind_comment | Sharp of int |
  (**)
  Unknown | Error of string * token_group | Directive of token_kind_directive | EOF

and token_kind_directive = Inline of token_group (* a not yet analyzed directive *)
                         | Include of token_group
                         | Define of token_group (* define *)
                                   * token_group (* name *)
                                   * token_group option (* functional arguments *)
                                   * token_group (* rewrite body *)
                         | Undef of token_group (* name *)
                         | Cpp of token_group
                         | Conditional of token_group (* if *)
                                        * token_group list (* elif *)
                                        * token_group option (* else *)
                                        * token_group (* endif *)

and token_group = Group1 of token list (* spaces and comments filtered from the directive *)
                          * token list (* directive: raw data *)
                | Group2 of token list (* spaces and comments filtered from the directive *)
                          * token list (* directive: function *)
                          * token list (* directive: arguments (same line) *)
                | Group3 of (  Position.range (* full directive (with blanks) *)
                             * token list (* spaces and comments filtered from the directive *)
                             * token list (* directive: function *)
                             * token list (* directive: arguments (same line) *))
                          * (Position.range * token list) (* C code or directive:
                                                               arguments (following lines) *)

and token = Token of Position.range * (token_kind * string);


(* position *)

fun set_range range (Token (_, x)) = Token (range, x);
fun range_of (Token (range, _)) = range;

val pos_of = #1 o range_of;
val end_pos_of = #2 o range_of;


(* stopper *)

fun mk_eof pos = Token ((pos, Position.none), (EOF, ""));
val eof = mk_eof Position.none;

fun is_eof (Token (_, (EOF, _))) = true
  | is_eof _ = false;

val stopper =
  Scan.stopper (fn [] =&gt; eof | toks =&gt; mk_eof (end_pos_of (List.last toks))) is_eof;

val one_not_eof = Scan.one (not o is_eof)

(* token content *)

fun kind_of (Token (_, (k, _))) = k;

val group_list_of = fn
   Inline g =&gt; [g]
 | Include g =&gt; [g]
 | Define (g1, g2, o_g3, g4) =&gt; flat [[g1], [g2], the_list o_g3, [g4]]
 | Undef g =&gt; [g]
 | Cpp g =&gt; [g]
 | Conditional (g1, gs2, o_g3, g4) =&gt; flat [[g1], gs2, the_list o_g3, [g4]]

fun content_of (Token (_, (_, x))) = x;
fun token_leq (tok, tok') = content_of tok &lt;= content_of tok';

val directive_cmds = fn
   Inline (Group1 (_, _ :: tok2 :: _)) =&gt; [tok2]
 | Include (Group2 (_, [_, tok2], _)) =&gt; [tok2]
 | Define (Group1 (_, [_, tok2]), _, _, _) =&gt; [tok2]
 | Undef (Group2 (_, [_, tok2], _)) =&gt; [tok2]
 | Conditional (c1, cs2, c3, c4) =&gt;
     maps (fn Group3 ((_, _, [_, tok2], _), _) =&gt; [tok2]
            | _ =&gt; error "Only expecting Group3")
          (flat [[c1], cs2, the_list c3, [c4]])
 | _ =&gt; []

fun is_keyword (Token (_, (Keyword, _))) = true
  | is_keyword _ = false;

fun is_ident (Token (_, (Ident, _))) = true
  | is_ident _ = false;

fun is_integer (Token (_, (Integer _, _))) = true
  | is_integer _ = false;

fun is_delimiter (Token (_, (Keyword, x))) = not (C_Symbol.is_ascii_identifier x)
  | is_delimiter _ = false;

(* range *)

val range_list_of0 =
 fn [] =&gt; Position.no_range
  | toks as tok1 :: _ =&gt; Position.range (pos_of tok1, end_pos_of (List.last toks))
    (* WARNING the use of:
       ‚Äï‚Äπ\&lt;^ML&gt;‚Äπfn content_of =&gt; fn pos_of =&gt; fn tok2 =&gt;
             List.last (Symbol_Pos.explode (content_of tok2, pos_of tok2)) |-&gt; Position.advance‚Ä∫‚Ä∫
       would not return an accurate position if for example several
       "backslash newlines" are present in the symbol *)

fun range_list_of toks = (range_list_of0 toks, toks)
fun range_list_of' toks1 toks2 = (range_list_of0 toks1, toks2)

local
fun cmp_pos x2 x1 = case Position.distance_of (pos_of x2, pos_of x1) of SOME dist =&gt; dist &lt; 0
                                                                      | NONE =&gt; error "cmp_pos"

fun merge_pos xs = case xs of (xs1, []) =&gt; xs1
                            | ([], xs2) =&gt; xs2
                            | (x1 :: xs1, x2 :: xs2) =&gt;
                                let val (x, xs) = if cmp_pos x2 x1 then (x1, (xs1, x2 :: xs2))
                                                                   else (x2, (x1 :: xs1, xs2))
                                in x :: merge_pos xs end
in
fun merge_blank toks_bl xs1 xs2 =
  let val cmp_tok2 = cmp_pos (List.last xs1)
  in ( range_list_of (merge_pos (xs1, filter cmp_tok2 toks_bl))
     , range_list_of (merge_pos (xs2, filter_out cmp_tok2 toks_bl)))
  end
end

val token_list_of = 
  let fun merge_blank' toks_bl xs1 xs2 =
    let val ((_, l1), (_, l2)) = merge_blank toks_bl xs1 xs2
    in [l1, l2] end
  in group_list_of
    #&gt; maps (fn
        Group1 (toks_bl, []) =&gt; [toks_bl]
      | Group1 (toks_bl, xs1) =&gt; merge_blank' toks_bl xs1 []
      | Group2 (toks_bl, xs1, xs2) =&gt; merge_blank' toks_bl xs1 xs2
      | Group3 ((_, toks_bl, xs1, xs2), (_, xs3)) =&gt; flat [merge_blank' toks_bl xs1 xs2, [xs3]])
    #&gt; flat
  end

local

fun warn0 pos l s =
  ()
  |&gt; tap
       (fn _ =&gt;
        if exists (fn Left s =&gt; not (Symbol.is_printable s) | _ =&gt; false) l then
          app (fn (s, pos) =&gt;
                if Symbol.is_printable s
                then ()
                else Output.information ("Not printable character " ^ @{make_string} (ord s, s)
                                         ^ Position.here pos))
              (Symbol_Pos.explode (s, pos))
        else ())
  |&gt; tap
       (fn _ =&gt;
        app (fn Left _ =&gt; ()
              | Right ((pos1, _), n) =&gt;
                  Output.information
                    ("Out of the supported range (character number " ^ Int.toString n ^ ")"
                     ^ Position.here pos1))
            l)



fun unknown pos = Output.information ("Unknown symbol" ^ Position.here pos)

val app_directive =
      app (fn Token (_, (Error (msg, _), _)) =&gt; warning msg
            | Token ((pos, _), (Unknown, _)) =&gt; unknown pos
            | _ =&gt; ())

in
val warn = fn
    Token ((pos, _), (Char (_, l), s)) =&gt; warn0 pos l s
  | Token ((pos, _), (String (_, l), s)) =&gt; warn0 pos l s
  | Token ((pos, _), (File (_, l), s)) =&gt; warn0 pos l s
  | Token ((pos, _), (Unknown, _)) =&gt; unknown pos
  | Token (_, (Comment (Comment_suspicious (SOME (explicit, msg, _))), _)) =&gt;
      (if explicit then warning else tracing) msg
  | Token (_, (Directive (kind as Conditional _), _)) =&gt; app_directive (token_list_of kind)
  | Token (_, (Directive (Define (_, _, _, Group1 (_, toks4))), _)) =&gt; app_directive toks4
  | Token (_, (Directive (Include (Group2 (_, _, toks))), _)) =&gt;
    (case toks of
       [Token (_, (String _, _))] =&gt; ()
     | [Token (_, (File _, _))] =&gt; ()
     | _ =&gt; Output.information
              ("Expecting at least and at most one file"
               ^ Position.here
                   (Position.range_position (pos_of (hd toks), end_pos_of (List.last toks)))))
  | _ =&gt; ();
end

fun check_error tok =
  case kind_of tok of
    Error (msg, _) =&gt; [msg]
  | _ =&gt; [];

(* markup *)

local

val token_kind_markup0 =
 fn Char _ =&gt; (Markup.ML_char, "")
  | Integer _ =&gt; (Markup.ML_numeral, "")
  | Float _ =&gt; (Markup.ML_numeral, "")
  | ClangC =&gt; (Markup.ML_numeral, "")
  | String _ =&gt; (Markup.ML_string, "")
  | File _ =&gt; (Markup.ML_string, "")
  | Sharp _ =&gt; (Markup.antiquote, "")
  | Unknown =&gt; (Markup.intensify, "")
  | Error (msg, _) =&gt; (Markup.bad (), msg)
  | _ =&gt; (Markup.empty, "");

fun token_report' escape_directive (tok as Token ((pos, _), (kind, x))) =
  if escape_directive andalso (is_keyword tok orelse is_ident tok) then
    [((pos, Markup.antiquote), "")]
  else if is_keyword tok then
    let
      val (markup, txt) = if is_delimiter tok then (Markup.ML_delimiter, "")
        else if member (op =) keywords2 x then (Markup.ML_keyword2 |&gt; Markup.keyword_properties, "")
        else if member (op =) keywords3 x then (Markup.ML_keyword3 |&gt; Markup.keyword_properties, "")
        else (Markup.ML_keyword1 |&gt; Markup.keyword_properties, "");
    in [((pos, markup), txt)] end
  else
    case kind of
     Directive (tokens as Inline _) =&gt;
       ((pos, Markup.antiquoted), "") :: maps token_report0 (token_list_of tokens)
   | Directive (Include (Group2 (toks_bl, tok1 :: _, toks2))) =&gt;
       ((pos, Markup.antiquoted), "")
       :: flat [ maps token_report1 [tok1]
               , maps token_report0 toks2
               , maps token_report0 toks_bl ]
   | Directive
       (Define
         (Group1 (toks_bl1, tok1 :: _), Group1 (toks_bl2, _), toks3, Group1 (toks_bl4, toks4))) =&gt;
       let val (toks_bl3, toks3) = case toks3 of SOME (Group1 x) =&gt; x | _ =&gt; ([], [])
       in ((pos, Markup.antiquoted), "")
         :: ((range_list_of0 toks4 |&gt; #1, Markup.intensify), "")
         :: flat [ maps token_report1 [tok1]
                 , maps token_report0 toks3
                 , maps token_report0 toks4
                 , maps token_report0 toks_bl1
                 , maps token_report0 toks_bl2
                 , map (fn tok =&gt; ((pos_of tok, Markup.antiquote), "")) toks_bl3
                 , maps token_report0 toks_bl4 ] end
   | Directive (Undef (Group2 (toks_bl, tok1 :: _, _))) =&gt;
       ((pos, Markup.antiquoted), "")
       :: flat [ maps token_report1 [tok1]
               , maps token_report0 toks_bl ]
   | Directive (Cpp (Group2 (toks_bl, toks1, toks2))) =&gt;
       ((pos, Markup.antiquoted), "")
       :: flat [ maps token_report1 toks1
               , maps token_report0 toks2
               , maps token_report0 toks_bl ]
   | Directive (Conditional (c1, cs2, c3, c4)) =&gt;
       maps (fn Group3 (((pos, _), toks_bl, tok1 :: _, toks2), ((pos3, _), toks3)) =&gt; 
                ((pos, Markup.antiquoted), "")
                :: ((pos3, Markup.intensify), "")
                :: flat [ maps token_report1 [tok1]
                        , maps token_report0 toks2
                        , maps token_report0 toks3
                        , maps token_report0 toks_bl ]
              | _ =&gt; error "Only expecting Group3")
            (flat [[c1], cs2, the_list c3, [c4]])
   | Error (msg, Group2 (toks_bl, toks1, toks2)) =&gt;
        ((range_list_of0 toks1 |&gt; #1, Markup.bad ()), msg)
        :: ((pos, Markup.antiquoted), "")
        :: flat [ maps token_report1 toks1
                , maps token_report0 toks2
                , maps token_report0 toks_bl ]
   | Error (msg, Group3 ((_, toks_bl, toks1, toks2), _)) =&gt;
        ((range_list_of0 toks1 |&gt; #1, Markup.bad ()), msg)
        :: ((pos, Markup.antiquoted), "")
        :: flat [ maps token_report1 toks1
                , maps token_report0 toks2
                , maps token_report0 toks_bl ]
   | Comment (Comment_suspicious c) =&gt; ((pos, Markup.ML_comment), "")
                                       :: (case c of NONE =&gt; [] | SOME (_, _, l) =&gt; l)
   | x =&gt; [let val (markup, txt) = token_kind_markup0 x in ((pos, markup), txt) end]

and token_report0 tok = token_report' false tok
and token_report1 tok = token_report' true tok

in
val token_report = token_report0
end;



(** scanners **)

val err_prefix = "C lexical error: ";

fun !!! msg = Symbol_Pos.!!! (fn () =&gt; err_prefix ^ msg);

fun !!!! msg = C_Symbol_Pos.!!!! (fn () =&gt; err_prefix ^ msg);

val many1_blanks_no_line = many1 C_Symbol.is_ascii_blank_no_line

(* identifiers *)

val scan_ident_sym =
  let val hex = one' Symbol.is_ascii_hex
  in   one' C_Symbol.is_identletter
    || $$$ "\\" @@@ $$$ "u" @@@ hex @@@ hex @@@ hex @@@ hex
    || $$$ "\\" @@@ $$$ "U" @@@ hex @@@ hex @@@ hex @@@ hex @@@ hex @@@ hex @@@ hex @@@ hex
    || one' Symbol.is_symbolic
    || one' Symbol.is_control
    || one' Symbol.is_utf8
  end
  
val scan_ident =
      scan_ident_sym
  @@@ Scan.repeats (scan_ident_sym || one' Symbol.is_ascii_digit);

val keywords_ident =
  map_filter
    (fn s =&gt; 
         Source.of_list (Symbol_Pos.explode (s, Position.none))
      |&gt; Source.source
           Symbol_Pos.stopper
           (Scan.bulk (scan_ident &gt;&gt; SOME || Scan.one (not o Symbol_Pos.is_eof) &gt;&gt; K NONE))
      |&gt; Source.exhaust
      |&gt; (fn [SOME _] =&gt; SOME s | _ =&gt; NONE))
    keywords

(* numerals *)

fun read_bin s = #1 (read_radix_int 2 s)
fun read_oct s = #1 (read_radix_int 8 s)
fun read_dec s = #1 (read_int s)
val read_hex =
  let fun conv_ascii c1 c0 = String.str (Char.chr (Char.ord #"9" + Char.ord c1 - Char.ord c0 + 1))
  in map (fn s =&gt; let val c = String.sub (s, 0) in
                  if c &gt;= #"A" andalso c &lt;= #"F" then
                    conv_ascii c #"A"
                  else if c &gt;= #"a" andalso c &lt;= #"f" then
                    conv_ascii c #"a"
                  else s
                  end)
  #&gt; read_radix_int 16
  #&gt; #1
  end

local
val many_digit = many Symbol.is_ascii_digit
val many1_digit = many1 Symbol.is_ascii_digit
val many_hex = many Symbol.is_ascii_hex
val many1_hex = many1 Symbol.is_ascii_hex

val scan_suffix_ll = ($$$ "l" @@@ $$$ "l" || $$$ "L" @@@ $$$ "L") &gt;&gt; K [Flag_long_long]
fun scan_suffix_gnu flag = ($$$ "i" || $$$ "j") &gt;&gt; K [flag]
val scan_suffix_int = 
  let val u = ($$$ "u" || $$$ "U") &gt;&gt; K [Flag_unsigned]
      val l = ($$$ "l" || $$$ "L") &gt;&gt; K [Flag_long] in
      u @@@ scan_suffix_ll
   || scan_suffix_ll @@@ opt u
   || u @@@ opt l
   || l @@@ opt u
  end

val scan_suffix_gnu_int0 = scan_suffix_gnu Flag_imag
val scan_suffix_gnu_int = scan_full !!!
                                    (member (op =) (raw_explode "uUlLij"))
                                    "Invalid integer constant suffix"
                                    (   scan_suffix_int @@@ opt scan_suffix_gnu_int0
                                     || scan_suffix_gnu_int0 @@@ opt scan_suffix_int)

fun scan_intgnu x =
  x -- opt scan_suffix_gnu_int
  &gt;&gt; (fn ((s1', read, repr), l) =&gt; (read (map (Symbol_Pos.content o single) s1'), repr, l))

val scan_intoct = scan_intgnu ($$ "0" |--
                               scan_full
                                 !!!
                                 Symbol.is_ascii_digit
                                 "Invalid digit in octal constant"
                                 (Scan.max
                                   (fn ((xs2, _, _), (xs1, _, _)) =&gt; length xs2 &lt; length xs1)
                                   (many C_Symbol.is_ascii_oct
                                      &gt;&gt; (fn xs =&gt; (xs, read_oct, Repr_octal)))
                                   (many (fn x =&gt; x = "0")
                                      &gt;&gt; (fn xs =&gt; (xs, read_dec, Repr_decimal)))))
val scan_intdec = scan_intgnu (one C_Symbol.is_ascii_digit1 -- many Symbol.is_ascii_digit
                               &gt;&gt; (fn (x, xs) =&gt; (x :: xs, read_dec, Repr_decimal)))
val scan_inthex = scan_intgnu (($$ "0" -- ($$ "x" || $$ "X")) |-- many1_hex
                               &gt;&gt; (fn xs2 =&gt; (xs2, read_hex, Repr_hexadecimal)))

(**)

fun scan_signpart a A = ($$$ a || $$$ A) @@@ opt ($$$ "+" || $$$ "-") @@@ many1_digit
val scan_exppart = scan_signpart "e" "E"

val scan_suffix_float = $$$ "f" || $$$ "F" || $$$ "l" || $$$ "L"
val scan_suffix_gnu_float0 = Scan.trace (scan_suffix_gnu ()) &gt;&gt; #2
val scan_suffix_gnu_float = scan_full !!!
                                      (member (op =) (raw_explode "fFlLij"))
                                      "Invalid float constant suffix"
                                      (   scan_suffix_float @@@ opt scan_suffix_gnu_float0
                                       || scan_suffix_gnu_float0 @@@ opt scan_suffix_float)

val scan_hex_pref = $$$ "0" @@@ $$$ "x"

val scan_hexmant = many_hex @@@ $$$ "." @@@ many1_hex
                || many1_hex @@@ $$$ "."
val scan_floatdec =
      (       (   many_digit @@@ $$$ "." @@@ many1_digit
               || many1_digit @@@ $$$ ".")
          @@@ opt scan_exppart
       || many1_digit @@@ scan_exppart)
  @@@ opt scan_suffix_gnu_float

val scan_floathex = scan_hex_pref @@@ (scan_hexmant || many1_hex)
                    @@@ scan_signpart "p" "P" @@@ opt scan_suffix_gnu_float
val scan_floatfail = scan_hex_pref @@@ scan_hexmant
in
val scan_int = scan_inthex
            || scan_intoct
            || scan_intdec

val recover_int =
     many1 (fn s =&gt; Symbol.is_ascii_hex s orelse member (op =) (raw_explode "xXuUlLij") s)

val scan_float = scan_floatdec
              || scan_floathex
              || scan_floatfail @@@ !!! "Hexadecimal floating constant requires an exponent"
                                        Scan.fail

val scan_clangversion = many1_digit @@@ $$$ "." @@@ many1_digit @@@ $$$ "." @@@ many1_digit

end;


(* chars and strings *)

val scan_blanks1 = many1 Symbol.is_ascii_blank

local
val escape_char = [ ("n", #"\n")
                  , ("t", #"\t")
                  , ("v", #"\v")
                  , ("b", #"\b")
                  , ("r", #"\r")
                  , ("f", #"\f")
                  , ("a", #"\a")
                  , ("e", #"\^[")
                  , ("E", #"\^[")
                  , ("\\", #"\\")
                  , ("?", #"?")
                  , ("'", #"'")
                  , ("\"", #"\"") ]

val _ = ‚Äï ‚Äπprinting a ML function translating code point from \&lt;^ML_type&gt;‚Äπint -&gt; string‚Ä∫‚Ä∫
 fn _ =&gt; 
  app (fn (x0, x) =&gt; writeln (" | "
                              ^ string_of_int (Char.ord x)
                              ^ " =&gt; \"\\\\"
                              ^ (if exists (fn x1 =&gt; x0 = x1) ["\"", "\\"] then "\\" ^ x0 else x0)
                              ^ "\""))
      escape_char

fun scan_escape s0 =
  let val oct = one' C_Symbol.is_ascii_oct
      val hex = one' Symbol.is_ascii_hex
      fun chr' f l =
        let val x = f (map Symbol_Pos.content l)
        in [if x &lt;= Char.maxOrd then Left (chr x) else Right (Symbol_Pos.range (flat l), x)] end
      val read_oct' = chr' read_oct
      val read_hex' = chr' read_hex
  in one' (member (op =) (raw_explode (s0 ^ String.concat (map #1 escape_char))))
     &gt;&gt; (fn i =&gt;
          [Left (case AList.lookup (op =) escape_char (Symbol_Pos.content i) of
                   NONE =&gt; s0
                 | SOME c =&gt; String.str c)])
  || oct -- oct -- oct &gt;&gt; (fn ((o1, o2), o3) =&gt; read_oct' [o1, o2, o3])
  || oct -- oct &gt;&gt; (fn (o1, o2) =&gt; read_oct' [o1, o2])
  || oct &gt;&gt; (read_oct' o single)
  || $$ "x" |-- many1 Symbol.is_ascii_hex
     &gt;&gt; (read_hex' o map single)
  || $$ "u" |-- hex -- hex -- hex -- hex
     &gt;&gt; (fn (((x1, x2), x3), x4) =&gt; read_hex' [x1, x2, x3, x4])
  || $$ "U" |-- hex -- hex -- hex -- hex -- hex -- hex -- hex -- hex
     &gt;&gt; (fn (((((((x1, x2), x3), x4), x5), x6), x7), x8) =&gt;
          read_hex' [x1, x2, x3, x4, x5, x6, x7, x8])
  end

fun scan_str s0 =
     Scan.unless newline
                 (Scan.one (fn (s, _) =&gt; Symbol.not_eof s andalso s &lt;&gt; s0 andalso s &lt;&gt; "\\"))
     &gt;&gt; (fn s =&gt; [Left (#1 s)])
  || Scan.ahead newline |-- !!! "bad newline" Scan.fail
  || $$ "\\" |-- !!! "bad escape character" (scan_escape s0);

fun scan_string0 s0 msg repeats =
  Scan.optional ($$ "L" &gt;&gt; K Encoding_L) Encoding_default --
    (Scan.ahead ($$ s0) |--
      !!! ("unclosed " ^ msg ^ " literal")
        ($$ s0 |-- repeats (scan_str s0) --| $$ s0))

fun recover_string0 s0 repeats =
  opt ($$$ "L") @@@ $$$ s0 @@@ repeats (Scan.permissive (Scan.trace (scan_str s0) &gt;&gt; #2));
in

val scan_char = scan_string0 "'" "char" Scan.repeats1
val scan_string = scan_string0 "\"" "string" Scan.repeats
fun scan_string' src =
  case
    Source.source
      Symbol_Pos.stopper
      (Scan.recover (Scan.bulk (!!! "bad input" scan_string &gt;&gt; K NONE))
                    (fn msg =&gt; C_Basic_Symbol_Pos.one_not_eof &gt;&gt; K [SOME msg]))
      (Source.of_list src)
    |&gt; Source.exhaust
  of
      [NONE] =&gt; NONE
    | [] =&gt; SOME "Empty input"
    | l =&gt; case map_filter I l of msg :: _ =&gt; SOME msg
                                | _ =&gt; SOME "More than one string"
val scan_file =
  let fun scan !!! s_l s_r =
    Scan.ahead ($$ s_l) |--
          !!!
          ($$ s_l
           |-- Scan.repeats
                 (Scan.unless newline
                              (Scan.one (fn (s, _) =&gt; Symbol.not_eof s andalso s &lt;&gt; s_r)
                               &gt;&gt; (fn s =&gt; [Left (#1 s)])))
           --| $$ s_r)
  in
     Scan.trace (scan (!!! ("unclosed file literal")) "\"" "\"")
       &gt;&gt; (fn (s, src) =&gt; String (Encoding_file (scan_string' src), s))
  || scan I ‚Äï ‚ÄπDue to conflicting symbols, raising \&lt;^ML&gt;‚ÄπSymbol_Pos.!!!‚Ä∫ here will not let a potential
                legal \&lt;^ML&gt;‚Äπ"&lt;"‚Ä∫ symbol be tried and parsed as a ‚àó‚Äπkeyword‚Ä∫.‚Ä∫
            "&lt;" "&gt;" &gt;&gt; (fn s =&gt; File (Encoding_default, s))
  end

val recover_char = recover_string0 "'" Scan.repeats1
val recover_string = recover_string0 "\"" Scan.repeats

end;

(* scan tokens *)

val check = fold (tap warn #&gt; fold cons o check_error)

local

fun token k ss = Token (Symbol_Pos.range ss, (k, Symbol_Pos.content ss));
fun scan_token f1 f2 = Scan.trace f1 &gt;&gt; (fn (v, s) =&gt; token (f2 v) s)

val comments =
     Scan.recover
       (scan_token C_Antiquote.scan_antiq (Comment o Comment_formal))
       (fn msg =&gt; Scan.ahead C_Antiquote.scan_antiq_recover
                  -- C_Symbol_Pos.scan_comment_no_nest err_prefix
                  &gt;&gt; (fn (explicit, res) =&gt;
                       token (Comment (Comment_suspicious (SOME (explicit, msg, [])))) res)
               || Scan.fail_with (fn _ =&gt; fn _ =&gt; msg))
  || C_Symbol_Pos.scan_comment_no_nest err_prefix &gt;&gt; token (Comment (Comment_suspicious NONE))

fun scan_fragment blanks comments sharps non_blanks =
     non_blanks (scan_token scan_char Char)
  || non_blanks (scan_token scan_string String)
  || blanks
  || comments
  || non_blanks sharps
  || non_blanks (Scan.max token_leq (Scan.literal lexicon &gt;&gt; token Keyword)
                                    (   scan_clangversion &gt;&gt; token ClangC
                                     || scan_token scan_float Float
                                     || scan_token scan_int Integer
                                     || scan_ident &gt;&gt; token Ident))
  || non_blanks (Scan.one (Symbol.is_printable o #1) &gt;&gt; single &gt;&gt; token Unknown)

(* scan tokens, directive part *)

val scan_sharp1 = $$$ "#"
val scan_sharp2 = $$$ "#" @@@ $$$ "#"

val scan_directive =
  let val f_filter = fn Token (_, (Space, _)) =&gt; true
                      | Token (_, (Comment _, _)) =&gt; true
                      | Token (_, (Error _, _)) =&gt; true
                      | _ =&gt; false
      val sharp1 = scan_sharp1 &gt;&gt; token (Sharp 1)
  in    (sharp1 &gt;&gt; single)
    @@@ Scan.repeat (   scan_token scan_file I
                     || scan_fragment (many1_blanks_no_line &gt;&gt; token Space)
                                      comments
                                      (scan_sharp2 &gt;&gt; token (Sharp 2) || sharp1)
                                      I)
    &gt;&gt; (fn tokens =&gt; Inline (Group1 (filter f_filter tokens, filter_out f_filter tokens)))
  end

local
fun !!! text scan =
  let
    fun get_pos [] = " (end-of-input)"
      | get_pos (t :: _) = Position.here (pos_of t);

    fun err (syms, msg) = fn () =&gt;
      err_prefix ^ text ^ get_pos syms ^
      (case msg of NONE =&gt; "" | SOME m =&gt; "\n" ^ m ());
  in Scan.!! err scan end

val pos_here_of = Position.here o pos_of

fun one_directive f =
  Scan.one (fn Token (_, (Directive ( Inline (Group1 (_, Token (_, (Sharp 1, _))
                                                         :: Token (_, s)
                                                         :: _)))
                                    , _))
                 =&gt; f s
             | _ =&gt; false)

val get_cond = fn Token (pos, (Directive (Inline (Group1 (toks_bl, tok1 :: tok2 :: toks))), _)) =&gt;
                    (fn t3 =&gt; Group3 ((pos, toks_bl, [tok1, tok2], toks), range_list_of t3))
                | _ =&gt; error "Inline directive expected"

val one_start_cond = one_directive (fn (Keyword, "if") =&gt; true
                                     | (Ident, "ifdef") =&gt; true
                                     | (Ident, "ifndef") =&gt; true
                                     | _ =&gt; false)
val one_elif = one_directive (fn (Ident, "elif") =&gt; true | _ =&gt; false)
val one_else = one_directive (fn (Keyword, "else") =&gt; true | _ =&gt; false)
val one_endif = one_directive (fn (Ident, "endif") =&gt; true | _ =&gt; false)

val not_cond =
 Scan.unless
  (one_start_cond || one_elif || one_else || one_endif)
  (one_not_eof
   &gt;&gt;
    (fn Token (pos, ( Directive (Inline (Group1 ( toks_bl
                                                , (tok1 as Token (_, (Sharp _, _)))
                                                  :: (tok2 as Token (_, (Ident, "include")))
                                                  :: toks)))
                    , s)) =&gt;
          Token (pos, ( case toks of [] =&gt;
                          Error ( "Expecting at least one file"
                                  ^ Position.here (end_pos_of tok2)
                                , Group2 (toks_bl, [tok1, tok2], toks))
                        | _ =&gt; Directive (Include (Group2 (toks_bl, [tok1, tok2], toks)))
                      , s))
      | Token (pos, ( Directive (Inline (Group1 ( toks_bl
                                                , (tok1 as Token (_, (Sharp _, _)))
                                                  :: (tok2 as Token (_, (Ident, "define")))
                                                  :: toks)))
                    , s)) =&gt;
         let
          fun define tok3 toks = 
           case
             case toks of
               (tok3' as Token (pos, (Keyword, "("(*)*)))) :: toks =&gt; 
                 if Position.offset_of (end_pos_of tok3) = Position.offset_of (pos_of tok3')
                 then
                  let
                    fun right msg pos = Right (msg ^ Position.here pos)
                    fun right1 msg = right msg o #1
                    fun right2 msg = right msg o #2
                    fun take_prefix' toks_bl toks_acc pos =
                     fn
                       (tok1 as Token (_, (Ident, _)))
                       :: (tok2 as Token (pos2, (Keyword, key)))
                       :: toks =&gt;
                         if key = ","
                         then take_prefix' (tok2 :: toks_bl) (tok1 :: toks_acc) pos2 toks
                         else if key = (*( *)")" then
                           Left (rev (tok2 :: toks_bl), rev (tok1 :: toks_acc), toks)
                         else
                           right1 "Expecting a colon delimiter or a closing parenthesis" pos2
                     | Token (pos1, (Ident, _)) :: _ =&gt;
                         right2 "Expecting a colon delimiter or a closing parenthesis" pos1
                     | (tok1 as Token (_, (Keyword, key1)))
                       :: (tok2 as Token (pos2, (Keyword, key2)))
                       :: toks =&gt;
                         if key1 = "..." then
                           if key2 = (*( *)")"
                           then Left (rev (tok2 :: toks_bl), rev (tok1 :: toks_acc), toks)
                           else right1 "Expecting a closing parenthesis" pos2
                         else right2 "Expecting an identifier or the keyword '...'" pos
                     | _ =&gt; right2 "Expecting an identifier or the keyword '...'" pos
                  in case
                      case toks of
                        (tok2 as Token (_, (Keyword, (*( *)")"))) :: toks =&gt; Left ([tok2], [], toks)
                      | _ =&gt; take_prefix' [] [] pos toks
                     of Left (toks_bl, toks_acc, toks) =&gt;
                          Left (SOME (Group1 (tok3' :: toks_bl, toks_acc)), Group1 ([], toks))
                      | Right x =&gt; Right x
                  end
                 else Left (NONE, Group1 ([], tok3' :: toks))
             | _ =&gt; Left (NONE, Group1 ([], toks))
           of Left (gr1, gr2) =&gt;
                Directive (Define (Group1 (toks_bl, [tok1, tok2]), Group1 ([], [tok3]), gr1, gr2))
            | Right msg =&gt; Error (msg, Group2 (toks_bl, [tok1, tok2], tok3 :: toks))
          fun err () = Error ( "Expecting at least one identifier" ^ Position.here (end_pos_of tok2)
                             , Group2 (toks_bl, [tok1, tok2], toks))
         in
           Token (pos, ( case toks of
                           (tok3 as Token (_, (Ident, _))) :: toks =&gt; define tok3 toks
                         | (tok3 as Token (_, (Keyword, cts))) :: toks =&gt;
                             if exists (fn cts0 =&gt; cts = cts0) keywords_ident
                             then define tok3 toks
                             else err ()
                         | _ =&gt; err ()
                       , s))
         end
      | Token (pos, ( Directive (Inline (Group1 ( toks_bl
                                                , (tok1 as Token (_, (Sharp _, _)))
                                                  :: (tok2 as Token (_, (Ident, "undef")))
                                                  :: toks)))
                    , s)) =&gt;
          Token (pos, ( let fun err () = Error ( "Expecting at least and at most one identifier"
                                                 ^ Position.here (end_pos_of tok2)
                                               , Group2 (toks_bl, [tok1, tok2], toks))
                        in
                          case toks of
                            [Token (_, (Ident, _))] =&gt;
                              Directive (Undef (Group2 (toks_bl, [tok1, tok2], toks)))
                          | [Token (_, (Keyword, cts))] =&gt;
                              if exists (fn cts0 =&gt; cts = cts0) keywords_ident
                              then Directive (Undef (Group2 (toks_bl, [tok1, tok2], toks)))
                              else err ()
                          | _ =&gt; err ()
                        end
                      , s))
      | Token (pos, ( Directive (Inline (Group1 ( toks_bl
                                                , (tok1 as Token (_, (Sharp _, _)))
                                                  :: (tok2 as Token (_, (Integer _, _)))
                                                  :: (tok3 as Token (_, (String _, _)))
                                                  :: toks)))
                    , s)) =&gt;
          Token (pos, ( if forall is_integer toks then
                          Directive (Cpp (Group2 (toks_bl, [tok1], tok2 :: tok3 :: toks)))
                        else Error ( "Expecting an integer"
                                     ^ Position.here (drop_prefix is_integer toks |&gt; hd |&gt; pos_of)
                                   , Group2 (toks_bl, [tok1], tok2 :: tok3 :: toks))
                      , s))
      | x =&gt; x))

fun scan_cond xs = xs |&gt;
  (one_start_cond -- scan_cond_list
   -- Scan.repeat (one_elif -- scan_cond_list)
   -- Scan.option (one_else -- scan_cond_list)
   -- Scan.recover one_endif
                   (fn msg =&gt;
                     Scan.fail_with
                       (fn toks =&gt; fn () =&gt;
                         case toks of
                           tok :: _ =&gt; "can be closed here" ^ Position.here (pos_of tok)
                         | _ =&gt; msg))
    &gt;&gt; (fn (((t_if, t_elif), t_else), t_endif) =&gt;
         Token ( Position.no_range
               , ( Directive
                     (Conditional
                       let fun t_body x = x |-&gt; get_cond
                       in
                       ( t_body t_if
                       , map t_body t_elif
                       , Option.map t_body t_else
                       , t_body (t_endif, []))
                       end)
                 , ""))))

and scan_cond_list xs = xs |&gt; Scan.repeat (not_cond || scan_cond)

val scan_directive_cond0 =
     not_cond
  || Scan.ahead ( one_start_cond |-- scan_cond_list
                 |-- Scan.repeat (one_elif -- scan_cond_list)
                 |-- one_else --| scan_cond_list -- (one_elif || one_else))
     :-- (fn (tok1, tok2) =&gt; !!! ( "directive" ^ pos_here_of tok2
                                 ^ " not expected after" ^ pos_here_of tok1
                                 ^ ", detected at")
                                 Scan.fail)
     &gt;&gt; #2
  || (Scan.ahead one_start_cond |-- !!! "unclosed directive" scan_cond)
  || (Scan.ahead one_not_eof |-- !!! "missing or ambiguous beginning of conditional" Scan.fail)

fun scan_directive_recover msg =
     not_cond
  || one_not_eof &gt;&gt;
       (fn tok as Token (pos, (_, s)) =&gt; Token (pos, (Error (msg, get_cond tok []), s)))

in

val scan_directive_cond =
  Scan.recover
    (Scan.bulk scan_directive_cond0)
    (fn msg =&gt; scan_directive_recover msg &gt;&gt; single)

end

(* scan tokens, main *)

val scan_ml =
  Scan.depend
    let
      fun non_blanks st scan = scan &gt;&gt; pair st 
      fun scan_frag st =
        scan_fragment (   C_Basic_Symbol_Pos.newline &gt;&gt; token Space &gt;&gt; pair true
                       || many1_blanks_no_line &gt;&gt; token Space &gt;&gt; pair st)
                      (non_blanks st comments)
                      ((scan_sharp2 || scan_sharp1) &gt;&gt; token Keyword)
                      (non_blanks false)
    in
      fn true =&gt; scan_token scan_directive Directive &gt;&gt; pair false || scan_frag true
       | false =&gt; scan_frag false
    end;

fun recover msg =
 (recover_char ||
  recover_string ||
  Symbol_Pos.recover_cartouche ||
  C_Symbol_Pos.recover_comment ||
  recover_int ||
  one' Symbol.not_eof)
  &gt;&gt; token (Error (msg, Group1 ([], [])));

fun reader scan syms =
  let
    val termination =
      if null syms then []
      else
        let
          val pos1 = List.last syms |-&gt; Position.advance;
          val pos2 = Position.advance Symbol.space pos1;
        in [Token (Position.range (pos1, pos2), (Space, Symbol.space))] end;

    val backslash1 =
          $$$ "\\" @@@ many C_Symbol.is_ascii_blank_no_line @@@ C_Basic_Symbol_Pos.newline
    val backslash2 = Scan.one (not o Symbol_Pos.is_eof)

    val input0 =
      Source.of_list syms
      |&gt; Source.source Symbol_Pos.stopper (Scan.bulk (backslash1 &gt;&gt; SOME || backslash2 &gt;&gt; K NONE))
      |&gt; Source.map_filter I
      |&gt; Source.exhaust
      |&gt; map (Symbol_Pos.range #&gt; Position.range_position)

    val input1 =
      Source.of_list syms
      |&gt; Source.source Symbol_Pos.stopper (Scan.bulk (backslash1 &gt;&gt; K NONE || backslash2 &gt;&gt; SOME))
      |&gt; Source.map_filter I
      |&gt; Source.source' true
                        Symbol_Pos.stopper
                        (Scan.recover (Scan.bulk (!!!! "bad input" scan))
                                      (fn msg =&gt; Scan.lift (recover msg) &gt;&gt; single))
      |&gt; Source.source stopper scan_directive_cond
      |&gt; Source.exhaust
      |&gt; (fn input =&gt; input @ termination);

    val _ = app (fn pos =&gt; Output.information ("Backslash newline" ^ Position.here pos)) input0
    val _ = Position.reports_text (map (fn pos =&gt; ((pos, Markup.intensify), "")) input0);
  in (input1, check input1)
end;

in

fun op @@ ((input1, f_error_lines1), (input2, f_error_lines2)) =
  (input1 @ input2, f_error_lines1 #&gt; f_error_lines2)

val read_init = ([], I)

fun read text = (reader scan_ml o Symbol_Pos.explode) (text, Position.none);

fun read_source' {language, symbols} scan source =
  let
    val pos = Input.pos_of source;
    val _ =
      if Position.is_reported_range pos
      then Position.report pos (language (Input.is_delimited source))
      else ();
  in
    Input.source_explode source
    |&gt; not symbols ? maps (fn (s, p) =&gt; raw_explode s |&gt; map (rpair p))
    |&gt; reader scan
  end;

val read_source =
  read_source' { language =
                  Markup.language' {name = "C", symbols = false, antiquotes = true}, symbols = true}
               scan_ml;

end;

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Ast">
<div class="head"><h1>Theory C_Ast</h1>
<span class="command">theory</span> <span class="name">C_Ast</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIsabelle/C‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCore Language: An Abstract Syntax Tree Definition (C Language without Annotations)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Ast</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLoading the Generated AST‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The abstract syntax tree of the C language considered in the Isabelle/C project is
arbitrary, but it must already come with a grammar making the connection with a default AST, so that
both the grammar and AST can be imported to SML.‚Åã‚ÄπAdditionally, the grammar and AST
must both have a free licence --- compatible with the Isabelle AFP, for them to be publishable
there.‚Ä∫ The Haskell Language.C project fulfills this property: see for instance
üåê‚Äπhttp://hackage.haskell.org/package/language-c‚Ä∫ and
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Syntax/AST.hs‚Ä∫,
where its AST is being imported in the present theory file üóè‚ÄπC_Ast.thy‚Ä∫, whereas
its grammar will be later in üóè‚ÄπC_Parser_Language.thy‚Ä∫
(üóè‚ÄπC_Parser_Language.thy‚Ä∫ depends on üóè‚ÄπC_Ast.thy‚Ä∫). The AST
importation is based on a modified version of Haskabelle, which generates the C AST from Haskell to
an ML file. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_ast.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
val fresh_ident0 =
  let val i = Synchronized.var "counter for new identifier" 38 in
    fn () =&gt; Int.toString (Synchronized.change_result i (fn i =&gt; (i, i + 1)))
  end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_ast.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚Äï ‚Äπüåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/blob/C/Citadelle/src/compiler_generic/meta_isabelle/Printer_init.thy‚Ä∫‚Ä∫
structure CodeType = struct
  type mlInt = string
  type 'a mlMonad = 'a option
end

structure CodeConst = struct
  structure Monad = struct
    val bind = fn
        NONE =&gt; (fn _ =&gt; NONE)
      | SOME a =&gt; fn f =&gt; f a
    val return = SOME
  end

  structure Printf = struct
    local
      fun sprintf s l =
        case String.fields (fn #"%" =&gt; true | _ =&gt; false) s of
          [] =&gt; ""
        | [x] =&gt; x
        | x :: xs =&gt;
            let fun aux acc l_pat l_s =
              case l_pat of
                [] =&gt; rev acc
              | x :: xs =&gt; aux (String.extract (x, 1, NONE) :: hd l_s :: acc) xs (tl l_s) in
            String.concat (x :: aux [] xs l)
      end
    in
      fun sprintf0 s_pat = s_pat
      fun sprintf1 s_pat s1 = sprintf s_pat [s1]
      fun sprintf2 s_pat s1 s2 = sprintf s_pat [s1, s2]
      fun sprintf3 s_pat s1 s2 s3 = sprintf s_pat [s1, s2, s3]
      fun sprintf4 s_pat s1 s2 s3 s4 = sprintf s_pat [s1, s2, s3, s4]
      fun sprintf5 s_pat s1 s2 s3 s4 s5 = sprintf s_pat [s1, s2, s3, s4, s5]
    end
  end

  structure String = struct
    val concat = String.concatWith
  end

  structure Sys = struct
    val isDirectory2 = SOME o File.is_dir o Path.explode handle ERROR _ =&gt; K NONE
  end

  structure To = struct
    fun nat f = Int.toString o f
  end

  fun outFile1 _ _ = tap (fn _ =&gt; warning "not implemented") NONE
  fun outStand1 f = outFile1 f ""
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../generated/c_ast.ML‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Note that the purpose of üóÄ‚Äπ../generated‚Ä∫ is to host any generated
files of the Isabelle/C project. It contains among others:

  ‚ñ™ üóè‚Äπ../generated/c_ast.ML‚Ä∫ representing the Abstract Syntax Tree of C,
  which has just been loaded.
  
  ‚ñ™ üóè‚Äπ../generated/c_grammar_fun.grm‚Ä∫ is a generated file not used by the
  project, except for further generating üóè‚Äπ../generated/c_grammar_fun.grm.sig‚Ä∫
  and üóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫. Its physical presence in the
  directory is actually not necessary, but has been kept for informative documentation purposes. It
  represents the basis point of our SML grammar file, generated by an initial Haskell grammar file
  (namely
  üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫)
  using a modified version of Happy.

  ‚ñ™ üóè‚Äπ../generated/c_grammar_fun.grm.sig‚Ä∫ and
  üóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫ are the two files generated from
  üóè‚Äπ../generated/c_grammar_fun.grm‚Ä∫ with a modified version of ML-Yacc. This
  last comes from MLton source in üóÄ‚Äπ../../src_ext/mlton‚Ä∫, see for example
  üóÄ‚Äπ../../src_ext/mlton/mlyacc‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ For the case of üóè‚Äπ../generated/c_ast.ML‚Ä∫, it is actually not
mandatory to have a ``physical'' representation of the file in üóÄ‚Äπ../generated‚Ä∫:
it could be generated ``on-the-fly'' with ‚¨ö‚Äπcode_reflect‚Ä∫ and immediately
loaded: Citadelle has an option to choose between the two
tasks~\cite{DBLP:journals/afp/TuongW15}.‚Åã‚Äπüåê‚Äπhttps://gitlri.lri.fr/ftuong/citadelle-devel‚Ä∫‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ After loading the AST, it is possible in Citadelle to do various meta-programming
renaming, such as the one depicted in the next command. Actually, its content is explicitly included
here by hand since we decided to manually load the AST using the above
‚¨ö‚ÄπML_file‚Ä∫ command. (Otherwise, one can automatically execute the overall
generation and renaming tasks in Citadelle without resorting to a manual copying-pasting.)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_ast.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Ast =
struct
  val Position = C_Ast.position val NoPosition = C_Ast.noPosition val BuiltinPosition = C_Ast.builtinPosition val InternalPosition = C_Ast.internalPosition val Name = C_Ast.name val OnlyPos = C_Ast.onlyPos val NodeInfo = C_Ast.nodeInfo val AnonymousRef = C_Ast.anonymousRef val NamedRef = C_Ast.namedRef val CChar = C_Ast.cChar val CChars = C_Ast.cChars val DecRepr = C_Ast.decRepr val HexRepr = C_Ast.hexRepr val OctalRepr = C_Ast.octalRepr val FlagUnsigned = C_Ast.flagUnsigned val FlagLong = C_Ast.flagLong val FlagLongLong = C_Ast.flagLongLong val FlagImag = C_Ast.flagImag val CFloat = C_Ast.cFloat val Flags = C_Ast.flags val CInteger = C_Ast.cInteger val CAssignOp = C_Ast.cAssignOp val CMulAssOp = C_Ast.cMulAssOp val CDivAssOp = C_Ast.cDivAssOp val CRmdAssOp = C_Ast.cRmdAssOp val CAddAssOp = C_Ast.cAddAssOp val CSubAssOp = C_Ast.cSubAssOp val CShlAssOp = C_Ast.cShlAssOp val CShrAssOp = C_Ast.cShrAssOp val CAndAssOp = C_Ast.cAndAssOp val CXorAssOp = C_Ast.cXorAssOp val COrAssOp = C_Ast.cOrAssOp val CMulOp = C_Ast.cMulOp val CDivOp = C_Ast.cDivOp val CRmdOp = C_Ast.cRmdOp val CAddOp = C_Ast.cAddOp val CSubOp = C_Ast.cSubOp val CShlOp = C_Ast.cShlOp val CShrOp = C_Ast.cShrOp val CLeOp = C_Ast.cLeOp val CGrOp = C_Ast.cGrOp val CLeqOp = C_Ast.cLeqOp val CGeqOp = C_Ast.cGeqOp val CEqOp = C_Ast.cEqOp val CNeqOp = C_Ast.cNeqOp val CAndOp = C_Ast.cAndOp val CXorOp = C_Ast.cXorOp val COrOp = C_Ast.cOrOp val CLndOp = C_Ast.cLndOp val CLorOp = C_Ast.cLorOp val CPreIncOp = C_Ast.cPreIncOp val CPreDecOp = C_Ast.cPreDecOp val CPostIncOp = C_Ast.cPostIncOp val CPostDecOp = C_Ast.cPostDecOp val CAdrOp = C_Ast.cAdrOp val CIndOp = C_Ast.cIndOp val CPlusOp = C_Ast.cPlusOp val CMinOp = C_Ast.cMinOp val CCompOp = C_Ast.cCompOp val CNegOp = C_Ast.cNegOp val CAuto = C_Ast.cAuto val CRegister = C_Ast.cRegister val CStatic = C_Ast.cStatic val CExtern = C_Ast.cExtern val CTypedef = C_Ast.cTypedef val CThread = C_Ast.cThread val CInlineQual = C_Ast.cInlineQual val CNoreturnQual = C_Ast.cNoreturnQual val CStructTag = C_Ast.cStructTag val CUnionTag = C_Ast.cUnionTag val CIntConst = C_Ast.cIntConst val CCharConst = C_Ast.cCharConst val CFloatConst = C_Ast.cFloatConst val CStrConst = C_Ast.cStrConst val CStrLit = C_Ast.cStrLit val CFunDef = C_Ast.cFunDef val CDecl = C_Ast.cDecl val CStaticAssert = C_Ast.cStaticAssert val CDeclr = C_Ast.cDeclr val CPtrDeclr = C_Ast.cPtrDeclr val CArrDeclr = C_Ast.cArrDeclr val CFunDeclr = C_Ast.cFunDeclr val CNoArrSize = C_Ast.cNoArrSize val CArrSize = C_Ast.cArrSize val CLabel = C_Ast.cLabel val CCase = C_Ast.cCase val CCases = C_Ast.cCases val CDefault = C_Ast.cDefault val CExpr = C_Ast.cExpr val CCompound = C_Ast.cCompound val CIf = C_Ast.cIf val CSwitch = C_Ast.cSwitch val CWhile = C_Ast.cWhile val CFor = C_Ast.cFor val CGoto = C_Ast.cGoto val CGotoPtr = C_Ast.cGotoPtr val CCont = C_Ast.cCont val CBreak = C_Ast.cBreak val CReturn = C_Ast.cReturn val CAsm = C_Ast.cAsm val CAsmStmt = C_Ast.cAsmStmt val CAsmOperand = C_Ast.cAsmOperand val CBlockStmt = C_Ast.cBlockStmt val CBlockDecl = C_Ast.cBlockDecl val CNestedFunDef = C_Ast.cNestedFunDef val CStorageSpec = C_Ast.cStorageSpec val CTypeSpec = C_Ast.cTypeSpec val CTypeQual = C_Ast.cTypeQual val CFunSpec = C_Ast.cFunSpec val CAlignSpec = C_Ast.cAlignSpec val CVoidType = C_Ast.cVoidType val CCharType = C_Ast.cCharType val CShortType = C_Ast.cShortType val CIntType = C_Ast.cIntType val CLongType = C_Ast.cLongType val CFloatType = C_Ast.cFloatType val CDoubleType = C_Ast.cDoubleType val CSignedType = C_Ast.cSignedType val CUnsigType = C_Ast.cUnsigType val CBoolType = C_Ast.cBoolType val CComplexType = C_Ast.cComplexType val CInt128Type = C_Ast.cInt128Type val CSUType = C_Ast.cSUType val CEnumType = C_Ast.cEnumType val CTypeDef = C_Ast.cTypeDef val CTypeOfExpr = C_Ast.cTypeOfExpr val CTypeOfType = C_Ast.cTypeOfType val CAtomicType = C_Ast.cAtomicType val CConstQual = C_Ast.cConstQual val CVolatQual = C_Ast.cVolatQual val CRestrQual = C_Ast.cRestrQual val CAtomicQual = C_Ast.cAtomicQual val CAttrQual = C_Ast.cAttrQual val CNullableQual = C_Ast.cNullableQual val CNonnullQual = C_Ast.cNonnullQual val CAlignAsType = C_Ast.cAlignAsType val CAlignAsExpr = C_Ast.cAlignAsExpr val CStruct = C_Ast.cStruct val CEnum = C_Ast.cEnum val CInitExpr = C_Ast.cInitExpr val CInitList = C_Ast.cInitList val CArrDesig = C_Ast.cArrDesig val CMemberDesig = C_Ast.cMemberDesig val CRangeDesig = C_Ast.cRangeDesig val CAttr = C_Ast.cAttr val CComma = C_Ast.cComma val CAssign = C_Ast.cAssign val CCond = C_Ast.cCond val CBinary = C_Ast.cBinary val CCast = C_Ast.cCast val CUnary = C_Ast.cUnary val CSizeofExpr = C_Ast.cSizeofExpr val CSizeofType = C_Ast.cSizeofType val CAlignofExpr = C_Ast.cAlignofExpr val CAlignofType = C_Ast.cAlignofType val CComplexReal = C_Ast.cComplexReal val CComplexImag = C_Ast.cComplexImag val CIndex = C_Ast.cIndex val CCall = C_Ast.cCall val CMember = C_Ast.cMember val CVar = C_Ast.cVar val CConst = C_Ast.cConst val CCompoundLit = C_Ast.cCompoundLit val CGenericSelection = C_Ast.cGenericSelection val CStatExpr = C_Ast.cStatExpr val CLabAddrExpr = C_Ast.cLabAddrExpr val CBuiltinExpr = C_Ast.cBuiltinExpr val CBuiltinVaArg = C_Ast.cBuiltinVaArg val CBuiltinOffsetOf = C_Ast.cBuiltinOffsetOf val CBuiltinTypesCompatible = C_Ast.cBuiltinTypesCompatible val CDeclExt = C_Ast.cDeclExt val CFDefExt = C_Ast.cFDefExt val CAsmExt = C_Ast.cAsmExt val CTranslUnit = C_Ast.cTranslUnit
  open C_Ast
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBasic Aliases and Initialization of the Haskell Library‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_ast.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Ast =
struct
type class_Pos = Position.T * Position.T
(**)
type NodeInfo = C_Ast.nodeInfo
type CStorageSpec = NodeInfo C_Ast.cStorageSpecifier
type CFunSpec = NodeInfo C_Ast.cFunctionSpecifier
type CConst = NodeInfo C_Ast.cConstant
type 'a CInitializerList = ('a C_Ast.cPartDesignator List.list * 'a C_Ast.cInitializer) List.list
type CTranslUnit = NodeInfo C_Ast.cTranslationUnit
type CExtDecl = NodeInfo C_Ast.cExternalDeclaration
type CFunDef = NodeInfo C_Ast.cFunctionDef
type CDecl = NodeInfo C_Ast.cDeclaration
type CDeclr = NodeInfo C_Ast.cDeclarator
type CDerivedDeclr = NodeInfo C_Ast.cDerivedDeclarator
type CArrSize = NodeInfo C_Ast.cArraySize
type CStat = NodeInfo C_Ast.cStatement
type CAsmStmt = NodeInfo C_Ast.cAssemblyStatement
type CAsmOperand = NodeInfo C_Ast.cAssemblyOperand
type CBlockItem = NodeInfo C_Ast.cCompoundBlockItem
type CDeclSpec = NodeInfo C_Ast.cDeclarationSpecifier
type CTypeSpec = NodeInfo C_Ast.cTypeSpecifier
type CTypeQual = NodeInfo C_Ast.cTypeQualifier
type CAlignSpec = NodeInfo C_Ast.cAlignmentSpecifier
type CStructUnion = NodeInfo C_Ast.cStructureUnion
type CEnum = NodeInfo C_Ast.cEnumeration
type CInit = NodeInfo C_Ast.cInitializer
type CInitList = NodeInfo CInitializerList
type CDesignator = NodeInfo C_Ast.cPartDesignator
type CAttr = NodeInfo C_Ast.cAttribute
type CExpr = NodeInfo C_Ast.cExpression
type CBuiltin = NodeInfo C_Ast.cBuiltinThing
type CStrLit = NodeInfo C_Ast.cStringLiteral
(**)
type ClangCVersion = C_Ast.clangCVersion
type Ident = C_Ast.ident
type Position = C_Ast.positiona
type PosLength = Position * int
type Name = C_Ast.namea
type Bool = bool
type CString = C_Ast.cString
type CChar = C_Ast.cChar
type CInteger = C_Ast.cInteger
type CFloat = C_Ast.cFloat
type CStructTag = C_Ast.cStructTag
type CUnaryOp = C_Ast.cUnaryOp
type 'a CStringLiteral = 'a C_Ast.cStringLiteral
type 'a CConstant = 'a C_Ast.cConstant
type ('a, 'b) Either = ('a, 'b) C_Ast.either
type CIntRepr = C_Ast.cIntRepr
type CIntFlag = C_Ast.cIntFlag
type CAssignOp = C_Ast.cAssignOp
type Comment = C_Ast.comment
(**)
type 'a Reversed = 'a
datatype CDeclrR = CDeclrR0 of C_Ast.ident C_Ast.optiona
                             * NodeInfo C_Ast.cDerivedDeclarator list Reversed
                             * NodeInfo C_Ast.cStringLiteral C_Ast.optiona
                             * NodeInfo C_Ast.cAttribute list
                             * NodeInfo
type 'a Maybe = 'a C_Ast.optiona
datatype 'a Located = Located of 'a * (Position * (Position * int))
(**)
fun CDeclrR ide l s a n = CDeclrR0 (ide, l, s, a, n)
val reverse = rev
val Nothing = C_Ast.None
val Just = C_Ast.Some
val False = false
val True = true
val Ident = C_Ast.Ident0
(**)
val CDecl_flat = fn l1 =&gt; C_Ast.CDecl l1 o map (fn (a, b, c) =&gt; ((a, b), c))
fun flat3 (a, b, c) = ((a, b), c)
fun maybe def f = fn C_Ast.None =&gt; def | C_Ast.Some x =&gt; f x 
val Reversed = I
(**)
val From_string =
    C_Ast.SS_base
  o C_Ast.ST
  o implode
  o map (fn s =&gt; ‚Äï ‚Äπprevent functions in üóè‚Äπ~~/src/HOL/String.thy‚Ä∫ of raising additional errors
                     (e.g., see the ML code associated to \&lt;^term&gt;‚ÄπString.asciis_of_literal‚Ä∫)‚Ä∫
          if Symbol.is_char s then s
          else if Symbol.is_utf8 s then translate_string (fn c =&gt; "\\" ^ string_of_int (ord c)) s
          else s)
  o Symbol.explode
val From_char_hd = hd o C_Ast.explode
(**)
val Namea = C_Ast.name
(**)
open C_Ast
fun flip f b a = f a b
open Basic_Library
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Environment">
<div class="head"><h1>Theory C_Environment</h1>
<span class="command">theory</span> <span class="name">C_Environment</span><br/>
<span class="keyword">imports</span> <a href="C_Lexer_Language.html"><span class="name">C_Lexer_Language</span></a> <a href="C_Ast.html"><span class="name">C_Ast</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπParsing Environment‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Environment</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Lexer_Language</span><span> </span><span>C_Ast</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The environment comes in two parts: a basic core structure, and a (thin) layer of
utilities. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/context.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Env = struct

type 'a markup_store = Position.T list * serial * 'a

type env_directives =
      (   ( string * Position.range -&gt; Context.generic -&gt; C_Lex.token list * Context.generic
          , C_Lex.token list)
        C_Scan.either
      * (string * Position.range -&gt; Context.generic -&gt; Context.generic))
    markup_store
  Symtab.table

(**)

datatype 'a parse_status = Parsed of 'a | Previous_in_stack

type markup_global = bool (*true: global*)

type markup_ident = { global : markup_global
                    , params : C_Ast.CDerivedDeclr list
                    , ret : C_Ast.CDeclSpec list parse_status }

type var_table = { tyidents : markup_global markup_store Symtab.table (*ident name*)
                                                                      Symtab.table (*internal
                                                                                     namespace*)
                 , idents : markup_ident markup_store Symtab.table (*ident name*) }

type 'antiq_language_list stream = ('antiq_language_list, C_Lex.token) C_Scan.either list

‚Äï ‚ÄπKey entry point environment to the C language‚Ä∫
type env_lang = { var_table : var_table ‚Äï ‚Äπcurrent active table in the scope‚Ä∫
                , scopes : (C_Ast.ident option * var_table) list  ‚Äï ‚Äπparent scope tables‚Ä∫
                , namesupply : int
                , stream_ignored : C_Antiquote.antiq stream
                , env_directives : env_directives }
(* NOTE: The distinction between type variable or identifier can not be solely made
         during the lexing process.
         Another pass on the parsed tree is required. *)

type error_lines = string list

type env_tree = { context : Context.generic
                , reports_text : C_Position.reports_text
                , error_lines : error_lines }

type rule_static = (env_tree -&gt; env_lang * env_tree) option

(**)

datatype comment_style = Comment_directive
                       | Comment_language

type env_propagation_reduce = int (*reduce rule number*) option (* NONE: shift action *)

type env_propagation_ctxt = env_propagation_reduce -&gt; Context.generic -&gt; Context.generic

type env_propagation_directive =
       env_propagation_reduce -&gt; env_directives -&gt; env_lang * env_tree -&gt; env_lang * env_tree

datatype env_propagation_bottom_up = Exec_annotation of env_propagation_ctxt
                                   | Exec_directive of env_propagation_directive

datatype env_propagation = Bottom_up (*during parsing*) of env_propagation_bottom_up
                         | Top_down (*after parsing*) of env_propagation_ctxt

type eval_node = Position.range
                 * env_propagation
                 * env_directives
                 * bool (* true: skip vacuous reduce rules *)

datatype eval_time = Lexing of Position.range
                               * (comment_style -&gt; Context.generic -&gt; Context.generic)
                   | Parsing of (Symbol_Pos.T list (* length = number of tokens to advance *) 
                                 * Symbol_Pos.T list (* length = number of steps back in stack *)) 
                                 * eval_node
                   | Never (* to be manually treated by the semantic back-end, and analyzed there *)

datatype antiq_language = Antiq_stack of C_Position.reports_text * eval_time
                        | Antiq_none of C_Lex.token

‚Äï ‚Äπ One of the key element of the structure is
\&lt;^ML_text&gt;‚Äπeval_time‚Ä∫, relevant for the generic annotation
module. ‚Ä∫

(**)

type ('LrTable_state, 'a, 'Position_T) stack_elem0 = 'LrTable_state
                                                     * ('a * 'Position_T * 'Position_T)
type ('LrTable_state, 'a, 'Position_T) stack0 = ('LrTable_state, 'a, 'Position_T) stack_elem0 list

type ('LrTable_state, 'svalue0, 'pos) rule_reduce0 =
       (('LrTable_state, 'svalue0, 'pos) stack0 * env_lang * eval_node) list
type ('LrTable_state, 'svalue0, 'pos) rule_reduce =
       int * ('LrTable_state, 'svalue0, 'pos) stack0 * eval_node list list
type ('LrTable_state, 'svalue0, 'pos) rule_reduce' =
       int * bool (*vacuous*) * ('LrTable_state, 'svalue0, 'pos) rule_reduce0

datatype ('LrTable_state, 'svalue0, 'pos) rule_type =
                               Void
                             | Shift
                             | Reduce of rule_static * ('LrTable_state, 'svalue0, 'pos) rule_reduce'

type ('LrTable_state, 'svalue0, 'pos) rule_ml =
  { rule_pos : 'pos * 'pos
  , rule_type : ('LrTable_state, 'svalue0, 'pos) rule_type }

(**)

type 'class_Pos rule_output0' = { output_pos : 'class_Pos option
                                , output_vacuous : bool
                                , output_env : rule_static }

type ('LrTable_state, 'svalue0, 'pos) rule_output0 =
                                         eval_node list list (* delayed *)
                                       * ('LrTable_state, 'svalue0, 'pos) rule_reduce0 (* actual *)
                                       * ('pos * 'pos) rule_output0'

type rule_output = C_Ast.class_Pos rule_output0'

(**)

datatype stream_lang_state = Stream_ident of Position.range * string
                           | Stream_string of (Position.range * string) list
                           | Stream_atomic
                           | Stream_regular

type T = { env_lang : env_lang
         , env_tree : env_tree
         , rule_output : rule_output
         , rule_input : C_Ast.class_Pos list * int
         , stream_hook : (Symbol_Pos.T list * Symbol_Pos.T list * eval_node) list list
         , stream_lang : stream_lang_state * (C_Antiquote.antiq * antiq_language list) stream }

(**)

datatype 'a tree = Tree of 'a * 'a tree list

type ('LrTable_state, 'a, 'Position_T) stack' =
     ('LrTable_state, 'a, 'Position_T) stack0
   * eval_node list list
   * ('Position_T * 'Position_T) list
   * ('LrTable_state, 'a, 'Position_T) rule_ml tree list

(**)

fun map_env_lang f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = f
                                 env_lang, env_tree = env_tree, rule_output = rule_output, 
                      rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang}

fun map_env_tree f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = env_lang, env_tree = f
                                                      env_tree, rule_output = rule_output, 
                      rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang}

fun map_rule_output f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = env_lang, env_tree = env_tree, rule_output = f
                                                                              rule_output,
                      rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang}

fun map_rule_input f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                      rule_input = f
                                   rule_input, stream_hook = stream_hook, stream_lang = stream_lang}

fun map_stream_hook f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                      rule_input = rule_input, stream_hook = f
                                                             stream_hook, stream_lang = stream_lang}

fun map_stream_lang f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                     {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                      rule_input = rule_input, stream_hook = stream_hook, stream_lang = f
                                                                                        stream_lang}

(**)

fun map_output_pos f {output_pos, output_vacuous, output_env} =
               {output_pos = f output_pos, output_vacuous = output_vacuous, output_env = output_env}

fun map_output_vacuous f {output_pos, output_vacuous, output_env} =
               {output_pos = output_pos, output_vacuous = f output_vacuous, output_env = output_env}

fun map_output_env f {output_pos, output_vacuous, output_env} =
               {output_pos = output_pos, output_vacuous = output_vacuous, output_env = f output_env}

(**)

fun map_tyidents f {tyidents, idents} =
                                        {tyidents = f tyidents, idents = idents}

fun map_idents f {tyidents, idents} =
                                        {tyidents = tyidents, idents = f idents}

(**)

fun map_var_table f {var_table, scopes, namesupply, stream_ignored, env_directives} =
                                  {var_table = f
                                               var_table, scopes = scopes, namesupply = namesupply, 
                                   stream_ignored = stream_ignored, env_directives = env_directives}

fun map_scopes f {var_table, scopes, namesupply, stream_ignored, env_directives} =
                                  {var_table = var_table, scopes = f
                                                                   scopes, namesupply = namesupply, 
                                   stream_ignored = stream_ignored, env_directives = env_directives}

fun map_namesupply f {var_table, scopes, namesupply, stream_ignored, env_directives} =
                                  {var_table = var_table, scopes = scopes, namesupply = f
                                                                                        namesupply, 
                                   stream_ignored = stream_ignored, env_directives = env_directives}

fun map_stream_ignored f {var_table, scopes, namesupply, stream_ignored, env_directives} =
                                  {var_table = var_table, scopes = scopes, namesupply = namesupply, 
                                   stream_ignored = f
                                                    stream_ignored, env_directives = env_directives}

fun map_env_directives f {var_table, scopes, namesupply, stream_ignored, env_directives} =
                                  {var_table = var_table, scopes = scopes, namesupply = namesupply, 
                                   stream_ignored = stream_ignored, env_directives = f
                                                                                     env_directives}

(**)

fun map_context f {context, reports_text, error_lines} =
                       {context = f context, reports_text = reports_text, error_lines = error_lines}

fun map_context' f {context, reports_text, error_lines} =
              let val (res, context) = f context
              in (res, {context = context, reports_text = reports_text, error_lines = error_lines})
              end

fun map_reports_text f {context, reports_text, error_lines} =
                       {context = context, reports_text = f reports_text, error_lines = error_lines}

fun map_error_lines f {context, reports_text, error_lines} =
                       {context = context, reports_text = reports_text, error_lines = f error_lines}

(**)

fun map_env_tree' f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                let val (res, env_tree) = f env_tree
                in (res, {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                    rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang})
                end

fun map_env_lang_tree f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                let val (env_lang, env_tree) = f env_lang env_tree
                in {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                    rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang}
                end

fun map_env_lang_tree' f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
                let val (res, (env_lang, env_tree)) = f env_lang env_tree
                in (res, {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
                    rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang})
                end

(**)

fun get_scopes (t : env_lang) = #scopes t

(**)

val empty_env_lang : env_lang = 
        {var_table = {tyidents = Symtab.make [], idents = Symtab.make []}, 
         scopes = [], namesupply = 0, stream_ignored = [],
         env_directives = Symtab.empty}
fun empty_env_tree context =
        {context = context, reports_text = [], error_lines = []}
val empty_rule_output : rule_output = 
        {output_pos = NONE, output_vacuous = true, output_env = NONE}
fun make env_lang stream_lang env_tree =
       { env_lang = env_lang
       , env_tree = env_tree
       , rule_output = empty_rule_output
       , rule_input = ([], 0)
       , stream_hook = []
       , stream_lang = ( Stream_regular
                       , map_filter (fn C_Scan.Right (C_Lex.Token (_, (C_Lex.Space, _))) =&gt; NONE
                                      | C_Scan.Right (C_Lex.Token (_, (C_Lex.Comment _, _))) =&gt; NONE
                                      | C_Scan.Right tok =&gt; SOME (C_Scan.Right tok)
                                      | C_Scan.Left antiq =&gt; SOME (C_Scan.Left antiq))
                                    stream_lang) }
fun string_of (env_lang : env_lang) = 
  let fun dest0 x f = x |&gt; Symtab.dest |&gt; map f
      fun dest {tyidents, idents} =
            (dest0 tyidents #1, dest0 idents (fn (i, (_,_,v)) =&gt;
                                               (i, if #global v then "global" else "local")))
  in \&lt;^make_string&gt; ( ("var_table", dest (#var_table env_lang))
                 , ("scopes", map (fn (id, i) =&gt;
                                    ( Option.map (fn C_Ast.Ident0 (i, _, _) =&gt;
                                                   C_Ast.meta_of_logic i)
                                                 id
                                    , dest i))
                                  (#scopes env_lang))
                 , ("namesupply", #namesupply env_lang)
                 , ("stream_ignored", #stream_ignored env_lang)) end

val namespace_typedef = "typedef"
val namespace_tag = "tag"
val namespace_enum = namespace_tag

(**)

val encode_positions =
     map (Position.dest
       #&gt; (fn pos =&gt; ((#line pos, #offset pos, #end_offset pos), #props pos)))
  #&gt; let open XML.Encode in list (pair (triple int int int) properties) end
  #&gt; YXML.string_of_body
  
val decode_positions =
     YXML.parse_body
  #&gt; let open XML.Decode in list (pair (triple int int int) properties) end
  #&gt; map ((fn ((line, offset, end_offset), props) =&gt;
           {line = line, offset = offset, end_offset = end_offset, props = props})
          #&gt; Position.make)

end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/context.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Env_Ext =
struct

local
fun map_tyidents' f = C_Env.map_var_table (C_Env.map_tyidents f)
fun map_tyidents f = C_Env.map_env_lang (map_tyidents' f)
in
fun map_tyidents_typedef f =
                       map_tyidents (Symtab.map_default (C_Env.namespace_typedef, Symtab.empty) f)
fun map_tyidents_enum f = map_tyidents (Symtab.map_default (C_Env.namespace_enum, Symtab.empty) f)
fun map_tyidents'_typedef f =
                        map_tyidents' (Symtab.map_default (C_Env.namespace_typedef, Symtab.empty) f)
fun map_tyidents'_enum f = map_tyidents' (Symtab.map_default (C_Env.namespace_enum, Symtab.empty) f)
end
fun map_idents' f = C_Env.map_var_table (C_Env.map_idents f)
fun map_idents f = C_Env.map_env_lang (map_idents' f)

(**)

fun map_var_table f = C_Env.map_env_lang (C_Env.map_var_table f)
fun map_scopes f = C_Env.map_env_lang (C_Env.map_scopes f)
fun map_namesupply f = C_Env.map_env_lang (C_Env.map_namesupply f)
fun map_stream_ignored f = C_Env.map_env_lang (C_Env.map_stream_ignored f)

(**)

local
fun get_tyidents' namespace (env_lang : C_Env.env_lang) =
  case Symtab.lookup (env_lang |&gt; #var_table |&gt; #tyidents) namespace of
    NONE =&gt; Symtab.empty
  | SOME t =&gt; t

fun get_tyidents namespace (t : C_Env.T) = get_tyidents' namespace (#env_lang t)
in
val get_tyidents_typedef = get_tyidents C_Env.namespace_typedef
val get_tyidents_enum = get_tyidents C_Env.namespace_enum
val get_tyidents'_typedef = get_tyidents' C_Env.namespace_typedef
val get_tyidents'_enum = get_tyidents' C_Env.namespace_enum
end

fun get_idents (t:C_Env.T) = #env_lang t |&gt; #var_table |&gt; #idents
fun get_idents' (env:C_Env.env_lang) = env |&gt; #var_table |&gt; #idents

(**)

fun get_var_table (t:C_Env.T) = #env_lang t |&gt; #var_table
fun get_scopes (t:C_Env.T) = #env_lang t |&gt; #scopes
fun get_namesupply (t:C_Env.T) = #env_lang t |&gt; #namesupply

(**)

fun map_output_pos f = C_Env.map_rule_output (C_Env.map_output_pos f)
fun map_output_vacuous f = C_Env.map_rule_output (C_Env.map_output_vacuous f)
fun map_output_env f = C_Env.map_rule_output (C_Env.map_output_env f)

(**)

fun get_output_pos (t : C_Env.T) = #rule_output t |&gt; #output_pos

(**)

fun map_context f = C_Env.map_env_tree (C_Env.map_context f)
fun map_reports_text f = C_Env.map_env_tree (C_Env.map_reports_text f)

(**)

fun get_context (t : C_Env.T) = #env_tree t |&gt; #context
fun get_reports_text (t : C_Env.T) = #env_tree t |&gt; #reports_text

(**)

fun map_env_directives' f {var_table, scopes, namesupply, stream_ignored, env_directives} =
  let val (res, env_directives) = f env_directives
  in (res, {var_table = var_table, scopes = scopes, namesupply = namesupply, 
                      stream_ignored = stream_ignored, env_directives = env_directives})
  end

(**)

fun map_stream_lang' f {env_lang, env_tree, rule_output, rule_input, stream_hook, stream_lang} =
  let val (res, stream_lang) = f stream_lang
  in (res, {env_lang = env_lang, env_tree = env_tree, rule_output = rule_output, 
            rule_input = rule_input, stream_hook = stream_hook, stream_lang = stream_lang})
  end

(**)

fun context_map (f : C_Env.env_tree -&gt; C_Env.env_tree) =
  C_Env.empty_env_tree #&gt; f #&gt; #context

fun context_map' (f : C_Env.env_tree -&gt; 'a * C_Env.env_tree) =
  C_Env.empty_env_tree #&gt; f #&gt; apsnd #context

(**)

fun list_lookup tab name = flat (map (fn (x, _, _) =&gt; x) (the_list (Symtab.lookup tab name)))

end

‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Parser_Language">
<div class="head"><h1>Theory C_Parser_Language</h1>
<span class="command">theory</span> <span class="name">C_Parser_Language</span><br/>
<span class="keyword">imports</span> <a href="C_Environment.html"><span class="name">C_Environment</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCore Language: Parsing Support (C Language without Annotations)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Parser_Language</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Environment</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ As mentioned in \&lt;^theory&gt;‚ÄπIsabelle_C.C_Ast‚Ä∫, Isabelle/C depends on
certain external parsing libraries, such as üóÄ‚Äπ../../src_ext/mlton‚Ä∫, and more
specifically üóÄ‚Äπ../../src_ext/mlton/lib/mlyacc-lib‚Ä∫. Actually, the sole theory
making use of the files in üóÄ‚Äπ../../src_ext/mlton/lib/mlyacc-lib‚Ä∫ is the present
üóè‚ÄπC_Parser_Language.thy‚Ä∫. (Any other remaining files in
üóÄ‚Äπ../../src_ext/mlton‚Ä∫ are not used by Isabelle/C, they come from the original
repository of MLton: üåê‚Äπhttps://github.com/MLton/mlton‚Ä∫.) ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπParsing Library (Including Semantic Functions)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Modified by Fr√©d√©ric Tuong, Universit√© Paris-Saclay
 *
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 *
 * Language.C
 * https://hackage.haskell.org/package/language-c
 *
 * Copyright (c) 1999-2017 Manuel M T Chakravarty
 *                         Duncan Coutts
 *                         Benedikt Huber
 * Portions Copyright (c) 1989,1990 James A. Roskind
 *
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 *
 * Language.C.Comments
 * https://hackage.haskell.org/package/language-c-comments
 *
 * Copyright (c) 2010-2014 Geoff Hulette
 *)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
signature C_GRAMMAR_RULE_LIB =
sig
  type arg = C_Env.T
  type 'a monad = arg -&gt; 'a * arg

  (* type aliases *)
  type class_Pos = C_Ast.class_Pos
  type reports_text0' = { markup : Markup.T, markup_body : string }
  type reports_text0 = reports_text0' list -&gt; reports_text0' list
  type ('a, 'b) reports_base = ('a C_Env.markup_store * Position.T list,
                                Position.T list * 'a C_Env.markup_store option) C_Ast.either -&gt;
                               Position.T list -&gt;
                               string -&gt;
                               'b -&gt;
                               'b
    (**)
  type NodeInfo = C_Ast.nodeInfo
  type CStorageSpec = NodeInfo C_Ast.cStorageSpecifier
  type CFunSpec = NodeInfo C_Ast.cFunctionSpecifier
  type CConst = NodeInfo C_Ast.cConstant
  type 'a CInitializerList = ('a C_Ast.cPartDesignator List.list * 'a C_Ast.cInitializer) List.list
  type CTranslUnit = NodeInfo C_Ast.cTranslationUnit
  type CExtDecl = NodeInfo C_Ast.cExternalDeclaration
  type CFunDef = NodeInfo C_Ast.cFunctionDef
  type CDecl = NodeInfo C_Ast.cDeclaration
  type CDeclr = NodeInfo C_Ast.cDeclarator
  type CDerivedDeclr = NodeInfo C_Ast.cDerivedDeclarator
  type CArrSize = NodeInfo C_Ast.cArraySize
  type CStat = NodeInfo C_Ast.cStatement
  type CAsmStmt = NodeInfo C_Ast.cAssemblyStatement
  type CAsmOperand = NodeInfo C_Ast.cAssemblyOperand
  type CBlockItem = NodeInfo C_Ast.cCompoundBlockItem
  type CDeclSpec = NodeInfo C_Ast.cDeclarationSpecifier
  type CTypeSpec = NodeInfo C_Ast.cTypeSpecifier
  type CTypeQual = NodeInfo C_Ast.cTypeQualifier
  type CAlignSpec = NodeInfo C_Ast.cAlignmentSpecifier
  type CStructUnion = NodeInfo C_Ast.cStructureUnion
  type CEnum = NodeInfo C_Ast.cEnumeration
  type CInit = NodeInfo C_Ast.cInitializer
  type CInitList = NodeInfo CInitializerList
  type CDesignator = NodeInfo C_Ast.cPartDesignator
  type CAttr = NodeInfo C_Ast.cAttribute
  type CExpr = NodeInfo C_Ast.cExpression
  type CBuiltin = NodeInfo C_Ast.cBuiltinThing
  type CStrLit = NodeInfo C_Ast.cStringLiteral
    (**)
  type ClangCVersion = C_Ast.clangCVersion
  type Ident = C_Ast.ident
  type Position = C_Ast.positiona
  type PosLength = Position * int
  type Name = C_Ast.namea
  type Bool = bool
  type CString = C_Ast.cString
  type CChar = C_Ast.cChar
  type CInteger = C_Ast.cInteger
  type CFloat = C_Ast.cFloat
  type CStructTag = C_Ast.cStructTag
  type CUnaryOp = C_Ast.cUnaryOp
  type 'a CStringLiteral = 'a C_Ast.cStringLiteral
  type 'a CConstant = 'a C_Ast.cConstant
  type ('a, 'b) Either = ('a, 'b) C_Ast.either
  type CIntRepr = C_Ast.cIntRepr
  type CIntFlag = C_Ast.cIntFlag
  type CAssignOp = C_Ast.cAssignOp
  type Comment = C_Ast.comment
    (**)
  type 'a Reversed = 'a C_Ast.Reversed
  type CDeclrR = C_Ast.CDeclrR
  type 'a Maybe = 'a C_Ast.optiona
  type 'a Located = 'a C_Ast.Located
    (**)
  structure List : sig val reverse : 'a list -&gt; 'a list end

  (* monadic operations *)
  val return : 'a -&gt; 'a monad
  val bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad
  val bind' : 'b monad -&gt; ('b -&gt; unit monad) -&gt; 'b monad
  val &gt;&gt; : unit monad * 'a monad -&gt; 'a monad

  (* position reports *)
  val markup_make : ('a -&gt; reports_text0' option) -&gt;
                    ('a -&gt; 'b) -&gt;
                    ('b option -&gt; string) -&gt;
                    ((Markup.T -&gt; reports_text0) -&gt;
                     bool -&gt;
                     ('b, 'b option * string * reports_text0) C_Ast.either -&gt;
                     reports_text0) -&gt;
                    ('a, C_Position.reports_text) reports_base
  val markup_tvar : (C_Env.markup_global, C_Position.reports_text) reports_base
  val markup_var_enum : (C_Env.markup_global, C_Position.reports_text) reports_base
  val markup_var : (C_Env.markup_ident, C_Position.reports_text) reports_base
  val markup_var_bound : (C_Env.markup_ident, C_Position.reports_text) reports_base
  val markup_var_improper : (C_Env.markup_ident, C_Position.reports_text) reports_base

  (* Language.C.Data.RList *)
  val empty : 'a list Reversed
  val singleton : 'a -&gt; 'a list Reversed
  val snoc : 'a list Reversed -&gt; 'a -&gt; 'a list Reversed
  val rappend : 'a list Reversed -&gt; 'a list -&gt; 'a list Reversed
  val rappendr : 'a list Reversed -&gt; 'a list Reversed -&gt; 'a list Reversed
  val rmap : ('a -&gt; 'b) -&gt; 'a list Reversed -&gt; 'b list Reversed

  (* Language.C.Data.Position *)
  val posOf : 'a -&gt; Position
  val posOf' : bool -&gt; class_Pos -&gt; Position * int
  val make_comment :
        Symbol_Pos.T list -&gt; Symbol_Pos.T list -&gt; Symbol_Pos.T list -&gt; Position.range -&gt; Comment

  (* Language.C.Data.Node *)
  val mkNodeInfo' : Position -&gt; PosLength -&gt; Name -&gt; NodeInfo
  val decode : NodeInfo -&gt; (class_Pos, string) Either
  val decode_error' : NodeInfo -&gt; Position.range

  (* Language.C.Data.Ident *)
  val quad : string list -&gt; int
  val ident_encode : string -&gt; int
  val ident_decode : int -&gt; string
  val mkIdent : Position * int -&gt; string -&gt; Name -&gt; Ident
  val internalIdent : string -&gt; Ident

  (* Language.C.Syntax.AST *)
  val liftStrLit : 'a CStringLiteral -&gt; 'a CConstant

  (* Language.C.Syntax.Constants *)
  val concatCStrings : CString list -&gt; CString

  (* Language.C.Parser.ParserMonad *)
  val getNewName : Name monad
  val shadowTypedef0'''' : string -&gt;
                           Position.T list -&gt;
                           C_Env.markup_ident -&gt;
                           C_Env.env_lang -&gt;
                           C_Env.env_tree -&gt;
                           C_Env.env_lang * C_Env.env_tree
  val shadowTypedef0' : C_Ast.CDeclSpec list C_Env.parse_status -&gt;
                        bool -&gt;
                        C_Ast.ident * C_Ast.CDerivedDeclr list -&gt;
                        C_Env.env_lang -&gt;
                        C_Env.env_tree -&gt;
                        C_Env.env_lang * C_Env.env_tree
  val isTypeIdent : string -&gt; arg -&gt; bool
  val enterScope : unit monad
  val leaveScope : unit monad
  val getCurrentPosition : Position monad

  (* Language.C.Parser.Tokens *)
  val CTokCLit : CChar -&gt; (CChar -&gt; 'a) -&gt; 'a
  val CTokILit : CInteger -&gt; (CInteger -&gt; 'a) -&gt; 'a
  val CTokFLit : CFloat -&gt; (CFloat -&gt; 'a) -&gt; 'a
  val CTokSLit : CString -&gt; (CString -&gt; 'a) -&gt; 'a

  (* Language.C.Parser.Parser *)
  val reverseList : 'a list -&gt; 'a list Reversed
  val L : 'a -&gt; int -&gt; 'a Located monad
  val unL : 'a Located -&gt; 'a
  val withNodeInfo : int -&gt; (NodeInfo -&gt; 'a) -&gt; 'a monad
  val withNodeInfo_CExtDecl : CExtDecl -&gt; (NodeInfo -&gt; 'a) -&gt; 'a monad
  val withNodeInfo_CExpr : CExpr list Reversed -&gt; (NodeInfo -&gt; 'a) -&gt; 'a monad
  val withLength : NodeInfo -&gt; (NodeInfo -&gt; 'a) -&gt; 'a monad
  val reverseDeclr : CDeclrR -&gt; CDeclr
  val withAttribute : int -&gt; CAttr list -&gt; (NodeInfo -&gt; CDeclrR) -&gt; CDeclrR monad
  val withAttributePF : int -&gt; CAttr list -&gt; (NodeInfo -&gt; CDeclrR -&gt; CDeclrR) -&gt;
                        (CDeclrR -&gt; CDeclrR) monad
  val appendObjAttrs : CAttr list -&gt; CDeclr -&gt; CDeclr
  val withAsmNameAttrs : CStrLit Maybe * CAttr list -&gt; CDeclrR -&gt; CDeclrR monad
  val appendDeclrAttrs : CAttr list -&gt; CDeclrR -&gt; CDeclrR
  val ptrDeclr : CDeclrR -&gt; CTypeQual list -&gt; NodeInfo -&gt; CDeclrR
  val funDeclr : CDeclrR -&gt; (Ident list, (CDecl list * Bool)) Either -&gt; CAttr list -&gt; NodeInfo -&gt;
                 CDeclrR
  val arrDeclr : CDeclrR -&gt; CTypeQual list -&gt; Bool -&gt; Bool -&gt; CExpr Maybe -&gt; NodeInfo -&gt; CDeclrR
  val liftTypeQuals : CTypeQual list Reversed -&gt; CDeclSpec list
  val liftCAttrs : CAttr list -&gt; CDeclSpec list
  val addTrailingAttrs : CDeclSpec list Reversed -&gt; CAttr list -&gt; CDeclSpec list Reversed
  val emptyDeclr : CDeclrR
  val mkVarDeclr : Ident -&gt; NodeInfo -&gt; CDeclrR
  val doDeclIdent : CDeclSpec list -&gt; CDeclrR -&gt; unit monad
  val ident_of_decl : (Ident list, CDecl list * bool) C_Ast.either -&gt;
                      (Ident * CDerivedDeclr list * CDeclSpec list) list
  val doFuncParamDeclIdent : CDeclr -&gt; unit monad
end

structure C_Grammar_Rule_Lib : C_GRAMMAR_RULE_LIB =
struct
  open C_Ast
  type arg = C_Env.T
  type 'a monad = arg -&gt; 'a * arg

  (**)
  type reports_text0' = { markup : Markup.T, markup_body : string }
  type reports_text0 = reports_text0' list -&gt; reports_text0' list
  type 'a reports_store = Position.T list * serial * 'a
  type ('a, 'b) reports_base = ('a C_Env.markup_store * Position.T list,
                                Position.T list * 'a C_Env.markup_store option) C_Ast.either -&gt;
                               Position.T list -&gt;
                               string -&gt;
                               'b -&gt;
                               'b
  fun markup_init markup = { markup = markup, markup_body = "" }
  val look_idents = C_Env_Ext.list_lookup o C_Env_Ext.get_idents
  val look_idents' = C_Env_Ext.list_lookup o C_Env_Ext.get_idents'
  val look_tyidents_typedef = C_Env_Ext.list_lookup o C_Env_Ext.get_tyidents_typedef
  val look_tyidents'_typedef = C_Env_Ext.list_lookup o C_Env_Ext.get_tyidents'_typedef
  val To_string0 = meta_of_logic
  val ident_encode =
    Word8Vector.foldl (fn (w, acc) =&gt; Word8.toInt w + acc * 256) 0 o Byte.stringToBytes
  fun ident_decode nb = radixpand (256, nb) |&gt; map chr |&gt; implode
  fun reverse l = rev l

  fun report _ [] _ = I
    | report markup ps x =
        let val ms = markup x
        in fold (fn p =&gt; fold (fn {markup, markup_body} =&gt; cons ((p, markup), markup_body)) ms) ps
        end

  fun markup_make typing get_global desc report' data =
   report
   (fn name =&gt;
    let 
      val (def, ps, id, global, typing) =
        case data of
          Left ((ps, id, param), ps' as _ :: _) =&gt;
            ( true
            , ps
            , id
            , Right ( SOME (get_global param)
                    , "Redefinition of " ^ quote name ^ Position.here_list ps
                 ‚Äï ‚ÄπAny positions provided here will be explicitly reported, which might not be the
                     desired effect. So we explicitly refer the reader to a separate tooltip.‚Ä∫
                                         ^ " (more details in the command modifier tooltip)"
                    , cons { markup = Markup.class_parameter
                           , markup_body = "redefining this" ^ Position.here_list ps' })
            , typing param)
        | Left ((ps, id, param), _) =&gt; (true, ps, id, Left (get_global param), typing param)
        | Right (_, SOME (ps, id, param)) =&gt; (false, ps, id, Left (get_global param), typing param)
        | Right (ps, _) =&gt; ( true
                           , ps
                           , serial ()
                           , Right (NONE, "Undeclared " ^ quote name ^ Position.here_list ps, I)
                           , NONE)
      fun markup_elem name = (name, (name, []): Markup.T)
      val (varN, var) = markup_elem (desc (case global of Left b =&gt; SOME b
                                                        | Right (SOME b, _, _) =&gt; SOME b
                                                        | _ =&gt; NONE));
      val entity = Markup.entity varN name
      val cons' = cons o markup_init
    in
     (cons' var
      #&gt; report' cons' def global
      #&gt; (case typing of NONE =&gt; I | SOME x =&gt; cons x))
       (map (fn pos =&gt;
              markup_init (Markup.properties (Position.entity_properties_of def id pos) entity))
            ps)
    end)

  fun markup_make' typing get_global desc report =
    markup_make
      typing
      get_global
      (fn global =&gt;
        "C " ^ (case global of SOME true =&gt; "global "
                             | SOME false =&gt; "local "
                             | NONE =&gt; "")
             ^ desc)
      (fn cons' =&gt; fn def =&gt;
       fn Left b =&gt; report cons' def b
        | Right (b, msg, f) =&gt; tap (fn _ =&gt; Output.information msg)
                            #&gt; f
                            #&gt; (case b of NONE =&gt; cons' Markup.free | SOME b =&gt; report cons' def b))

  fun markup_tvar0 desc =
    markup_make'
      (K NONE)
      I
      desc
      (fn cons' =&gt; fn def =&gt;
       fn true =&gt; cons' (if def then Markup.free else Markup.ML_keyword3)
        | false =&gt; cons' Markup.skolem)

  val markup_tvar = markup_tvar0 "type variable"
  val markup_var_enum = markup_tvar0 "enum tag"

  fun string_of_list f =
    (fn [] =&gt; NONE | [s] =&gt; SOME s | s =&gt; SOME ("[" ^ String.concatWith ", " s ^ "]"))
    o map f

  val string_of_cDeclarationSpecifier =
    fn C_Ast.CStorageSpec0 _ =&gt; "storage"
     | C_Ast.CTypeSpec0 t =&gt; (case t of 
                                 CVoidType0 _ =&gt; "void"
                               | CCharType0 _ =&gt; "char"
                               | CShortType0 _ =&gt; "short"
                               | CIntType0 _ =&gt; "int"
                               | CLongType0 _ =&gt; "long"
                               | CFloatType0 _ =&gt; "float"
                               | CDoubleType0 _ =&gt; "double"
                               | CSignedType0 _ =&gt; "signed"
                               | CUnsigType0 _ =&gt; "unsig"
                               | CBoolType0 _ =&gt; "bool"
                               | CComplexType0 _ =&gt; "complex"
                               | CInt128Type0 _ =&gt; "int128"
                               | CSUType0 _ =&gt; "SU"
                               | CEnumType0 _ =&gt; "enum"
                               | CTypeDef0 _ =&gt; "typedef"
                               | CTypeOfExpr0 _ =&gt; "type_of_expr"
                               | CTypeOfType0 _ =&gt; "type_of_type"
                               | CAtomicType0 _ =&gt; "atomic")
     | C_Ast.CTypeQual0 _ =&gt; "type_qual"
     | C_Ast.CFunSpec0 _ =&gt; "fun"
     | C_Ast.CAlignSpec0 _ =&gt; "align"

  fun typing {params, ret, ...} =
    SOME
    { markup = Markup.typing
    , markup_body =
       case
        ( string_of_list
           (fn C_Ast.CPtrDeclr0 _ =&gt; "pointer"
             | C_Ast.CArrDeclr0 _ =&gt; "array"
             | C_Ast.CFunDeclr0 (C_Ast.Left _, _, _) =&gt; "function [...] -&gt;"
             | C_Ast.CFunDeclr0 (C_Ast.Right (l_decl, _), _, _) =&gt;
                "function "
                ^ (String.concatWith
                    " -&gt; "
                    (map (fn CDecl0 ([decl], _, _) =&gt; string_of_cDeclarationSpecifier decl
                           | CDecl0 (l, _, _) =&gt; "(" ^ String.concatWith
                                                         " "
                                                         (map string_of_cDeclarationSpecifier l)
                                                     ^ ")"
                           | CStaticAssert0 _ =&gt; "static_assert")
                         l_decl))
                ^ " -&gt;")
           params
        , case ret of C_Env.Previous_in_stack =&gt; SOME "..."
                    | C_Env.Parsed ret =&gt; string_of_list string_of_cDeclarationSpecifier ret)
       of (NONE, NONE) =&gt; let val _ = warning "markup_var: Not yet implemented" in "" end
        | (SOME params, NONE) =&gt; params
        | (NONE, SOME ret) =&gt; ret
        | (SOME params, SOME ret) =&gt; params ^ " " ^ ret }

  val markup_var =
    markup_make'
      typing
      #global
      "variable"
      (fn cons' =&gt; fn def =&gt;
       fn true =&gt; if def then cons' Markup.free else cons' Markup.delimiter (*explicit black color,
                                                     otherwise the default color of constants might
                                                     be automatically chosen (especially in term
                                                     cartouches)*)
        | false =&gt; cons' Markup.bound)

  val markup_var_bound =
    markup_make' typing #global "variable" (fn cons' =&gt; K (K (cons' Markup.bound)))

  val markup_var_improper =
    markup_make' typing #global "variable" (fn cons' =&gt; K (K (cons' Markup.improper)))

  (**)
  val return = pair
  fun bind f g = f #-&gt; g
  fun bind' f g = bind f (fn r =&gt; bind (g r) (fn () =&gt; return r))
  fun a &gt;&gt; b = a #&gt; b o #2
  fun sequence_ f = fn [] =&gt; return ()
                     | x :: xs =&gt; f x &gt;&gt; sequence_ f xs

  (* Language.C.Data.RList *)
  val empty = []
  fun singleton x = [x]
  fun snoc xs x = x :: xs
  fun rappend xs ys = rev ys @ xs
  fun rappendr xs ys = ys @ xs
  val rmap = map
  val viewr = fn [] =&gt; error "viewr: empty RList"
               | x :: xs =&gt; (xs, x)

  (* Language.C.Data.Position *)
  val nopos = NoPosition
  fun posOf _ = NoPosition
  fun posOf' mk_range =
    (if mk_range then Position.range else I)
    #&gt; (fn (pos1, pos2) =&gt;
          let val {offset = offset, end_offset = end_offset, ...} = Position.dest pos1
          in ( Position offset (From_string (C_Env.encode_positions [pos1, pos2])) 0 0
             , end_offset - offset)
          end)
  fun posOf'' node env =
    let val (stack, len) = #rule_input env
        val (mk_range, (pos1a, pos1b)) = case node of Left i =&gt; (true, nth stack (len - i - 1))
                                                    | Right range =&gt; (false, range)
        val (pos2a, pos2b) = nth stack 0
    in ( (posOf' mk_range (pos1a, pos1b) |&gt; #1, posOf' true (pos2a, pos2b))
       , env |&gt; C_Env_Ext.map_output_pos (K (SOME (pos1a, pos2b)))
             |&gt; C_Env_Ext.map_output_vacuous (K false)) end
  val posOf''' = posOf'' o Left
  val internalPos = InternalPosition
  fun make_comment body_begin body body_end range =
    Commenta ( posOf' false range |&gt; #1
             , From_string (Symbol_Pos.implode (body_begin @ body @ body_end))
             , case body_end of [] =&gt; SingleLine | _ =&gt; MultiLine)

  (* Language.C.Data.Node *)
  val undefNode = OnlyPos nopos (nopos, ~1)
  fun mkNodeInfoOnlyPos pos = OnlyPos pos (nopos, ~1)
  fun mkNodeInfo pos name = NodeInfo pos (nopos, ~1) name
  val mkNodeInfo' = NodeInfo
  val decode =
   (fn OnlyPos0 range =&gt; range
     | NodeInfo0 (pos1, (pos2, len2), _) =&gt; (pos1, (pos2, len2)))
   #&gt; (fn (Position0 (_, s1, _, _), (Position0 (_, s2, _, _), _)) =&gt;
            (case (C_Env.decode_positions (To_string0 s1), C_Env.decode_positions (To_string0 s2))
             of ([pos1, _], [_, pos2]) =&gt; Left (Position.range (pos1, pos2))
              | _ =&gt; Right "Expecting 2 elements")
        | _ =&gt; Right "Invalid position")
  fun decode_error' x = case decode x of Left x =&gt; x | Right msg =&gt; error msg
  fun decode_error x = Right (decode_error' x)
  val nameOfNode = fn OnlyPos0 _ =&gt; NONE
                    | NodeInfo0 (_, _, name) =&gt; SOME name

  (* Language.C.Data.Ident *)
  local
    val bits7 = Integer.pow 7 2
    val bits14 = Integer.pow 14 2
    val bits21 = Integer.pow 21 2
    val bits28 = Integer.pow 28 2
  in
  fun quad s = case s of
    [] =&gt; 0
  | c1 :: [] =&gt; ord c1
  | c1 :: c2 :: [] =&gt; ord c2 * bits7 + ord c1
  | c1 :: c2 :: c3 :: [] =&gt; ord c3 * bits14 + ord c2 * bits7 + ord c1
  | c1 :: c2 :: c3 :: c4 :: s =&gt; ((ord c4 * bits21
                                   + ord c3 * bits14
                                   + ord c2 * bits7
                                   + ord c1)
                                  mod bits28)
                                 + (quad s mod bits28)
  end

  local
    fun internalIdent0 pos s = Ident (From_string s, ident_encode s, pos)
  in
  fun mkIdent (pos, len) s name = internalIdent0 (mkNodeInfo' pos (pos, len) name) s
  val internalIdent = internalIdent0 (mkNodeInfoOnlyPos internalPos)
  end

  (* Language.C.Syntax.AST *)
  fun liftStrLit (CStrLit0 (str, at)) = CStrConst str at

  (* Language.C.Syntax.Constants *)
  fun concatCStrings cs =
        CString0 (flattena (map (fn CString0 (s,_) =&gt; s) cs), exists (fn CString0 (_, b) =&gt; b) cs)

  (* Language.C.Parser.ParserMonad *)
  fun getNewName env =
    (Namea (C_Env_Ext.get_namesupply env), C_Env_Ext.map_namesupply (fn x =&gt; x + 1) env)

  fun addTypedef (Ident0 (_, i, node)) env =
    let val name = ident_decode i
        val pos1 = [decode_error' node |&gt; #1]
        val data = (pos1, serial (), null (C_Env_Ext.get_scopes env))
    in ((), env |&gt; C_Env_Ext.map_idents (Symtab.delete_safe name)
                |&gt; C_Env_Ext.map_tyidents_typedef (Symtab.update (name, data))
                |&gt; C_Env_Ext.map_reports_text
                     (markup_tvar
                       (Left (data, flat [ look_idents env name, look_tyidents_typedef env name ]))
                       pos1
                       name))
    end
  fun shadowTypedef0''' name pos data0 env_lang env_tree =
    let val data = (pos, serial (), data0)
        val update_id = Symtab.update (name, data)
    in ( env_lang |&gt; C_Env_Ext.map_tyidents'_typedef (Symtab.delete_safe name)
                  |&gt; C_Env_Ext.map_idents' update_id
       , update_id
       , env_tree
          |&gt; C_Env.map_reports_text
               (markup_var (Left (data, flat [ look_idents' env_lang name
                                             , look_tyidents'_typedef env_lang name ]))
                           pos
                           name))
    end
  fun shadowTypedef0'''' name pos data0 env_lang env_tree =
    let val (env_lang, _, env_tree) = shadowTypedef0''' name pos data0 env_lang env_tree
    in ( env_lang, env_tree) end
  fun shadowTypedef0'' ret global (Ident0 (_, i, node), params) =
    shadowTypedef0''' (ident_decode i)
                      [decode_error' node |&gt; #1]
                      {global = global, params = params, ret = ret}
  fun shadowTypedef0' ret global ident env_lang env_tree =
    let val (env_lang, _, env_tree) = shadowTypedef0'' ret global ident env_lang env_tree 
    in (env_lang, env_tree) end
  fun shadowTypedef0 ret global f ident env =
    let val (update_id, env) =
          C_Env.map_env_lang_tree'
            (fn env_lang =&gt; fn env_tree =&gt; 
              let val (env_lang, update_id, env_tree) =
                        shadowTypedef0'' ret global ident env_lang env_tree 
              in (update_id, (env_lang, env_tree)) end)
            env
    in ((), f update_id env) end
  fun shadowTypedef_fun ident env =
    shadowTypedef0 C_Env.Previous_in_stack
                   (case C_Env_Ext.get_scopes env of _ :: [] =&gt; true | _ =&gt; false)
                   (fn update_id =&gt;
                    C_Env_Ext.map_scopes
                     (fn (NONE, x) :: xs =&gt; (SOME (fst ident), C_Env.map_idents update_id x) :: xs
                       | (SOME _, _) :: _ =&gt; error "Not yet implemented"
                       | [] =&gt; error "Not expecting an empty scope"))
                   ident
                   env
  fun shadowTypedef (i, params, ret) env =
    shadowTypedef0 (C_Env.Parsed ret) (List.null (C_Env_Ext.get_scopes env)) (K I) (i, params) env
  fun isTypeIdent s0 = Symtab.exists (fn (s1, _) =&gt; s0 = s1) o C_Env_Ext.get_tyidents_typedef
  fun enterScope env =
    ((), C_Env_Ext.map_scopes (cons (NONE, C_Env_Ext.get_var_table env)) env)
  fun leaveScope env = 
    case C_Env_Ext.get_scopes env of
      [] =&gt; error "leaveScope: already in global scope"
    | (_, var_table) :: scopes =&gt; ((), env |&gt; C_Env_Ext.map_scopes (K scopes)
                                           |&gt; C_Env_Ext.map_var_table (K var_table))
  val getCurrentPosition = return NoPosition

  (* Language.C.Parser.Tokens *)
  fun CTokCLit x f = x |&gt; f
  fun CTokILit x f = x |&gt; f
  fun CTokFLit x f = x |&gt; f
  fun CTokSLit x f = x |&gt; f

  (* Language.C.Parser.Parser *)
  fun reverseList x = rev x
  fun L a i = posOf''' i #&gt;&gt; curry Located a
  fun unL (Located (a, _)) = a
  fun withNodeInfo00 (pos1, (pos2, len2)) mkAttrNode name =
    return (mkAttrNode (NodeInfo pos1 (pos2, len2) name))
  fun withNodeInfo0 x = x |&gt; bind getNewName oo withNodeInfo00
  fun withNodeInfo0' node mkAttrNode env = let val (range, env) = posOf'' node env
                                           in withNodeInfo0 range mkAttrNode env end
  fun withNodeInfo x = x |&gt; withNodeInfo0' o Left
  fun withNodeInfo' x = x |&gt; withNodeInfo0' o decode_error
  fun withNodeInfo_CExtDecl x = x |&gt;
    withNodeInfo' o (fn CDeclExt0 (CDecl0 (_, _, node)) =&gt; node
                      | CDeclExt0 (CStaticAssert0 (_, _, node)) =&gt; node
                      | CFDefExt0 (CFunDef0 (_, _, _, _, node)) =&gt; node
                      | CAsmExt0 (_, node) =&gt; node)
  val get_node_CExpr =
    fn CComma0 (_, a) =&gt; a | CAssign0 (_, _, _, a) =&gt; a | CCond0 (_, _, _, a) =&gt; a |
    CBinary0 (_, _, _, a) =&gt; a | CCast0 (_, _, a) =&gt; a | CUnary0 (_, _, a) =&gt; a |
    CSizeofExpr0 (_, a) =&gt; a | CSizeofType0 (_, a) =&gt; a | CAlignofExpr0 (_, a) =&gt; a |
    CAlignofType0 (_, a) =&gt; a | CComplexReal0 (_, a) =&gt; a | CComplexImag0 (_, a) =&gt; a |
    CIndex0 (_, _, a) =&gt; a |
    CCall0 (_, _, a) =&gt; a | CMember0 (_, _, _, a) =&gt; a | CVar0 (_, a) =&gt; a | CConst0 c =&gt; (case c of
    CIntConst0 (_, a) =&gt; a | CCharConst0 (_, a) =&gt; a | CFloatConst0 (_, a) =&gt; a |
    CStrConst0 (_, a) =&gt; a) |
    CCompoundLit0 (_, _, a) =&gt; a | CGenericSelection0 (_, _, a) =&gt; a | CStatExpr0 (_, a) =&gt; a |
    CLabAddrExpr0 (_, a) =&gt; a | CBuiltinExpr0 cBuiltinThing =&gt; (case cBuiltinThing
     of CBuiltinVaArg0 (_, _, a) =&gt; a
     | CBuiltinOffsetOf0 (_, _, a) =&gt; a
     | CBuiltinTypesCompatible0 (_, _, a) =&gt; a)
  fun withNodeInfo_CExpr x = x |&gt; withNodeInfo' o get_node_CExpr o hd
  fun withLength node mkAttrNode =
    bind (posOf'' (decode_error node)) (fn range =&gt; 
      withNodeInfo00 range mkAttrNode (case nameOfNode node of NONE =&gt; error "nameOfNode"
                                                             | SOME name =&gt; name))
  fun reverseDeclr (CDeclrR0 (ide, reversedDDs, asmname, cattrs, at)) =
                    CDeclr ide (rev reversedDDs) asmname cattrs at
  fun appendDeclrAttrs newAttrs (CDeclrR0 (ident, l, asmname, cattrs, at)) =
    case l of
      [] =&gt; CDeclrR ident empty asmname (cattrs @ newAttrs) at
    | x :: xs =&gt;
      let
        val appendAttrs =
          fn CPtrDeclr0 (typeQuals, at) =&gt; CPtrDeclr (typeQuals @ map CAttrQual newAttrs) at
           | CArrDeclr0 (typeQuals, arraySize, at) =&gt; CArrDeclr (typeQuals @ map CAttrQual newAttrs)
                                                                arraySize
                                                                at
           | CFunDeclr0 (parameters, cattrs, at) =&gt; CFunDeclr parameters (cattrs @ newAttrs) at
      in CDeclrR ident (appendAttrs x :: xs) asmname cattrs at end
  fun withAttribute node cattrs mkDeclrNode =
    bind (posOf''' node) (fn (pos, _) =&gt;
    bind getNewName (fn name =&gt;
        let val attrs = mkNodeInfo pos name
            val newDeclr = appendDeclrAttrs cattrs (mkDeclrNode attrs)
        in return newDeclr end))
  fun withAttributePF node cattrs mkDeclrCtor =
    bind (posOf''' node) (fn (pos, _) =&gt;
    bind getNewName (fn name =&gt;
        let val attrs = mkNodeInfo pos name
            val newDeclr = appendDeclrAttrs cattrs o mkDeclrCtor attrs
        in return newDeclr end))
  fun appendObjAttrs newAttrs (CDeclr0 (ident, indirections, asmname, cAttrs, at)) =
    CDeclr ident indirections asmname (cAttrs @ newAttrs) at
  fun appendObjAttrsR newAttrs (CDeclrR0 (ident, indirections, asmname, cAttrs, at)) =
    CDeclrR ident indirections asmname (cAttrs @ newAttrs) at
  fun setAsmName mAsmName (CDeclrR0 (ident, indirections, oldName, cattrs, at)) =
    case (case (mAsmName, oldName)
          of (None, None) =&gt; Right None
           | (None, oldname as Some _) =&gt; Right oldname
           | (newname as Some _, None) =&gt; Right newname
           | (Some n1, Some n2) =&gt; Left (n1, n2))
    of
      Left (n1, n2) =&gt; let fun showName (CStrLit0 (CString0 (s, _), _)) = To_string0 s
                       in error ("Duplicate assembler name: " ^ showName n1 ^ " " ^ showName n2) end
    | Right newName =&gt; return (CDeclrR ident indirections newName cattrs at)
  fun withAsmNameAttrs (mAsmName, newAttrs) declr =
        setAsmName mAsmName (appendObjAttrsR newAttrs declr)
  fun ptrDeclr (CDeclrR0 (ident, derivedDeclrs, asmname, cattrs, dat)) tyquals at =
    CDeclrR ident (snoc derivedDeclrs (CPtrDeclr tyquals at)) asmname cattrs dat
  fun funDeclr (CDeclrR0 (ident, derivedDeclrs, asmname, dcattrs, dat)) params cattrs at =
    CDeclrR ident (snoc derivedDeclrs (CFunDeclr params cattrs at)) asmname dcattrs dat
  fun arrDeclr (CDeclrR0 (ident, derivedDeclrs, asmname, cattrs, dat))
               tyquals
               var_sized
               static_size
               size_expr_opt
               at =
    CDeclrR ident
            (snoc
               derivedDeclrs
               (CArrDeclr tyquals (case size_expr_opt of
                                     Some e =&gt; CArrSize static_size e
                                   | None =&gt; CNoArrSize var_sized) at))
            asmname
            cattrs
            dat
  val liftTypeQuals = map CTypeQual o reverse
  val liftCAttrs = map (CTypeQual o CAttrQual)
  fun addTrailingAttrs declspecs new_attrs =
    case viewr declspecs of
      (specs_init, CTypeSpec0 (CSUType0 (CStruct0 (tag, name, Some def, def_attrs, su_node), node)))
      =&gt;
        snoc
          specs_init
          (CTypeSpec (CSUType (CStruct tag name (Just def) (def_attrs @ new_attrs) su_node) node))
    | (specs_init, CTypeSpec0 (CEnumType0 (CEnum0 (name, Some def, def_attrs, e_node), node))) =&gt; 
        snoc
          specs_init
          (CTypeSpec (CEnumType (CEnum name (Just def) (def_attrs @ new_attrs) e_node) node))
    | _ =&gt; rappend declspecs (liftCAttrs new_attrs)
  val emptyDeclr = CDeclrR Nothing empty Nothing [] undefNode
  fun mkVarDeclr ident = CDeclrR (Some ident) empty Nothing []
  fun doDeclIdent declspecs (decl as CDeclrR0 (mIdent, _, _, _, _)) =
    case mIdent of
      None =&gt; return ()
    | Some ident =&gt;
       if exists (fn CStorageSpec0 (CTypedef0 _) =&gt; true | _ =&gt; false) declspecs
       then addTypedef ident
       else shadowTypedef ( ident
                          , case reverseDeclr decl of CDeclr0 (_, params, _, _, _) =&gt; params
                          , declspecs)

  val ident_of_decl =
    fn Left params =&gt; map (fn i =&gt; (i, [], [])) params
     | Right (params, _) =&gt;
        maps (fn CDecl0 (ret, l, _) =&gt;
                   maps (fn ((Some (CDeclr0 (Some mIdent, params, _, _, _)),_),_) =&gt;
                              [(mIdent, params, ret)]
                          | _ =&gt; [])
                        l
               | _ =&gt; [])
             params

  local
  fun sequence_' f = sequence_ f o ident_of_decl
  val is_fun = fn CFunDeclr0 _ =&gt; true | _ =&gt; false
  in
  fun doFuncParamDeclIdent (CDeclr0 (mIdent0, param0, _, _, node0)) =
    let
      val (param_not_fun, param0') = chop_prefix (not o is_fun) param0
      val () =
        if null param_not_fun then ()
        else
          Output.information
            ("Not a function"
             ^ Position.here
                 (decode_error' (case mIdent0 of None =&gt; node0
                                               | Some (Ident0 (_, _, node)) =&gt; node) |&gt; #1))
      val (param_fun, param0') = chop_prefix is_fun param0'
    in
      (case mIdent0 of None =&gt; return ()
                     | Some mIdent0 =&gt; shadowTypedef_fun (mIdent0, param0))
      &gt;&gt;
      sequence_ shadowTypedef
                (maps (fn CFunDeclr0 (params, _, _) =&gt; ident_of_decl params | _ =&gt; []) param_fun)
      &gt;&gt;
      sequence_
        (fn CFunDeclr0 (params, _, _) =&gt;
            C_Env.map_env_tree
              (pair Symtab.empty
               #&gt; sequence_'
                  (fn (Ident0 (_, i, node), params, ret) =&gt; fn (env_lang, env_tree) =&gt; pair ()
                    let
                      val name = ident_decode i
                      val pos = [decode_error' node |&gt; #1]
                      val data = ( pos
                                 , serial ()
                                 , {global = false, params = params, ret = C_Env.Parsed ret})
                    in
                      ( env_lang |&gt; Symtab.update (name, data)
                      , env_tree
                          |&gt; C_Env.map_reports_text
                               (markup_var_improper
                                 (Left (data, C_Env_Ext.list_lookup env_lang name))
                                 pos
                                 name))
                    end)
                  params
               #&gt; #2 o #2)
            #&gt; pair ()
          | _ =&gt; return ())
        param0'
    end
  end

  (**)
  structure List = struct val reverse = rev end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMiscellaneous‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/document_antiquotations.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Thy/document_antiquotations.ML
    Author:     Makarius

Miscellaneous document antiquotations.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure ML_Document_Antiquotations =
struct

(* ML text *)

local

fun ml_text name ml =
  Thy_Output.antiquotation_raw_embedded name (Scan.lift Args.text_input ‚Äï ‚ÄπTODO: enable reporting with \&lt;^ML_type&gt;‚ÄπToken.file‚Ä∫ as in \&lt;^ML&gt;‚ÄπResources.parse_files‚Ä∫‚Ä∫)
    (fn ctxt =&gt; fn text =&gt;
      let val file_content =
            Token.file_source
              (Command.read_file (Resources.master_directory (Proof_Context.theory_of ctxt))
                                 Position.none
                                 (Path.explode (#1 (Input.source_content text))))
          val _ = (*TODO: avoid multiple file scanning*)
            ML_Context.eval_in (SOME ctxt) ML_Compiler.flags Position.none (* ‚Üê (optionally)
                                                                              disabling a potential
                                                                              double report*)
                                                                           (ml file_content)
      in file_content
         |&gt; Input.source_explode
         |&gt; Source.of_list
         |&gt; Source.source
              Symbol_Pos.stopper
                (Scan.bulk (Symbol_Pos.scan_comment "" &gt;&gt; (C_Scan.Left o pair true)
                            || Scan.many1 (Symbol.is_ascii_blank o Symbol_Pos.symbol)
                                 &gt;&gt; (C_Scan.Left o pair false)
                            || Scan.one (not o Symbol_Pos.is_eof) &gt;&gt; C_Scan.Right))
         |&gt; Source.exhaust
         |&gt; drop_prefix (fn C_Scan.Left _ =&gt; true | _ =&gt; false)
         |&gt; drop_suffix (fn C_Scan.Left (false, _) =&gt; true | _ =&gt; false)
         |&gt; maps (fn C_Scan.Left (_, x) =&gt; x | C_Scan.Right x =&gt; [x])
         |&gt; Symbol_Pos.implode
         |&gt; enclose "\n" "\n"
         |&gt; cartouche
         |&gt; Thy_Output.output_source ctxt
         |&gt; Thy_Output.isabelle ctxt
      end);

fun ml_enclose bg en source =
  ML_Lex.read bg @ ML_Lex.read_source source @ ML_Lex.read en;

in

val _ = Theory.setup (ml_text \&lt;^binding&gt;‚ÄπML_file‚Ä∫ (ml_enclose "" ""));

end;

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLoading the Grammar Simulator‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The parser consists of a generic module
üóè‚Äπ../../src_ext/mlton/lib/mlyacc-lib/base.sig‚Ä∫, which interprets an
automata-like format generated from ML-Yacc. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../../src_ext/mlton/lib/mlyacc-lib/base.sig"</span></span></span><span> </span><span class="comment">‚Äï
‚Äπ\&lt;^ML_file&gt;‚Äπ../../src_ext/mlton/lib/mlyacc-lib/base.sig‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../../src_ext/mlton/lib/mlyacc-lib/join.sml"</span></span></span><span> </span><span class="comment">‚Äï
‚Äπ\&lt;^ML_file&gt;‚Äπ../../src_ext/mlton/lib/mlyacc-lib/join.sml‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../../src_ext/mlton/lib/mlyacc-lib/lrtable.sml"</span></span></span><span> </span><span class="comment">‚Äï
‚Äπ\&lt;^ML_file&gt;‚Äπ../../src_ext/mlton/lib/mlyacc-lib/lrtable.sml‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../../src_ext/mlton/lib/mlyacc-lib/stream.sml"</span></span></span><span> </span><span class="comment">‚Äï
‚Äπ\&lt;^ML_file&gt;‚Äπ../../src_ext/mlton/lib/mlyacc-lib/stream.sml‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../../src_ext/mlton/lib/mlyacc-lib/parser1.sml"</span></span></span><span> </span><span class="comment">‚Äï
‚Äπ\&lt;^ML_file&gt;‚Äπ../../src_ext/mlton/lib/mlyacc-lib/parser1.sml‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLoading the Generated Grammar (SML signature)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../generated/c_grammar_fun.grm.sig"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπOverloading Grammar Rules (Optional Part)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar_Rule_Wrap_Overloading = struct
open C_Grammar_Rule_Lib

fun update_env_bottom_up f x arg = ((), C_Env.map_env_lang_tree (f x) arg)
fun update_env_top_down f x =
  pair () ##&gt; (fn arg =&gt; C_Env_Ext.map_output_env (K (SOME (f x (#env_lang arg)))) arg)

(*type variable (report bound)*)

val specifier3 : (CDeclSpec list) -&gt; unit monad =
  update_env_bottom_up
    (fn l =&gt; fn env_lang =&gt; fn env_tree =&gt;
      ( env_lang
      , fold
          let open C_Ast
          in fn CTypeSpec0 (CTypeDef0 (Ident0 (_, i, node), _)) =&gt;
                let val name = ident_decode i
                    val pos1 = [decode_error' node |&gt; #1]
                in 
                  C_Env.map_reports_text
                    (markup_tvar
                      (Right (pos1, Symtab.lookup (C_Env_Ext.get_tyidents'_typedef env_lang) name))
                      pos1
                      name)
                end
              | _ =&gt; I
          end
          l
          env_tree))
val declaration_specifier3 : (CDeclSpec list) -&gt; unit monad = specifier3
val type_specifier3 : (CDeclSpec list) -&gt; unit monad = specifier3


(*basic variable (report bound)*)

val primary_expression1 : (CExpr) -&gt; unit monad =
  update_env_bottom_up
    (fn e =&gt; fn env_lang =&gt; fn env_tree =&gt;
      ( env_lang
      , let open C_Ast
        in fn CVar0 (Ident0 (_, i, node), _) =&gt;
              let val name = ident_decode i
                  val pos1 = [decode_error' node |&gt; #1]
              in 
                C_Env.map_reports_text
                  (markup_var
                    (Right (pos1, Symtab.lookup (C_Env_Ext.get_idents' env_lang) name))
                    pos1
                    name)
              end
            | _ =&gt; I
        end
          e
          env_tree))


(*basic variable, parameter functions (report bound)*)

val declarator1 : (CDeclrR) -&gt; unit monad =
  update_env_bottom_up
    (fn d =&gt; fn env_lang =&gt; fn env_tree =&gt;
      ( env_lang
      , let open C_Ast
            fun markup markup_var params =
             pair Symtab.empty
             #&gt; fold
                  (fn (Ident0 (_, i, node), params, ret) =&gt; fn (env_lang, env_tree) =&gt;
                    let
                      val name = ident_decode i
                      val pos = [decode_error' node |&gt; #1]
                      val data = ( pos
                                 , serial ()
                                 , {global = false, params = params, ret = C_Env.Parsed ret})
                    in
                      ( env_lang |&gt; Symtab.update (name, data)
                      , env_tree
                          |&gt; C_Env.map_reports_text
                               (markup_var (Left (data, C_Env_Ext.list_lookup env_lang name))
                                           pos
                                           name))
                    end)
                  (ident_of_decl params)
             #&gt; #2
        in fn CDeclrR0 (_, param0, _, _, _) =&gt;
          (case rev param0 of
            CFunDeclr0 (params, _, _) :: param0 =&gt;
              pair param0 o markup markup_var_bound params
          | param0 =&gt; pair param0)
            #-&gt;
            fold
             (fn CFunDeclr0 (params, _, _) =&gt; markup markup_var_improper params
               | _ =&gt; I)
        end
          d
          env_tree))


(*old style syntax for functions (legacy feature)*)

val external_declaration1 : (CExtDecl) -&gt; unit monad =
  update_env_bottom_up (fn f =&gt; fn env_lang =&gt; fn env_tree =&gt;
    ( env_lang
    , let open C_Ast
      in fn CFDefExt0 (CFunDef0 (_, _, l, _, node)) =&gt; 
            if null l then
              I
            else
              tap (fn _ =&gt; legacy_feature ("Scope analysing for old function syntax not implemented"
                                           ^ Position.here (decode_error' node |&gt; #1)))
          | _ =&gt; I
      end
        f
        env_tree))


(*(type) enum, struct, union (report define &amp; report bound)*)

fun report_enum_bound i' node env_lang =
  let open C_Ast
      val name = ident_decode i'
      val pos1 = [decode_error' node |&gt; #1]
  in
    C_Env.map_reports_text
      (markup_var_enum
        (Right (pos1, Symtab.lookup (C_Env_Ext.get_tyidents'_enum env_lang) name)) pos1 name)
  end

local
val look_tyidents'_enum = C_Env_Ext.list_lookup o C_Env_Ext.get_tyidents'_enum
val declaration : (CDecl) -&gt; unit monad =
  update_env_bottom_up
    (fn decl =&gt; fn env_lang =&gt; fn env_tree =&gt;
      let open C_Ast
      in
       fn CDecl0 (l, _, _) =&gt;
          fold
            (fn CTypeSpec0 (CEnumType0 (CEnum0 (Some (Ident0 (_, i, node)), body, _, _), _)) =&gt;
                (case body of
                   None =&gt; (fn (env_lang, env_tree) =&gt;
                             (env_lang, report_enum_bound i node env_lang env_tree))
                 | Some _ =&gt;
                    fn (env_lang, env_tree) =&gt;
                     let val name = ident_decode i
                         val pos1 = [decode_error' node |&gt; #1]
                         val data = (pos1, serial (), null (C_Env.get_scopes env_lang))
                     in
                       ( C_Env_Ext.map_tyidents'_enum (Symtab.update (name, data)) env_lang
                       , C_Env.map_reports_text
                           (markup_var_enum
                             (Left (data, look_tyidents'_enum env_lang name))
                             pos1
                             name)
                           env_tree)
                     end)
              | _ =&gt; I)
            l
        | _ =&gt; I
      end
        decl
        (env_lang, env_tree))
in
val declaration1 = declaration
val declaration2 = declaration
val declaration3 = declaration
end


(*(basic) enum, struct, union (report define)*)

local
val enumerator : ( ( Ident * CExpr Maybe ) ) -&gt; unit monad =
  update_env_bottom_up
    (fn id =&gt; fn env_lang =&gt;
      let open C_Ast
      in
        fn (ident as Ident0 (_, _, node), _) =&gt;
          C_Grammar_Rule_Lib.shadowTypedef0'
            (C_Env.Parsed [CTypeSpec0 (CIntType0 node)])
            (null (C_Env.get_scopes env_lang))
            (ident, [])
            env_lang
      end
        id)
in
val enumerator1 = enumerator
val enumerator2 = enumerator
val enumerator3 = enumerator
val enumerator4 = enumerator
end


(*(type) enum, struct, union (report bound)*)

local
fun declaration_specifier env_lang =
  let open C_Ast
  in
    fold
      (fn CTypeSpec0 (CEnumType0 (CEnum0 (Some (Ident0 (_, i, node)), _, _, _), _)) =&gt; 
          report_enum_bound i node env_lang
        | _ =&gt; I)
  end
in
val declaration_specifier2 : (CDeclSpec list) -&gt; unit monad =
  update_env_bottom_up
    (fn d =&gt; fn env_lang =&gt; fn env_tree =&gt;
      let open C_Ast
      in
      ( env_lang
      , env_tree |&gt;
         (if exists (fn CStorageSpec0 (CTypedef0 _) =&gt; true | _ =&gt; false) d then
            I
          else
            declaration_specifier env_lang d))
      end)

local
val f_definition : (CFunDef) -&gt; unit monad =
  update_env_bottom_up
    (fn d =&gt; fn env_lang =&gt; fn env_tree =&gt;
      ( env_lang
      , let open C_Ast
        in
         fn CFunDef0 (l, _, _, _, _) =&gt; declaration_specifier env_lang l
        end
          d
          env_tree))
in
val function_definition4 = f_definition
val nested_function_definition2 = f_definition
end

local
val parameter_type_list : ( ( CDecl list * Bool ) ) -&gt; unit monad =
  update_env_bottom_up
    (fn d =&gt; fn env_lang =&gt; fn env_tree =&gt;
      ( env_lang
      , let open C_Ast
        in
         #1 #&gt; fold (fn CDecl0 (l, _, _) =&gt; declaration_specifier env_lang l | _ =&gt; I)
        end
          d
          env_tree))
in
val parameter_type_list2 = parameter_type_list
val parameter_type_list3 = parameter_type_list
end
end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar_Rule_Wrap = struct
  open C_Grammar_Rule_Wrap
  open C_Grammar_Rule_Wrap_Overloading
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLoading the Generated Grammar (SML structure)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../generated/c_grammar_fun.grm.sml"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGrammar Initialization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFunctor Application‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar = C_Grammar_Fun (structure Token = LALR_Parser_Eval.Token)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMapping Strings to Structured Tokens‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ../generated/c_grammar_fun.grm.sml‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar_Tokens =
struct
local open C_Grammar.Tokens in
  fun token_of_string
        error
        ty_ClangCVersion
        ty_cChar
        ty_cFloat
        ty_cInteger
        ty_cString
        ty_ident
        ty_string
        a1
        a2 =
   fn
     "(" =&gt; x28 (ty_string, a1, a2)
    | ")" =&gt; x29 (ty_string, a1, a2)
    | "[" =&gt; x5b (ty_string, a1, a2)
    | "]" =&gt; x5d (ty_string, a1, a2)
    | "-&gt;" =&gt; x2d_x3e (ty_string, a1, a2)
    | "." =&gt; x2e (ty_string, a1, a2)
    | "!" =&gt; x21 (ty_string, a1, a2)
    | "~" =&gt; x7e (ty_string, a1, a2)
    | "++" =&gt; x2b_x2b (ty_string, a1, a2)
    | "--" =&gt; x2d_x2d (ty_string, a1, a2)
    | "+" =&gt; x2b (ty_string, a1, a2)
    | "-" =&gt; x2d (ty_string, a1, a2)
    | "*" =&gt; x2a (ty_string, a1, a2)
    | "/" =&gt; x2f (ty_string, a1, a2)
    | "%" =&gt; x25 (ty_string, a1, a2)
    | "&amp;" =&gt; x26 (ty_string, a1, a2)
    | "&lt;&lt;" =&gt; x3c_x3c (ty_string, a1, a2)
    | "&gt;&gt;" =&gt; x3e_x3e (ty_string, a1, a2)
    | "&lt;" =&gt; x3c (ty_string, a1, a2)
    | "&lt;=" =&gt; x3c_x3d (ty_string, a1, a2)
    | "&gt;" =&gt; x3e (ty_string, a1, a2)
    | "&gt;=" =&gt; x3e_x3d (ty_string, a1, a2)
    | "==" =&gt; x3d_x3d (ty_string, a1, a2)
    | "!=" =&gt; x21_x3d (ty_string, a1, a2)
    | "^" =&gt; x5e (ty_string, a1, a2)
    | "|" =&gt; x7c (ty_string, a1, a2)
    | "&amp;&amp;" =&gt; x26_x26 (ty_string, a1, a2)
    | "||" =&gt; x7c_x7c (ty_string, a1, a2)
    | "?" =&gt; x3f (ty_string, a1, a2)
    | ":" =&gt; x3a (ty_string, a1, a2)
    | "=" =&gt; x3d (ty_string, a1, a2)
    | "+=" =&gt; x2b_x3d (ty_string, a1, a2)
    | "-=" =&gt; x2d_x3d (ty_string, a1, a2)
    | "*=" =&gt; x2a_x3d (ty_string, a1, a2)
    | "/=" =&gt; x2f_x3d (ty_string, a1, a2)
    | "%=" =&gt; x25_x3d (ty_string, a1, a2)
    | "&amp;=" =&gt; x26_x3d (ty_string, a1, a2)
    | "^=" =&gt; x5e_x3d (ty_string, a1, a2)
    | "|=" =&gt; x7c_x3d (ty_string, a1, a2)
    | "&lt;&lt;=" =&gt; x3c_x3c_x3d (ty_string, a1, a2)
    | "&gt;&gt;=" =&gt; x3e_x3e_x3d (ty_string, a1, a2)
    | "," =&gt; x2c (ty_string, a1, a2)
    | ";" =&gt; x3b (ty_string, a1, a2)
    | "{" =&gt; x7b (ty_string, a1, a2)
    | "}" =&gt; x7d (ty_string, a1, a2)
    | "..." =&gt; x2e_x2e_x2e (ty_string, a1, a2)
    | x =&gt; let 
    val alignof = alignof (ty_string, a1, a2)
    val alignas = alignas (ty_string, a1, a2)
    val atomic = x5f_Atomic (ty_string, a1, a2)
    val asm = asm (ty_string, a1, a2)
    val auto = auto (ty_string, a1, a2)
    val break = break (ty_string, a1, a2)
    val bool = x5f_Bool (ty_string, a1, a2)
    val case0 = case0 (ty_string, a1, a2)
    val char = char (ty_string, a1, a2)
    val const = const (ty_string, a1, a2)
    val continue = continue (ty_string, a1, a2)
    val complex = x5f_Complex (ty_string, a1, a2)
    val default = default (ty_string, a1, a2)
    val do0 = do0 (ty_string, a1, a2)
    val double = double (ty_string, a1, a2)
    val else0 = else0 (ty_string, a1, a2)
    val enum = enum (ty_string, a1, a2)
    val extern = extern (ty_string, a1, a2)
    val float = float (ty_string, a1, a2)
    val for0 = for0 (ty_string, a1, a2)
    val generic = x5f_Generic (ty_string, a1, a2)
    val goto = goto (ty_string, a1, a2)
    val if0 = if0 (ty_string, a1, a2)
    val inline = inline (ty_string, a1, a2)
    val int = int (ty_string, a1, a2)
    val int128 = x5f_x5f_int_x31_x32_x38 (ty_string, a1, a2)
    val long = long (ty_string, a1, a2)
    val label = x5f_x5f_label_x5f_x5f (ty_string, a1, a2)
    val noreturn = x5f_Noreturn (ty_string, a1, a2)
    val nullable = x5f_Nullable (ty_string, a1, a2)
    val nonnull = x5f_Nonnull (ty_string, a1, a2)
    val register = register (ty_string, a1, a2)
    val restrict = restrict (ty_string, a1, a2)
    val return0 = return0 (ty_string, a1, a2)
    val short = short (ty_string, a1, a2)
    val signed = signed (ty_string, a1, a2)
    val sizeof = sizeof (ty_string, a1, a2)
    val static = static (ty_string, a1, a2)
    val staticassert = x5f_Static_assert (ty_string, a1, a2)
    val struct0 = struct0 (ty_string, a1, a2)
    val switch = switch (ty_string, a1, a2)
    val typedef = typedef (ty_string, a1, a2)
    val typeof = typeof (ty_string, a1, a2)
    val thread = x5f_x5f_thread (ty_string, a1, a2)
    val union = union (ty_string, a1, a2)
    val unsigned = unsigned (ty_string, a1, a2)
    val void = void (ty_string, a1, a2)
    val volatile = volatile (ty_string, a1, a2)
    val while0 = while0 (ty_string, a1, a2)
    val cchar = cchar (ty_cChar, a1, a2)
    val cint = cint (ty_cInteger, a1, a2)
    val cfloat = cfloat (ty_cFloat, a1, a2)
    val cstr = cstr (ty_cString, a1, a2)
    val ident = ident (ty_ident, a1, a2)
    val tyident = tyident (ty_ident, a1, a2)
    val attribute = x5f_x5f_attribute_x5f_x5f (ty_string, a1, a2)
    val extension = x5f_x5f_extension_x5f_x5f (ty_string, a1, a2)
    val real = x5f_x5f_real_x5f_x5f (ty_string, a1, a2)
    val imag = x5f_x5f_imag_x5f_x5f (ty_string, a1, a2)
    val builtinvaarg = x5f_x5f_builtin_va_arg (ty_string, a1, a2)
    val builtinoffsetof = x5f_x5f_builtin_offsetof (ty_string, a1, a2)
    val builtintypescompatiblep = x5f_x5f_builtin_types_compatible_p (ty_string, a1, a2)
    val clangcversion = clangcversion (ty_ClangCVersion, a1, a2)
    in case x of
      "_Alignas" =&gt; alignas
    | "_Alignof" =&gt; alignof
    | "__alignof" =&gt; alignof
    | "alignof" =&gt; alignof
    | "__alignof__" =&gt; alignof
    | "__asm" =&gt; asm
    | "asm" =&gt; asm
    | "__asm__" =&gt; asm
    | "_Atomic" =&gt; atomic
    | "__attribute" =&gt; attribute
    | "__attribute__" =&gt; attribute
    | "auto" =&gt; auto
    | "_Bool" =&gt; bool
    | "break" =&gt; break
    | "__builtin_offsetof" =&gt; builtinoffsetof
    | "__builtin_types_compatible_p" =&gt; builtintypescompatiblep
    | "__builtin_va_arg" =&gt; builtinvaarg
    | "case" =&gt; case0
    | "char" =&gt; char
    | "_Complex" =&gt; complex
    | "__complex__" =&gt; complex
    | "__const" =&gt; const
    | "const" =&gt; const
    | "__const__" =&gt; const
    | "continue" =&gt; continue
    | "default" =&gt; default
    | "do" =&gt; do0
    | "double" =&gt; double
    | "else" =&gt; else0
    | "enum" =&gt; enum
    | "__extension__" =&gt; extension
    | "extern" =&gt; extern
    | "float" =&gt; float
    | "for" =&gt; for0
    | "_Generic" =&gt; generic
    | "goto" =&gt; goto
    | "if" =&gt; if0
    | "__imag" =&gt; imag
    | "__imag__" =&gt; imag
    | "__inline" =&gt; inline
    | "inline" =&gt; inline
    | "__inline__" =&gt; inline
    | "int" =&gt; int
    | "__int128" =&gt; int128
    | "__label__" =&gt; label
    | "long" =&gt; long
    | "_Nonnull" =&gt; nonnull
    | "__nonnull" =&gt; nonnull
    | "_Noreturn" =&gt; noreturn
    | "_Nullable" =&gt; nullable
    | "__nullable" =&gt; nullable
    | "__real" =&gt; real
    | "__real__" =&gt; real
    | "register" =&gt; register
    | "__restrict" =&gt; restrict
    | "restrict" =&gt; restrict
    | "__restrict__" =&gt; restrict
    | "return" =&gt; return0
    | "short" =&gt; short
    | "__signed" =&gt; signed
    | "signed" =&gt; signed
    | "__signed__" =&gt; signed
    | "sizeof" =&gt; sizeof
    | "static" =&gt; static
    | "_Static_assert" =&gt; staticassert
    | "struct" =&gt; struct0
    | "switch" =&gt; switch
    | "__thread" =&gt; thread
    | "_Thread_local" =&gt; thread
    | "typedef" =&gt; typedef
    | "__typeof" =&gt; typeof
    | "typeof" =&gt; typeof
    | "__typeof__" =&gt; typeof
    | "union" =&gt; union
    | "unsigned" =&gt; unsigned
    | "void" =&gt; void
    | "__volatile" =&gt; volatile
    | "volatile" =&gt; volatile
    | "__volatile__" =&gt; volatile
    | "while" =&gt; while0
    | _ =&gt; error
    end
end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Lexer_Annotation">
<div class="head"><h1>Theory C_Lexer_Annotation</h1>
<span class="command">theory</span> <span class="name">C_Lexer_Annotation</span><br/>
<span class="keyword">imports</span> <a href="C_Lexer_Language.html"><span class="name">C_Lexer_Language</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnnotation Language: Parsing Combinator‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Lexer_Annotation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Lexer_Language</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/keyword.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Isar/keyword.ML
    Author:     Makarius

Isar keyword classification.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Keyword =
struct

(** keyword classification **)

(* kinds *)


val command_kinds =
  [Keyword.diag, Keyword.document_heading, Keyword.document_body, Keyword.document_raw,
                             Keyword.thy_begin, Keyword.thy_end, Keyword.thy_load, Keyword.thy_decl,
    Keyword.thy_decl_block, Keyword.thy_defn, Keyword.thy_stmt, Keyword.thy_goal,
                      Keyword.thy_goal_defn, Keyword.thy_goal_stmt, Keyword.qed, Keyword.qed_script,
    Keyword.qed_block, Keyword.qed_global, Keyword.prf_goal, Keyword.prf_block, Keyword.next_block,
                                             Keyword.prf_open, Keyword.prf_close, Keyword.prf_chain,
    Keyword.prf_decl, Keyword.prf_asm, Keyword.prf_asm_goal, Keyword.prf_script,
                                              Keyword.prf_script_goal, Keyword.prf_script_asm_goal];


(* specifications *)


type entry =
 {pos: Position.T,
  id: serial,
  kind: string,
  files: string list,  (*extensions of embedded files*)
  tags: string list};

fun check_spec pos ((kind, files), tags) : entry =
  if not (member (op =) command_kinds kind) then
    error ("Unknown annotation syntax keyword kind " ^ quote kind)
  else if not (null files) andalso kind &lt;&gt; Keyword.thy_load then
    error ("Illegal specification of files for " ^ quote kind)
  else {pos = pos, id = serial (), kind = kind, files = files, tags = tags};


(** keyword tables **)

(* type keywords *)

datatype keywords = Keywords of
 {minor: Scan.lexicon,
  major: Scan.lexicon,
  commands: entry Symtab.table};

fun minor_keywords (Keywords {minor, ...}) = minor;
fun major_keywords (Keywords {major, ...}) = major;

fun make_keywords (minor, major, commands) =
  Keywords {minor = minor, major = major, commands = commands};

fun map_keywords f (Keywords {minor, major, commands}) =
  make_keywords (f (minor, major, commands));



(* build keywords *)

val empty_keywords =
  make_keywords (Scan.empty_lexicon, Scan.empty_lexicon, Symtab.empty);

fun empty_keywords' minor =
  make_keywords (minor, Scan.empty_lexicon, Symtab.empty);

fun merge_keywords
  (Keywords {minor = minor1, major = major1, commands = commands1},
    Keywords {minor = minor2, major = major2, commands = commands2}) =
  make_keywords
   (Scan.merge_lexicons (minor1, minor2),
    Scan.merge_lexicons (major1, major2),
    Symtab.merge (K true) (commands1, commands2));

val add_keywords0 =
  fold
    (fn ((name, pos), force_minor, spec as ((kind, _), _)) =&gt;
      map_keywords (fn (minor, major, commands) =&gt;
        let val extend = Scan.extend_lexicon (Symbol.explode name)
            fun update spec = Symtab.update (name, spec)
        in
          if force_minor then
            (extend minor, major, update (check_spec pos spec) commands)
          else if kind = "" orelse kind = Keyword.before_command
                            orelse kind = Keyword.quasi_command then
            (extend minor, major, commands)
          else
            (minor, extend major, update (check_spec pos spec) commands)
        end));

val add_keywords = add_keywords0 o map (fn (cmd, spec) =&gt; (cmd, false, spec))
val add_keywords_minor = add_keywords0 o map (fn (cmd, spec) =&gt; (cmd, true, spec))


(* keyword status *)

fun is_command (Keywords {commands, ...}) = Symtab.defined commands;
fun dest_commands (Keywords {commands, ...}) = Symtab.keys commands;


(* command keywords *)

fun lookup_command (Keywords {commands, ...}) = Symtab.lookup commands;

fun command_markup keywords name =
  lookup_command keywords name
  |&gt; Option.map (fn {pos, id, ...} =&gt;
      Markup.properties (Position.entity_properties_of false id pos)
        (Markup.entity Markup.command_keywordN name));


fun command_files keywords name path =
  (case lookup_command keywords name of
    NONE =&gt; []
  | SOME {kind, files, ...} =&gt;
      if kind &lt;&gt; Keyword.thy_load then []
      else if null files then [path]
      else map (fn ext =&gt; Path.ext ext path) files);


(* command categories *)

fun command_category ks =
  let
    val tab = Symtab.make_set ks;
    fun pred keywords name =
      (case lookup_command keywords name of
        NONE =&gt; false
      | SOME {kind, ...} =&gt; Symtab.defined tab kind);
  in pred end;




val is_theory_end = command_category [Keyword.thy_end];








val is_proof_asm = command_category [Keyword.prf_asm, Keyword.prf_asm_goal];
val is_improper = command_category [ Keyword.qed_script
                                   , Keyword.prf_script
                                   , Keyword.prf_script_goal
                                   , Keyword.prf_script_asm_goal];


end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Notes:
  ‚ñ™ The next structure contains a duplicated copy of the type
  \&lt;^ML_type&gt;‚ÄπToken.T‚Ä∫, since it is not possible to set an arbitrary
  ‚àó‚Äπslot‚Ä∫ value in \&lt;^ML_structure&gt;‚ÄπToken‚Ä∫.

  ‚ñ™ Parsing priorities in C and HOL slightly differ, see for instance
  \&lt;^ML&gt;‚ÄπToken.explode‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/token.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Isar/token.ML
    Author:     Markus Wenzel, TU Muenchen

Outer token syntax for Isabelle/Isar.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Token =
struct

(** tokens **)

(* token kind *)

val immediate_kinds' = fn Token.Command =&gt; 0
                        | Token.Keyword =&gt; 1
                        | Token.Ident =&gt; 2
                        | Token.Long_Ident =&gt; 3
                        | Token.Sym_Ident =&gt; 4
                        | Token.Var =&gt; 5
                        | Token.Type_Ident =&gt; 6
                        | Token.Type_Var =&gt; 7
                        | Token.Nat =&gt; 8
                        | Token.Float =&gt; 9
                        | Token.Space =&gt; 10
                        | _ =&gt; ~1

val delimited_kind =
  (fn Token.String =&gt; true
    | Token.Alt_String =&gt; true
    | Token.Verbatim =&gt; true
    | Token.Cartouche =&gt; true
    | Token.Comment _ =&gt; true
    | _ =&gt; false);


(* datatype token *)

(*The value slot assigns an (optional) internal value to a token,
  usually as a side-effect of special scanner setup (see also
  args.ML).  Note that an assignable ref designates an intermediate
  state of internalization -- it is NOT meant to persist.*)

datatype T = Token of (Symbol_Pos.text * Position.range) * (Token.kind * string) * slot

and slot =
  Slot |
  Value of value option |
  Assignable of value option Unsynchronized.ref

and value =
  Source of T list |
  Literal of bool * Markup.T |
  Name of Token.name_value * morphism |
  Typ of typ |
  Term of term |
  Fact of string option * thm list |  (*optional name for dynamic fact, i.e. fact "variable"*)
  Attribute of morphism -&gt; attribute |
  Declaration of declaration |
  Files of Token.file Exn.result list;

type src = T list;


(* position *)

fun pos_of (Token ((_, (pos, _)), _, _)) = pos;
fun end_pos_of (Token ((_, (_, pos)), _, _)) = pos;

fun adjust_offsets adjust (Token ((x, range), y, z)) =
  Token ((x, apply2 (Position.adjust_offsets adjust) range), y, z);


(* stopper *)

fun mk_eof pos = Token (("", (pos, Position.none)), (Token.EOF, ""), Slot);
val eof = mk_eof Position.none;

fun is_eof (Token (_, (Token.EOF, _), _)) = true
  | is_eof _ = false;

val not_eof = not o is_eof;

val stopper =
  Scan.stopper (fn [] =&gt; eof | toks =&gt; mk_eof (end_pos_of (List.last toks))) is_eof;


(* kind of token *)

fun kind_of (Token (_, (k, _), _)) = k;
fun is_kind k (Token (_, (k', _), _)) = k = k';

val is_command = is_kind Token.Command;

fun keyword_with pred (Token (_, (Token.Keyword, x), _)) = pred x
  | keyword_with _ _ = false;

val is_command_modifier = keyword_with (fn x =&gt; x = "private" orelse x = "qualified");

fun ident_with pred (Token (_, (Token.Ident, x), _)) = pred x
  | ident_with _ _ = false;

fun is_ignored (Token (_, (Token.Space, _), _)) = true
  | is_ignored (Token (_, (Token.Comment NONE, _), _)) = true
  | is_ignored _ = false;

fun is_proper (Token (_, (Token.Space, _), _)) = false
  | is_proper (Token (_, (Token.Comment _, _), _)) = false
  | is_proper _ = true;

fun is_comment (Token (_, (Token.Comment _, _), _)) = true
  | is_comment _ = false;

fun is_informal_comment (Token (_, (Token.Comment NONE, _), _)) = true
  | is_informal_comment _ = false;

fun is_formal_comment (Token (_, (Token.Comment (SOME _), _), _)) = true
  | is_formal_comment _ = false;

fun is_document_marker (Token (_, (Token.Comment (SOME Comment.Marker), _), _)) = true
  | is_document_marker _ = false;

fun is_begin_ignore (Token (_, (Token.Comment NONE, "&lt;"), _)) = true
  | is_begin_ignore _ = false;

fun is_end_ignore (Token (_, (Token.Comment NONE, "&gt;"), _)) = true
  | is_end_ignore _ = false;

fun is_error (Token (_, (Token.Error _, _), _)) = true
  | is_error _ = false;

fun is_error' (Token (_, (Token.Error msg, _), _)) = SOME msg
  | is_error' _ = NONE;

fun content_of (Token (_, (_, x), _)) = x;
fun content_of' (Token (_, (_, _), Value (SOME (Source l)))) =
                    map (fn Token ((_, (pos, _)), (_, x), _) =&gt; (x, pos)) l
  | content_of' _ = [];

val is_stack1 = fn Token (_, (Token.Sym_Ident, _), Value (SOME (Source l))) =&gt;
                        forall (fn tok =&gt; content_of tok = "+") l
                 | _ =&gt; false;

val is_stack2 = fn Token (_, (Token.Sym_Ident, _), Value (SOME (Source l))) =&gt;
                        forall (fn tok =&gt; content_of tok = "@") l
                 | _ =&gt; false;

val is_stack3 = fn Token (_, (Token.Sym_Ident, _), Value (SOME (Source l))) =&gt;
                        forall (fn tok =&gt; content_of tok = "&amp;") l
                 | _ =&gt; false;


(* blanks and newlines -- space tokens obey lines *)

fun is_space (Token (_, (Space, _), _)) = true
  | is_space _ = false;

fun is_blank (Token (_, (Space, x), _)) = not (String.isSuffix "\n" x)
  | is_blank _ = false;

fun is_newline (Token (_, (Space, x), _)) = String.isSuffix "\n" x
  | is_newline _ = false;


(* range of tokens *)

fun range_of (toks as tok :: _) =
      let val pos' = end_pos_of (List.last toks)
      in Position.range (pos_of tok, pos') end
  | range_of [] = Position.no_range;

val core_range_of =
  drop_prefix is_ignored #&gt; drop_suffix is_ignored #&gt; range_of;


(* token content *)

fun content_of (Token (_, (_, x), _)) = x;
fun source_of (Token ((source, _), _, _)) = source;

fun input_of (Token ((source, range), (kind, _), _)) =
  Input.source (delimited_kind kind) source range;

fun inner_syntax_of tok =
  let val x = content_of tok
  in if YXML.detect x then x else Syntax.implode_input (input_of tok) end;


(* markup reports *)

local

val token_kind_markup =
 fn Token.Var =&gt; (Markup.var, "")
  | Token.Type_Ident =&gt; (Markup.tfree, "")
  | Token.Type_Var =&gt; (Markup.tvar, "")
  | Token.String =&gt; (Markup.string, "")
  | Token.Alt_String =&gt; (Markup.alt_string, "")
  | Token.Verbatim =&gt; (Markup.verbatim, "")
  | Token.Cartouche =&gt; (Markup.cartouche, "")
  | Token.Comment _ =&gt; (Markup.ML_comment, "")
  | Token.Error msg =&gt; (Markup.bad (), msg)
  | _ =&gt; (Markup.empty, "");

fun keyword_reports tok = map (fn markup =&gt; ((pos_of tok, markup), ""));

fun command_markups keywords x =
  if C_Keyword.is_theory_end keywords x then [Markup.keyword2 |&gt; Markup.keyword_properties]
  else
    (if C_Keyword.is_proof_asm keywords x then [Markup.keyword3]
     else if C_Keyword.is_improper keywords x then [Markup.keyword1, Markup.improper]
     else [Markup.keyword1])
    |&gt; map Markup.command_properties;

fun keyword_markup (important, keyword) x =
  if important orelse Symbol.is_ascii_identifier x then keyword else Markup.delimiter;

fun command_minor_markups keywords x =
  if C_Keyword.is_theory_end keywords x then [Markup.keyword2 |&gt; Markup.keyword_properties]
  else
    (if C_Keyword.is_proof_asm keywords x then [Markup.keyword3]
     else if C_Keyword.is_improper keywords x then [Markup.keyword1, Markup.improper]
     else if C_Keyword.is_command keywords x then [Markup.keyword1]
     else [keyword_markup (false, Markup.keyword2 |&gt; Markup.keyword_properties) x]);

in

fun completion_report tok =
  if is_kind Token.Keyword tok
  then map (fn m =&gt; ((pos_of tok, m), "")) (Completion.suppress_abbrevs (content_of tok))
  else [];

fun reports keywords tok =
  if is_command tok then
    keyword_reports tok (command_markups keywords (content_of tok))
  else if is_stack1 tok orelse is_stack2 tok orelse is_stack3 tok then
    keyword_reports tok [Markup.keyword2 |&gt; Markup.keyword_properties]
  else if is_kind Token.Keyword tok then
    keyword_reports tok (command_minor_markups keywords (content_of tok))
  else
    let
      val pos = pos_of tok;
      val (m, text) = token_kind_markup (kind_of tok);
      val delete = #2 (Symbol_Pos.explode_delete (source_of tok, pos));
    in ((pos, m), text) :: map (fn p =&gt; ((p, Markup.delete), "")) delete end;

fun markups keywords = map (#2 o #1) o reports keywords;

end;


(* unparse *)

fun unparse' (Token ((source0, _), (kind, x), _)) =
  let
    val source =
      ‚Äï ‚Äπ We are computing a reverse function of \&lt;^ML&gt;‚ÄπSymbol_Pos.implode_range‚Ä∫
          taking into account consecutive \&lt;^ML&gt;‚ÄπSymbol.DEL‚Ä∫ symbols potentially appearing
          at the beginning, or at the end of the string.

          As remark, \&lt;^ML&gt;‚ÄπSymbol_Pos.explode_delete‚Ä∫
          will remove any potentially consecutive \&lt;^ML&gt;‚ÄπSymbol.DEL‚Ä∫ symbols.
          This is why it is not used here.‚Ä∫
      case Symbol.explode source0 of
        x :: xs =&gt;
          if x = Symbol.DEL then
            case rev xs of x' :: xs =&gt; if x' = Symbol.DEL then implode (rev xs) else source0
                         | _ =&gt; source0
          else
           source0
      | _ =&gt; source0
  in
    case kind of
      Token.String =&gt; Symbol_Pos.quote_string_qq source
    | Token.Alt_String =&gt; Symbol_Pos.quote_string_bq source
    | Token.Verbatim =&gt; enclose "{*" "*}" source
    | Token.Cartouche =&gt; cartouche source
    | Token.Comment NONE =&gt; enclose "(*" "*)" source
    | Token.EOF =&gt; ""
    | _ =&gt; x
  end;

fun text_of tok =
  let
    val k = Token.str_of_kind (kind_of tok);
    val ms = markups C_Keyword.empty_keywords tok;
    val s = unparse' tok;
  in
    if s = "" then (k, "")
    else if size s &lt; 40 andalso not (exists_string (fn c =&gt; c = "\n") s)
    then (k ^ " " ^ Markup.markups ms s, "")
    else (k, Markup.markups ms s)
  end;



(** associated values **)

(* inlined file content *)

fun file_source (file: Token.file) =
  let
    val text = cat_lines (#lines file);
    val end_pos = fold Position.advance (Symbol.explode text) (#pos file);
  in Input.source true text (Position.range (#pos file, end_pos)) end;

fun get_files (Token (_, _, Value (SOME (Files files)))) = files
  | get_files _ = [];

fun put_files [] tok = tok
  | put_files files (Token (x, y, Slot)) = Token (x, y, Value (SOME (Files files)))
  | put_files _ tok = raise Fail ("Cannot put inlined files here" ^ Position.here (pos_of tok));


(* access values *)



(* reports of value *)



(* name value *)



(* maxidx *)



(* fact values *)



(* transform *)



(* static binding *)

(*1st stage: initialize assignable slots*)
fun init_assignable tok =
  (case tok of
    Token (x, y, Slot) =&gt; Token (x, y, Assignable (Unsynchronized.ref NONE))
  | Token (_, _, Value _) =&gt; tok
  | Token (_, _, Assignable r) =&gt; (r := NONE; tok));

(*2nd stage: assign values as side-effect of scanning*)
fun assign v tok =
  (case tok of
    Token (x, y, Slot) =&gt; Token (x, y, Value v)
  | Token (_, _, Value _) =&gt; tok
  | Token (_, _, Assignable r) =&gt; (r := v; tok));

fun evaluate mk eval arg =
  let val x = eval arg in (assign (SOME (mk x)) arg; x) end;

(*3rd stage: static closure of final values*)
fun closure (Token (x, y, Assignable (Unsynchronized.ref v))) = Token (x, y, Value v)
  | closure tok = tok;


(* pretty *)



(* src *)







(** scanners **)

open Basic_Symbol_Pos;

val err_prefix = "Annotation lexical error: ";

fun !!! msg = Symbol_Pos.!!! (fn () =&gt; err_prefix ^ msg);


(* scan stack *)

fun scan_stack is_stack = Scan.optional (Scan.one is_stack &gt;&gt; content_of') []


(* scan symbolic idents *)

val scan_symid =
  Scan.many1 (Symbol.is_symbolic_char o Symbol_Pos.symbol) ||
  Scan.one (Symbol.is_symbolic o Symbol_Pos.symbol) &gt;&gt; single;

fun is_symid str =
  (case try Symbol.explode str of
    SOME [s] =&gt; Symbol.is_symbolic s orelse Symbol.is_symbolic_char s
  | SOME ss =&gt; forall Symbol.is_symbolic_char ss
  | _ =&gt; false);

fun ident_or_symbolic "begin" = false
  | ident_or_symbolic ":" = true
  | ident_or_symbolic "::" = true
  | ident_or_symbolic s = Symbol_Pos.is_identifier s orelse is_symid s;


(* scan verbatim text *)

val scan_verb =
  $$$ "*" --| Scan.ahead (~$$ "}") ||
  Scan.one (fn (s, _) =&gt; s &lt;&gt; "*" andalso Symbol.not_eof s) &gt;&gt; single;

val scan_verbatim =
  Scan.ahead ($$ "{" -- $$ "*") |--
    !!! "unclosed verbatim text"
      ((Symbol_Pos.scan_pos --| $$ "{" --| $$ "*") --
        (Scan.repeats scan_verb -- ($$ "*" |-- $$ "}" |-- Symbol_Pos.scan_pos)));

val recover_verbatim =
  $$$ "{" @@@ $$$ "*" @@@ Scan.repeats scan_verb;


(* scan cartouche *)

val scan_cartouche =
  Symbol_Pos.scan_pos --
    ((Symbol_Pos.scan_cartouche err_prefix &gt;&gt; Symbol_Pos.cartouche_content) -- Symbol_Pos.scan_pos);


(* scan space *)

fun space_symbol (s, _) = Symbol.is_blank s andalso s &lt;&gt; "\n";

val scan_space =
  Scan.many1 space_symbol @@@ Scan.optional ($$$ "\n") [] ||
  Scan.many space_symbol @@@ $$$ "\n";


(* scan comment *)

val scan_comment =
  Symbol_Pos.scan_pos -- (Symbol_Pos.scan_comment_body err_prefix -- Symbol_Pos.scan_pos);



(** token sources **)

local

fun token_leq ((_, syms1), (_, syms2)) = length syms1 &lt;= length syms2;

fun token k ss =
  Token ((Symbol_Pos.implode ss, Symbol_Pos.range ss), (k, Symbol_Pos.content ss), Slot);

fun token' (mk_value, k) ss =
  if mk_value then
    Token ( (Symbol_Pos.implode ss, Symbol_Pos.range ss)
          , (k, Symbol_Pos.content ss)
          , Value (SOME (Source (map (fn (s, pos) =&gt;
                                       Token (("", (pos, Position.none)), (k, s), Slot))
                                     ss))))
  else
    token k ss;

fun token_t k = token' (true, k)

fun token_range k (pos1, (ss, pos2)) =
  Token (Symbol_Pos.implode_range (pos1, pos2) ss, (k, Symbol_Pos.content ss), Slot);

fun scan_token keywords = !!! "bad input"
  (Symbol_Pos.scan_string_qq err_prefix &gt;&gt; token_range Token.String ||
    Symbol_Pos.scan_string_bq err_prefix &gt;&gt; token_range Token.Alt_String ||
    scan_verbatim &gt;&gt; token_range Token.Verbatim ||
    scan_cartouche &gt;&gt; token_range Token.Cartouche ||
    scan_comment &gt;&gt; token_range (Token.Comment NONE) ||
    Comment.scan_outer &gt;&gt; (fn (k, ss) =&gt; token (Token.Comment (SOME k)) ss) ||
    scan_space &gt;&gt; token Token.Space ||
    Scan.repeats1 ($$$ "+") &gt;&gt; token_t Token.Sym_Ident ||
    Scan.repeats1 ($$$ "@") &gt;&gt; token_t Token.Sym_Ident ||
    Scan.repeats1 ($$$ "&amp;") &gt;&gt; token_t Token.Sym_Ident ||
    (Scan.max token_leq
      (Scan.max token_leq
        (Scan.literal (C_Keyword.major_keywords keywords) &gt;&gt; pair Token.Command)
        (Scan.literal (C_Keyword.minor_keywords keywords) &gt;&gt; pair Token.Keyword))
      (Lexicon.scan_longid &gt;&gt; pair Token.Long_Ident ||
        Scan.max
          token_leq
          (C_Lex.scan_ident &gt;&gt; pair Token.Ident)
          (Lexicon.scan_id &gt;&gt; pair Token.Ident) ||
        Lexicon.scan_var &gt;&gt; pair Token.Var ||
        Lexicon.scan_tid &gt;&gt; pair Token.Type_Ident ||
        Lexicon.scan_tvar &gt;&gt; pair Token.Type_Var ||
        Symbol_Pos.scan_float &gt;&gt; pair Token.Float ||
        Symbol_Pos.scan_nat &gt;&gt; pair Token.Nat ||
        scan_symid &gt;&gt; pair Token.Sym_Ident)) &gt;&gt; uncurry (token' o pair false));

fun recover msg =
  (Symbol_Pos.recover_string_qq ||
    Symbol_Pos.recover_string_bq ||
    recover_verbatim ||
    Symbol_Pos.recover_cartouche ||
    Symbol_Pos.recover_comment ||
    Scan.one (Symbol.not_eof o Symbol_Pos.symbol) &gt;&gt; single)
  &gt;&gt; (single o token (Token.Error msg));

in

fun make_source keywords {strict} =
  let
    val scan_strict = Scan.bulk (scan_token keywords);
    val scan = if strict then scan_strict else Scan.recover scan_strict recover;
  in Source.source Symbol_Pos.stopper scan end;


end;


(* explode *)

fun tokenize keywords strict syms =
  Source.of_list syms |&gt; make_source keywords strict |&gt; Source.exhaust;

fun explode keywords pos text =
  Symbol_Pos.explode (text, pos) |&gt; tokenize keywords {strict = false};

fun explode0 keywords = explode keywords Position.none;


(* print name in parsable form *)



(* make *)




(** parsers **)

type 'a parser = T list -&gt; 'a * T list;
type 'a context_parser = Context.generic * T list -&gt; 'a * (Context.generic * T list);


(* read body -- e.g. antiquotation source *)

fun read_with_commands'0 keywords syms =
  Source.of_list syms
  |&gt; make_source keywords {strict = false}
  |&gt; Source.filter (not o is_proper)
  |&gt; Source.exhaust

fun read_with_commands' keywords scan syms =
  Source.of_list syms
  |&gt; make_source keywords {strict = false}
  |&gt; Source.filter is_proper
  |&gt; Source.source
       stopper
       (Scan.recover
         (Scan.bulk scan)
         (fn msg =&gt;
           Scan.one (not o is_eof)
           &gt;&gt; (fn tok =&gt; [C_Scan.Right
                           let
                             val msg = case is_error' tok of SOME msg0 =&gt; msg0 ^ " (" ^ msg ^ ")"
                                                           | NONE =&gt; msg
                           in ( msg
                              , [((pos_of tok, Markup.bad ()), msg)]
                              , tok)
                           end])))
  |&gt; Source.exhaust;

fun read_antiq' keywords scan = read_with_commands' keywords (scan &gt;&gt; C_Scan.Left);

(* wrapped syntax *)

local
fun make src pos = Token.make src pos |&gt; #1
fun make_default text pos = make ((~1, 0), text) pos
fun explode keywords pos text =
  case Token.explode keywords pos text of [tok] =&gt; tok
                                        | _ =&gt; make_default text pos
in
fun syntax' f =
  I #&gt; map
   (fn tok0 as Token ((source, (pos1, pos2)), (kind, x), _) =&gt;
    if is_stack1 tok0 orelse is_stack2 tok0 orelse is_stack3 tok0 then
      make_default source pos1
    else if is_eof tok0 then
      Token.eof
    else if delimited_kind kind then
      explode Keyword.empty_keywords pos1 (unparse' tok0)
    else
      let
        val tok1 =
          explode
            ((case kind of
                Token.Keyword =&gt; Keyword.add_keywords [((x, Position.none), Keyword.no_spec)]
              | Token.Command =&gt; Keyword.add_keywords [( (x, Position.none)
                                                       , ((Keyword.thy_decl, []), []))]
              | _ =&gt; I)
               Keyword.empty_keywords)
            pos1
            source
      in
        if Token.kind_of tok1 = kind then
          tok1
        else
          make ( ( immediate_kinds' kind
                 , case Position.distance_of (pos1, pos2) of NONE =&gt; 0 | SOME i =&gt; i)
               , source)
               pos1
      end)
    #&gt; f
    #&gt; apsnd (map (fn tok =&gt; Token ( (Token.source_of tok, Token.range_of [tok])
                                   , (Token.kind_of tok, Token.content_of tok)
                                   , Slot)))
end
end;

type 'a c_parser = 'a C_Token.parser;
type 'a c_context_parser = 'a C_Token.context_parser;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/parse.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Isar/parse.ML
    Author:     Markus Wenzel, TU Muenchen

Generic parsers for Isabelle/Isar outer syntax.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
signature C_PARSE =
sig
  type T
  type src = T list
  type 'a parser = T list -&gt; 'a * T list
  type 'a context_parser = Context.generic * T list -&gt; 'a * (Context.generic * T list)
(**)
  val C_source: Input.source parser
  val star: string parser
(**)
  val group: (unit -&gt; string) -&gt; (T list -&gt; 'a) -&gt; T list -&gt; 'a
  val !!! : (T list -&gt; 'a) -&gt; T list -&gt; 'a
  val !!!! : (T list -&gt; 'a) -&gt; T list -&gt; 'a
  val not_eof: T parser
  val token: 'a parser -&gt; T parser
  val range: 'a parser -&gt; ('a * Position.range) parser
  val position: 'a parser -&gt; ('a * Position.T) parser
  val input: 'a parser -&gt; Input.source parser
  val inner_syntax: 'a parser -&gt; string parser
  val command: string parser
  val keyword: string parser
  val short_ident: string parser
  val long_ident: string parser
  val sym_ident: string parser
  val dots: string parser
  val minus: string parser
  val term_var: string parser
  val type_ident: string parser
  val type_var: string parser
  val number: string parser
  val float_number: string parser
  val string: string parser
  val string_position: (string * Position.T) parser
  val alt_string: string parser
  val verbatim: string parser
  val cartouche: string parser
  val eof: string parser
  val command_name: string -&gt; string parser
  val keyword_with: (string -&gt; bool) -&gt; string parser
  val keyword_markup: bool * Markup.T -&gt; string -&gt; string parser
  val keyword_improper: string -&gt; string parser
  val $$$ : string -&gt; string parser
  val reserved: string -&gt; string parser
  val underscore: string parser
  val maybe: 'a parser -&gt; 'a option parser
  val maybe_position: ('a * Position.T) parser -&gt; ('a option * Position.T) parser
  val opt_keyword: string -&gt; bool parser
  val opt_bang: bool parser
  val begin: string parser
  val opt_begin: bool parser
  val nat: int parser
  val int: int parser
  val real: real parser
  val enum_positions: string -&gt; 'a parser -&gt; ('a list * Position.T list) parser
  val enum1_positions: string -&gt; 'a parser -&gt; ('a list * Position.T list) parser
  val enum: string -&gt; 'a parser -&gt; 'a list parser
  val enum1: string -&gt; 'a parser -&gt; 'a list parser
  val and_list: 'a parser -&gt; 'a list parser
  val and_list1: 'a parser -&gt; 'a list parser
  val enum': string -&gt; 'a context_parser -&gt; 'a list context_parser
  val enum1': string -&gt; 'a context_parser -&gt; 'a list context_parser
  val and_list': 'a context_parser -&gt; 'a list context_parser
  val and_list1': 'a context_parser -&gt; 'a list context_parser
  val list: 'a parser -&gt; 'a list parser
  val list1: 'a parser -&gt; 'a list parser
  val properties: Properties.T parser
  val name: string parser
  val name_range: (string * Position.range) parser
  val name_position: (string * Position.T) parser
  val binding: binding parser
  val embedded: string parser
  val embedded_input: Input.source parser
  val embedded_position: (string * Position.T) parser
  val text: string parser
  val path: string parser
  val path_binding: (string * Position.T) parser
  val session_name: (string * Position.T) parser
  val theory_name: (string * Position.T) parser
  val liberal_name: string parser
  val parname: string parser
  val parbinding: binding parser
  val class: string parser
  val sort: string parser
  val type_const: string parser
  val arity: (string * string list * string) parser
  val multi_arity: (string list * string list * string) parser
  val type_args: string list parser
  val type_args_constrained: (string * string option) list parser
  val typ: string parser
  val mixfix: mixfix parser
  val mixfix': mixfix parser
  val opt_mixfix: mixfix parser
  val opt_mixfix': mixfix parser
  val syntax_mode: Syntax.mode parser
  val where_: string parser
  val const_decl: (string * string * mixfix) parser
  val const_binding: (binding * string * mixfix) parser
  val params: (binding * string option * mixfix) list parser
  val vars: (binding * string option * mixfix) list parser
  val for_fixes: (binding * string option * mixfix) list parser
  val ML_source: Input.source parser
  val document_source: Input.source parser
  val document_marker: Input.source parser
  val const: string parser
  val term: string parser
  val prop: string parser
  val literal_fact: string parser
  val propp: (string * string list) parser
  val termp: (string * string list) parser
  val private: Position.T parser
  val qualified: Position.T parser
  val target: (string * Position.T) parser
  val opt_target: (string * Position.T) option parser
  val args: T list parser
  val args1: (string -&gt; bool) -&gt; T list parser
  val attribs: src list parser
  val opt_attribs: src list parser
  val thm_sel: Facts.interval list parser
  val thm: (Facts.ref * src list) parser
  val thms1: (Facts.ref * src list) list parser
  val options: ((string * Position.T) * (string * Position.T)) list parser
end;

structure C_Parse: C_PARSE =
struct
type T = C_Token.T
type src = T list
type 'a parser = T list -&gt; 'a * T list
type 'a context_parser = Context.generic * T list -&gt; 'a * (Context.generic * T list)
structure Token =
struct
  open Token
  open C_Token
end

(** error handling **)

(* group atomic parsers (no cuts!) *)

fun group s scan = scan || Scan.fail_with
  (fn [] =&gt; (fn () =&gt; s () ^ " expected,\nbut end-of-input was found")
    | tok :: _ =&gt;
        (fn () =&gt;
          (case Token.text_of tok of
            (txt, "") =&gt;
              s () ^ " expected,\nbut " ^ txt ^ Position.here (Token.pos_of tok) ^
              " was found"
          | (txt1, txt2) =&gt;
              s () ^ " expected,\nbut " ^ txt1 ^ Position.here (Token.pos_of tok) ^
              " was found:\n" ^ txt2)));


(* cut *)

fun cut kind scan =
  let
    fun get_pos [] = " (end-of-input)"
      | get_pos (tok :: _) = Position.here (Token.pos_of tok);

    fun err (toks, NONE) = (fn () =&gt; kind ^ get_pos toks)
      | err (toks, SOME msg) =
          (fn () =&gt;
            let val s = msg () in
              if String.isPrefix kind s then s
              else kind ^ get_pos toks ^ ": " ^ s
            end);
  in Scan.!! err scan end;

fun !!! scan = cut "Annotation syntax error" scan;
fun !!!! scan = cut "Corrupted annotation syntax in presentation" scan;



(** basic parsers **)

(* tokens *)

fun RESET_VALUE atom = (*required for all primitive parsers*)
  Scan.ahead (Scan.one (K true)) -- atom &gt;&gt; (fn (arg, x) =&gt; (Token.assign NONE arg; x));


val not_eof = RESET_VALUE (Scan.one Token.not_eof);

fun token atom = Scan.ahead not_eof --| atom;

fun range scan = (Scan.ahead not_eof &gt;&gt; (Token.range_of o single)) -- scan &gt;&gt; Library.swap;
fun position scan = (Scan.ahead not_eof &gt;&gt; Token.pos_of) -- scan &gt;&gt; Library.swap;
fun input atom = Scan.ahead atom |-- not_eof &gt;&gt; Token.input_of;
fun inner_syntax atom = Scan.ahead atom |-- not_eof &gt;&gt; Token.inner_syntax_of;

fun kind k =
  group (fn () =&gt; Token.str_of_kind k)
    (RESET_VALUE (Scan.one (Token.is_kind k) &gt;&gt; Token.content_of));

val command = kind Token.Command;
val keyword = kind Token.Keyword;
val short_ident = kind Token.Ident;
val long_ident = kind Token.Long_Ident;
val sym_ident = kind Token.Sym_Ident;
val term_var = kind Token.Var;
val type_ident = kind Token.Type_Ident;
val type_var = kind Token.Type_Var;
val number = kind Token.Nat;
val float_number = kind Token.Float;
val string = kind Token.String;
val alt_string = kind Token.Alt_String;
val verbatim = kind Token.Verbatim;
val cartouche = kind Token.Cartouche;
val eof = kind Token.EOF;

fun command_name x =
  group (fn () =&gt; Token.str_of_kind Token.Command ^ " " ^ quote x)
    (RESET_VALUE (Scan.one (fn tok =&gt; Token.is_command tok andalso Token.content_of tok = x)))
  &gt;&gt; Token.content_of;

fun keyword_with pred = RESET_VALUE (Scan.one (Token.keyword_with pred) &gt;&gt; Token.content_of);

fun keyword_markup markup x =
  group (fn () =&gt; Token.str_of_kind Token.Keyword ^ " " ^ quote x)
    (Scan.ahead not_eof -- keyword_with (fn y =&gt; x = y))
  &gt;&gt; (fn (tok, x) =&gt; (Token.assign (SOME (Token.Literal markup)) tok; x));

val keyword_improper = keyword_markup (true, Markup.improper);
val $$$ = keyword_markup (false, Markup.quasi_keyword);

fun reserved x =
  group (fn () =&gt; "reserved identifier " ^ quote x)
    (RESET_VALUE (Scan.one (Token.ident_with (fn y =&gt; x = y)) &gt;&gt; Token.content_of));

val dots = sym_ident :-- (fn "‚Ä¶" =&gt; Scan.succeed () | _ =&gt; Scan.fail) &gt;&gt; #1;

val minus = sym_ident :-- (fn "-" =&gt; Scan.succeed () | _ =&gt; Scan.fail) &gt;&gt; #1;

val underscore = sym_ident :-- (fn "_" =&gt; Scan.succeed () | _ =&gt; Scan.fail) &gt;&gt; #1;
fun maybe scan = underscore &gt;&gt; K NONE || scan &gt;&gt; SOME;
fun maybe_position scan = position (underscore &gt;&gt; K NONE) || scan &gt;&gt; apfst SOME;

val nat = number &gt;&gt; (#1 o Library.read_int o Symbol.explode);
val int = Scan.optional (minus &gt;&gt; K ~1) 1 -- nat &gt;&gt; op *;
val real = float_number &gt;&gt; Value.parse_real || int &gt;&gt; Real.fromInt;

fun opt_keyword s = Scan.optional ($$$ "(" |-- !!! (($$$ s &gt;&gt; K true) --| $$$ ")")) false;
val opt_bang = Scan.optional ($$$ "!" &gt;&gt; K true) false;

val begin = $$$ "begin";
val opt_begin = Scan.optional (begin &gt;&gt; K true) false;


(* enumerations *)

fun enum1_positions sep scan =
  scan -- Scan.repeat (position ($$$ sep) -- !!! scan) &gt;&gt;
    (fn (x, ys) =&gt; (x :: map #2 ys, map (#2 o #1) ys));
fun enum_positions sep scan =
  enum1_positions sep scan || Scan.succeed ([], []);

fun enum1 sep scan = scan ::: Scan.repeat ($$$ sep |-- !!! scan);
fun enum sep scan = enum1 sep scan || Scan.succeed [];

fun enum1' sep scan = scan ::: Scan.repeat (Scan.lift ($$$ sep) |-- scan);
fun enum' sep scan = enum1' sep scan || Scan.succeed [];

fun and_list1 scan = enum1 "and" scan;
fun and_list scan = enum "and" scan;

fun and_list1' scan = enum1' "and" scan;
fun and_list' scan = enum' "and" scan;

fun list1 scan = enum1 "," scan;
fun list scan = enum "," scan;

val properties = $$$ "(" |-- !!! (list (string -- ($$$ "=" |-- string)) --| $$$ ")");


(* names and embedded content *)

val name =
  group (fn () =&gt; "name")
    (short_ident || long_ident || sym_ident || number || string);

val name_range = input name &gt;&gt; Input.source_content_range;
val name_position = input name &gt;&gt; Input.source_content;

val string_position = input string &gt;&gt; Input.source_content;

val binding = name_position &gt;&gt; Binding.make;

val embedded =
  group (fn () =&gt; "embedded content")
    (cartouche || string || short_ident || long_ident || sym_ident ||
      term_var || type_ident || type_var || number);

val embedded_input = input embedded;
val embedded_position = embedded_input &gt;&gt; Input.source_content;

val text = group (fn () =&gt; "text") (embedded || verbatim);

val path = group (fn () =&gt; "file name/path specification") embedded;
val path_binding = group (fn () =&gt; "path binding (strict file name)") (position embedded);

val session_name = group (fn () =&gt; "session name") name_position;
val theory_name = group (fn () =&gt; "theory name") name_position;

val liberal_name = keyword_with Token.ident_or_symbolic || name;

val parname = Scan.optional ($$$ "(" |-- name --| $$$ ")") "";
val parbinding = Scan.optional ($$$ "(" |-- binding --| $$$ ")") Binding.empty;


(* type classes *)

val class = group (fn () =&gt; "type class") (inner_syntax embedded);

val sort = group (fn () =&gt; "sort") (inner_syntax embedded);

val type_const = group (fn () =&gt; "type constructor") (inner_syntax embedded);

val arity = type_const -- ($$$ "::" |-- !!!
  (Scan.optional ($$$ "(" |-- !!! (list1 sort --| $$$ ")")) [] -- sort)) &gt;&gt; Scan.triple2;

val multi_arity = and_list1 type_const -- ($$$ "::" |-- !!!
  (Scan.optional ($$$ "(" |-- !!! (list1 sort --| $$$ ")")) [] -- sort)) &gt;&gt; Scan.triple2;


(* types *)

val typ = group (fn () =&gt; "type") (inner_syntax embedded);

fun type_arguments arg =
  arg &gt;&gt; single ||
  $$$ "(" |-- !!! (list1 arg --| $$$ ")") ||
  Scan.succeed [];

val type_args = type_arguments type_ident;
val type_args_constrained = type_arguments (type_ident -- Scan.option ($$$ "::" |-- !!! sort));


(* mixfix annotations *)

local

val mfix = input (string || cartouche);

val mixfix_ =
  mfix -- !!! (Scan.optional ($$$ "[" |-- !!! (list nat --| $$$ "]")) [] -- Scan.optional nat 1000)
    &gt;&gt; (fn (sy, (ps, p)) =&gt; fn range =&gt; Mixfix (sy, ps, p, range));

val structure_ = $$$ "structure" &gt;&gt; K Structure;

val binder_ =
  $$$ "binder" |-- !!! (mfix -- ($$$ "[" |-- nat --| $$$ "]" -- nat || nat &gt;&gt; (fn n =&gt; (n, n))))
    &gt;&gt; (fn (sy, (p, q)) =&gt; fn range =&gt; Binder (sy, p, q, range));

val infixl_ = $$$ "infixl"
              |-- !!! (mfix -- nat &gt;&gt; (fn (sy, p) =&gt; fn range =&gt; Infixl (sy, p, range)));
val infixr_ = $$$ "infixr"
              |-- !!! (mfix -- nat &gt;&gt; (fn (sy, p) =&gt; fn range =&gt; Infixr (sy, p, range)));
val infix_ = $$$ "infix"
              |-- !!! (mfix -- nat &gt;&gt; (fn (sy, p) =&gt; fn range =&gt; Infix (sy, p, range)));

val mixfix_body = mixfix_ || structure_ || binder_ || infixl_ || infixr_ || infix_;

fun annotation guard body =
  Scan.trace ($$$ "(" |-- guard (body --| $$$ ")"))
    &gt;&gt; (fn (mx, toks) =&gt; mx (Token.range_of toks));

fun opt_annotation guard body = Scan.optional (annotation guard body) NoSyn;

in

val mixfix = annotation !!! mixfix_body;
val mixfix' = annotation I mixfix_body;
val opt_mixfix = opt_annotation !!! mixfix_body;
val opt_mixfix' = opt_annotation I mixfix_body;

end;


(* syntax mode *)

val syntax_mode_spec =
  ($$$ "output" &gt;&gt; K ("", false)) || name -- Scan.optional ($$$ "output" &gt;&gt; K false) true;

val syntax_mode =
  Scan.optional ($$$ "(" |-- !!! (syntax_mode_spec --| $$$ ")")) Syntax.mode_default;


(* fixes *)

val where_ = $$$ "where";

val const_decl = name -- ($$$ "::" |-- !!! typ) -- opt_mixfix &gt;&gt; Scan.triple1;
val const_binding = binding -- ($$$ "::" |-- !!! typ) -- opt_mixfix &gt;&gt; Scan.triple1;

val param_mixfix = binding -- Scan.option ($$$ "::" |-- typ) -- mixfix' &gt;&gt; (single o Scan.triple1);

val params =
  (binding -- Scan.repeat binding) -- Scan.option ($$$ "::" |-- !!! (Scan.ahead typ -- embedded))
    &gt;&gt; (fn ((x, ys), T) =&gt;
        (x, Option.map #1 T, NoSyn) :: map (fn y =&gt; (y, Option.map #2 T, NoSyn)) ys);

val vars = and_list1 (param_mixfix || params) &gt;&gt; flat;

val for_fixes = Scan.optional ($$$ "for" |-- !!! vars) [];


(* embedded source text *)

val ML_source = input (group (fn () =&gt; "ML source") text);
val document_source = input (group (fn () =&gt; "document source") text);

val document_marker =
  group (fn () =&gt; "document marker")
    (RESET_VALUE (Scan.one Token.is_document_marker &gt;&gt; Token.input_of));


(* terms *)

val const = group (fn () =&gt; "constant") (inner_syntax embedded);
val term = group (fn () =&gt; "term") (inner_syntax embedded);
val prop = group (fn () =&gt; "proposition") (inner_syntax embedded);

val literal_fact = inner_syntax (group (fn () =&gt; "literal fact") (alt_string || cartouche));


(* patterns *)

val is_terms = Scan.repeat1 ($$$ "is" |-- term);
val is_props = Scan.repeat1 ($$$ "is" |-- prop);

val propp = prop -- Scan.optional ($$$ "(" |-- !!! (is_props --| $$$ ")")) [];
val termp = term -- Scan.optional ($$$ "(" |-- !!! (is_terms --| $$$ ")")) [];


(* target information *)

val private = position ($$$ "private") &gt;&gt; #2;
val qualified = position ($$$ "qualified") &gt;&gt; #2;

val target = ($$$ "(" -- $$$ "in") |-- !!! (name_position --| $$$ ")");
val opt_target = Scan.option target;


(* arguments within outer syntax *)

local

val argument_kinds =
 [Token.Ident, Token.Long_Ident, Token.Sym_Ident, Token.Var, Token.Type_Ident, Token.Type_Var,
  Token.Nat, Token.Float, Token.String, Token.Alt_String, Token.Cartouche, Token.Verbatim];

fun arguments is_symid =
  let
    fun argument blk =
      group (fn () =&gt; "argument")
        (Scan.one (fn tok =&gt;
          let val kind = Token.kind_of tok in
            member (op =) argument_kinds kind orelse
            Token.keyword_with is_symid tok orelse
            (blk andalso Token.keyword_with (fn s =&gt; s = ",") tok)
          end));

    fun args blk x = Scan.optional (args1 blk) [] x
    and args1 blk x =
      (Scan.repeats1 (Scan.repeat1 (argument blk) || argsp "(" ")" || argsp "[" "]")) x
    and argsp l r x = (token ($$$ l) ::: !!! (args true @@@ (token ($$$ r) &gt;&gt; single))) x;
  in (args, args1) end;

in

val args = #1 (arguments Token.ident_or_symbolic) false;
fun args1 is_symid = #2 (arguments is_symid) false;

end;


(* attributes *)

val attrib = token liberal_name ::: !!! args;
val attribs = $$$ "[" |-- list attrib --| $$$ "]";
val opt_attribs = Scan.optional attribs [];


(* theorem references *)

val thm_sel = $$$ "(" |-- list1
 (nat --| minus -- nat &gt;&gt; Facts.FromTo ||
  nat --| minus &gt;&gt; Facts.From ||
  nat &gt;&gt; Facts.Single) --| $$$ ")";

val thm =
  $$$ "[" |-- attribs --| $$$ "]" &gt;&gt; pair (Facts.named "") ||
  (literal_fact &gt;&gt; Facts.Fact ||
    name_position -- Scan.option thm_sel &gt;&gt; Facts.Named) -- opt_attribs;

val thms1 = Scan.repeat1 thm;


(* options *)

val option_name = group (fn () =&gt; "option name") name_position;
val option_value = group (fn () =&gt; "option value") ((token real || token name) &gt;&gt; Token.content_of);

val option =
  option_name :-- (fn (_, pos) =&gt;
    Scan.optional ($$$ "=" |-- !!! (position option_value)) ("true", pos));

val options = $$$ "[" |-- list1 option --| $$$ "]";


(** C basic parsers **)

(* embedded source text *)

val C_source = input (group (fn () =&gt; "C source") text);

(* AutoCorres (MODIFIES) *)

val star = sym_ident :-- (fn "*" =&gt; Scan.succeed () | _ =&gt; Scan.fail) &gt;&gt; #1;

end;

structure C_Parse_Native: C_PARSE =
struct
open Token
open Parse

(** C basic parsers **)

(* embedded source text *)

val C_source = input (group (fn () =&gt; "C source") text);

(* AutoCorres (MODIFIES) *)

val star = sym_ident :-- (fn "*" =&gt; Scan.succeed () | _ =&gt; Scan.fail) &gt;&gt; #1;
end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/thy_header.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Thy/thy_header.ML
    Author:     Makarius

Static theory header information.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Thy_Header =
struct
val bootstrap_keywords =
  C_Keyword.empty_keywords' (Keyword.minor_keywords (Thy_Header.get_keywords @{theory}))

(* theory data *)

structure Data = Theory_Data
(
  type T = C_Keyword.keywords;
  val empty = bootstrap_keywords;
  val extend = I;
  val merge = C_Keyword.merge_keywords;
);

val add_keywords = Data.map o C_Keyword.add_keywords;
val add_keywords_minor = Data.map o C_Keyword.add_keywords_minor;

val get_keywords = Data.get;
val get_keywords' = get_keywords o Proof_Context.theory_of;

end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Parser_Annotation">
<div class="head"><h1>Theory C_Parser_Annotation</h1>
<span class="command">theory</span> <span class="name">C_Parser_Annotation</span><br/>
<span class="keyword">imports</span> <a href="C_Lexer_Annotation.html"><span class="name">C_Lexer_Annotation</span></a> <a href="C_Environment.html"><span class="name">C_Environment</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnnotation Language: Command Parser Registration‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Parser_Annotation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Lexer_Annotation</span><span> </span><span>C_Environment</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/outer_syntax.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Isar/outer_syntax.ML
    Author:     Markus Wenzel, TU Muenchen

Isabelle/Isar outer syntax.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Annotation  =
struct

(** outer syntax **)

(* errors *)

fun err_command msg name ps =
  error (msg ^ quote (Markup.markup Markup.keyword1 name) ^ Position.here_list ps);

fun err_dup_command name ps =
  err_command "Duplicate annotation syntax command " name ps;


(* command parsers *)

datatype command_parser =
  Parser of (Symbol_Pos.T list * (bool * Symbol_Pos.T list)) * Position.range -&gt;
            C_Env.eval_time c_parser;

datatype command = Command of
 {comment: string,
  command_parser: command_parser,
  pos: Position.T,
  id: serial};

fun eq_command (Command {id = id1, ...}, Command {id = id2, ...}) = id1 = id2;

fun new_command comment command_parser pos =
  Command {comment = comment, command_parser = command_parser, pos = pos, id = serial ()};

fun command_pos (Command {pos, ...}) = pos;

fun command_markup def (name, Command {pos, id, ...}) =
  Markup.properties (Position.entity_properties_of def id pos)
    (Markup.entity Markup.commandN name);



(* theory data *)

structure Data = Theory_Data
(
  type T = command Symtab.table;
  val empty = Symtab.empty;
  val extend = I;
  fun merge data : T =
    data |&gt; Symtab.join (fn name =&gt; fn (cmd1, cmd2) =&gt;
      if eq_command (cmd1, cmd2) then raise Symtab.SAME
      else err_dup_command name [command_pos cmd1, command_pos cmd2]);
);

val get_commands = Data.get;
val dest_commands = get_commands #&gt; Symtab.dest #&gt; sort_by #1;
val lookup_commands = Symtab.lookup o get_commands;


(* maintain commands *)

fun add_command name cmd thy =
    let
      val _ =
        C_Keyword.is_command (C_Thy_Header.get_keywords thy) name orelse
          err_command "Undeclared outer syntax command " name [command_pos cmd];
      val _ =
        (case lookup_commands thy name of
          NONE =&gt; ()
        | SOME cmd' =&gt; err_dup_command name [command_pos cmd, command_pos cmd']);
      val _ =
        Context_Position.report_generic (Context.the_generic_context ())
          (command_pos cmd) (command_markup true (name, cmd));
    in Data.map (Symtab.update (name, cmd)) thy end;

fun delete_command (name, pos) thy =
    let
      val _ =
        C_Keyword.is_command (C_Thy_Header.get_keywords thy) name orelse
          err_command "Undeclared outer syntax command " name [pos];
    in Data.map (Symtab.delete name) thy end;


(* implicit theory setup *)

type command_keyword = string * Position.T;

fun raw_command0 kind (name, pos) comment command_parser =
  C_Thy_Header.add_keywords [((name, pos), ((kind, []), [name]))]
  #&gt; add_command name (new_command comment command_parser pos);

fun raw_command (name, pos) comment command_parser =
  let val setup = add_command name (new_command comment command_parser pos)
  in Context.&gt;&gt; (Context.mapping setup (Local_Theory.background_theory setup)) end;

fun command (name, pos) comment parse =
  raw_command (name, pos) comment (Parser parse);

fun command'' kind (name, pos) comment parse =
  raw_command0 kind (name, pos) comment (Parser parse);

val command' = command'' Keyword.thy_decl;



(** toplevel parsing **)

(* parse spans *)


(* parse commands *)

local
fun scan_stack' f b = Scan.one f &gt;&gt; (pair b o C_Token.content_of')
in
val before_command =
  C_Token.scan_stack C_Token.is_stack1
  -- Scan.optional (   scan_stack' C_Token.is_stack2 false
                    || scan_stack' C_Token.is_stack3 true)
                   (pair false [])
end

fun parse_command thy =
  Scan.ahead (before_command |-- C_Parse.position C_Parse.command) :|-- (fn (name, pos) =&gt;
    let val command_tags = before_command -- C_Parse.range C_Parse.command
                           &gt;&gt; (fn (cmd, (_, range)) =&gt; (cmd, range));
    in
      case lookup_commands thy name of
        SOME (cmd as Command {command_parser = Parser parse, ...}) =&gt;
          C_Parse.!!! (command_tags :|-- parse)
          &gt;&gt; pair [((pos, command_markup false (name, cmd)), "")]
      | NONE =&gt;
          Scan.fail_with (fn _ =&gt; fn _ =&gt;
            let
              val msg = "undefined command ";
            in msg ^ quote (Markup.markup Markup.keyword1 name) end)
    end)


(* check commands *)

fun command_reports thy tok =
  if C_Token.is_command tok then
    let val name = C_Token.content_of tok in
      (case lookup_commands thy name of
        NONE =&gt; []
      | SOME cmd =&gt; [((C_Token.pos_of tok, command_markup false (name, cmd)), "")])
    end
  else [];

fun check_command ctxt (name, pos) =
  let
    val thy = Proof_Context.theory_of ctxt;
    val keywords = C_Thy_Header.get_keywords thy;
  in
    if C_Keyword.is_command keywords name then
      let
        val markup =
          C_Token.explode0 keywords name
          |&gt; maps (command_reports thy)
          |&gt; map (#2 o #1);
        val _ = Context_Position.reports ctxt (map (pair pos) markup);
      in name end
    else
      let
        val completion_report =
          Completion.make_report (name, pos)
            (fn completed =&gt;
              C_Keyword.dest_commands keywords
              |&gt; filter completed
              |&gt; sort_strings
              |&gt; map (fn a =&gt; (a, (Markup.commandN, a))));
      in error ("Bad command " ^ quote name ^ Position.here pos ^ completion_report) end
  end;
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/PIDE/resources.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/PIDE/resources.ML
    Author:     Makarius

Resources for theories and auxiliary files.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Resources =
struct
(* load files *)

fun parse_files cmd =
  Scan.ahead C_Parse.not_eof -- C_Parse.path &gt;&gt; (fn (tok, name) =&gt; fn thy =&gt;
    (case C_Token.get_files tok of
      [] =&gt;
        let
          val keywords = C_Thy_Header.get_keywords thy;
          val master_dir = Resources.master_directory thy;
          val pos = C_Token.pos_of tok;
          val src_paths = C_Keyword.command_files keywords cmd (Path.explode name);
        in map (Command.read_file master_dir pos) src_paths end
    | files =&gt; map Exn.release files));

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Eval">
<div class="head"><h1>Theory C_Eval</h1>
<span class="command">theory</span> <span class="name">C_Eval</span><br/>
<span class="keyword">imports</span> <a href="C_Parser_Language.html"><span class="name">C_Parser_Language</span></a> <a href="C_Parser_Annotation.html"><span class="name">C_Parser_Annotation</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπEvaluation Scheduling‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Eval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Parser_Language</span><span>
</span><span>          </span><span>C_Parser_Annotation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπEvaluation Engine for the Core Language‚Ä∫</span></span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/thy_info.ML‚Ä∫:
                                                        \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Environment‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Stack =
struct
type 'a stack_elem = (LALR_Table.state, 'a, Position.T) C_Env.stack_elem0
type stack_data = (LALR_Table.state, C_Grammar.Tokens.svalue0, Position.T) C_Env.stack0
type stack_data_elem = (LALR_Table.state, C_Grammar.Tokens.svalue0, Position.T) C_Env.stack_elem0

fun map_svalue0 f (st, (v, pos1, pos2)) = (st, (f v, pos1, pos2))

structure Data_Lang =
struct
val empty' = ([], C_Env.empty_env_lang)
structure Data_Lang = Generic_Data
  (type T = (stack_data * C_Env.env_lang) option
   val empty = NONE
   val extend = K empty
   val merge = K empty)
open Data_Lang
fun get' context = case get context of NONE =&gt; empty' | SOME data =&gt; data
fun setmp data f context = put (get context) (f (put data context))
end

structure Data_Tree_Args : GENERIC_DATA_ARGS =
struct
  type T = C_Position.reports_text * C_Env.error_lines
  val empty = ([], [])
  val extend = I
  fun merge ((l11, l12), (l21, l22)) = (l11 @ l21, l12 @ l22)
end

structure Data_Tree = Generic_Data (Data_Tree_Args)

fun setmp_tree f context =
  let val x = Data_Tree.get context
      val context = f (Data_Tree.put Data_Tree_Args.empty context)
  in (Data_Tree.get context, Data_Tree.put x context) end

fun stack_exec0 f {context, reports_text, error_lines} =
  let val ((reports_text', error_lines'), context) = setmp_tree f context
  in { context = context
     , reports_text = append reports_text' reports_text
     , error_lines = append error_lines' error_lines } end

fun stack_exec env_dir data_put =
  stack_exec0 o Data_Lang.setmp (SOME (apsnd (C_Env.map_env_directives (K env_dir)) data_put))
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_context.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/ML/ml_context.ML
    Author:     Makarius

ML context and antiquotations.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Context0 =
struct
(* theory data *)

type env_direct = bool (* internal result for conditional directives: branch skipping *)
                * (C_Env.env_directives * C_Env.env_tree)

structure Directives = Generic_Data
  (type T = (Position.T list
             * serial
             * ( (* evaluated during lexing phase *)
                 (C_Lex.token_kind_directive
                  -&gt; env_direct
                  -&gt; C_Env.antiq_language list (* nested annotations from the input *)
                     * env_direct (*NOTE: remove the possibility of returning a too modified env?*))
               * (* evaluated during parsing phase *)
                 (C_Lex.token_kind_directive -&gt; C_Env.env_propagation_directive)))
            Symtab.table
   val empty = Symtab.empty
   val extend = I
   val merge = Symtab.join (K #2));
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Lexer_Language‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar_Lexer : ARG_LEXER1 =
struct
structure LALR_Lex_Instance =
struct
  type ('a,'b) token = ('a, 'b) C_Grammar.Tokens.token
  type pos = Position.T
  type arg = C_Grammar.Tokens.arg
  type svalue0 = C_Grammar.Tokens.svalue0
  type svalue = arg -&gt; svalue0 * arg
  type state = C_Grammar.ParserData.LALR_Table.state
end

type stack =
       (LALR_Lex_Instance.state, LALR_Lex_Instance.svalue0, LALR_Lex_Instance.pos) C_Env.stack'

fun advance_hook stack = (fn f =&gt; fn (arg, stack_ml) =&gt; f (#stream_hook arg) (arg, stack_ml))
 (fn [] =&gt; I | l :: ls =&gt;
  I
  #&gt; fold_rev 
    (fn (_, syms, ml_exec) =&gt;
      let
        val len = length syms
      in 
        if len = 0 then
          I #&gt;&gt;
          (case ml_exec of
             (_, C_Env.Bottom_up (C_Env.Exec_annotation exec), env_dir, _) =&gt;
              (fn arg =&gt; C_Env.map_env_tree (C_Stack.stack_exec env_dir (stack, #env_lang arg)
                                                                        (exec NONE))
                                            arg)
           | (_, C_Env.Bottom_up (C_Env.Exec_directive exec), env_dir, _) =&gt;
              C_Env.map_env_lang_tree (curry (exec NONE env_dir))
           | ((pos, _), _, _, _) =&gt;
              C_Env_Ext.map_context (fn _ =&gt; error ( "Style of evaluation not yet implemented"
                                                   ^ Position.here pos)))
        else
          I ##&gt;
          let
            val len = len - 1
          in
            fn stack_ml =&gt;
              stack_ml
              |&gt; (if length stack_ml &lt;= len then
                   tap (fn _ =&gt; warning ("Maximum depth reached ("
                                         ^ Int.toString (len - length stack_ml + 1)
                                         ^ " in excess)"
                                         ^ Position.here (Symbol_Pos.range syms
                                                          |&gt; Position.range_position)))
                   #&gt; tap (fn _ =&gt; warning ("Unevaluated code"
                                            ^ Position.here (ml_exec |&gt; #1
                                                                     |&gt; Position.range_position)))
                   #&gt; I
                  else if length stack_ml - len &lt;= 2 then
                   tap
                     (fn _ =&gt;
                       warning ("Unevaluated code\
                                \ as the hook is pointing to an internal initial value"
                                ^ Position.here (ml_exec |&gt; #1 |&gt; Position.range_position)))
                   #&gt; I
                  else nth_map len (cons ml_exec))
          end
      end)
    l
  #&gt;&gt; C_Env.map_stream_hook (K ls))

fun add_stream_hook (syms_shift, syms, ml_exec) =
  C_Env.map_stream_hook
   (fn stream_hook =&gt; 
    case
       fold (fn _ =&gt; fn (eval1, eval2) =&gt;
           (case eval2 of e2 :: eval2 =&gt; (e2, eval2)
                        | [] =&gt; ([], []))
           |&gt;&gt; (fn e1 =&gt; e1 :: eval1))
         syms_shift
         ([], stream_hook)
    of (eval1, eval2) =&gt; fold cons
                              eval1
                              (case eval2 of e :: es =&gt; ((syms_shift, syms, ml_exec) :: e) :: es
                                           | [] =&gt; [[(syms_shift, syms, ml_exec)]]))

fun makeLexer ((stack, stack_ml, stack_pos, stack_tree), arg) =
  let val (token, arg) = C_Env_Ext.map_stream_lang' (fn (st, []) =&gt; (NONE, (st, []))
                                                      | (st, x :: xs) =&gt; (SOME x, (st, xs)))
                                                    arg
      fun return0' f =
        (arg, stack_ml)
        |&gt; advance_hook stack
        |&gt; f
        |&gt; (fn (arg, stack_ml) =&gt; rpair ((stack, stack_ml, stack_pos, stack_tree), arg))
      fun return0 x = ‚Äï ‚ÄπWarning: ‚Äπadvance_hook‚Ä∫ must not be early evaluated here, as it might
                                   generate undesirable markup reporting (in annotation commands).‚Ä∫
                      ‚Äï ‚ÄπTodo: Arrange ‚Äπadvance_hook‚Ä∫ as a pure function, so that the overall could
                                be eta-simplified.‚Ä∫
        return0' I x
      val encoding = fn C_Lex.Encoding_L =&gt; true | _ =&gt; false
      open C_Ast
      fun token_err pos1 pos2 src =
        C_Grammar_Tokens.token_of_string
          (C_Grammar.Tokens.error (pos1, pos2))
          (ClangCVersion0 (From_string src))
          (CChar (From_char_hd "0") false)
          (CFloat (From_string src))
          (CInteger 0 DecRepr (Flags 0))
          (CString0 (From_string src, false))
          (Ident (From_string src, 0, OnlyPos NoPosition (NoPosition, 0)))
          src
          pos1
          pos2
          src
      open C_Scan
  in
    case token
    of NONE =&gt; 
        return0'
          (tap (fn (arg, _) =&gt; 
              fold (uncurry
                     (fn pos =&gt; 
                       fold_rev (fn (syms, _, _) =&gt; fn () =&gt;
                                  let val () = error ("Maximum depth reached ("
                                                      ^ Int.toString (pos + 1)
                                                      ^ " in excess)"
                                                      ^ Position.here (Symbol_Pos.range syms
                                                                       |&gt; Position.range_position))
                                  in () end)))
                   (map_index I (#stream_hook arg))
                   ()))
          (C_Grammar.Tokens.x25_eof (Position.none, Position.none))
     | SOME (Left (antiq_raw, l_antiq)) =&gt;
        makeLexer
          ( (stack, stack_ml, stack_pos, stack_tree)
          , (arg, false)
             |&gt; fold (fn C_Env.Antiq_stack (_, C_Env.Parsing ((syms_shift, syms), ml_exec)) =&gt;
                           I #&gt;&gt; add_stream_hook (syms_shift, syms, ml_exec)
                       | C_Env.Antiq_stack (_, C_Env.Never) =&gt; I ##&gt; K true
                       | _ =&gt; I)
                     l_antiq
             |&gt; (fn (arg, false) =&gt; arg
                  | (arg, true) =&gt; C_Env_Ext.map_stream_ignored (cons (Left antiq_raw)) arg))
     | SOME (Right (tok as C_Lex.Token (_, (C_Lex.Directive dir, _)))) =&gt;
        makeLexer
          ( (stack, stack_ml, stack_pos, stack_tree)
          , arg
            |&gt; let val context = C_Env_Ext.get_context arg
               in
                fold (fn dir_tok =&gt; 
                      add_stream_hook
                        ( []
                        , []
                        , ( Position.no_range
                          , C_Env.Bottom_up (C_Env.Exec_directive
                                              (dir |&gt; (case Symtab.lookup
                                                              (C_Context0.Directives.get context)
                                                              (C_Lex.content_of dir_tok)
                                                       of NONE =&gt; K (K (K I))
                                                        | SOME (_, _, (_, exec)) =&gt; exec)))
                           , Symtab.empty
                           , true)))
                     (C_Lex.directive_cmds dir)
               end
            |&gt; C_Env_Ext.map_stream_ignored (cons (Right tok)))
     | SOME (Right (C_Lex.Token ((pos1, pos2), (tok, src)))) =&gt;
      case tok of 
        C_Lex.String (C_Lex.Encoding_file (SOME err), _) =&gt;
        return0' (apfst
                   (C_Env.map_env_tree (C_Env.map_error_lines (cons (err ^ Position.here pos1)))))
                 (token_err pos1 pos2 src)
      | _ =&gt;
        return0
          (case tok of
             C_Lex.Char (b, [c]) =&gt;
              C_Grammar.Tokens.cchar
                (CChar (From_char_hd (case c of Left c =&gt; c | _ =&gt; chr 0)) (encoding b), pos1, pos2)
           | C_Lex.String (b, s) =&gt;
              C_Grammar.Tokens.cstr
                (CString0 ( From_string ( implode (map (fn Left s =&gt; s | Right _ =&gt; chr 0) s))
                                        , encoding b)
                          , pos1
                          , pos2)
           | C_Lex.Integer (i, repr, flag) =&gt;
              C_Grammar.Tokens.cint
               ( CInteger i (case repr of C_Lex.Repr_decimal =&gt; DecRepr0
                                        | C_Lex.Repr_hexadecimal =&gt; HexRepr0
                                        | C_Lex.Repr_octal =&gt; OctalRepr0)
                   (C_Lex.read_bin
                     (fold (fn flag =&gt;
                             map (fn (bit, flag0) =&gt;
                                   ( if flag0 = (case flag of
                                                   C_Lex.Flag_unsigned =&gt; FlagUnsigned0
                                                 | C_Lex.Flag_long =&gt; FlagLong0
                                                 | C_Lex.Flag_long_long =&gt; FlagLongLong0
                                                 | C_Lex.Flag_imag =&gt; FlagImag0)
                                     then "1"
                                     else bit
                                   , flag0)))
                           flag
                           ([FlagUnsigned, FlagLong, FlagLongLong, FlagImag] |&gt; rev
                                                                             |&gt; map (pair "0"))
                      |&gt; map #1)
                    |&gt; Flags)
               , pos1
               , pos2)
           | C_Lex.Float s =&gt;
              C_Grammar.Tokens.cfloat (CFloat (From_string (implode (map #1 s))), pos1, pos2)
           | C_Lex.Ident =&gt; 
              let val (name, arg) = C_Grammar_Rule_Lib.getNewName arg
                  val ident0 = C_Grammar_Rule_Lib.mkIdent
                                 (C_Grammar_Rule_Lib.posOf' false (pos1, pos2))
                                 src
                                 name
              in if C_Grammar_Rule_Lib.isTypeIdent src arg then
                   C_Grammar.Tokens.tyident (ident0, pos1, pos2)
                 else
                   C_Grammar.Tokens.ident (ident0, pos1, pos2)
              end
           | _ =&gt; token_err pos1 pos2 src)
  end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ This is where the instancing of the parser functor (from
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫) with the lexer (from
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Lexer_Language‚Ä∫) actually happens ... ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Grammar_Parser =
  LALR_Parser_Join (structure LrParser = LALR_Parser_Eval
                    structure ParserData = C_Grammar.ParserData
                    structure Lex = C_Grammar_Lexer)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_compiler.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Language = struct

open C_Env

fun exec_tree write msg (Tree ({rule_pos, rule_type}, l_tree)) =
  case rule_type of
    Void =&gt; write msg rule_pos "VOID" NONE
  | Shift =&gt; write msg rule_pos "SHIFT" NONE
  | Reduce (rule_static, (rule0, vacuous, rule_antiq)) =&gt;
      write
        msg
        rule_pos
        ("REDUCE " ^ Int.toString rule0 ^ " " ^ (if vacuous then "X" else "O"))
        (SOME (C_Grammar_Rule.string_reduce rule0 ^ " " ^ C_Grammar_Rule.type_reduce rule0))
      #&gt; (case rule_static of SOME rule_static =&gt; rule_static #&gt;&gt; SOME | NONE =&gt; pair NONE)
      #-&gt; (fn env_lang =&gt;
            fold (fn (stack0, env_lang0, (_, C_Env.Top_down exec, env_dir, _)) =&gt;
                     C_Stack.stack_exec env_dir
                                        (stack0, Option.getOpt (env_lang, env_lang0))
                                        (exec (SOME rule0))
                   | _ =&gt; I)
                 rule_antiq)
      #&gt; fold (exec_tree write (msg ^ " ")) l_tree

fun exec_tree' l env_tree = env_tree
  |&gt; fold (exec_tree let val ctxt = Context.proof_of (#context env_tree)
                         val write =
                           if Config.get ctxt C_Options.parser_trace
                              andalso Context_Position.is_visible ctxt
                           then fn f =&gt; tap (tracing o f) else K I
                     in fn msg =&gt; fn (p1, p2) =&gt; fn s1 =&gt; fn s2 =&gt;
                       write (fn _ =&gt; msg ^ s1 ^ " " ^ Position.here p1 ^ " " ^ Position.here p2
                                          ^ (case s2 of SOME s2 =&gt; " " ^ s2 | NONE =&gt; ""))
                     end
                     "")
          l

fun uncurry_context f pos = uncurry (fn x =&gt; fn arg =&gt; map_env_tree' (f pos x (#env_lang arg)) arg)

fun eval env_lang start err accept stream_lang =
 make env_lang stream_lang
 #&gt; C_Grammar_Parser.makeLexer
 #&gt; C_Grammar_Parser.parse
      ( 0
      , uncurry_context (fn (next_pos1, next_pos2) =&gt; fn (stack, _, _, stack_tree) =&gt; fn env_lang =&gt;
          C_Env.map_reports_text
            (cons ( ( Position.range_position (case hd stack of (_, (_, pos1, pos2)) =&gt;
                                                                  (pos1, pos2))
                    , Markup.bad ())
                  , "")
            #&gt; (case rev (tl stack) of
                  _ :: _ :: stack =&gt;
                 append
                   (map_filter
                     (fn (pos1, pos2) =&gt;
                      if Position.offset_of pos1 = Position.offset_of pos2
                      then NONE
                      else SOME ((Position.range_position (pos1, pos2), Markup.intensify), ""))
                     ((next_pos1, next_pos2)
                      :: map (fn (_, (_, pos1, pos2)) =&gt; (pos1, pos2)) stack))
                | _ =&gt; I))
          #&gt; exec_tree' (rev stack_tree)
          #&gt; err
               env_lang
               stack
               (Position.range_position
                 (case hd stack_tree of Tree ({rule_pos = (rule_pos1, _), ...}, _) =&gt;
                                          (rule_pos1, next_pos2))))
      , Position.none
      , start
      , uncurry_context (fn _ =&gt; fn (stack, _, _, stack_tree) =&gt; fn env_lang =&gt;
          exec_tree' stack_tree
          #&gt; accept env_lang (stack |&gt; hd |&gt; C_Stack.map_svalue0 C_Grammar_Rule.reduce0))
      , fn (stack, arg) =&gt; arg |&gt; map_rule_input (K stack)
                               |&gt; map_rule_output (K empty_rule_output)
      , fn (rule0, stack0, pre_ml) =&gt; fn arg =&gt;
          let val rule_output = #rule_output arg
              val env_lang = #env_lang arg
              val (delayed, actual) =
                if #output_vacuous rule_output
                then let fun f (_, _, _, to_delay) = to_delay
                     in (map (filter f) pre_ml, map (filter_out f) pre_ml) end
                else ([], pre_ml)
              val actual = flat (map rev actual)
          in
            ( (delayed, map (fn x =&gt; (stack0, env_lang, x)) actual, rule_output)
            , fold (fn (_, C_Env.Bottom_up (C_Env.Exec_annotation exec), env_dir, _) =&gt;
                       C_Env.map_env_tree
                         (C_Stack.stack_exec env_dir (stack0, env_lang) (exec (SOME rule0)))
                     | (_, C_Env.Bottom_up (C_Env.Exec_directive exec), env_dir, _) =&gt;
                       C_Env.map_env_lang_tree (curry (exec (SOME rule0) env_dir))
                     | _ =&gt; I)
                   actual
                   arg)
          end)
 #&gt; snd
 #&gt; apsnd #env_tree
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFull Evaluation Engine (Core Language with Annotations)‚Ä∫</span></span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/thy_info.ML‚Ä∫:
                                                                         \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫,
                                                                         \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Annotation‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_context.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/ML/ml_context.ML
    Author:     Makarius

ML context and antiquotations.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Context =
struct
fun fun_decl a v s ctxt =
  let
    val (b, ctxt') = ML_Context.variant a ctxt;
    val env = "fun " ^ b ^ " " ^ v ^ " = " ^ s ^ " " ^ v ^ ";\n";
    val body = ML_Context.struct_name ctxt ^ "." ^ b;
    fun decl (_: Proof.context) = (env, body);
  in (decl, ctxt') end;

(* parsing and evaluation *)

local

fun scan_antiq context syms =
  let val keywords = C_Thy_Header.get_keywords' (Context.proof_of context)
  in ( C_Token.read_antiq'
         keywords
         (C_Parse.!!! (Scan.trace (C_Annotation.parse_command (Context.theory_of context))
                       &gt;&gt; (I #&gt;&gt; C_Env.Antiq_stack)))
         syms
     , C_Token.read_with_commands'0 keywords syms)
  end

fun print0 s =
  maps
    (fn C_Lex.Token (_, (t as C_Lex.Directive d, _)) =&gt;
        (s ^ @{make_string} t) :: print0 (s ^ "  ") (C_Lex.token_list_of d)
      | C_Lex.Token (_, t) =&gt; 
        [case t of (C_Lex.Char _, _) =&gt; "Text Char"
                 | (C_Lex.String _, _) =&gt; "Text String"
                 | _ =&gt; let val t' = @{make_string} (#2 t)
                        in
                          if String.size t' &lt;= 2 then @{make_string} (#1 t)
                          else
                            s ^ @{make_string} (#1 t) ^ " "
                              ^ (String.substring (t', 1, String.size t' - 2)
                                 |&gt; Markup.markup Markup.intensify)
                        end])

val print = tracing o cat_lines o print0 ""

open C_Scan

fun markup_directive ty = C_Grammar_Rule_Lib.markup_make (K NONE) (K ()) (K ty)

in

fun markup_directive_command data =
  markup_directive
    "directive command"
    (fn cons' =&gt; fn def =&gt;
     fn C_Ast.Left _ =&gt;
          cons' (Markup.keyword_properties (if def then Markup.free else Markup.keyword1))
      | C_Ast.Right (_, msg, f) =&gt; tap (fn _ =&gt; Output.information msg)
                                #&gt; f
                                #&gt; cons' (Markup.keyword_properties Markup.free))
    data

fun directive_update (name, pos) f tab =
  let val pos = [pos]
      val data = (pos, serial (), f)
      val _ = Position.reports_text
                (markup_directive_command (C_Ast.Left (data, C_Env_Ext.list_lookup tab name))
                                          pos
                                          name
                                          [])
  in Symtab.update (name, data) tab end

fun markup_directive_define in_direct =
  C_Env.map_reports_text ooo
  markup_directive
    "directive define"
    (fn cons' =&gt; fn def =&gt; fn err =&gt; 
         (if def orelse in_direct then I else cons' Markup.language_antiquotation)
      #&gt; (case err of C_Ast.Left _ =&gt; I
                    | C_Ast.Right (_, msg, f) =&gt; tap (fn _ =&gt; Output.information msg) #&gt; f)
      #&gt; (if def then cons' Markup.free else if in_direct then I else cons' Markup.antiquote))

fun eval env start err accept (ants, ants_err) {context, reports_text, error_lines} =
  let val error_lines = ants_err error_lines
      fun scan_comment tag pos (antiq as {explicit, body, ...}) cts =
           let val (res, l_comm) = scan_antiq context body
           in 
             Left
                 ( tag
                 , antiq
                 , l_comm
                 , if forall (fn Right _ =&gt; true | _ =&gt; false) res then
                     let val (l_msg, res) =
                           split_list (map_filter (fn Right (msg, l_report, l_tok) =&gt;
                                                      SOME (msg, (l_report, l_tok))
                                                    | _ =&gt; NONE)
                                                  res)
                         val (l_report, l_tok) = split_list res
                     in [( C_Env.Antiq_none
                             (C_Lex.Token
                              (pos, ( (C_Lex.Comment o C_Lex.Comment_suspicious o SOME)
                                        ( explicit
                                        , cat_lines l_msg
                                        , if explicit then flat l_report else [])
                                    , cts)))
                         , l_tok)]
                     end
                   else
                     map (fn Left x =&gt; x
                           | Right (msg, l_report, tok) =&gt;
                               (C_Env.Antiq_none
                                 (C_Lex.Token
                                   ( C_Token.range_of [tok]
                                   , ( (C_Lex.Comment o C_Lex.Comment_suspicious o SOME)
                                         (explicit, msg, l_report)
                                     , C_Token.content_of tok)))
                               , [tok]))
                         res)
           end

      val ants = map (fn C_Lex.Token (pos, (C_Lex.Comment (C_Lex.Comment_formal antiq), cts)) =&gt;
                          scan_comment C_Env.Comment_language pos antiq cts
                       | tok =&gt; Right tok)
                     ants

      fun map_ants f1 f2 = maps (fn Left x =&gt; f1 x | Right tok =&gt; f2 tok)

      val ants_none =
            map_ants (fn (_, _, _, l) =&gt; maps (fn (C_Env.Antiq_none x, _) =&gt; [x] | _ =&gt; []) l)
                     (K [])
                     ants

      val _ = Position.reports (maps (fn Left (_, _, _, [(C_Env.Antiq_none _, _)]) =&gt; []
                                       | Left (_, {start, stop, range = (pos, _), ...}, _, _) =&gt;
                                          (case stop of SOME stop =&gt; cons (stop, Markup.antiquote)
                                                      | NONE =&gt; I)
                                            [(start, Markup.antiquote),
                                             (pos, Markup.language_antiquotation)]
                                       | _ =&gt; [])
                                     ants);
      val _ =
        Position.reports_text
          (maps C_Lex.token_report ants_none
           @ maps (fn Left (_, _, _, [(C_Env.Antiq_none _, _)]) =&gt; []
                    | Left (_, _, l, ls) =&gt;
                        maps (fn (C_Env.Antiq_stack (pos, _), _) =&gt; pos | _ =&gt; []) ls
                        @ maps (maps (C_Token.reports (C_Thy_Header.get_keywords
                                                        (Context.theory_of context))))
                               (l :: map #2 ls)
                    | _ =&gt; [])
                  ants);
      val error_lines = C_Lex.check ants_none error_lines;

      val ((ants, {context, reports_text, error_lines}), env) =
        C_Env_Ext.map_env_directives'
          (fn env_dir =&gt;
            let val (ants, (env_dir, env_tree)) =
              fold_map
                let
                  fun subst_directive tok (range1 as (pos1, _)) name (env_dir, env_tree) =
                    case Symtab.lookup env_dir name of
                      NONE =&gt; (Right (Left tok), (env_dir, env_tree))
                    | SOME (data as (_, _, (exec_toks, exec_antiq))) =&gt;
                        env_tree
                        |&gt; markup_directive_define
                            false
                            (C_Ast.Right ([pos1], SOME data))
                            [pos1]
                            name
                        |&gt; (case exec_toks of
                              Left exec_toks =&gt;
                                C_Env.map_context' (exec_toks (name, range1))
                                #&gt; apfst
                                     (fn toks =&gt;
                                       (toks, Symtab.update (name, ( #1 data
                                                                   , #2 data
                                                                   , (Right toks, exec_antiq)))
                                                            env_dir))
                            | Right toks =&gt; pair (toks, env_dir))
                        ||&gt; C_Env.map_context (exec_antiq (name, range1))
                        |-&gt; (fn (toks, env_dir) =&gt;
                              pair (Right (Right (pos1, map (C_Lex.set_range range1) toks)))
                              o pair env_dir)
                in
                 fn Left (tag, antiq, toks, l_antiq) =&gt;
                      fold_map
                       (fn antiq as (C_Env.Antiq_stack (_, C_Env.Lexing (_, exec)), _) =&gt;
                             apsnd (C_Stack.stack_exec0 (exec C_Env.Comment_language)) #&gt; pair antiq
                         | (C_Env.Antiq_stack
                             (rep, C_Env.Parsing (syms, (range, exec, _, skip))), toks) =&gt;
                             (fn env as (env_dir, _) =&gt;
                               ( ( C_Env.Antiq_stack
                                    (rep, C_Env.Parsing (syms, (range, exec, env_dir, skip)))
                                 , toks)
                               , env))
                         | antiq =&gt; pair antiq)
                       l_antiq
                      #&gt; apfst (fn l_antiq =&gt; Left (tag, antiq, toks, l_antiq))
                  | Right tok =&gt;
                  case tok of
                    C_Lex.Token (_, (C_Lex.Directive dir, _)) =&gt;
                      pair false
                      #&gt; fold
                          (fn dir_tok =&gt;
                            let val name = C_Lex.content_of dir_tok
                                val pos1 = [C_Lex.pos_of dir_tok]
                            in
                              fn env_tree as (_, (_, {context = context, ...})) =&gt;
                              let val data = Symtab.lookup (C_Context0.Directives.get context) name
                              in
                              env_tree
                              |&gt; apsnd (apsnd (C_Env.map_reports_text (markup_directive_command
                                                                        (C_Ast.Right (pos1, data))
                                                                        pos1
                                                                        name)))
                              |&gt; (case data of NONE =&gt; I | SOME (_, _, (exec, _)) =&gt; exec dir #&gt; #2)
                              end
                            end)
                          (C_Lex.directive_cmds dir)
                      #&gt; snd
                      #&gt; tap
                           (fn _ =&gt;
                             app (fn C_Lex.Token ( (pos, _)
                                                 , (C_Lex.Comment (C_Lex.Comment_formal _), _)) =&gt;
                                     (Position.reports_text [((pos, Markup.ML_comment), "")];
                                      (* not yet implemented *)
                                      warning ("Ignored annotation in directive"
                                               ^ Position.here pos))
                                   | _ =&gt; ())
                                 (C_Lex.token_list_of dir))
                      #&gt; pair (Right (Left tok))
                  | C_Lex.Token (pos, (C_Lex.Keyword, cts)) =&gt; subst_directive tok pos cts
                  | C_Lex.Token (pos, (C_Lex.Ident, cts)) =&gt; subst_directive tok pos cts
                  | _ =&gt; pair (Right (Left tok))
                end
                ants
                ( env_dir
                , {context = context, reports_text = reports_text, error_lines = error_lines})
            in ((ants, env_tree), env_dir) end)
          env

      val ants_stack =
        map_ants (single o Left o (fn (_, a, _, l) =&gt; (a, maps (single o #1) l)))
                 (map Right o (fn Left tok =&gt; [tok] | Right (_, toks) =&gt; toks))
                 ants
      val _ =
          Position.reports_text (maps (fn Right (Left tok) =&gt; C_Lex.token_report tok
                                        | Right (Right (pos, [])) =&gt; [((pos, Markup.intensify), "")]
                                        | _ =&gt; [])
                                      ants);
      val ctxt = Context.proof_of context
      val () = if Config.get ctxt C_Options.lexer_trace andalso Context_Position.is_visible ctxt
               then print (map_filter (fn Right x =&gt; SOME x | _ =&gt; NONE) ants_stack)
               else ()
  in
   C_Language.eval env
                   start
                   err
                   accept
                   ants_stack
                   {context = context, reports_text = reports_text, error_lines = error_lines}
  end


(* derived versions *)

fun eval' env start err accept ants =
  Context.&gt;&gt;&gt; (fn context =&gt;
               C_Env_Ext.context_map'
                 (eval (env context) (start context) err accept ants
                  #&gt; apsnd (tap (Position.reports_text o #reports_text)
                            #&gt; tap (#error_lines #&gt; (fn [] =&gt; () | l =&gt; error (cat_lines (rev l))))
                            #&gt; (C_Env.empty_env_tree o #context)))
                 context)
end;

fun eval_source env start err accept source =
  eval' env (start source) err accept (C_Lex.read_source source);

fun eval_source' env start err accept source =
  eval env (start source) err accept (C_Lex.read_source source);

fun eval_in o_context env start err accept toks =
  Context.setmp_generic_context o_context
    (fn () =&gt; eval' env start err accept toks) ();

fun expression struct_open range name constraint body ants context = context |&gt;
  ML_Context.exec
    let val verbose = Config.get (Context.proof_of context) C_Options.ML_verbose
    in fn () =&gt;
      ML_Context.eval (ML_Compiler.verbose verbose ML_Compiler.flags) (#1 range)
       (ML_Lex.read ("Context.put_generic_context (SOME (let open " ^ struct_open ^ " val ") @
                                                                 ML_Lex.read_set_range range name @
        ML_Lex.read (": " ^ constraint ^ " =") @ ants @
        ML_Lex.read ("in " ^ body ^ " end (Context.the_generic_context ())));"))
    end;
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Command">
<div class="head"><h1>Theory C_Command</h1>
<span class="command">theory</span> <span class="name">C_Command</span><br/>
<span class="keyword">imports</span> <a href="C_Eval.html"><span class="name">C_Eval</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInterface: Inner and Outer Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Command</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Eval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"ML"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C_file"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_load</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"ML"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C_export_boot"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"ML"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C_export_file"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C_prf"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME % "ML" ?? *)</span></span></span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C_val"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>diag</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"ML"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπParsing Entry-Point: Error and Acceptance Cases‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Tools/ghc.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Tools/ghc.ML
    Author:     Makarius

Support for GHC: Glasgow Haskell Compiler.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Serialize =
struct

(** string literals **)

fun print_codepoint c =
  (case c of
    10 =&gt; "\\n"
  | 9 =&gt; "\\t"
  | 11 =&gt; "\\v"
  | 8 =&gt; "\\b"
  | 13 =&gt; "\\r"
  | 12 =&gt; "\\f"
  | 7 =&gt; "\\a"
  | 27 =&gt; "\\e"
  | 92 =&gt; "\\\\"
  | 63 =&gt; "\\?"
  | 39 =&gt; "\\'"
  | 34 =&gt; "\\\""
  | c =&gt;
      if c &gt;= 32 andalso c &lt; 127 then chr c
      else error "Not yet implemented");

fun print_symbol sym =
  (case Symbol.decode sym of
    Symbol.Char s =&gt; print_codepoint (ord s)
  | Symbol.UTF8 s =&gt; UTF8.decode_permissive s |&gt; map print_codepoint |&gt; implode
  | Symbol.Sym s =&gt; "\\092&lt;" ^ s ^ "&gt;"
  | Symbol.Control s =&gt; "\\092&lt;^" ^ s ^ "&gt;"
  | _ =&gt; translate_string (print_codepoint o ord) sym);

val print_string = quote o implode o map print_symbol o Symbol.explode;
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Tools/generated_files.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Tools/generated_files.ML
    Author:     Makarius

Generated source files for other languages: with antiquotations, without Isabelle symbols.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Generated_Files =
struct

val c_dir = "C";
val c_ext = "c";
val c_make_comment = enclose "/*" "*/";

(** context data **)

(* file types *)

fun get_file_type ext =
  if ext = "" then error "Bad file extension"
  else if c_ext = ext then ()
  else error ("Unknown file type for extension " ^ quote ext);



(** Isar commands **)

(* generate_file *)

fun generate_file (binding, src_content) lthy =
  let
    val (path, pos) = Path.dest_binding binding;
    val () =
      get_file_type (#2 (Path.split_ext path))
        handle ERROR msg =&gt; error (msg ^ Position.here pos);
    val header = c_make_comment " generated by Isabelle ";
    val content = header ^ "\n" ^ src_content;
  in lthy |&gt; (Local_Theory.background_theory o Generated_Files.add_files) (binding, content) end;



(** concrete file types **)

val _ =
  Theory.setup
    (Generated_Files.file_type \&lt;^binding&gt;‚ÄπC‚Ä∫
      {ext = c_ext,
       make_comment = c_make_comment,
       make_string = C_Serialize.print_string});
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Eval‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Module =
struct

structure Data_In_Source = Generic_Data
  (type T = Input.source list
   val empty = []
   val extend = K empty
   val merge = K empty)

structure Data_In_Env = Generic_Data
  (type T = C_Env.env_lang
   val empty = C_Env.empty_env_lang
   val extend = K empty
   val merge = K empty)

structure Data_Accept = Generic_Data
  (type T = C_Grammar_Rule.start_happy -&gt; C_Env.env_lang -&gt; Context.generic -&gt; Context.generic
   fun empty _ _ = I
   val extend = I
   val merge = #2)

structure Data_Term = Generic_Data
  (type T = (C_Grammar_Rule.start_happy -&gt; C_Env.env_lang -&gt; local_theory -&gt; term) Symtab.table
   val empty = Symtab.empty
   val extend = I
   val merge = #2)

structure C_Term =
struct
val key_translation_unit = ‚Äπtranslation_unit‚Ä∫
val key_external_declaration = ‚Äπexternal_declaration‚Ä∫
val key_statement = ‚Äπstatement‚Ä∫
val key_expression = ‚Äπexpression‚Ä∫
val key_default = ‚Äπdefault‚Ä∫

local
val source_content = Input.source_content #&gt; #1
in
val key0_translation_unit = source_content key_translation_unit
val key0_external_declaration = source_content key_external_declaration
val key0_statement = source_content key_statement
val key0_expression = source_content key_expression
val key0_default = source_content key_default
end

val tok0_translation_unit = (key0_translation_unit, C_Grammar.Tokens.start_translation_unit)
val tok0_external_declaration = ( key0_external_declaration
                                , C_Grammar.Tokens.start_external_declaration)
val tok0_statement = (key0_statement, C_Grammar.Tokens.start_statement)
val tok0_expression = (key0_expression, C_Grammar.Tokens.start_expression)

val tok_translation_unit = (key_translation_unit, C_Grammar.Tokens.start_translation_unit)
val tok_external_declaration = ( key_external_declaration
                               , C_Grammar.Tokens.start_external_declaration)
val tok_statement = (key_statement, C_Grammar.Tokens.start_statement)
val tok_expression = (key_expression, C_Grammar.Tokens.start_expression)

val tokens = [ tok0_translation_unit
             , tok0_external_declaration
             , tok0_statement
             , tok0_expression ]

local
fun map_upd0 key v = Context.theory_map (Data_Term.map (Symtab.update (key, v)))
fun map_upd key start f = map_upd0 key (f o the o start)
in
val map_translation_unit = map_upd key0_translation_unit C_Grammar_Rule.start_happy1
val map_external_declaration = map_upd key0_external_declaration C_Grammar_Rule.start_happy2
val map_statement = map_upd key0_statement C_Grammar_Rule.start_happy3
val map_expression = map_upd key0_expression C_Grammar_Rule.start_happy4
val map_default = map_upd0 key0_default
end

end

fun env0 ctxt =
  case Config.get ctxt C_Options.starting_env of
    "last" =&gt; Data_In_Env.get (Context.Proof ctxt)
  | "empty" =&gt; C_Env.empty_env_lang
  | s =&gt; error ("Unknown option: " ^ s ^ Position.here (Config.pos_of C_Options.starting_env))

val env = env0 o Context.proof_of

fun start source context =
 Input.range_of source
 |&gt;
  let val s = Config.get (Context.proof_of context) C_Options.starting_rule
  in case AList.lookup (op =) C_Term.tokens s of
       SOME tok =&gt; tok
     | NONE =&gt; error ("Unknown option: " ^ s
                                         ^ Position.here (Config.pos_of C_Options.starting_rule))
  end

fun err0 _ _ pos =
  C_Env.map_error_lines (cons ("Parser: No matching grammar rule" ^ Position.here pos))

val err = pair () oooo err0

fun accept0 f env_lang ast =
  Data_In_Env.put env_lang
  #&gt; (fn context =&gt; f context ast env_lang (Data_Accept.get context ast env_lang context))

fun accept env_lang (_, (ast, _, _)) =
  pair () o C_Env.map_context (accept0 (K (K (K I))) env_lang ast)

val eval_source = C_Context.eval_source env start err accept

fun c_enclose bg en source =
  C_Lex.@@ ( C_Lex.@@ (C_Lex.read bg, C_Lex.read_source source)
           , C_Lex.read en);

structure C_Term' =
struct
val err = pair Term.dummy oooo err0

fun accept ctxt start_rule =
  let 
    val (key, start) =
      case start_rule of NONE =&gt; (C_Term.key_default, start)
                       | SOME (key, start_rule) =&gt;
                           (key, fn source =&gt; fn _ =&gt; start_rule (Input.range_of source))
    val (key, pos) = Input.source_content key
  in
    ( start
    , fn env_lang =&gt; fn (_, (ast, _, _)) =&gt;
        C_Env.map_context'
          (accept0
            (fn context =&gt;
              pair oo (case Symtab.lookup (Data_Term.get context) key of
                         NONE =&gt; tap (fn _ =&gt; warning ("Representation function associated to\
                                                       \ \"" ^ key ^ "\"" ^ Position.here pos
                                                       ^ " not found (returning a dummy term)"))
                                     (fn _ =&gt; fn _ =&gt; @{term "()"})
                       | SOME f =&gt; fn ast =&gt; fn env_lang =&gt; f ast env_lang ctxt))
            env_lang
            ast))
  end

fun eval_in text context env start_rule =
  let 
    val (start, accept) = accept (Context.proof_of context) start_rule
  in
    C_Context.eval_in (SOME context) env (start text) err accept
  end

fun parse_translation l = l |&gt;
  map
  (apsnd
    (fn start_rule =&gt; fn ctxt =&gt; fn args =&gt;
      let val msg = (case start_rule of NONE =&gt; C_Term.key_default
                                      | SOME (key, _) =&gt; key)
                    |&gt; Input.source_content |&gt; #1
          fun err () = raise TERM (msg, args)
      in
       case args of
         [(c as Const (\&lt;^syntax_const&gt;‚Äπ_constrain‚Ä∫, _)) $ Free (s, _) $ p] =&gt;
          (case Term_Position.decode_position p of
            SOME (pos, _) =&gt;
            c
            $ let val src = 
                uncurry
                  (Input.source false)
                  let val s0 = Symbol_Pos.explode (s, pos)
                      val s = Symbol_Pos.cartouche_content s0
                  in
                    ( Symbol_Pos.implode s
                    , case s of [] =&gt; Position.no_range
                              | (_, pos0) :: _ =&gt; Position.range (pos0, s0 |&gt; List.last |&gt; snd))
                  end
              in
              eval_in
                src
                (case Context.get_generic_context () of
                   NONE =&gt; Context.Proof ctxt
                 | SOME context =&gt; Context.mapping I (K ctxt) context)
                (C_Stack.Data_Lang.get #&gt; (fn NONE =&gt; env0 ctxt
                                            | SOME (_, env_lang) =&gt; env_lang))
                start_rule
                (c_enclose "" "" src)
              end
            $ p
          | NONE =&gt; err ())
       | _ =&gt; err ()
      end))
end

fun eval_in text ctxt = C_Context.eval_in ctxt env (start text) err accept

fun exec_eval source =
  Data_In_Source.map (cons source)
  #&gt; ML_Context.exec (fn () =&gt; eval_source source)

fun C_prf source =
  Proof.map_context (Context.proof_map (exec_eval source))
  #&gt; Proof.propagate_ml_env

fun C_export_boot source context =
  context
  |&gt; Config.put_generic ML_Env.ML_environment ML_Env.Isabelle
  |&gt; Config.put_generic ML_Env.ML_write_global true
  |&gt; exec_eval source
  |&gt; Config.restore_generic ML_Env.ML_write_global context
  |&gt; Config.restore_generic ML_Env.ML_environment context
  |&gt; Local_Theory.propagate_ml_env

fun C source =
  exec_eval source
  #&gt; Local_Theory.propagate_ml_env

fun C' env_lang src context =
  context
  |&gt; C_Env.empty_env_tree
  |&gt; C_Context.eval_source'
       env_lang
       (fn src =&gt; start src context)
       err
       accept
       src
  |&gt; (fn (_, {context, reports_text, error_lines}) =&gt; 
     tap (fn _ =&gt; case error_lines of [] =&gt; () | l =&gt; warning (cat_lines (rev l)))
         (C_Stack.Data_Tree.map (curry C_Stack.Data_Tree_Args.merge (reports_text, []))
                                context))

fun C_export_file (pos, _) lthy =
  let
    val c_sources = Data_In_Source.get (Context.Proof lthy)
    val binding =
      Path.binding
        ( Path.appends [ Path.basic C_Generated_Files.c_dir
                       , Path.basic (string_of_int (length c_sources))
                       , lthy |&gt; Proof_Context.theory_of |&gt; Context.theory_name |&gt; Path.explode
                              |&gt; Path.ext C_Generated_Files.c_ext ]
        , pos)
  in
    lthy
    |&gt; C_Generated_Files.generate_file (binding, rev c_sources |&gt; map (Input.source_content #&gt; #1)
                                                               |&gt; cat_lines)
    |&gt; tap (Proof_Context.theory_of
            #&gt; (fn thy =&gt; let val file = Generated_Files.get_file thy binding
                          in Generated_Files.export_file thy file;
                             writeln (Export.message thy Path.current);
                             writeln (prefix "  " (Generated_Files.print_file file))
                          end))
  end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefinitions of Inner Directive Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInitialization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπPure‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Directive =
struct
local
fun directive_update keyword data = C_Context.directive_update keyword (data, K (K (K I)))
fun return f (env_cond, env) = ([], (env_cond, f env))
fun directive_update_define pos f_toks f_antiq =
  directive_update ("define", pos)
    (return
     o
      (fn C_Lex.Define (_, C_Lex.Group1 ([], [tok3]), NONE, C_Lex.Group1 ([], toks)) =&gt;
          let val map_ctxt = 
              case (tok3, toks) of
                (C_Lex.Token ((pos, _), (C_Lex.Ident, ident)),
                 [C_Lex.Token (_, (C_Lex.Integer (_, C_Lex.Repr_decimal, []), integer))]) =&gt;
                  C_Env.map_context
                    (Context.map_theory
                      (Named_Target.theory_map
                        (Specification.definition_cmd
                          (SOME (Binding.make (ident, pos), NONE, NoSyn))
                          []
                          []
                          (Binding.empty_atts, ident ^ " ‚â° " ^ integer)
                          true
                         #&gt; tap (fn ((_, (_, t)), ctxt) =&gt;
                                 Output.information
                                   ("Generating "
                                    ^ Pretty.string_of (Syntax.pretty_term ctxt (Thm.prop_of t))
                                    ^ Position.here
                                        (Position.range_position
                                          ( C_Lex.pos_of tok3
                                          , C_Lex.end_pos_of (List.last toks)))))
                         #&gt; #2)))
              | _ =&gt; I
          in 
            fn (env_dir, env_tree) =&gt;
              let val name = C_Lex.content_of tok3
                  val pos = [C_Lex.pos_of tok3]
                  val data = (pos, serial (), (C_Scan.Left (f_toks toks), f_antiq))
              in
                ( Symtab.update (name, data) env_dir
                , env_tree |&gt; C_Context.markup_directive_define
                                false
                                (C_Ast.Left (data, C_Env_Ext.list_lookup env_dir name))
                                pos
                                name
                           |&gt; map_ctxt)
              end
          end
        | C_Lex.Define (_, C_Lex.Group1 ([], [tok3]), SOME (C_Lex.Group1 (_ :: toks_bl, _)), _)
          =&gt;
            tap (fn _ =&gt; (* not yet implemented *)
                   warning ("Ignored functional macro directive"
                            ^ Position.here
                                (Position.range_position
                                  (C_Lex.pos_of tok3, C_Lex.end_pos_of (List.last toks_bl)))))
        | _ =&gt; I))
in
val setup_define = Context.theory_map o C_Context0.Directives.map ooo directive_update_define

val _ =
  Theory.setup
  (Context.theory_map
    (C_Context0.Directives.map
      (directive_update_define ‚åÇ (K o pair) (K I)
       #&gt;
       directive_update ("undef", ‚åÇ)
        (return
         o
          (fn C_Lex.Undef (C_Lex.Group2 (_, _, [tok])) =&gt;
                (fn (env_dir, env_tree) =&gt;
                  let val name = C_Lex.content_of tok
                      val pos1 = [C_Lex.pos_of tok]
                      val data = Symtab.lookup env_dir name
                  in ( (case data of NONE =&gt; env_dir | SOME _ =&gt; Symtab.delete name env_dir)
                     , C_Context.markup_directive_define true
                                                         (C_Ast.Right (pos1, data))
                                                         pos1
                                                         name
                                                         env_tree)
                  end)
            | _ =&gt; I)))))
end
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefinitions of Inner Annotation Commands‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLibrary‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/toplevel.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Inner_Toplevel =
struct
val theory = Context.map_theory
fun local_theory' target f gthy =
  let
    val (finish, lthy) = Named_Target.switch target gthy;
    val lthy' = lthy
      |&gt; Local_Theory.new_group
      |&gt; f false
      |&gt; Local_Theory.reset_group;
  in finish lthy' end
val generic_theory = I
fun keep'' f = tap (f o Context.proof_of)
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/isar_cmd.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Inner_Isar_Cmd = 
struct


(** theory declarations **)

(* generic setup *)

fun setup0 f_typ f_val src =
 fn NONE =&gt;
    let val setup = "setup"
    in C_Context.expression
        "C_Ast"
        (Input.range_of src)
        setup
        (f_typ "C_Stack.stack_data"
               "C_Stack.stack_data_elem -&gt; C_Env.env_lang -&gt; Context.generic -&gt; Context.generic")
        ("fn context =&gt; \
           \let val (stack, env_lang) = C_Stack.Data_Lang.get' context \
           \in " ^ f_val setup "stack" ^ " (stack |&gt; hd) env_lang end context")
        (ML_Lex.read_source src) end
  | SOME rule =&gt; 
    let val hook = "hook"
    in C_Context.expression
        "C_Ast"
        (Input.range_of src)
        hook
        (f_typ "C_Stack.stack_data"
               (C_Grammar_Rule.type_reduce rule
                ^ " C_Stack.stack_elem -&gt; C_Env.env_lang -&gt; Context.generic -&gt; Context.generic"))
        ("fn context =&gt; \
           \let val (stack, env_lang) = C_Stack.Data_Lang.get' context \
           \in " ^ f_val hook
                         "stack" ^ " "
                       ^ "(stack \
                           \|&gt; hd \
                           \|&gt; C_Stack.map_svalue0 C_Grammar_Rule.reduce" ^ Int.toString rule ^ ")\
                         \env_lang \
           \end \
           \  context")
        (ML_Lex.read_source src)
    end
val setup = setup0 (fn a =&gt; fn b =&gt; a ^ " -&gt; " ^ b) (fn a =&gt; fn b =&gt; a ^ " " ^ b)
val setup' = setup0 (K I) K


(* print theorems, terms, types etc. *)

local

fun string_of_term ctxt s =
  let
    val t = Syntax.read_term ctxt s;
    val T = Term.type_of t;
    val ctxt' = Proof_Context.augment t ctxt;
  in
    Pretty.string_of
      (Pretty.block [Pretty.quote (Syntax.pretty_term ctxt' t), Pretty.fbrk,
        Pretty.str "::", Pretty.brk 1, Pretty.quote (Syntax.pretty_typ ctxt' T)])
  end;

fun print_item string_of (modes, arg) ctxt =
  Print_Mode.with_modes modes (fn () =&gt; writeln (string_of ctxt arg)) ();

in

val print_term = print_item string_of_term;

end;

end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/outer_syntax.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Inner_Syntax =
struct
val drop1 = fn C_Scan.Left f =&gt; C_Scan.Left (K o f)
             | C_Scan.Right (f, dir) =&gt; C_Scan.Right (K o f, dir)

val drop2 = fn C_Scan.Left f =&gt; C_Scan.Left (K o K o f)
             | C_Scan.Right (f, dir) =&gt; C_Scan.Right (K o K o f, dir)

val bottom_up = C_Env.Bottom_up o C_Env.Exec_annotation

(**)

fun pref_lex name = "#" ^ name
val pref_bot = I
fun pref_top name = name ^ "‚áì"

(**)

fun command2' cmd f (pos_bot, pos_top) =
  let fun cmd' dir = cmd (C_Scan.Right (f, dir)) Keyword.thy_decl
  in   cmd' bottom_up (pref_bot, pos_bot)
    #&gt; cmd' C_Env.Top_down (pref_top, pos_top)
  end

fun command3' cmd f (pos_lex, pos_bot, pos_top) =
     cmd (C_Scan.Left f) (pref_lex, pos_lex)
  #&gt; command2' (K o cmd) f (pos_bot, pos_top)

fun command2 cmd f (name, pos_bot, pos_top) =
  command2' (fn f =&gt; fn kind =&gt; fn (name_pref, pos) =&gt; cmd f kind (name_pref name, pos))
            f
            (pos_bot, pos_top)

fun command3 cmd f (name, pos_lex, pos_bot, pos_top) =
  command3' (fn f =&gt; fn (name_pref, pos) =&gt; cmd f (name_pref name, pos))
            f
            (pos_lex, pos_bot, pos_top)

(**)

fun command00 f kind scan name =
  C_Annotation.command'' kind name ""
    (case f of
       C_Scan.Left f =&gt;
        (fn _ =&gt;
          C_Parse.range scan &gt;&gt;
            (fn (src, range) =&gt;
              C_Env.Lexing (range, f src range)))
     | C_Scan.Right (f, dir) =&gt;
         fn ((stack1, (to_delay, stack2)), _) =&gt;
          C_Parse.range scan &gt;&gt;
            (fn (src, range) =&gt;
              C_Env.Parsing ((stack1, stack2), (range, dir (f src range), Symtab.empty, to_delay))))

fun command00_no_range f kind name =
  C_Annotation.command'' kind name ""
    (case f of
       C_Scan.Left f =&gt;
        (fn (_, range) =&gt;
          Scan.succeed () &gt;&gt;
            K (C_Env.Lexing (range, f range)))
     | C_Scan.Right (f, dir) =&gt;
         fn ((stack1, (to_delay, stack2)), range) =&gt;
          Scan.succeed () &gt;&gt;
            K (C_Env.Parsing ((stack1, stack2), (range, dir (f range), Symtab.empty, to_delay))))

(**)

fun command' f = command00 (drop1 f) Keyword.thy_decl

fun command f scan = command2 (fn f =&gt; fn kind =&gt; command00 f kind scan) (K o f)

fun command_range f = command00_no_range f Keyword.thy_decl

val command_range' = command3 (command_range o drop1)

fun command_no_range' f = command00_no_range (drop1 f) Keyword.thy_decl

fun command_no_range f = command2 command00_no_range (K f)

fun command0 f scan = command3 (fn f =&gt; command' (drop1 f) scan) f

fun local_command' (name, pos_lex, pos_bot, pos_top) scan f =
  command3' (fn f =&gt; fn (name_pref, pos) =&gt;
              command' (drop1 f)
                       (C_Token.syntax' (Parse.opt_target -- scan name_pref))
                       (name_pref name, pos))
            (fn (target, arg) =&gt; C_Inner_Toplevel.local_theory' target (f arg))
            (pos_lex, pos_bot, pos_top)

fun local_command'' spec = local_command' spec o K

val command0_no_range = command_no_range' o drop1

fun command0' f kind scan =
  command3 (fn f =&gt; fn (name, pos) =&gt; command00 (drop2 f) kind (scan name) (name, pos)) f
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_file.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Inner_File =
struct

fun command_c ({lines, pos, ...}: Token.file) =
  C_Module.C (Input.source true (cat_lines lines) (pos, pos));

fun C files gthy =
  command_c (hd (files (Context.theory_of gthy))) gthy;

fun command_ml environment debug files gthy =
  let
    val file: Token.file = hd (files (Context.theory_of gthy));
    val source = Token.file_source file;

    val _ = Thy_Output.check_comments (Context.proof_of gthy) (Input.source_explode source);

    val flags: ML_Compiler.flags =
      {environment = environment, redirect = true, verbose = true,
        debug = debug, writeln = writeln, warning = warning};
  in
    gthy
    |&gt; ML_Context.exec (fn () =&gt; ML_Context.eval_source flags source)
    |&gt; Local_Theory.propagate_ml_env
  end;

val ML = command_ml "";
val SML = command_ml ML_Env.SML;
end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInitialization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπPure‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
C_Thy_Header.add_keywords_minor
  (maps (fn ((name, pos_lex, pos_bot, pos_top), ty) =&gt;
          [ ((C_Inner_Syntax.pref_lex name, pos_lex), ty)
          , ((C_Inner_Syntax.pref_bot name, pos_bot), ty)
          , ((C_Inner_Syntax.pref_top name, pos_top), ty) ])
        [ (("apply", ‚åÇ, ‚åÇ, ‚åÇ), ((Keyword.prf_script, []), ["proof"]))
        , (("by", ‚åÇ, ‚åÇ, ‚åÇ), ((Keyword.qed, []), ["proof"]))
        , (("done", ‚åÇ, ‚åÇ, ‚åÇ), ((Keyword.qed_script, []), ["proof"])) ])
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπPure‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local
val semi = Scan.option (C_Parse.$$$ ";");

structure C_Isar_Cmd = 
struct
fun ML source = ML_Context.exec (fn () =&gt;
                   ML_Context.eval_source (ML_Compiler.verbose true ML_Compiler.flags) source) #&gt;
                 Local_Theory.propagate_ml_env

fun theorem schematic ((long, binding, includes, elems, concl), (l_meth, o_meth)) int lthy =
     (if schematic then Specification.schematic_theorem_cmd else Specification.theorem_cmd)
       long Thm.theoremK NONE (K I) binding includes elems concl int lthy
  |&gt; fold (fn m =&gt; tap (fn _ =&gt; Method.report m) #&gt; Proof.apply m #&gt; Seq.the_result "") l_meth
  |&gt; (case o_meth of
        NONE =&gt; Proof.global_done_proof
      | SOME (m1, m2) =&gt;
          tap (fn _ =&gt; (Method.report m1; Option.map Method.report m2))
          #&gt; Proof.global_terminal_proof (m1, m2))

fun definition (((decl, spec), prems), params) =
  #2 oo Specification.definition_cmd decl params prems spec

fun declare (facts, fixes) =
  #2 oo Specification.theorems_cmd "" [(Binding.empty_atts, flat facts)] fixes
end

local
val long_keyword =
  Parse_Spec.includes &gt;&gt; K "" ||
  Parse_Spec.long_statement_keyword;

val long_statement =
  Scan.optional (Parse_Spec.opt_thm_name ":" --| Scan.ahead long_keyword) Binding.empty_atts --
  Scan.optional Parse_Spec.includes [] -- Parse_Spec.long_statement
    &gt;&gt; (fn ((binding, includes), (elems, concl)) =&gt; (true, binding, includes, elems, concl));

val short_statement =
  Parse_Spec.statement -- Parse_Spec.if_statement -- Parse.for_fixes
    &gt;&gt; (fn ((shows, assumes), fixes) =&gt;
      (false, Binding.empty_atts, [], [Element.Fixes fixes, Element.Assumes assumes],
        Element.Shows shows));
in
fun theorem spec schematic =
  C_Inner_Syntax.local_command'
    spec
    (fn name_pref =&gt;
      (long_statement || short_statement)
      -- let val apply = Parse.$$$ (name_pref "apply") |-- Method.parse
         in Scan.repeat1 apply -- (Parse.$$$ (name_pref "done") &gt;&gt; K NONE)
         || Scan.repeat apply -- (Parse.$$$ (name_pref "by")
                                  |-- Method.parse -- Scan.option Method.parse &gt;&gt; SOME)
         end)
    (C_Isar_Cmd.theorem schematic)
end

val opt_modes =
  Scan.optional (\&lt;^keyword&gt;‚Äπ(‚Ä∫ |-- Parse.!!! (Scan.repeat1 Parse.name --| \&lt;^keyword&gt;‚Äπ)‚Ä∫)) [];

val _ = Theory.setup
 (   C_Inner_Syntax.command (C_Inner_Toplevel.generic_theory oo C_Inner_Isar_Cmd.setup)
                            C_Parse.ML_source
                            ("‚âàsetup", ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0 (C_Inner_Toplevel.theory o Isar_Cmd.setup)
                             C_Parse.ML_source
                             ("setup", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0 (C_Inner_Toplevel.generic_theory o C_Isar_Cmd.ML)
                             C_Parse.ML_source
                             ("ML", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0 (C_Inner_Toplevel.generic_theory o C_Module.C)
                             C_Parse.C_source
                             ("C", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0' (C_Inner_Toplevel.generic_theory o C_Inner_File.ML NONE)
                              Keyword.thy_load
                              (fn name =&gt; C_Resources.parse_files name --| semi)
                              ("ML_file", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0' (C_Inner_Toplevel.generic_theory o C_Inner_File.C)
                              Keyword.thy_load
                              (fn name =&gt; C_Resources.parse_files name --| semi)
                              ("C_file", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command0 (C_Inner_Toplevel.generic_theory o C_Module.C_export_boot)
                             C_Parse.C_source
                             ("C_export_boot", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command_range'
                             (Context.map_theory o Named_Target.theory_map o C_Module.C_export_file)
                             ("C_export_file", ‚åÇ, ‚åÇ, ‚åÇ)
  #&gt; C_Inner_Syntax.command_no_range
       (C_Inner_Toplevel.generic_theory oo C_Inner_Isar_Cmd.setup
         ‚Äπfn ((_, (_, pos1, pos2)) :: _) =&gt;
              (fn _ =&gt; fn _ =&gt;
                tap (fn _ =&gt;
                      Position.reports_text [((Position.range (pos1, pos2)
                                               |&gt; Position.range_position, Markup.intensify), "")]))
           | _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫)
       ("highlight", ‚åÇ, ‚åÇ)
  #&gt; theorem ("theorem", ‚åÇ, ‚åÇ, ‚åÇ) false
  #&gt; theorem ("lemma", ‚åÇ, ‚åÇ, ‚åÇ) false
  #&gt; theorem ("corollary", ‚åÇ, ‚åÇ, ‚åÇ) false
  #&gt; theorem ("proposition", ‚åÇ, ‚åÇ, ‚åÇ) false
  #&gt; theorem ("schematic_goal", ‚åÇ, ‚åÇ, ‚åÇ) true
  #&gt; C_Inner_Syntax.local_command''
      ("definition", ‚åÇ, ‚åÇ, ‚åÇ)
      (Scan.option Parse_Spec.constdecl -- (Parse_Spec.opt_thm_name ":" -- Parse.prop) --
        Parse_Spec.if_assumes -- Parse.for_fixes)
      C_Isar_Cmd.definition
  #&gt; C_Inner_Syntax.local_command''
      ("declare", ‚åÇ, ‚åÇ, ‚åÇ)
      (Parse.and_list1 Parse.thms1 -- Parse.for_fixes)
      C_Isar_Cmd.declare
  #&gt; C_Inner_Syntax.command0
      (C_Inner_Toplevel.keep'' o C_Inner_Isar_Cmd.print_term)
      (C_Token.syntax' (opt_modes -- Parse.term))
      ("term", ‚åÇ, ‚åÇ, ‚åÇ))
in end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefinitions of Outer Classical Commands‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLibrary‚Ä∫</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Pure.thy
    Author:     Makarius

The Pure theory, with definitions of Isar commands and some lemmas.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/parse.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Outer_Parse =
struct
  val C_source = Parse.input (Parse.group (fn () =&gt; "C source") Parse.text)
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/outer_syntax.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Outer_Syntax =
struct
val _ =
  Outer_Syntax.command \&lt;^command_keyword&gt;‚ÄπC‚Ä∫ ""
    (C_Outer_Parse.C_source &gt;&gt; (Toplevel.generic_theory o C_Module.C));
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Isar/isar_cmd.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Outer_Isar_Cmd =
struct
(* diagnostic ML evaluation *)

structure Diag_State = Proof_Data
(
  type T = Toplevel.state option;
  fun init _ = NONE;
);

fun C_diag source state =
  let
    val opt_ctxt =
      try Toplevel.generic_theory_of state
      |&gt; Option.map (Context.proof_of #&gt; Diag_State.put (SOME state));
  in Context.setmp_generic_context (Option.map Context.Proof opt_ctxt)
    (fn () =&gt; C_Module.eval_source source) () end;

fun diag_state ctxt =
  (case Diag_State.get ctxt of
    SOME st =&gt; st
  | NONE =&gt; Toplevel.init_toplevel ());

val diag_goal = Proof.goal o Toplevel.proof_of o diag_state;

val _ = Theory.setup
  (ML_Antiquotation.value (Binding.qualify true "Isar" \&lt;^binding&gt;‚ÄπC_state‚Ä∫)
    (Scan.succeed "C_Outer_Isar_Cmd.diag_state ML_context") #&gt;
   ML_Antiquotation.value (Binding.qualify true "Isar" \&lt;^binding&gt;‚ÄπC_goal‚Ä∫)
    (Scan.succeed "C_Outer_Isar_Cmd.diag_goal ML_context"));

end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/ML/ml_file.ML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Outer_File =
struct

fun command_c ({src_path, lines, digest, pos}: Token.file) =
  let
    val provide = Resources.provide (src_path, digest);
  in I
    #&gt; C_Module.C (Input.source true (cat_lines lines) (pos, pos))
    #&gt; Context.mapping provide (Local_Theory.background_theory provide)
  end;

fun C files gthy =
  command_c (hd (files (Context.theory_of gthy))) gthy;

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInitialization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπPure‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local

val semi = Scan.option \&lt;^keyword&gt;‚Äπ;‚Ä∫;

val _ =
  Outer_Syntax.command \&lt;^command_keyword&gt;‚ÄπC_file‚Ä∫ "read and evaluate Isabelle/C file"
    (Resources.parse_files "C_file" --| semi &gt;&gt; (Toplevel.generic_theory o C_Outer_File.C));

val _ =
  Outer_Syntax.command \&lt;^command_keyword&gt;‚ÄπC_export_boot‚Ä∫
    "C text within theory or local theory, and export to bootstrap environment"
    (C_Outer_Parse.C_source &gt;&gt; (Toplevel.generic_theory o C_Module.C_export_boot));

val _ =
  Outer_Syntax.command \&lt;^command_keyword&gt;‚ÄπC_prf‚Ä∫ "C text within proof"
    (C_Outer_Parse.C_source &gt;&gt; (Toplevel.proof o C_Module.C_prf));

val _ =
  Outer_Syntax.command \&lt;^command_keyword&gt;‚ÄπC_val‚Ä∫ "diagnostic C text"
    (C_Outer_Parse.C_source &gt;&gt; (Toplevel.keep o C_Outer_Isar_Cmd.C_diag));

val _ =
  Outer_Syntax.local_theory \&lt;^command_keyword&gt;‚ÄπC_export_file‚Ä∫ "diagnostic C text"
    (Scan.succeed () &gt;&gt; K (C_Module.C_export_file Position.no_range));
in end‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSyntax for Pure Term‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_C_translation_unit"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcartouche_position ‚áí string‚Ä∫</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"\&lt;^C&gt;<span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>t</sub> _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_C_external_declaration"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcartouche_position ‚áí string‚Ä∫</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"\&lt;^C&gt;<span class="hidden">‚á©</span><sub>d</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>c</sub><span class="hidden">‚á©</span><sub>l</sub> _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_C_expression"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcartouche_position ‚áí string‚Ä∫</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub> _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_C_statement"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcartouche_position ‚áí string‚Ä∫</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"\&lt;^C&gt;<span class="hidden">‚á©</span><sub>s</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>m</sub><span class="hidden">‚á©</span><sub>t</sub> _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_C"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπcartouche_position ‚áí string‚Ä∫</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"\&lt;^C&gt; _"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
C_Module.C_Term'.parse_translation
  [ (\&lt;^syntax_const&gt;‚Äπ_C_translation_unit‚Ä∫, SOME C_Module.C_Term.tok_translation_unit)
  , (\&lt;^syntax_const&gt;‚Äπ_C_external_declaration‚Ä∫, SOME C_Module.C_Term.tok_external_declaration)
  , (\&lt;^syntax_const&gt;‚Äπ_C_expression‚Ä∫, SOME C_Module.C_Term.tok_expression)
  , (\&lt;^syntax_const&gt;‚Äπ_C_statement‚Ä∫, SOME C_Module.C_Term.tok_statement)
  , (\&lt;^syntax_const&gt;‚Äπ_C‚Ä∫, NONE) ]
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Document">
<div class="head"><h1>Theory C_Document</h1>
<span class="command">theory</span> <span class="name">C_Document</span><br/>
<span class="keyword">imports</span> <a href="C_Command.html"><span class="name">C_Command</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInterface: Ontology Document‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Document</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C_Command</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/thy_output.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Thy/thy_output.ML
    Author:     Makarius

Theory document output.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Thy_Output =
struct

(* output document source *)

val output_symbols = single o Latex.symbols_output;

fun output_comment ctxt (kind, syms) =
  (case kind of
    Comment.Comment =&gt;
      Input.cartouche_content syms
      |&gt; output_document (ctxt |&gt; Config.put Document_Antiquotation.thy_output_display false)
          {markdown = false}
      |&gt; Latex.enclose_body "%\n\\isamarkupcmt{" "%\n}"
  | Comment.Cancel =&gt;
      Symbol_Pos.cartouche_content syms
      |&gt; output_symbols
      |&gt; Latex.enclose_body "%\n\\isamarkupcancel{" "}"
  | Comment.Latex =&gt;
      [Latex.symbols (Symbol_Pos.cartouche_content syms)]
  | Comment.Marker =&gt; [])
and output_comment_document ctxt (comment, syms) =
  (case comment of
    SOME kind =&gt; output_comment ctxt (kind, syms)
  | NONE =&gt; [Latex.symbols syms])
and output_document_text ctxt syms =
  Comment.read_body syms |&gt; maps (output_comment_document ctxt)
and output_document ctxt {markdown} source =
  let
    val pos = Input.pos_of source;
    val syms = Input.source_explode source;

    val output_antiquotes =
      maps (Document_Antiquotation.evaluate (output_document_text ctxt) ctxt);

    fun output_line line =
      (if Markdown.line_is_item line then [Latex.string "\\item "] else []) @
        output_antiquotes (Markdown.line_content line);

    fun output_block (Markdown.Par lines) =
          Latex.block (separate (Latex.string "\n") (map (Latex.block o output_line) lines))
      | output_block (Markdown.List {kind, body, ...}) =
          Latex.environment_block (Markdown.print_kind kind) (output_blocks body)
    and output_blocks blocks = separate (Latex.string "\n\n") (map output_block blocks);
  in
    if Toplevel.is_skipped_proof (Toplevel.presentation_state ctxt) then []
    else if markdown andalso exists (Markdown.is_control o Symbol_Pos.symbol) syms
    then
      let
        val ants = Antiquote.parse_comments pos syms;
        val reports = Antiquote.antiq_reports ants;
        val blocks = Markdown.read_antiquotes ants;
        val _ = Context_Position.reports ctxt (reports @ Markdown.reports blocks);
      in output_blocks blocks end
    else
      let
        val ants = Antiquote.parse_comments pos (trim (Symbol.is_blank o Symbol_Pos.symbol) syms);
        val reports = Antiquote.antiq_reports ants;
        val _ = Context_Position.reports ctxt (reports @ Markdown.text_reports ants);
      in output_antiquotes ants end
  end;


(* output tokens with formal comments *)

local

val output_symbols_antiq =
  (fn Antiquote.Text syms =&gt; output_symbols syms
    | Antiquote.Control {name = (name, _), body, ...} =&gt;
        Latex.string (Latex.output_symbols [Symbol.encode (Symbol.Control name)]) ::
          output_symbols body
    | Antiquote.Antiq {body, ...} =&gt;
        Latex.enclose_body "%\n\\isaantiq\n" "{}%\n\\endisaantiq\n" (output_symbols body));

fun output_comment_symbols ctxt {antiq} (comment, syms) =
  (case (comment, antiq) of
    (NONE, false) =&gt; output_symbols syms
  | (NONE, true) =&gt;
      Antiquote.parse_comments (#1 (Symbol_Pos.range syms)) syms
      |&gt; maps output_symbols_antiq
  | (SOME comment, _) =&gt; output_comment ctxt (comment, syms));

fun output_body ctxt antiq bg en syms =
  Comment.read_body syms
  |&gt; maps (output_comment_symbols ctxt {antiq = antiq})
  |&gt; Latex.enclose_body bg en;

in

fun output_token ctxt tok =
  let
    fun output antiq bg en =
      output_body ctxt antiq bg en (Input.source_explode (C_Token.input_of tok));
  in
    (case C_Token.kind_of tok of
      Token.Comment NONE =&gt; []
    | Token.Comment (SOME Comment.Marker) =&gt; []
    | Token.Command =&gt; output false "\\isacommand{" "}"
    | Token.Keyword =&gt;
        if Symbol.is_ascii_identifier (C_Token.content_of tok)
        then output false "\\isakeyword{" "}"
        else output false "" ""
    | Token.String =&gt; output false "{\\isachardoublequoteopen}" "{\\isachardoublequoteclose}"
    | Token.Alt_String =&gt; output false "{\\isacharbackquoteopen}" "{\\isacharbackquoteclose}"
    | Token.Verbatim =&gt; output true "{\\isacharverbatimopen}" "{\\isacharverbatimclose}"
    | Token.Cartouche =&gt; output false "{\\isacartoucheopen}" "{\\isacartoucheclose}"
    | _ =&gt; output false "" "")
  end handle ERROR msg =&gt; error (msg ^ Position.here (C_Token.pos_of tok));


end;
end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Pure/Thy/document_antiquotations.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Pure/Thy/document_antiquotations.ML
    Author:     Makarius

Miscellaneous document antiquotations.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Document_Antiquotations =
struct

(* quasi-formal text (unchecked) *)

local

fun report_text ctxt text =
  let val pos = Input.pos_of text in
    Context_Position.reports ctxt
      [(pos, Markup.language_text (Input.is_delimited text)),
       (pos, Markup.raw_text)]
  end;

fun prepare_text ctxt =
  Input.source_content #&gt; #1 #&gt; Document_Antiquotation.prepare_lines ctxt;

val theory_text_antiquotation =
  Thy_Output.antiquotation_raw_embedded \&lt;^binding&gt;‚ÄπC_theory_text‚Ä∫ (Scan.lift Args.text_input)
    (fn ctxt =&gt; fn text =&gt;
      let
        val keywords = C_Thy_Header.get_keywords' ctxt;

        val _ = report_text ctxt text;
        val _ =
          Input.source_explode text
          |&gt; C_Token.tokenize keywords {strict = true}
          |&gt; maps (C_Token.reports keywords)
          |&gt; Context_Position.reports_text ctxt;
      in
        prepare_text ctxt text
        |&gt; C_Token.explode0 keywords
        |&gt; maps (C_Thy_Output.output_token ctxt)
        |&gt; Thy_Output.isabelle ctxt
      end);

in

val _ =
  Theory.setup theory_text_antiquotation;

end;

(* C text *)

local

fun c_text name c =
  Thy_Output.antiquotation_verbatim_embedded name (Scan.lift Args.text_input)
    (fn ctxt =&gt; fn text =&gt;
      let val _ = C_Module.eval_in text (SOME (Context.Proof ctxt)) (c text)
      in #1 (Input.source_content text) end);

in

val _ = Theory.setup
 (c_text \&lt;^binding&gt;‚ÄπC‚Ä∫ (C_Module.c_enclose "" "") #&gt;
  c_text \&lt;^binding&gt;‚ÄπC_text‚Ä∫ (K C_Lex.read_init));

end;

end;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Main">
<div class="head"><h1>Theory C_Main</h1>
<span class="command">theory</span> <span class="name">C_Main</span><br/>
<span class="keyword">imports</span> <a href="C_Document.html"><span class="name">C_Document</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Main</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src/C_Document"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>
</div>
</div><div id="C0">
<div class="head"><h1>Theory C0</h1>
<span class="command">theory</span> <span class="name">C0</span><br/>
<span class="keyword">imports</span> <a href="C_Main.html"><span class="name">C_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExample: Lexer Stress Test‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C0</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../C_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_lexer_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRegular C Code‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπComments, Keywords and Pragmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting of comments following the example suite of
      üåê‚Äπhttps://gcc.gnu.org/onlinedocs/cpp/Initial-processing.html‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/* inside /* inside */ int a = "outside";
// inside // inside until end of line
int a = "outside";
/* inside
  // inside
inside
*/ int a = "outside";
// inside /* inside until end of line
int a = "outside";
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπBackslash newline‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
i\    
n\                
t a = "/* //  /\ 
*\
fff */\
";
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπBackslash newline, Directive üåê‚Äπhttps://gcc.gnu.org/onlinedocs/cpp/Initial-processing.html‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/\
*
*/ # /*
*/ defi\
ne FO\
O 10\
20‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπDirective: conditional‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#ifdef a
#elif
#else
#if
#endif
#endif
‚Ä∫</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
C ‚Äï ‚ÄπDirective: pragma‚Ä∫ ‚Äπ# f # "/**/"
/**/
#     /**/ //  #

_Pragma /\
**/("a")
‚Ä∫
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπDirective: macro‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#define a zz
#define a(x1,x2) z erz(( zz
#define a (x1,x2) z erz(( zz
#undef z
#if
#define a zz
#define a(x1,x2) z erz(( zz
#define a (x1,x2) z erz(( zz
#endif
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπScala/jEdit Latency on Multiple Bindings‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπExample of obfuscated code üåê‚Äπhttps://en.wikipedia.org/wiki/International_Obfuscated_C_Code_Contest‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#define _ -F&lt;00||--F-OO--;
int F=00,OO=00;main(){F_OO();printf("%1.3f\n",4.*-F/OO/OO);}F_OO()
{
            _-_-_-_
       _-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
        _-_-_-_-_-_-_-_
            _-_-_-_
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Select inside the ball, experience the latency.
A special keyboard combination ``Ctrl-like key‚Åã‚Äπon Apple: Cmd‚Ä∫ + Shift +
Enter'' lets Isabelle/Scala/jEdit enter in a mode where the selected bound occurrences can be all
simultaneously replaced by new input characters typed on the keyboard. (The ``select-entity'' action
exists since Isabelle2016-1, see the respective section ``Prover IDE -- Isabelle/Scala/jEdit'' in
the NEWS.)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLexing and Parsing Obfuscated Sources‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnother lexer/parser - stress test: parsing an obfuscated C source.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπExample of obfuscated code üåê‚Äπhttps://www.ioccc.org/2018/endoh1/prog.c‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
        #define/*__Int3rn^ti[]n/l_()I3fusc^t3|]_C_C&lt;&gt;I7E_C[]nt3st__*/L/*__MMXVIII__*/for
    #include/*!"'()*+,-./12357:;&lt;=&gt;?CEFGHIJKLMNSTUVWXYZ[]^_`cfhijklmnrstuvwxyz{|}*/&lt;stdio.h&gt;
  char*r,F[1&lt;&lt;21]="~T/}3(|+G{&gt;/zUhy;Jx+5wG&lt;v&gt;&gt;u55t.?sIZrC]n.;m+:l+Hk]WjNJi/Sh+2f1&gt;c2H`)(_2(^L\
 -]=([1/Z&lt;2Y7/X12W:.VFFU1,T77S+;N?;M/&gt;L..K1+JCCI&lt;&lt;H:(G*5F--E11C=5?.(&gt;+(=3)Z-;*(:*.Y/5(-=)2*-U,\
/+-?5'(,+++***''EE&gt;T,215IEUF:N`2`:?GK;+^`+?&gt;)5?&gt;U&gt;_)5GxG).2K.2};}_235(]:5,S7E1(vTSS,-SSTvU(&lt;-HG\
-2E2/2L2/EE-&gt;E:?EE,2XMMMM1Hy`)5rHK;+.T+?[n2/_2{LKN2/_|cK2+.2`;}:?{KL57?|cK:2{NrHKtMMMK2nrH;rH[n"
"CkM_E21-E,-1-&gt;E(_:mSE/LhLE/mm:2Ul;2M&gt;,2KW-+.-u).5Lm?fM`2`2nZXjj?[n&lt;YcK?2}yC}H[^7N7LX^7N7UN&lt;/:-\
ZWXI&lt;^I2K?&gt;T+?KH~-?f&lt;;G_x2;;2XT7LXIuuVF2X(G(GVV-:-:KjJ]HKLyN7UjJ3.WXjNI2KN&lt;l|cKt2~[IsHfI2w{[&lt;VV"
"GIfZG&gt;x#&amp;#&amp;&amp;$#$;ZXIc###$&amp;$$#&gt;7[LMv{&amp;&amp;&amp;&amp;#&amp;##L,l2TY.&amp;$#$#&amp;&amp;$,(iiii,#&amp;&amp;&amp;#$#$?TY2.$#$1(x###;2EE[t,\
SSEz.SW-k,T&amp;&amp;jC?E-.$##      &amp;#&amp;57+$$#      &amp;&amp;&amp;W1-&amp;$$7W  -J$#$kEN&amp;#&amp;      $##C^+$##W,h###n/+L2YE"
"2nJk/H;YNs#$[,:TU(#$   ,:   &amp;&amp;~H&gt;&amp;#   Y;   &amp;&amp;G_x&amp;#2;   ,mT&amp;$YE-#&amp;   5G   $#VVF$#&amp;zNs$$&amp;Ej]HELy\
CN/U^Jk71&lt;(#&amp;:G7E+^&amp;#  l|?1  $$Y.2$$  7lzs  WzZw&gt;&amp;$E    -&lt;V-wE(2$$  G&gt;x;  2zsW/$$#HKt&amp;$$v&gt;+t1(&gt;"
"7&gt;S7S,;TT,&amp;$;S7S&gt;7&amp;#&gt;E_::U  $$'",op  ,*G=  F,*I=957+F  ;int*t,k,O,  i,   j,T[+060&lt;&lt;+020];int M(
int m,int nop){;;;return+   m%(0+nop  );;}  int*tOo,w,  h,z,W;void(C)  (int n){n=putchar(n);}int
f,c,H=11,Y=64&lt;&lt;2,Z,pq,X   ;void(E/*d  */)(  int/*RP*/n  ){L(Z=k+00;  Z;  Z/=+2+000)G[000]=*G*!!f
|M(n,2)&lt;&lt;f,pq=2,f=+06   &lt;f?++pq,++pq  ,G++  ,z:f+001,n  /=2;;}void  (V)(  int/*opqrstabd*/n){C(n
%Y);;C(n/Y+00);;}void  J(){L(pq--,pq   =j   =O=-1+0;++  j&lt;240;I[6+   (h   +6+j/12/2*2+M(j/2,2))*
W+M(j/2/2,+06)*2+w*014      +00+M(00+      000+j,002      +00)]=000      +00+k)k=M(G[j/2/2+(*r-+
32)**"&lt;nopqabdeg"],/*4649&amp;96#*/3);/*&amp;oaogoqo*/;}/*xD%P$Q#Rq*/int/*dbqpdbqpxyzzyboo3570OQ*/main()
{L(X=Y-1;i&lt;21*3;i++,I++)L(r=G,G+=2;*G++;)*G&gt;=13*3?*G-*r?*I++=*G:(*I++=r[1],*I++=r[2]):1;L(j=12,r
=I;(*I=i=getchar())&gt;-1;I++)i-7-3?I-=i&lt;32||127&lt;=i,j+=12:(H+=17+3,W=W&lt;j?j:W,j=12);L(;*r&gt;-1;r++)*r-
7-3?J(),w++:(w=z,h+=17+3);C(71);C(73);V('*'*'1'*7);C(57);C(32*3+1);V(W);V(H);C(122*2);L(V(i=z);i
&lt;32*3;)C(i++/3*X/31);C(33);C(X);C(11);L(G="SJYXHFUJ735";*G;)C(*G++-5);C(3);V(1);L(V(j=z);j&lt;21*3;
 j++){k=257;V(63777);V(k&lt;&lt;2);V(M(j,32)?11:511);V(z);C(22*2);V(i=f=z);V(z);V(W);V(H);V(1&lt;&lt;11);r=
  G=I+W*H;L(t=T;i&lt;1&lt;&lt;21;i++)T[i]=i&lt;Y?i:-1;E(Y);L(i=-1;++i&lt;W*H;t=T+Z*Y+Y)c=I[i]?I[i]*31-31:(31&lt;
    j?j-31:31-j),Z=c[t[c]&lt;z?E(Z),k&lt;(1&lt;&lt;12)-2?t[c]=++k,T:T:t];E(Z);E(257);L(G++;k=G-r&gt;X?X:G-r
        ,C(k),k;)L(;k--;C(*r++/*---#$%&amp;04689@ABDOPQRabdegopq---*/));}C(53+6);return(z);}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExperiments with üóÄ‚Äπ../../src_ext/parser_menhir‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_lexer_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExpecting to succeed‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/aligned_struct_c18.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/argument_scope.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/atomic.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/atomic_parenthesis.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/bitfield_declaration_ambiguity.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/bitfield_declaration_ambiguity.ok.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/block_scope.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/c11-noreturn.c‚Ä∫‚Ä∫</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/c1x-alignas.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/char-literal-printing.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/c-namespace.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/control-scope.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/dangling_else.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/dangling_else_lookahead.c‚Ä∫‚Ä∫</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/dangling_else_lookahead.if.c‚Ä∫‚Ä∫</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/declaration_ambiguity.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/declarators.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/declarator_visibility.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/designator.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/enum.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/enum_constant_visibility.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/enum_shadows_typedef.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/enum-trick.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/expressions.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/function-decls.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/function_parameter_scope.c‚Ä∫‚Ä∫</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/function_parameter_scope_extends.c‚Ä∫‚Ä∫</span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/if_scopes.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/local_scope.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/local_typedef.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/long-long-struct.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/loop_scopes.c‚Ä∫‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/namespaces.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/no_local_scope.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/parameter_declaration_ambiguity.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/parameter_declaration_ambiguity.test.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/statements.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/struct-recursion.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/typedef_star.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/types.c‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/variable_star.c‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExpecting to fail‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ../../src_ext/parser_menhir/tests/bitfield_declaration_ambiguity.fail.c‚Ä∫</span></span></span><span>
</span><span class="comment">‚å¶‚ÄπC_file ‚Äπ../../src_ext/parser_menhir/tests/dangling_else_misleading.fail.c‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C1">
<div class="head"><h1>Theory C1</h1>
<span class="command">theory</span> <span class="name">C1</span><br/>
<span class="keyword">imports</span> <a href="C_Main.html"><span class="name">C_Main</span></a> <a href="Cartouche_Examples.html"><span class="name">Cartouche_Examples</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExample: Annotation Navigation and Context Serialization‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C1</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../C_Main"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"HOL-ex.Cartouche_Examples"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Operationally, the ‚¨ö‚ÄπC‚Ä∫ command can be thought of as
behaving as ‚¨ö‚ÄπML‚Ä∫, where it is for example possible to recursively nest C
code in C. Generally, the present chapter assumes a familiarity with all advance concepts of ML as
described in üóè‚Äπ~~/src/HOL/ex/ML.thy‚Ä∫, as well as the concept of ML
antiquotations (üóè‚Äπ~~/src/Doc/Implementation/ML.thy‚Ä∫). However, even if
‚¨ö‚ÄπC‚Ä∫ might resemble to ‚¨ö‚ÄπML‚Ä∫, we will now see
in detail that there are actually subtle differences between the two commands.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSetup of ML Antiquotations Displaying the Environment (For Debugging) ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
fun print_top make_string f _ (_, (value, _, _)) _ = tap (fn _ =&gt; writeln (make_string value)) o f

fun print_top' _ f _ _ env = tap (fn _ =&gt; writeln ("ENV " ^ C_Env.string_of env)) o f

fun print_stack s make_string stack _ _ thy =
  let
    val () = Output.information ("SHIFT  " ^ (case s of NONE =&gt; "" | SOME s =&gt; "\"" ^ s ^ "\" ")
                                 ^ Int.toString (length stack - 1) ^ "    +1 ")
    val () =   stack
            |&gt; split_list
            |&gt; #2
            |&gt; map_index I
            |&gt; app (fn (i, (value, pos1, pos2)) =&gt;
                     writeln ("   " ^ Int.toString (length stack - i) ^ " " ^ make_string value
                              ^ " " ^ Position.here pos1 ^ " " ^ Position.here pos2))
  in thy end

fun print_stack' s _ stack _ env thy =
  let
    val () = Output.information ("SHIFT  " ^ (case s of NONE =&gt; "" | SOME s =&gt; "\"" ^ s ^ "\" ")
                                 ^ Int.toString (length stack - 1) ^ "    +1 ")
    val () = writeln ("ENV " ^ C_Env.string_of env)
  in thy end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπML_Antiquotation.inline @{binding print_top}
                               (Args.context
                                &gt;&gt; K ("print_top " ^ ML_Pretty.make_string_fn ^ " I"))‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπML_Antiquotation.inline @{binding print_top'}
                               (Args.context
                                &gt;&gt; K ("print_top' " ^ ML_Pretty.make_string_fn ^ " I"))‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπML_Antiquotation.inline @{binding print_stack}
                               (Scan.peek (fn _ =&gt; Scan.option Args.text)
                                &gt;&gt; (fn name =&gt; ("print_stack "
                                                ^ (case name of NONE =&gt; "NONE"
                                                              | SOME s =&gt; "(SOME \"" ^ s ^ "\")")
                                                ^ " " ^ ML_Pretty.make_string_fn)))‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπML_Antiquotation.inline @{binding print_stack'}
                               (Scan.peek (fn _ =&gt; Scan.option Args.text)
                                &gt;&gt; (fn name =&gt; ("print_stack' "
                                                ^ (case name of NONE =&gt; "NONE"
                                                              | SOME s =&gt; "(SOME \"" ^ s ^ "\")")
                                                ^ " " ^ ML_Pretty.make_string_fn)))‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_lexer_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIntroduction to C Annotations: Navigating in the Parsing Stack‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBasics‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Since the present theory üóè‚ÄπC1.thy‚Ä∫ is depending on
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Lexer_Language‚Ä∫ and
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫, the syntax one is writing in the
‚¨ö‚ÄπC‚Ä∫ command is C11. Additionally, üóè‚ÄπC1.thy‚Ä∫ also
depends on \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Annotation‚Ä∫, making it possible to write
commands in C comments, called annotation commands, such as
‚¨ö‚Äπ‚âàsetup‚Ä∫. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting ML code in C comments‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = (((0))); /*@ highlight */
                 /*@ ‚âàsetup ‚Äπ@{print_stack}‚Ä∫ */
                 /*@ ‚âàsetup ‚Äπ@{print_top}‚Ä∫ */
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ In terms of execution order, nested annotation commands are not pre-filtered out of the
C code, but executed when the C code is still being parsed. Since the parser implemented is a LALR
parser ‚Åã‚Äπüåê‚Äπhttps://en.wikipedia.org/wiki/LALR‚Ä∫‚Ä∫, C tokens
are uniquely read and treated from left to right. Thus, each nested command is (supposed by default
to be) executed when the parser has already read all C tokens before the comment associated to the
nested command, so when the parser is in a particular intermediate parsing step (not necessarily
final)
‚Åã‚Äπüåê‚Äπhttps://en.wikipedia.org/wiki/Shift-reduce_parser‚Ä∫‚Ä∫. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe command ‚¨ö‚Äπ‚âàsetup‚Ä∫ is similar to the command
‚¨ö‚Äπsetup‚Ä∫ except that the former takes a function with additional
arguments. These arguments are precisely depending on the current parsing state. To better examine
these arguments, it is convenient to use ML antiquotations (be it for printing, or for doing any
regular ML actions like PIDE reporting).

Note that, in contrast with ‚¨ö‚Äπsetup‚Ä∫, the return type of the
‚¨ö‚Äπ‚âàsetup‚Ä∫ function is not
\&lt;^ML_type&gt;‚Äπtheory -&gt; theory‚Ä∫ but
\&lt;^ML_type&gt;‚ÄπContext.generic -&gt; Context.generic‚Ä∫. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPositional navigation: referring to any previous parsed sub-tree in the stack‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = (((0
      + 5)))  /*@@ ‚âàsetup ‚Äπprint_top @{make_string} I‚Ä∫
                 @ highlight
               */
      * 4; 
float b = 7 / 3;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe special ‚Äπ@‚Ä∫ symbol makes the command be executed whenever the first element ‚ÄπE‚Ä∫
 in the stack is about to be irremediably replaced by a more structured parent element (having ‚ÄπE‚Ä∫
as one of its direct children). It is the parent element which is provided to the ML code.

Instead of always referring to the first element of the stack, 
‚ÄπN‚Ä∫ consecutive occurrences of ‚Äπ@‚Ä∫ will make the ML code getting as argument the direct parent
of the ‚ÄπN‚Ä∫-th element.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPositional navigation: referring to any previous parsed sub-tree in the stack‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = (((0 + 5)))  /*@@ highlight */
      * 4;

int a = (((0 + 5)))  /*@&amp; highlight */
      * 4;

int a = (((0 + 5)))  /*@@@@@ highlight */
      * 4;

int a = (((0 + 5)))  /*@&amp;&amp;&amp;&amp; highlight */
      * 4;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚Äπ&amp;‚Ä∫ behaves as ‚Äπ@‚Ä∫, but instead of always giving the designated direct parent to the ML code,
it finds the first parent ancestor making non-trivial changes in the respective grammar rule
(a non-trivial change can be for example the registration of the position of the current AST node
being built).‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPositional navigation: moving the comment after a number of C token‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int b = 7 / (3) * 50;
/*@+++@@ highlight */
long long f (int a) {
  while (0) { return 0; }
}
int b = 7 / (3) * 50;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚ÄπN‚Ä∫ consecutive occurrences of ‚Äπ+‚Ä∫ will delay the interpretation of the comment,
which is ignored at the place it is written. The comment is only really considered after the
C parser has treated ‚ÄπN‚Ä∫ more tokens.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπClosing C comments ‚Äπ*/‚Ä∫ must close anything, even when editing ML code‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = (((0 //@ (* inline *) ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; fn context =&gt; let in (* */ *) context end‚Ä∫
             /*@ ‚âàsetup ‚Äπ(K o K o K) I‚Ä∫ (*   * /   *) */
         )));
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπInline comments with antiquotations‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
 /*@ ‚âàsetup‚Äπ(K o K o K) (fn x =&gt; K x @{con\
text (**)})‚Ä∫ */ // break of line activated everywhere (also in antiquotations)
int a = 0; //\
@ ‚âàsetup‚Äπ(K o K o K) (fn x =&gt; K x @{term ‚Äπa \
          + b‚Ä∫ (* (**) *\      
\     
)})‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπErroneous Annotations Treated as Regular C Comments‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPermissive Types of Antiquotations‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
  /*@ ‚âàsetup (* Errors: Explicit warning + Explicit markup reporting *)
   */
  /** ‚âàsetup (* Errors: Turned into tracing report information *)
   */

  /** ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫ (* An example of correct syntax accepted as usual *)
   */
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPermissive Types of Antiquotations‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
  /*@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫
      ‚âàsetup (* Parsing error of a single command does not propagate to other commands *)
      ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫
      context
   */
  /** ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫
      ‚âàsetup (* Parsing error of a single command does not propagate to other commands *)
      ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; I‚Ä∫
      context
   */
  
  /*@ ‚âàsetup (* Errors in all commands are all rendered *)
      ‚âàsetup (* Errors in all commands are all rendered *)
      ‚âàsetup (* Errors in all commands are all rendered *)
   */
  /** ‚âàsetup (* Errors in all commands makes the whole comment considered as an usual comment *)
      ‚âàsetup (* Errors in all commands makes the whole comment considered as an usual comment *)
      ‚âàsetup (* Errors in all commands makes the whole comment considered as an usual comment *)
   */
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBottom-Up vs. Top-Down Evaluation‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Example_Data = Generic_Data (type T = string list
                                       val empty = [] val extend = K empty val merge = K empty)
fun add_ex s1 s2 =
  Example_Data.map (cons s2)
  #&gt; (fn context =&gt; let val () = Output.information (s1 ^ s2)
                        val () = app (fn s =&gt; writeln ("  Data content: " ^ s))
                                     (Example_Data.get context)
                    in context end)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContext.theory_map (Example_Data.put [])‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>ML_source_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_parser_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπArbitrary interleaving of effects: ‚Äπ‚âàsetup‚Ä∫ vs ‚Äπ‚âàsetup‚áì‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int b,c,d/*@@ ‚âàsetup ‚Äπfn s =&gt; fn x =&gt; fn env =&gt; @{print_top} s x env
                                                #&gt; add_ex "evaluation of " "3_print_top"‚Ä∫
          */,e = 0; /*@@
              ‚âàsetup ‚Äπfn s =&gt; fn x =&gt; fn env =&gt; @{print_top} s x env
                                                #&gt; add_ex "evaluation of " "4_print_top"‚Ä∫ */

int b,c,d/*@@ ‚âàsetup‚áì ‚Äπfn s =&gt; fn x =&gt; fn env =&gt; @{print_top} s x env
                                                #&gt; add_ex "evaluation of " "6_print_top"‚Ä∫
          */,e = 0; /*@@
              ‚âàsetup‚áì ‚Äπfn s =&gt; fn x =&gt; fn env =&gt; @{print_top} s x env
                                                #&gt; add_ex "evaluation of " "5_print_top"‚Ä∫ */
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReporting of Positions and Contextual Update of Environment‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
To show the content of the parsing environment, the ML antiquotations ‚Äπprint_top'‚Ä∫ and ‚Äπprint_stack'‚Ä∫
will respectively be used instead of ‚Äπprint_top‚Ä∫ and ‚Äπprint_stack‚Ä∫. 
This example suite allows to explore the bindings represented in the C environment 
and made accessible in PIDE for hovering. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReporting: ‚Äπtypedef‚Ä∫, ‚Äπenum‚Ä∫‚Ä∫</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*‚Äπstruct‚Ä∫*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>ML_source_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_lexer_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπReporting of Positions‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
typedef int i, j;
  /*@@ ‚âàsetup ‚Äπ@{print_top'}‚Ä∫ @highlight */ //@ +++++@ ‚âàsetup ‚Äπ@{print_top'}‚Ä∫ +++++@highlight
int j = 0;
typedef int i, j;
j jj1 = 0;
j jj = jj1;
j j = jj1 + jj;
typedef i j;
typedef i j;
typedef i j;
i jj = jj;
j j = jj;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting type definitions‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
typedef int j;
j a = 0;
typedef int k;
int main (int c) {
  j b = 0;
  typedef int k;
  typedef k l;
  k a = c;
  l a = 0;
}
k a = a;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπReporting ‚Äπenum‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
enum a b; // bound case: undeclared
enum a {aaa}; // define case
enum a {aaa}; // define case: redefined
enum a _; // bound case

__thread (f ( enum a,  enum a vv));

enum a /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.function_definition4‚Ä∫‚Ä∫*/ f (enum a a) {
}

__thread enum a /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.declaration_specifier2‚Ä∫‚Ä∫*/ f (enum a a) {
  enum c {ccc}; // define case
  __thread enum c f (enum c a) {
    return 0;
  }
  enum c /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.nested_function_definition2‚Ä∫‚Ä∫*/ f (enum c a) {
    return 0;
  }
  return 0;
}

enum z {zz}; // define case
int main (enum z *x) /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.parameter_type_list2‚Ä∫‚Ä∫*/ {
  return zz; }
int main (enum a *x, ...) /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.parameter_type_list3‚Ä∫‚Ä∫*/ {
  return zz; }
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContinuation Calculus with the C Environment: Presentation in ML‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_parser_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
val C = tap o C_Module.C
val C' = C_Module.C'
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting C code without propagating the C environment‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
int b = 7 / (3) * 50
  /*@@@@@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt;
               C      ‚Äπint b = a + a + a + a + a + a + a
                       ;‚Ä∫ ‚Ä∫ */;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting C code and propagating the C environment‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
int b = 7 / (3) * 50
  /*@@@@@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn env =&gt;
               C' env ‚Äπint b = a + a + a + a + a + a + a
                       ;‚Ä∫ ‚Ä∫ */;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContinuation Calculus with the C Environment: Presentation with Outer Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
val _ = Theory.setup
          (C_Inner_Syntax.command0 
            (fn src =&gt; fn context =&gt; C' (C_Stack.Data_Lang.get' context |&gt; #2) src context)
            C_Parse.C_source
            ("C'", ‚åÇ, ‚åÇ, ‚åÇ))
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting C code without propagating the C environment‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int f (int a) {
  int b = 7 / (3) * 50 /*@ C  ‚Äπint b = a + a + a + a + a + a + a;‚Ä∫ */;
  int c = b + a + a + a + a + a + a;
} ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting C code and propagating the C environment‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int f (int a) {
  int b = 7 / (3) * 50 /*@ C' ‚Äπint b = a + a + a + a + a + a + a;‚Ä∫ */;
  int c = b + b + b + b + a + a + a + a + a + a;
} ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπMiscellaneous‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int f (int a) {
  int b = 7 / (3) * 50 /*@ C  ‚Äπint b = a + a + a + a + a; //@ C' ‚Äπint c = b + b + b + b + a;‚Ä∫ ‚Ä∫ */;
  int b = 7 / (3) * 50 /*@ C' ‚Äπint b = a + a + a + a + a; //@ C' ‚Äπint c = b + b + b + b + a;‚Ä∫ ‚Ä∫ */;
  int c = b + b + b + b + a + a + a + a + a + a;
} ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContinuation Calculus with the C Environment: Deep-First Nesting vs Breadth-First Folding: Propagation of \&lt;^ML_type&gt;‚ÄπC_Env.env_lang‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPropagation of report environment while manually composing at ML level (with ‚Äπ#&gt;‚Ä∫)‚Ä∫</span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπIn ‚Äπc1 #&gt; c2‚Ä∫, ‚Äπc1‚Ä∫ and ‚Äπc2‚Ä∫ should not interfere each other.‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
//@ ML ‚Äπfun C_env src _ _ env = C' env src‚Ä∫
int a;
int f (int b) {
int c = 0; /*@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn env =&gt;
     C' env ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C' env ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
‚Ä∫ */
int e = a + b + c + d;
}‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPropagation of directive environment (evaluated before parsing)
      to any other annotations (evaluated at parsing time)‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#undef int
#define int(a,b) int
#define int int
int a;
int f (int b) {
int c = 0; /*@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn env =&gt;
     C' env ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C' env ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ ‚âàsetup ‚ÄπC_env ‚Äπint e = a + b + c + d;‚Ä∫‚Ä∫‚Ä∫
‚Ä∫ */
#undef int
int e = a + b + c + d;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContinuation Calculus with the C Environment: Deep-First Nesting vs Breadth-First Folding: Propagation of \&lt;^ML_type&gt;‚ÄπC_Env.env_tree‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Data_Out = Generic_Data
  (type T = int
   val empty = 0
   val extend = K empty
   val merge = K empty)

fun show_env0 make_string f msg context =
  Output.information ("(" ^ msg ^ ") " ^ make_string (f (Data_Out.get context)))

val show_env = tap o show_env0 @{make_string} I
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContext.theory_map (C_Module.Data_Accept.put (fn _ =&gt; fn _ =&gt; Data_Out.map (fn x =&gt; x + 1)))‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPropagation of Updates‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
typedef int i, j;
int j = 0;
typedef int i, j;
j jj1 = 0;
j jj = jj1; /*@@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; show_env "POSITION 0"‚Ä∫ @‚âàsetup ‚Äπ@{print_top'}‚Ä∫ */
typedef int k; /*@@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn env =&gt;
                          C' env ‚Äπk jj = jj; //@@ ‚âàsetup ‚Äπ@{print_top'}‚Ä∫
                                  k jj = jj + jj1;
                                  typedef k l; //@@ ‚âàsetup ‚Äπ@{print_top'}‚Ä∫‚Ä∫
                          #&gt; show_env "POSITION 1"‚Ä∫ */
j j = jj1 + jj; //@@ ‚âàsetup ‚Äπ@{print_top'}‚Ä∫
typedef i j; /*@@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn _ =&gt; show_env "POSITION 2"‚Ä∫ */
typedef i j;
typedef i j;
i jj = jj;
j j = jj;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπshow_env "POSITION 3" (Context.Theory @{theory})‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContext.theory_map (C_Module.Data_Accept.put (fn _ =&gt; fn _ =&gt; I))‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReporting: Scope of Recursive Functions‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_starting_env</span><span> </span><span class="delimiter">=</span><span> </span><span>last</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPropagation of Updates‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
int b = a * a + 0;
int jjj = b;
int main (void main(int *x,int *y),int *jjj) {
  return a + jjj + main(); }
int main2 () {
  int main3 () { main2() + main(); }
  int main () { main2() + main(); }
  return a + jjj + main3() + main(); }
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int main3 () { main2 (); }
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_starting_env</span><span> </span><span class="delimiter">=</span><span> </span><span>empty</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReporting: Extensions to Function Types, Array Types‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint f (int z);‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint * f (int z);‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint (* f) (int z /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.declarator1‚Ä∫‚Ä∫*/);‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπtypedef int (* f) (int z);‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint f (int z) {}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint * f (int z) {return z;}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint ((* f) (int z1, int z2)) {return z1 + z2;}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint (* (* f) (int z1, int z2)) {return z1 + z2;}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπtypedef int (* f) (int z); f uuu (int b) {return b;};‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπtypedef int (* (* f) (int z, int z)) (int a); f uuu (int b) {return b;};‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπstruct z { int (* f) (int z); int (* (* ff) (int z)) (int a); };‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπdouble (* (* f (int a /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading.declarator1‚Ä∫‚Ä∫*/)) (int a, double d)) (char a);‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπdouble (* (((* f) []) (int a)) (int b, double c)) (char d) {int a = b + c + d;}‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπdouble ((*((f) (int a))) (int a /* ‚Üê‚Äï ‚Äπ\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.doFuncParamDeclIdent‚Ä∫‚Ä∫*/, double)) (char c) {int a = 0;}‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπNesting functions‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
double (* (* f (int a)) (int a, double)) (char c) {
double (* (* f (int a)) (double a, int a)) (char) {
  return a;
}
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπOld function syntax‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
f (x) int x; {return x;}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGeneral Isar Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>zz</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z' = ()"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπMixing arbitrary commands‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;
int b = a * a + 0;
int jjj = b;
/*@
  @@@ ML ‚Äπ@{lemma ‚ÄπA ‚àß B ‚ü∂ B ‚àß A‚Ä∫ by (ml_tactic ‚Äπblast_tac ctxt 1‚Ä∫)}‚Ä∫
  definition "a' = ()"
  declare [[ML_source_trace]]
  lemma (in zz) ‚ÄπA ‚àß B ‚ü∂ B ‚àß A‚Ä∫ by (ml_tactic ‚Äπblast_tac ctxt 1‚Ä∫)
  definition (in zz) "z = ()"
  corollary "zz.z' = ()"
   apply (unfold zz.z'_def)
  by blast
  theorem "True &amp;&amp;&amp; True" by (auto, presburger?)
*/
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>ML_source_trace</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπBackslash newlines must be supported by \&lt;^ML&gt;‚ÄπC_Token.syntax'‚Ä∫ (in particular in keywords)‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
//@  lem\
ma (i\
n z\
z) \
‚Äπ\  
AA ‚àß B\
                    ‚ü∂\     
                    B ‚àß A\    
\
A‚Ä∫ b\
y (ml_t\
actic ‚Äπ\
bla\
st_tac c\
txt\
 0\  
001‚Ä∫)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStarting Parsing Rule‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBasics‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπParameterizing starting rule‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/*@
declare [[C_starting_rule = "statement"]]
C ‚Äπwhile (a) {}‚Ä∫
C ‚Äπa = 2;‚Ä∫
declare [[C_starting_rule = "expression"]]
C ‚Äπ2 + 3‚Ä∫
C ‚Äπa = 2‚Ä∫
C ‚Äπa[1]‚Ä∫
C ‚Äπ&amp;a‚Ä∫
C ‚Äπa‚Ä∫
*/
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπEmbedding in Inner Terms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt; ‚Äï ‚Äπdefault behavior of parsing depending on the activated option‚Ä∫ ‚Äπ0‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>t</sub> ‚Äï ‚Äπforce the explicit parsing‚Ä∫ ‚Äπf () {while (a) {}; return 0;} int a = 0;‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>d</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>c</sub><span class="hidden">‚á©</span><sub>l</sub> ‚Äï ‚Äπforce the explicit parsing‚Ä∫ ‚Äπint a = 0; ‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äï ‚Äπforce the explicit parsing‚Ä∫ ‚Äπa‚Ä∫‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>s</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>m</sub><span class="hidden">‚á©</span><sub>t</sub> ‚Äï ‚Äπforce the explicit parsing‚Ä∫ ‚Äπwhile (a) {}‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_starting_rule</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"translation_unit"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt; ‚Äï ‚Äπdefault behavior of parsing depending on the current option‚Ä∫ ‚Äπint a = 0;‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUser Defined Setup of Syntax‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC_Module.C_Term.map_expression (fn _ =&gt; fn _ =&gt; fn _ =&gt; @{term "10 :: nat"})‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC_Module.C_Term.map_statement (fn _ =&gt; fn _ =&gt; fn _ =&gt; @{term "20 :: nat"})‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπ1‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>s</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>m</sub><span class="hidden">‚á©</span><sub>t</sub>‚Äπfor (;;);‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="comment">‚Äï ‚Äπredefinition‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC_Module.C_Term.map_expression
                           (fn _ =&gt; fn _ =&gt; fn _ =&gt; @{term "1000 :: nat"})‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπ1‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>s</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>m</sub><span class="hidden">‚á©</span><sub>t</sub>‚Äπfor (;;);‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC_Module.C_Term.map_default (fn _ =&gt; fn _ =&gt; fn _ =&gt; @{term "True"})‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπValidity of Context for Annotations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπfun fac x = if x = 0 then 1 else x * fac (x - 1)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚ÄπExecution of annotations in term possible in (the outermost) ‚¨ö‚ÄπML‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
\&lt;^term&gt;‚Äπ \&lt;^C&gt; ‚Äπint c = 0; /*@ ML ‚Äπfac 100‚Ä∫ */‚Ä∫ ‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="comment">‚Äï ‚ÄπExecution of annotations in term possible in \&lt;^ML_type&gt;‚Äπlocal_theory‚Ä∫ commands (such as ‚¨ö‚Äπdefinition‚Ä∫)‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
term = \&lt;^C&gt; ‚Äπint c = 0; /*@ ML ‚Äπfac 100‚Ä∫ */‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπScopes of Inner and Outer Terms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local
fun bind scan ((stack1, (to_delay, stack2)), _) =
  C_Parse.range scan
  &gt;&gt; (fn (src, range) =&gt;
      C_Env.Parsing
        ( (stack1, stack2)
        , ( range
          , C_Inner_Syntax.bottom_up
              (fn _ =&gt; fn context =&gt;
                ML_Context.exec
                  (tap (fn _ =&gt; Syntax.read_term (Context.proof_of context)
                                                 (Token.inner_syntax_of src)))
                  context)
          , Symtab.empty
          , to_delay)))
in
val _ =
  Theory.setup
    (   C_Annotation.command'
          ("term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub>", ‚åÇ)
          ""
          (bind (C_Token.syntax' (Parse.token Parse.cartouche)))
     #&gt; C_Inner_Syntax.command0
          (C_Inner_Toplevel.keep'' o C_Inner_Isar_Cmd.print_term)
          (C_Token.syntax' (Scan.succeed [] -- Parse.term))
          ("term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub>", ‚åÇ, ‚åÇ, ‚åÇ))
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int z = z;
 /*@ C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫
     C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫ */‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*outer*)</span></span></span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int z = z;
 /*@ C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫
     C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫ */‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*outer*)</span></span></span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_starting_env</span><span> </span><span class="delimiter">=</span><span> </span><span>last</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int z = z;
 /*@ C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫
     C  ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
     C' ‚Äπ//@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫‚Ä∫
             term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫ */‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*outer*)</span></span></span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπz‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>C_starting_env</span><span> </span><span class="delimiter">=</span><span> </span><span>empty</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπPropagation of report environment while manually composing at ML level‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a;
int f (int b) {
int c = 0;
/*@ ‚âàsetup ‚Äπfn _ =&gt; fn _ =&gt; fn env =&gt;
     C' env ‚Äπint d = a + b + c + d; //@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫‚Ä∫
  #&gt; C' env ‚Äπint d = a + b + c + d; //@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫‚Ä∫
  #&gt; C      ‚Äπint d = a + b + c + d; //@ term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫ term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫‚Ä∫
‚Ä∫
    term<span class="hidden">‚á©</span><sub>i</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫
    term<span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>u</sub><span class="hidden">‚á©</span><sub>t</sub><span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>r</sub> ‚Äπ\&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπc‚Ä∫ + \&lt;^C&gt;<span class="hidden">‚á©</span><sub>e</sub><span class="hidden">‚á©</span><sub>x</sub><span class="hidden">‚á©</span><sub>p</sub><span class="hidden">‚á©</span><sub>r</sub>‚Äπd‚Ä∫‚Ä∫ */
int e = a + b + c + d;
}‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCalculation in Directives‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnnotation Command Classification‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπLexing category vs. parsing category‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a = 0;

// ‚Äï ‚ÄπCategory 2: only parsing‚Ä∫

//@   ‚âàsetup  ‚ÄπK (K (K I))‚Ä∫ (* evaluation at parsing *)
//@@  ‚âàsetup‚áì ‚ÄπK (K (K I))‚Ä∫ (* evaluation at parsing *)

//@   highlight             (* evaluation at parsing *)
//@@  highlight‚áì            (* evaluation at parsing *)

// ‚Äï ‚ÄπCategory 3: with lexing‚Ä∫

//@  #setup  I              (* evaluation at lexing (and directives resolving) *)
//@   setup  I              (* evaluation at parsing *)
//@@  setup‚áì I              (* evaluation at parsing *)

//@  #ML     I              (* evaluation at lexing (and directives resolving) *)
//@   ML     I              (* evaluation at parsing *)
//@@  ML‚áì    I              (* evaluation at parsing *)

//@  #C     ‚Äπ‚Ä∫              (* evaluation at lexing (and directives resolving) *)
//@   C     ‚Äπ‚Ä∫              (* evaluation at parsing *)
//@@  C‚áì    ‚Äπ‚Ä∫              (* evaluation at parsing *)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπScheduling example‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
//@+++++   ML  ‚Äπwriteln "2"‚Ä∫
int a = 0;
//@@       ML‚áì ‚Äπwriteln "3"‚Ä∫
//@       #ML  ‚Äπwriteln "1"‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπScheduling example‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
//*  lemma True  by simp
//* #lemma True #by simp
//* #lemma True  by simp
//*  lemma True #by simp
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπScheduling example‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ /*@
lemma ‚Äπ1 = one‚Ä∫
      ‚Äπ2 = two‚Ä∫
      ‚Äπtwo + one = three‚Ä∫
by auto

#definition [simp]: ‚Äπthree = 3‚Ä∫
#definition [simp]: ‚Äπtwo   = 2‚Ä∫
#definition [simp]: ‚Äπone   = 1‚Ä∫
*/ ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGeneralizing ML Antiquotations with C Directives‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Directive_setup_define = Generic_Data
  (type T = int
   val empty = 0
   val extend = K empty
   val merge = K empty)

fun setup_define1 pos f =
  C_Directive.setup_define
    pos
    (fn toks =&gt; fn (name, (pos1, _)) =&gt;
      tap (fn _ =&gt; writeln ("Executing " ^ name ^ Position.here pos1 ^ " (only once)"))
      #&gt; pair (f toks))
    (K I)

fun setup_define2 pos = C_Directive.setup_define pos (K o pair)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπGeneral scheme of C antiquotations‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/*@
    #setup ‚Äï ‚ÄπOverloading ‚Äπ#define‚Ä∫‚Ä∫ ‚Äπ
      setup_define2
        ‚åÇ
        (fn (name, (pos1, _)) =&gt;
          op ` Directive_setup_define.get
          #&gt;&gt; (case name of "f3" =&gt; curry op * 152263 | _ =&gt; curry op + 1)
          #&gt;  tap (fn (nb, _) =&gt;
                    tracing ("Executing antiquotation " ^ name ^ Position.here pos1
                             ^ " (number = " ^ Int.toString nb ^ ")"))
          #&gt;  uncurry Directive_setup_define.put)
    ‚Ä∫
*/
#define f1
#define f2 int a = 0;
#define f3
        f1
        f2
        f1
        f3

//@ #setup ‚Äï ‚ÄπResetting ‚Äπ#define‚Ä∫‚Ä∫ ‚Äπsetup_define2 ‚åÇ (K I)‚Ä∫
        f3
#define f3
        f3
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπDynamic token computing in ‚Äπ#define‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ

//@ #setup ‚Äπsetup_define1 ‚åÇ (K [])‚Ä∫
#define f int a = 0;
        f f f f

//@ #setup ‚Äπsetup_define1 ‚åÇ (fn toks =&gt; toks @ toks)‚Ä∫
#define f int b = a;
        f f

//@ #setup ‚Äπsetup_define1 ‚åÇ I‚Ä∫
#define f int a = 0;
        f f
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMiscellaneous‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπAntiquotations acting on a parsed-subtree‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
# /**/ include  &lt;a\b\\c&gt; // backslash rendered unescaped
f(){0 +  0;} /**/  // val _ : theory =&gt; 'a =&gt; theory
# /* context */ if if elif
#include &lt;stdio.h&gt;
if then else ;
# /* zzz */  elif /**/
#else\
            
#define FOO  00 0 "" ((
FOO(FOO(a,b,c))
#endif‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπHeader-names in directives‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#define F &lt;stdio.h&gt;
#define G "stdio\h" // expecting an error whenever expanded
#define H "stdio_h" // can be used anywhere without errors
int f = /*F*/ "";
int g = /*G*/ "";
int h =   H   "";

#include F
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπParsing tokens as directives only when detecting space symbols before ‚Äπ#‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ/*
 */ \
    \

 //
         #  /*
*/   define /**/ \
 a
a a /*#include &lt;&gt;*/ // must not be considered as a directive
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment">‚Äï ‚ÄπUniversal character names in identifiers and Isabelle symbols‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#include &lt;stdio.h&gt;
int main () {
  char * √≥üåê√≤ = "√≥üåê√≤";
  printf ("%s", √≥üåê√≤);
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C2">
<div class="head"><h1>Theory C2</h1>
<span class="command">theory</span> <span class="name">C2</span><br/>
<span class="keyword">imports</span> <a href="C_Main.html"><span class="name">C_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExample: A Simple C Program with Directives and Annotations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../C_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA Simplistic Setup: Parse and Store‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following setup just stores the result of the parsed values in the environment.‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Data_Out = Generic_Data
  (type T = (C_Grammar_Rule.start_happy * C_Antiquote.antiq C_Env.stream) list
   val empty = []
   val extend = K empty
   val merge = K empty)

fun get_module thy =
  let val context = Context.Theory thy
  in (Data_Out.get context 
      |&gt; map (apfst (C_Grammar_Rule.start_happy1 #&gt; the)), C_Module.Data_In_Env.get context)
  end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContext.theory_map (C_Module.Data_Accept.put
                            (fn ast =&gt; fn env_lang =&gt;
                              Data_Out.map (cons (ast, #stream_ignored env_lang |&gt; rev))))‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExample of a Possible Semantics for ‚Äπ#include‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπImplementation‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The CPP directive \&lt;^C&gt;‚Äπ#include _‚Ä∫ is used to import signatures of
modules in C. This has the effect that imported identifiers are included in the C environment and,
as a consequence, appear as constant symbols and not as free variables in the output. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The following structure is an extra mechanism to define the effect of \&lt;^C&gt;‚Äπ#include _‚Ä∫ wrt. to
its definition in its environment. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Directive_include = Generic_Data
  (type T = (Input.source * C_Env.markup_ident) list Symtab.table
   val empty = Symtab.empty
   val extend = K empty
   val merge = K empty)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπPure‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local
fun return f (env_cond, env) = ([], (env_cond, f env))

val _ =
  Theory.setup
  (Context.theory_map
    (C_Context0.Directives.map
      (C_Context.directive_update ("include", ‚åÇ)
        ( (return o K I)
        , fn C_Lex.Include (C_Lex.Group2 (toks_bl, _, tok :: _)) =&gt;
               let
                 fun exec file =
                   if exists (fn C_Scan.Left _ =&gt; false | C_Scan.Right _ =&gt; true) file then
                     K (error ("Unsupported character"
                               ^ Position.here
                                   (Position.range_position
                                     (C_Lex.pos_of tok, C_Lex.end_pos_of (List.last toks_bl)))))
                   else
                     fn (env_lang, env_tree) =&gt;
                       fold
                         (fn (src, data) =&gt; fn (env_lang, env_tree) =&gt; 
                           let val (name, pos) = Input.source_content src
                           in C_Grammar_Rule_Lib.shadowTypedef0''''
                                name
                                [pos]
                                data
                                env_lang
                                env_tree
                           end)
                         (these (Symtab.lookup (Directive_include.get (#context env_tree))
                                               (String.concat
                                                 (maps (fn C_Scan.Left s =&gt; [s] | _ =&gt; []) file))))
                         (env_lang, env_tree)
               in
                 case tok of
                   C_Lex.Token (_, (C_Lex.String (_, file), _)) =&gt; exec file
                 | C_Lex.Token (_, (C_Lex.File (_, file), _)) =&gt; exec file
                 | _ =&gt; tap (fn _ =&gt; (* not yet implemented *)
                                     warning ("Ignored directive"
                                              ^ Position.here 
                                                  (Position.range_position
                                                    ( C_Lex.pos_of tok
                                                    , C_Lex.end_pos_of (List.last toks_bl)))))
               end |&gt; K |&gt; K
           | _ =&gt; K (K I)))))
in end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure Include =
struct
fun init name vars =
  Context.theory_map
    (Directive_include.map
      (Symtab.update
        (name, map (rpair {global = true, params = [], ret = C_Env.Previous_in_stack}) vars)))

fun append name vars =
  Context.theory_map
    (Directive_include.map
      (Symtab.map_default
        (name, [])
        (rev o fold (cons o rpair {global = true, params = [], ret = C_Env.Previous_in_stack}) vars
             o rev)))

val show =
  Context.theory_map
    (Directive_include.map
      (tap
        (Symtab.dest
         #&gt;
          app (fn (fic, vars) =&gt;
            writeln ("Content of \"" ^ fic ^ "\": "
                     ^ String.concat (map (fn (i, _) =&gt; let val (name, pos) = Input.source_content i
                                                        in name ^ Position.here pos ^ " " end)
                                          vars))))))
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInclude.append "stdio.h" [‚Äπprintf‚Ä∫, ‚Äπscanf‚Ä∫]‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTests‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
//@ setup ‚ÄπInclude.append "tmp" [‚Äπb‚Ä∫]‚Ä∫
#include "tmp"
int a = b;

‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int b = 0;
//@ setup ‚ÄπInclude.init "tmp" [‚Äπb‚Ä∫]‚Ä∫
#include "tmp"
int a = b;
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int c = 0;
//@ setup ‚ÄπInclude.append "tmp" [‚Äπc‚Ä∫]‚Ä∫
//@ setup ‚ÄπInclude.append "tmp" [‚Äπc‚Ä∫]‚Ä∫
#include "tmp"
int a = b + c;
//@ setup ‚ÄπInclude.show‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWorking with Pragmas‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ

#include &lt;stdio.h&gt;
#include /*sdfsdf */ &lt;stdlib.h&gt;
#define a B
#define b(C) 
#pragma   /* just exists syntaxically */
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIn the following, we retrieve the C11 AST parsed above. ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ val ((C_Ast.CTranslUnit0 (t,u), v)::R, env) = get_module @{theory};
    val u = C_Grammar_Rule_Lib.decode u; 
    C_Ast.CTypeSpec0; ‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWorking with Annotation Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Command‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚Äï ‚Äπsetup for a dummy ensures : the "Hello World" of Annotation Commands‚Ä∫
local
datatype antiq_hol = Term of string (* term *)

val scan_opt_colon = Scan.option (C_Parse.$$$ ":")

fun msg cmd_name call_pos cmd_pos =
  tap (fn _ =&gt;
        tracing ("‚ÄπHello World‚Ä∫ reported by \"" ^ cmd_name ^ "\" here" ^ call_pos cmd_pos))

fun command (cmd as (cmd_name, _)) scan0 scan f =
  C_Annotation.command'
    cmd
    ""
    (fn (_, (cmd_pos, _)) =&gt;
      (scan0 -- (scan &gt;&gt; f) &gt;&gt; (fn _ =&gt; C_Env.Never |&gt; msg cmd_name Position.here cmd_pos)))
in
val _ = Theory.setup (   C_Inner_Syntax.command_no_range
                           (C_Inner_Toplevel.generic_theory oo C_Inner_Isar_Cmd.setup ‚ÄπK (K (K I))‚Ä∫)
                           ("loop", ‚åÇ, ‚åÇ)
                      #&gt; command ("ensures", ‚åÇ) scan_opt_colon C_Parse.term Term
                      #&gt; command ("invariant", ‚åÇ) scan_opt_colon C_Parse.term Term
                      #&gt; command ("assigns", ‚åÇ) scan_opt_colon C_Parse.term Term
                      #&gt; command ("requires", ‚åÇ) scan_opt_colon C_Parse.term Term
                      #&gt; command ("variant", ‚åÇ) scan_opt_colon C_Parse.term Term)
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/*@ ensures "result &gt;= x &amp;&amp; result &gt;= y"
 */

int max(int x, int y) {
  if (x &gt; y) return x; else return y;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ 
val ((C_Ast.CTranslUnit0 (t,u), v)::R, env) = get_module @{theory};
val u = C_Grammar_Rule_Lib.decode u
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC Code: Various Examples‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThis example suite is drawn from Frama-C and used in our GLA - TPs. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int sqrt(int a) {
  int i = 0;
  int tm = 1;
  int sum = 1;

  /*@ loop invariant "1 &lt;= sum &lt;= a+tm"
      loop invariant "(i+1)*(i+1) == sum"
      loop invariant "tm+(i*i) == sum"
      loop invariant "1&lt;=tm&lt;=sum"
      loop assigns "i, tm, sum"
      loop variant "a-sum"
   */
  while (sum &lt;= a) {      
    i++;
    tm = tm + 2;
    sum = sum + tm;
  }
  
  return i;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/*@ requires "n &gt;= 0"
    requires "valid(t+(0..n-1))"
    ensures "exists integer i; (0&lt;=i&lt;n &amp;&amp; t[i] != 0) &lt;==&gt; result == 0"
    ensures "(forall integer i; 0&lt;=i&lt;n ==&gt; t[i] == 0) &lt;==&gt; result == 1"
    assigns nothing
 */

int allzeros(int t[], int n) {
  int k = 0;

  /*@ loop invariant "0 &lt;= k &lt;= n"
      loop invariant "forall integer i; 0&lt;=i&lt;k ==&gt; t[i] == 0"
      loop assigns k
      loop variant "n-k"
   */
  while(k &lt; n) {
    if (t[k]) return 0;
    k = k + 1;
  }
  return 1;
}

‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ

/*@ requires "n &gt;= 0"
    requires "valid(t+(0..n-1))"
    ensures "(forall integer i; 0&lt;=i&lt;n ==&gt; t[i] != v) &lt;==&gt; result == -1"
    ensures "(exists integer i; 0&lt;=i&lt;n &amp;&amp; t[i] == v) &lt;==&gt; result == v"
    assigns nothing
 */

int binarysearch(int t[], int n, int v) {
  int l = 0;
  int u = n-1;

  /*@ loop invariant false
   */
  while (l &lt;= u) {
    int m = (l + u) / 2;
    if (t[m] &lt; v) {
      l = m + 1;
    } else if (t[m] &gt; v) {
      u = m - 1;
    }
    else return m; 
  }
  return -1;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
/*@ requires "n &gt;= 0"
    requires "valid(t+(0..n-1))"
    requires "(forall integer i,j; 0&lt;=i&lt;=j&lt;n ==&gt; t[i] &lt;= t[j])"
    ensures "exists integer i; (0&lt;=i&lt;n &amp;&amp; t[i] == x) &lt;==&gt; result == 1"
    ensures "(forall integer i; 0&lt;=i&lt;n ==&gt; t[i] != x) &lt;==&gt; result == 0"
    assigns nothing
 */

int linearsearch(int x, int t[], int n) {
  int i = 0;

  /*@ loop invariant "0&lt;=i&lt;=n"
      loop invariant "forall integer j; 0&lt;=j&lt;i ==&gt; (t[j] != x)"
      loop assigns i
      loop variant "n-i"
   */
  while (i &lt; n) {
    if (t[i] &lt; x) {
      i++;
    } else {
      return (t[i] == x);
    }
  }

  return 0;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC Code: A Sorting Algorithm‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#include &lt;stdio.h&gt;
 
int main()
{
  int array[100], n, c, d, position, swap;
 
  printf("Enter number of elements\n");
  scanf("%d", &amp;n);
 
  printf("Enter %d integers\n", n);
 
  for (c = 0; c &lt; n; c++) scanf("%d", &amp;array[c]);
 
  for (c = 0; c &lt; (n - 1); c++)
  {
    position = c;
   
    for (d = c + 1; d &lt; n; d++)
    {
      if (array[position] &gt; array[d])
        position = d;
    }
    if (position != c)
    {
      swap = array[c];
      array[c] = array[position];
      array[position] = swap;
    }
  }

printf("Sorted list in ascending order:\n");
 
  for (c = 0; c &lt; n; c++)
    printf("%d\n", array[c]);
 
  return 0;
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA better example implementation:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
#define SIZE 10
 
void swap(int *x,int *y);
void selection_sort(int* a, const int n);
void display(int a[],int size);
 
void main()
{
 
    int a[SIZE] = {8,5,2,3,1,6,9,4,0,7};
 
    int i;
    printf("The array before sorting:\n");
    display(a,SIZE);
 
    selection_sort(a,SIZE);
 
    printf("The array after sorting:\n");
    display(a,SIZE);
}
 
/*
    swap two integers
*/
void swap(int *x,int *y)
{
    int temp;
 
    temp = *x;
    *x = *y;
    *y = temp;
}
/*
    perform selection sort
*/
void selection_sort(int* a,const int size)
{
    int i, j, min;
 
    for (i = 0; i &lt; size - 1; i++)
    {
        min = i;
        for (j = i + 1; j &lt; size; j++)
        {
            if (a[j] &lt; a[min])
            {
                min = j;
            }
        }
        swap(&amp;a[i], &amp;a[min]);
    }
}
/*
    display array content
*/
void display(int a[],const int size)
{
    int i;
    for(i=0; i&lt;size; i++)
        printf("%d ",a[i]);
    printf("\n");
}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAccessing the underlying C11-AST's via the ML Interface.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local open C_Ast in
val _ = CTranslUnit0
val ((CTranslUnit0 (t,u), v)::_, _) = get_module @{theory};
val u = C_Grammar_Rule_Lib.decode u
val _ = case u of Left (p1,p2) =&gt; writeln (Position.here p1 ^ " " ^ Position.here p2)
                | Right _ =&gt; error "Not expecting that value"
val CDeclExt0(x1)::_ = t;
val _ = CDecl0
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπC Code: Floats Exist‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a;
float b;
int m() {return 0;}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="C_paper">
<div class="head"><h1>Theory C_paper</h1>
<span class="command">theory</span> <span class="name">C_paper</span><br/>
<span class="keyword">imports</span> <a href="C_Main.html"><span class="name">C_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExamples from the F-IDE Paper‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_paper</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../C_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ This theory contains the examples presented in F-IDE
2019~\cite{Tuong-IsabelleC:2019}. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSetup‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚Äï ‚ÄπAnnotation Commands Mimicking the ‚¨ö‚Äπsetup‚Ä∫ command‚Ä∫
val _ = Theory.setup
          (C_Inner_Syntax.command C_Inner_Isar_Cmd.setup' C_Parse.ML_source ("‚âÉsetup", ‚åÇ, ‚åÇ))

val C' = C_Module.C'

fun C opt = case opt of NONE =&gt; C' (C_Module.env (Context.the_generic_context ()))
                      | SOME env =&gt; C' env

fun C_def dir name _ _ =
  Context.map_theory 
    (C_Inner_Syntax.command'
      (C_Inner_Syntax.drop1
        (C_Scan.Right ( (fn src =&gt; fn context =&gt;
                          C' (C_Stack.Data_Lang.get' context |&gt; #2) src context)
                      , dir)))
      C_Parse.C_source
      name)

‚Äï ‚ÄπDefining the ML Antiquotation ‚ÄπC_def‚Ä∫ to define on the fly new C annotation commands‚Ä∫
local
in
val _ = Theory.setup
  (ML_Antiquotation.declaration
    @{binding "C_def"}
    (Scan.lift (Parse.sym_ident -- Parse.position Parse.name))
    (fn _ =&gt; fn (top_down, (name, pos)) =&gt;
      tap (fn ctxt =&gt; Context_Position.reports ctxt [(pos, Markup.keyword1)]) #&gt;
      C_Context.fun_decl
               "cmd" "x" ( "C_def "
                         ^ (case top_down of "‚áë" =&gt; "C_Inner_Syntax.bottom_up"
                                           | "‚áì" =&gt; "C_Env.Top_down"
                                           | _ =&gt; error "Illegal symbol")
                         ^ " (\"" ^ name ^ "\", " ^ ML_Syntax.print_position pos ^ ")")))
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The next command is predefined here, so that the example below can later refer to the
constant. ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UINT_MAX ‚â° (2 :: nat) ^ 32 - 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDefining Annotation Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπ\&lt;^theory&gt;‚ÄπIsabelle_C.C_Command‚Ä∫‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
local
datatype antiq_hol = Invariant of string (* term *)
val scan_colon = C_Parse.$$$ ":" &gt;&gt; SOME
fun command cmd scan0 scan f =
  C_Annotation.command' cmd "" (K (scan0 -- (scan &gt;&gt; f)
                                      &gt;&gt; K C_Env.Never))
in
val _ = Theory.setup ((* 1 '@' *)
                         command ("INVARIANT", ‚åÇ) scan_colon C_Parse.term Invariant
                      #&gt; command ("INV", ‚åÇ) scan_colon C_Parse.term Invariant)
end
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDemonstrating the Effect of Annotation Command Context Navigation ‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int sum1(int a)
{
  while (a &lt; 10)
    /*@ @ INV: ‚Äπ‚Ä¶‚Ä∫
        @ highlight */
    { a = a + 1; }
  return a;
}‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int sum2(int a)
/*@ ++@ INV: ‚Äπ‚Ä¶‚Ä∫
    ++@ highlight */
{
  while (a &lt; 10)
    { a = a + 1; }
  return a;
}‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NONE*)</span></span></span></span></span><span> </span><span class="comment">‚Äï ‚Äπstarting environment = empty‚Ä∫</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
int a (int b) { return &amp;a + b + c; }
/*@ ‚âÉsetup ‚Äπfn stack_top =&gt; fn env =&gt;
            C (SOME env) ‚Äπint c = &amp;a + b + c;‚Ä∫‚Ä∫
    ‚âÉsetup ‚Äπfn stack_top =&gt; fn env =&gt;
            C  NONE      ‚Äπint c = &amp;a + b + c;‚Ä∫‚Ä∫
    declare [[C_starting_env = last]]
    C        (*SOME*)    ‚Äπint c = &amp;a + b + c;‚Ä∫
*/‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπProofs inside C-Annotations‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment">‚Äï ‚ÄπSee also: üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_TEC.thy‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
#define SQRT_UINT_MAX 65536
/*@ lemma uint_max_factor [simp]:
      "UINT_MAX = SQRT_UINT_MAX * SQRT_UINT_MAX - 1"
    by (clarsimp simp: UINT_MAX_def SQRT_UINT_MAX_def)
*/‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>SQRT_UINT_MAX</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπScheduling the Effects on the Logical Context‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint _;
/*@ @ C ‚Äπ//@ C1 ‚Äπint _; //@ @ ‚âÉsetup‚áì ‚Äπ@{C_def ‚áë C2}‚Ä∫ \
                            @ C1  ‚Äπ//* C2 ‚Äπint _;‚Ä∫‚Ä∫   \
                            @ C1‚áì ‚Äπ//* C2 ‚Äπint _;‚Ä∫‚Ä∫    ‚Ä∫‚Ä∫
    @ C ‚Äπ//* C2 ‚Äπint _;‚Ä∫                                ‚Ä∫
      ‚âÉsetup ‚Äπ@{C_def ‚áë (* bottom-up *)  C1  }‚Ä∫
      ‚âÉsetup ‚Äπ@{C_def ‚áì (* top-down  *) "C1‚áì"}‚Ä∫
*/‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAs Summary: A Spaghetti Language --- Bon App√©tit!‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ... with the Bonus of a local C-inside-ML-inside-C-inside-Isar ...‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
fun highlight (_, (_, pos1, pos2)) =
  tap (fn _ =&gt; Position.reports_text [((Position.range (pos1, pos2)
                                        |&gt; Position.range_position, Markup.intensify), "")])
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NONE*)</span></span></span></span></span><span> </span><span class="comment">‚Äï ‚Äπ the command starts with a default empty environment ‚Ä∫</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπint f (int a)
  //@ ++&amp; ‚âÉsetup ‚Äπfn stack_top =&gt; fn env =&gt; highlight stack_top‚Ä∫
  { /*@ @ ‚âÉsetup ‚Äπfn stack_top =&gt; fn env =&gt;
                    C (SOME env) (* the command starts with some provided environment *)
                     ‚Äπint b = a + b; //@ C1' ‚Äπint c; //@ @ ‚âÉsetup‚áì ‚Äπ@{C_def ‚áë C2'}‚Ä∫ \
                                                         @ C1'  ‚Äπ//* C2' ‚Äπint d;‚Ä∫‚Ä∫        \
                                                         @ C1'‚áì ‚Äπ//* C2' ‚Äπint d;‚Ä∫‚Ä∫        ‚Ä∫
                      int b = a + b + c + d;‚Ä∫‚Ä∫
        @ ‚âÉsetup ‚Äπfn stack_top =&gt; fn env =&gt; C NONE ‚Äπ#define int int
                                                    int b = a + b; //* C2' ‚Äπint c = b;‚Ä∫‚Ä∫‚Ä∫
          ‚âÉsetup ‚Äπ@{C_def ‚áë (* bottom-up *)  C1'  }‚Ä∫
          ‚âÉsetup ‚Äπ@{C_def ‚áì (* top-down  *) "C1'‚áì"}‚Ä∫
     */
    return a + b + c + d; /* explicit highlighting */ }‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Note that in the current design-implementation of Isabelle/C, C directives have a
propagation side-effect to any occurring subsequent C annotations, even if C directives are supposed
to be all evaluated before any C code. (Making such effect inexistent would be equally easier to
implement though, this is what was the default behavior of directives in previous versions of
Isabelle/C.)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C_Appendices">
<div class="head"><h1>Theory C_Appendices</h1>
<span class="command">theory</span> <span class="name">C_Appendices</span><br/>
<span class="keyword">imports</span> <a href="C1.html"><span class="name">C1</span></a> <a href="Base.html"><span class="name">Base</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnnexes‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C_Appendices</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"examples/C1"</span></span></span><span>
</span><span>          </span><span>Isar_Ref.Base</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="comment">‚Äï ‚Äπüóè‚Äπ~~/src/Doc/antiquote_setup.ML‚Ä∫‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Fr√©d√©ric Tuong, Universit√© Paris-Saclay *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Doc/antiquote_setup.ML
    Author:     Makarius

Auxiliary antiquotations for the Isabelle manuals.
*)</span></span></span></span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
structure C_Antiquote_Setup =
struct

(* misc utils *)

fun translate f = Symbol.explode #&gt; map f #&gt; implode;

val clean_string = translate
  (fn "_" =&gt; "\\_"
    | "#" =&gt; "\\#"
    | "$" =&gt; "\\$"
    | "%" =&gt; "\\%"
    | "&lt;" =&gt; "$&lt;$"
    | "&gt;" =&gt; "$&gt;$"
    | "{" =&gt; "\\{"
    | "|" =&gt; "$\\mid$"
    | "}" =&gt; "\\}"
    | "‚Äê" =&gt; "-"
    | c =&gt; c);

fun clean_name "‚Ä¶" = "dots"
  | clean_name ".." = "ddot"
  | clean_name "." = "dot"
  | clean_name "_" = "underscore"
  | clean_name "{" = "braceleft"
  | clean_name "}" = "braceright"
  | clean_name s = s |&gt; translate (fn "_" =&gt; "-"
                                    | "‚Äê" =&gt; "-"
                                    | "#" =&gt; "symbol-hash"
                                    | "‚âà" =&gt; "symbol-lower-approx"
                                    | "‚áì" =&gt; "symbol-upper-down"
                                    | c =&gt; c);


(* Isabelle/Isar entities (with index) *)

local

val arg = enclose "{" "}" o clean_string;

fun entity check markup binding index =
  Thy_Output.antiquotation_raw
    (binding |&gt; Binding.map_name (fn name =&gt; name ^
      (case index of NONE =&gt; "" | SOME true =&gt; "_def" | SOME false =&gt; "_ref")))
    (Scan.lift (Scan.optional (Args.parens Args.name) "" -- Parse.position Args.name))
    (fn ctxt =&gt; fn (logic, (name, pos)) =&gt;
      let
        val kind = translate (fn "_" =&gt; " " | c =&gt; c) (Binding.name_of binding);
        val hyper_name =
          "{" ^ Long_Name.append kind (Long_Name.append logic (clean_name name)) ^ "}";
        val hyper =
          enclose ("\\hyperlink" ^ hyper_name ^ "{") "}" #&gt;
          index = SOME true ? enclose ("\\hypertarget" ^ hyper_name ^ "{") "}";
        val idx =
          (case index of
            NONE =&gt; ""
          | SOME is_def =&gt;
              "\\index" ^ (if is_def then "def" else "ref") ^ arg logic ^ arg kind ^ arg name);
        val _ =
          if Context_Position.is_reported ctxt pos then ignore (check ctxt (name, pos)) else ();
        val latex =
          idx ^
          (Output.output name
            |&gt; (if markup = "" then I else enclose ("\\" ^ markup ^ "{") "}")
            |&gt; hyper o enclose "\\mbox{\\isa{" "}}");
      in Latex.string latex end);

fun entity_antiqs check markup kind =
  entity check markup kind NONE #&gt;
  entity check markup kind (SOME true) #&gt;
  entity check markup kind (SOME false);

in

val _ =
  Theory.setup
   (entity_antiqs C_Annotation.check_command "isacommand" \&lt;^binding&gt;‚Äπannotation‚Ä∫);

end;

end;

‚Ä∫</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSyntax Commands for Isabelle/C‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπOuter Classical Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  \begin{matharray}{rcl}
    @{command_def "C_file"} &amp; : &amp; ‚Äπlocal_theory ‚Üí local_theory‚Ä∫ \\
    @{command_def "C"} &amp; : &amp; ‚Äπlocal_theory ‚Üí local_theory‚Ä∫ \\
    @{command_def "C_export_boot"} &amp; : &amp; ‚Äπlocal_theory ‚Üí local_theory‚Ä∫ \\
    @{command_def "C_prf"} &amp; : &amp; ‚Äπproof ‚Üí proof‚Ä∫ \\
    @{command_def "C_val"} &amp; : &amp; ‚Äπany ‚Üí‚Ä∫ \\
    @{command_def "C_export_file"} &amp; : &amp; ‚Äπany ‚Üí‚Ä∫ \\
  \end{matharray}
  \begin{tabular}{rcll}
    @{attribute_def C_lexer_trace} &amp; : &amp; ‚Äπattribute‚Ä∫ &amp; default ‚Äπfalse‚Ä∫ \\
    @{attribute_def C_parser_trace} &amp; : &amp; ‚Äπattribute‚Ä∫ &amp; default ‚Äπfalse‚Ä∫ \\
    @{attribute_def C_ML_verbose} &amp; : &amp; ‚Äπattribute‚Ä∫ &amp; default ‚Äπtrue‚Ä∫ \\
    @{attribute_def C_starting_env} &amp; : &amp; ‚Äπattribute‚Ä∫ &amp; default ‚Äπempty‚Ä∫ \\
    @{attribute_def C_starting_rule} &amp; : &amp; ‚Äπattribute‚Ä∫ &amp; default ‚Äπtranslation_unit‚Ä∫ \\
  \end{tabular}

  \&lt;^rail&gt;‚Äπ
    @@{command C_file} @{syntax name} ';'?
    ;
    (@@{command C} | @@{command C_export_boot} | @@{command C_prf} |
      @@{command C_val}) @{syntax text}
    ;
    @@{command C_export_file}
    ;
  ‚Ä∫

  ‚ûß ‚¨ö‚ÄπC_file name‚Ä∫ reads the given C file, and let any attached
  semantic back-ends to proceed for further subsequent evaluation. Top-level C bindings are stored
  within the (global or local) theory context; the initial environment is set by default to be an
  empty one, or the one returned by a previous ‚¨ö‚ÄπC_file‚Ä∫ (depending on
  @{attribute_def C_starting_env}). The entry-point of the grammar taken as initial starting parser
  is read from @{attribute_def C_starting_rule} (see
  üåê‚Äπhttps://www.haskell.org/happy/doc/html/sec-directives.html#sec-parser-name‚Ä∫).
  Multiple ‚¨ö‚ÄπC_file‚Ä∫ commands may be used to build larger C projects if
  they are all written in a single theory file (existing parent theories are ignored, and not
  affecting the current working theory).

  ‚ûß ‚¨ö‚ÄπC‚Ä∫ is similar to
  ‚¨ö‚ÄπC_file‚Ä∫, but evaluates directly the
  given ‚Äπtext‚Ä∫. Top-level resulting bindings are stored
  within the (global or local) theory context.

  ‚ûß ‚¨ö‚ÄπC_export_boot‚Ä∫ is similar to
  ‚¨ö‚ÄπML_export‚Ä∫, except that the code in
  input is understood as being processed by
  ‚¨ö‚ÄπC‚Ä∫ instead of ‚¨ö‚ÄπML‚Ä∫.

  ‚ûß ‚¨ö‚ÄπC_prf‚Ä∫ is similar to
  ‚¨ö‚ÄπML_prf‚Ä∫, except that the code in input
  is understood as being processed by
  ‚¨ö‚ÄπC‚Ä∫ instead of ‚¨ö‚ÄπML‚Ä∫.

  ‚ûß ‚¨ö‚ÄπC_val‚Ä∫ is similar to
  ‚¨ö‚ÄπML_val‚Ä∫, except that the code in input
  is understood as being processed by
  ‚¨ö‚ÄπC‚Ä∫ instead of ‚¨ö‚ÄπML‚Ä∫.

  ‚ûß ‚¨ö‚ÄπC_export_file‚Ä∫ is similar to
  ‚¨ö‚Äπgenerate_file fic = ‚Äπcode‚Ä∫
    export_generated_files fic‚Ä∫, except that
    ‚ñ™ ‚Äπcode‚Ä∫ refers to the dump of all existing previous C code in the current
    theory (parent theories are ignored),
    ‚ñ™ and any ML antiquotations in ‚Äπcode‚Ä∫ are not analyzed by
    ‚¨ö‚Äπgenerate_file‚Ä∫ (in contrast with its default behavior). ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ

  ‚ûß @{attribute C_lexer_trace} indicates whether the list of C
  tokens associated to the source text should be output (that list is
  computed during the lexing phase).

  ‚ûß @{attribute C_parser_trace} indicates whether the stack
  forest of Shift-Reduce node should be output (it is the final stack
  which is printed, i.e., the one taken as soon as the parsing
  terminates).

  ‚ûß @{attribute C_ML_verbose} indicates whether nested
  ‚¨ö‚ÄπML‚Ä∫ commands are acting similarly as
  their default verbose configuration in top-level.

  ‚ûß @{attribute C_starting_env} makes the start of a C
  command (e.g., ‚¨ö‚ÄπC_file‚Ä∫,
  ‚¨ö‚ÄπC‚Ä∫) initialized with the environment of
  the previous C command if existing.

  ‚ûß @{attribute C_starting_rule} sets which parsing function will be used to parse the next
  C commands (e.g., ‚¨ö‚ÄπC_file‚Ä∫, ‚¨ö‚ÄπC‚Ä∫).
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInner Annotation Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  \&lt;^rail&gt;‚Äπ
    (@@{annotation "#ML_file"} | @@{annotation ML_file} | @@{annotation "ML_file‚áì"} |
      @@{annotation "#C_file"} | @@{annotation C_file} | @@{annotation "C_file‚áì"}) @{syntax name} ';'?
    ;
    (@@{annotation "#ML"} | @@{annotation ML} | @@{annotation "ML‚áì"} |
      @@{annotation "#setup"} | @@{annotation setup} | @@{annotation "setup‚áì"} |
      @@{annotation "‚âàsetup"} | @@{annotation "‚âàsetup‚áì"} |
      @@{annotation "#C"} | @@{annotation C} | @@{annotation "C‚áì"} |
      @@{annotation "#C_export_boot"} | @@{annotation C_export_boot} | @@{annotation "C_export_boot‚áì"}) @{syntax text}
    ;
    (@@{annotation "#C_export_file"} | @@{annotation C_export_file} | @@{annotation "C_export_file‚áì"} |
     @@{annotation highlight} | @@{annotation "highlight‚áì"})
    ;
  ‚Ä∫

  ‚ûß \&lt;^C_theory_text&gt;‚ÄπML_file‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπC_file‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπML‚Ä∫, \&lt;^C_theory_text&gt;‚Äπsetup‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπC_export_boot‚Ä∫, and
  \&lt;^C_theory_text&gt;‚ÄπC_export_file‚Ä∫ behave similarly as the respective outer commands
  ‚¨ö‚ÄπML_file‚Ä∫, ‚¨ö‚ÄπC_file‚Ä∫,
  ‚¨ö‚ÄπML‚Ä∫, ‚¨ö‚Äπsetup‚Ä∫,
  ‚¨ö‚ÄπC‚Ä∫, ‚¨ö‚ÄπC_export_boot‚Ä∫,
  ‚¨ö‚ÄπC_export_file‚Ä∫.

  ‚ûß \&lt;^C_theory_text&gt;‚Äπ‚âàsetup ‚Äπf'‚Ä∫‚Ä∫ has the same semantics
  as \&lt;^C_theory_text&gt;‚Äπsetup ‚Äπf‚Ä∫‚Ä∫ whenever \&lt;^term&gt;‚Äπ‚ãÄ stack top
  env. f' stack top env = f‚Ä∫. In particular, depending on where the annotation
  \&lt;^C_theory_text&gt;‚Äπ‚âàsetup ‚Äπf'‚Ä∫‚Ä∫ is located in the C code, the
  additional values ‚Äπstack‚Ä∫, ‚Äπtop‚Ä∫ and ‚Äπenv‚Ä∫ can drastically
  vary, and then can be possibly used in the body of ‚Äπf'‚Ä∫ for implementing new
  interactive features (e.g., in contrast to ‚Äπf‚Ä∫, which by default does not have the
  possibility to directly use the information provided by ‚Äπstack‚Ä∫, ‚Äπtop‚Ä∫
  and ‚Äπenv‚Ä∫).

  ‚ûß \&lt;^C_theory_text&gt;‚Äπhighlight‚Ä∫ changes the background color of the C tokens pointed by the command.

  ‚ûß \&lt;^C_theory_text&gt;‚Äπ#ML_file‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ#C_file‚Ä∫, \&lt;^C_theory_text&gt;‚Äπ#ML‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ#setup‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ#C‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ#C_export_boot‚Ä∫, and
  \&lt;^C_theory_text&gt;‚Äπ#C_export_file‚Ä∫
  behave similarly as the respective (above inner) commands
  \&lt;^C_theory_text&gt;‚ÄπML_file‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_file‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπML‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπsetup‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_export_boot‚Ä∫, and
  \&lt;^C_theory_text&gt;‚ÄπC_export_file‚Ä∫
  except that their evaluations happen as earliest as possible.

  ‚ûß \&lt;^C_theory_text&gt;‚ÄπML_file‚áì‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_file‚áì‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπML‚áì‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπsetup‚áì‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ‚âàsetup‚áì‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπC‚áì‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_export_boot‚áì‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_export_file‚áì‚Ä∫, and
  \&lt;^C_theory_text&gt;‚Äπhighlight‚áì‚Ä∫
  behave similarly as the respective (above inner) commands
  \&lt;^C_theory_text&gt;‚ÄπML_file‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπC_file‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπML‚Ä∫, \&lt;^C_theory_text&gt;‚Äπsetup‚Ä∫,
  \&lt;^C_theory_text&gt;‚Äπ‚âàsetup‚Ä∫, \&lt;^C_theory_text&gt;‚ÄπC‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_export_boot‚Ä∫,
  \&lt;^C_theory_text&gt;‚ÄπC_export_file‚Ä∫, and
  \&lt;^C_theory_text&gt;‚Äπhighlight‚Ä∫
  except that their evaluations happen as latest as possible.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInner Directive Commands‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  ‚ûß Among the directives provided as predefined in Isabelle/C, we currently have:
  \&lt;^C&gt;‚Äπ#define _‚Ä∫ and \&lt;^C&gt;‚Äπ#undef _‚Ä∫. In particular, for the case of
  \&lt;^C&gt;‚Äπ#define _‚Ä∫, rewrites are restricted to variable-form macros: support of
  functional macros is not yet provided.
  ‚ûß In Isabelle/C, not-yet-defined directives (such as \&lt;^C&gt;‚Äπ#include _‚Ä∫ or
  \&lt;^C&gt;‚Äπ#if
  #endif‚Ä∫, etc.) do not make the parsing fail, but are treated as ``free variable commands''.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπQuick Start (for People More Familiar with C than Isabelle)‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚ñ™ Assuming we are working with Isabelle 2019
üåê‚Äπhttp://isabelle.in.tum.de/dist/Isabelle2019_app.tar.gz‚Ä∫, the shortest way to
start programming in C is to open a new theory file with the shell-command:

‚ñ©‚Äπ$ISABELLE_HOME/bin/isabelle jedit -d $AFP_HOME/thys Scratch.thy‚Ä∫

where ‚ñ©‚Äπ$ISABELLE_HOME‚Ä∫ is the path of the above extracted Isabelle source,
and ‚ñ©‚Äπ$AFP_HOME‚Ä∫ is the downloaded content of
üåê‚Äπhttps://bitbucket.org/isa-afp/afp-2019‚Ä∫.‚Åã‚ÄπThis folder
particularly contains the Isabelle/C project, located in
üåê‚Äπhttps://bitbucket.org/isa-afp/afp-2019/src/default/thys/Isabelle_C‚Ä∫. To inspect
the latest developper version, one can also replace ‚ñ©‚Äπ$AFP_HOME/thys‚Ä∫ by the
content downloaded from üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c‚Ä∫.‚Ä∫
‚ñ™ The next step is to copy this minimal content inside the newly opened window:
‚ñ©‚Äπtheory Scratch imports Isabelle_C.C_Main begin C ‚Äπ
// C code
‚Ä∫ end‚Ä∫
‚ñ™ ‚àó‚ÄπQuod Erat Demonstrandum!‚Ä∫ This already enables the support of C code inside the special
brackets ``‚ñ©‚Äπ‚Äπ‚Ä∫‚Ä∫'', now depicted as
``‚Äπ‚Äπ‚Ä∫‚Ä∫'' for readability reasons. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
\begin{figure}
  \centering
\includegraphics[width=\textwidth]{figures/C-export-example}
  \caption{Making the File Browser Pointing to the Virtual File System}
  \label{fig:file-bro}
\end{figure}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Additionally, Isabelle/C comes with several functionalities that can be alternatively
explored:
‚ñ™ To write theorems and proofs along with C code, the special C comment
\&lt;^C&gt;‚Äπ/*@ (* Isabelle content *) */‚Ä∫ can be used at any position where C comments are
usually regularly allowed. At the time of writing, not yet all Isabelle commands can be written in C
comments, and certain proof-solving-command combinations are also not yet implemented --- manual
registration of commands to retrieve some more or less native user-experience remains possible
though. Generally, the kind of content one can write in C comments should be arbitrary. The
exhaustive list of Isabelle commands is provided in the accompanying above archive, for example in
üóÄ‚Äπ$ISABELLE_HOME/src/Doc/Isar_Ref‚Ä∫ or
üåê‚Äπhttps://isabelle.in.tum.de/doc/isar-ref.pdf‚Ä∫.

‚ñ™ Instead of starting from scratch, any existing C files can also be opened with Isabelle/C,
it suffices to replace:

\begin{tabular}{c}
 ‚ñ©‚ÄπC‚Ä∫ ‚¨ö‚Äπ‚Äπ /* C */ ‚Ä∫‚Ä∫ \\
 by \\
 ‚ñ©‚ÄπC_file‚Ä∫ ‚¨ö‚Äπ‚Äπ~/file.c‚Ä∫‚Ä∫
\end{tabular}

Once done, one can press a CTRL-like key while hovering the mouse over the file name, then followed
by a click on it to open a new window loading that file.

‚ñ™ After a ‚ñ©‚ÄπC‚Ä∫ ‚¨ö‚Äπ‚Äπ /* C */ ‚Ä∫‚Ä∫
command, one has either the possibility to keep the content as such in the theory file, or use
‚ñ©‚ÄπC_export_file‚Ä∫ to export all previous C content into a ``real'' C file.

Note that since Isabelle2019, Isabelle/C uses a virtual file-system. This has the consequence, that
some extra operations are needed to export a file generated into the virtual file-system of Isabelle
into the ``real'' file-system. First, the ‚ñ©‚ÄπC_export_file‚Ä∫ command needs to
be activated, by putting the cursor on the command. This leads to the following message in the
output window: ‚ñ©‚ÄπSee theory exports "C/*/*.c"‚Ä∫ (see
\autoref{fig:file-bro}). By clicking on ‚Äπtheory exports‚Ä∫ in
this message, Isabelle opens a ‚ÄπFile Browser‚Ä∫ showing the content of the virtual
file-system in the left window. Selecting and opening a generated file in the latter lets jEdit
display it in a new buffer, which gives the possibility to export this file via ``‚ÄπFile
‚Üí Save As‚Ä¶‚Ä∫'' into the real file-system. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCase Study: Mapping on the Parsed AST‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ In this section, we give a concrete example of a situation where one is interested to
do some automated transformations on the parsed AST, such as changing the type of every encountered
variables from \&lt;^C&gt;‚Äπint _;‚Ä∫ to \&lt;^C&gt;‚Äπint _ [];‚Ä∫. The main theory of
interest here is \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫, where the C grammar is
loaded, in contrast to \&lt;^theory&gt;‚ÄπIsabelle_C.C_Lexer_Language‚Ä∫ which is only dedicated
to build a list of C tokens. As another example,
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫ also contains the portion of the code
implementing the report to the user of various characteristics of encountered variables during
parsing: if a variable is bound or free, or if the declaration of a variable is made in the global
topmost space or locally declared in a function. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPrerequisites‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Even if üóè‚Äπgenerated/c_grammar_fun.grm.sig‚Ä∫ and
üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫ are files written in ML syntax, we have
actually modified üóÄ‚Äπ../src_ext/mlton/lib/mlyacc-lib‚Ä∫ in such a way that at run
time, the overall loading and execution of
\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫ will mimic all necessary features of the
Haskell parser generator Happy
‚Åã‚Äπüåê‚Äπhttps://www.haskell.org/happy/doc/html/index.html‚Ä∫‚Ä∫,
including any monadic interactions between the lexing
(\&lt;^theory&gt;‚ÄπIsabelle_C.C_Lexer_Language‚Ä∫) and parsing part
(\&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫).

This is why in the remaining part, we will at least assume a mandatory familiarity with Happy (e.g.,
the reading of ML-Yacc's manual can happen later if wished
‚Åã‚Äπüåê‚Äπhttps://www.cs.princeton.edu/~appel/modern/ml/ml-yacc/manual.html‚Ä∫‚Ä∫). In
particular, we will use the term ‚àó‚Äπrule code‚Ä∫ to designate ‚àó‚Äπa
Haskell expression enclosed in braces‚Ä∫
‚Åã‚Äπüåê‚Äπhttps://www.haskell.org/happy/doc/html/sec-grammar.html‚Ä∫‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπStructure of \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ In more detail, \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫ can be seen as being
principally divided into two parts:
  ‚ñ™ a first part containing the implementation of
  \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫, which provides the ML implementation library
  used by any rule code written in the C grammar
  üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
  (üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫).
  ‚ñ™ a second part implementing \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫, providing
  one wrapping function for each rule code, for potentially complementing the rule code with an
  additional action to be executed after its call. The use of wrapping functions is very optional:
  by default, they are all assigned as identity functions.

The difference between \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ and
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫ relies in how often functions in the two
structures are called: while building subtree pieces of the final AST, grammar rules are free to
call any functions in \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ for completing their
respective tasks, but also free to not use \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ at
all. On the other hand, irrespective of the actions done by a rule code, the function associated to
the rule code in \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫ is retrieved and always executed
(but a visible side-effect will likely mostly happen whenever one has provided an implementation far
different from \&lt;^ML&gt;‚ÄπI‚Ä∫). ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Because the grammar
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
(üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫) has been defined in such a way that
computation of variable scopes are completely handled by functions in
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ and not in rule code (which are just calling
functions in \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫), it is enough to overload functions
in \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ whenever it is wished to perform new actions
depending on variable scopes, for example to do a specific PIDE report at the first time when a C
variable is being declared. In particular, functions in
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ are implemented in monadic style, making a
subsequent modification on the parsing environment \&lt;^theory&gt;‚ÄπIsabelle_C.C_Environment‚Ä∫ possible
(whenever appropriate) as this last is carried in the monadic state.

Fundamentally, this is feasible because the monadic environment fulfills the property of being
always properly enriched with declared variable information at any time, because we assume
  ‚ñ™ working with a language where a used variable must be at most declared or redeclared
  somewhere before its actual usage,
  ‚ñ™ and using a parser scanning tokens uniquely, from left to right, in the same order as
  the execution of rule code actions. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExample‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ As illustration, \&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var o C_Ast.Left‚Ä∫ is
(implicitly) called by a rule code while a variable being declared is encountered. Later, a call to
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var o C_Ast.Right‚Ä∫ in
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫ (actually, in
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading‚Ä∫) is made after the execution of
another rule code to signal the position of a variable in use, together with the information
retrieved from the environment of the position of where it is declared. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ In more detail, the second argument of
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var‚Ä∫ is among other of the form:
\&lt;^ML_type&gt;‚ÄπPosition.T * {global: bool}‚Ä∫, where particularly the field
\&lt;^ML&gt;‚Äπ#global : C_Env.markup_ident -&gt; bool‚Ä∫ of the record is informing
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var‚Ä∫ if the variable being reported (at either first
declaration time, or first use time) is global or local (inside a function for instance). Because
once declared, the property \&lt;^ML&gt;‚Äπ#global : C_Env.markup_ident -&gt; bool‚Ä∫ of a variable
does not change afterwards, it is enough to store that information in the monadic environment:
‚ñ™ <span class="hidden">‚ùô</span><span class="bold">‚Äπ</span>Storing the information at declaration time‚Ä∫ The part deciding if a
variable being declared is global or not is implemented in
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.doDeclIdent‚Ä∫ and
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.doFuncParamDeclIdent‚Ä∫. The two functions come from
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
(so do any functions in \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫). Ultimately, they are
both calling \&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var o C_Ast.Left‚Ä∫ at some point.
‚ñ™ <span class="hidden">‚ùô</span><span class="bold">‚Äπ</span>Retrieving the information at use time‚Ä∫
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var o C_Ast.Right‚Ä∫ is only called by
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Wrap.primary_expression1‚Ä∫, while treating a variable being
already declared. In particular the second argument of
\&lt;^ML&gt;‚ÄπC_Grammar_Rule_Lib.markup_var‚Ä∫ is just provided by what has been computed by the
above point when the variable was declared (e.g., the globality versus locality
information). ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRewriting of AST node‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ For the case of rewriting a specific AST node, from subtree ‚ÄπT1‚Ä∫ to
subtree ‚ÄπT2‚Ä∫, it is useful to zoom on the different parsing evaluation stages, as well
as make precise when the evaluation of semantic back-ends are starting.

‚ñ∏ Whereas annotations in Isabelle/C code have the potential of carrying arbitrary ML code (as
in \&lt;^theory&gt;‚ÄπIsabelle_C.C1‚Ä∫), the moment when they are effectively evaluated
will not be discussed here, because to closely follow the semantics of the language in embedding (so
C), we suppose comments --- comprising annotations --- may not affect any parsed tokens living
outside comments. So no matter when annotations are scheduled to be future evaluated in Isabelle/C,
the design decision of Isabelle/C is to not let a code do directive-like side-effects in
annotations, such as changing ‚ÄπT1‚Ä∫ to ‚ÄπT2‚Ä∫ inside annotations.

‚ñ∏ To our knowledge, the sole category of code having the capacity to affect incoming stream
of tokens are directives, which are processed and evaluated before the ``major'' parsing step
occurs. Since in Isabelle/C, directives are relying on ML code, changing an AST node from
‚ÄπT1‚Ä∫ to ‚ÄπT2‚Ä∫ can then be perfectly implemented in directives.

‚ñ∏ After the directive (pre)processing step, the main parsing happens. But since what are
driving the parsing engine are principally rule code, this step means to execute
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Lib‚Ä∫ and
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫, i.e., rules in
üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫.

‚ñ∏ Once the parsing finishes, we have a final AST value, which topmost root type entry-point
constitutes the last node built before the grammar parser
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
ever entered in a stop state. For the case of a stop acceptance state, that moment happens when we
reach the first rule code building the type \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫, since there
is only one possible node making the parsing stop, according to what is currently written in the C
grammar. (For the case of a state stopped due to an error, it is the last successfully built value
that is returned, but to simplify the discussion, we will assume in the rest of the document the
parser is taking in input a fully well-parsed C code.)

‚ñ∏ By ‚àó‚Äπsemantic back-ends‚Ä∫, we denote any kind of ``relatively
efficient'' compiled code generating Isabelle/HOL theorems, proofs, definitions, and so with the
potential of generally generating Isabelle packages. In our case, the input of semantic back-ends
will be the type \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ (actually, whatever value provided by
the above parser). But since our parser is written in monadic style, it is as well possible to give
slightly more information to semantic back-ends, such as the last monadic computed state, so
including the last state of the parsing environment. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Generally, semantic back-ends can be written in full ML starting from
\&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫, but to additionally support formalizing tasks requiring
to start from an AST defined in Isabelle/HOL, we provide an equivalent AST in HOL in the project,
such as the one obtained after loading
üåê‚Äπhttps://gitlri.lri.fr/ftuong/citadelle-devel/blob/master/doc/Meta_C_generated.thy‚Ä∫.
(In fact, the ML AST is just generated from the HOL one.) ‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
Based on the above information, there are now several ‚àó‚Äπequivalent‚Ä∫ ways to
proceed for the purpose of having an AST node be mapped from ‚ÄπT1‚Ä∫ to
‚ÄπT2‚Ä∫. The next bullets providing several possible solutions to follow are particularly
sorted in increasing action time.

‚ñ™ ‚àó‚ÄπBefore even starting the Isabelle system.‚Ä∫ A first approach would be
to modify the C code in input, by adding a directive \&lt;^C&gt;‚Äπ#define _ _‚Ä∫ performing the
necessary rewrite.

‚ñ™ ‚àó‚ÄπBefore even starting the Isabelle system.‚Ä∫ As an alternative of
changing the C code, one can modify
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
by hand, by explicitly writing ‚ÄπT2‚Ä∫ at the specific position of the rule code
generating ‚ÄπT1‚Ä∫. However, this solution implies to re-generate
üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫.

‚ñ™ ‚àó‚ÄπAt grammar loading time, while the source of Isabelle/C is still being
processed.‚Ä∫ Instead of modifying the grammar, it should be possible to first locate which
rule code is building ‚ÄπT1‚Ä∫. Then it would remain to retrieve and modify the respective
function of \&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap‚Ä∫ executed after that rule code, by
providing a replacement function to be put in
\&lt;^ML_structure&gt;‚ÄπC_Grammar_Rule_Wrap_Overloading‚Ä∫. However, as a design decision,
wrapping functions generated in üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫ have only
been generated to affect monadic states, not AST values. This is to prevent an erroneous replacement
of an end-user while parsing C code. (It is currently left open about whether this feature will be
implemented in future versions of the parser...)

‚ñ™ ‚àó‚ÄπAt directive setup time, before executing any
‚¨ö‚ÄπC‚Ä∫ command of interest.‚Ä∫ Since the behavior of directives can be
dynamically modified, this solution amounts to change the semantics of any wished directive,
appearing enough earlier in the code. (But for the overall code be in the end mostly compatible with
any other C preprocessors, the implementation change has to be somehow at least consistent with how
a preprocessor is already expected to treat an initial C un(pre)processed code.) For example, the
current semantics of \&lt;^C&gt;‚Äπ#undef _‚Ä∫ depends on what has been registered in
\&lt;^ML&gt;‚ÄπC_Context.directive_update‚Ä∫ (see \&lt;^theory&gt;‚ÄπIsabelle_C.C_Command‚Ä∫).

‚ñ™ ‚àó‚ÄπAfter parsing and obtaining a constructive value.‚Ä∫ Another solution
consists in directly writing a mapping function acting on the full AST, so writing a ML function of
type \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit -&gt; C_Ast.CTranslUnit‚Ä∫ (or a respective HOL function)
which has to act on every constructor of the AST (so in the worst case about hundred of constructors
for the considered AST, i.e., whenever a node has to be not identically returned). However, as we
have already implemented a conversion function from \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫
(subset of C11) to a subset AST of C99, it might be useful to save some effort by starting from this
conversion function, locate where ‚ÄπT1‚Ä∫ is pattern-matched by the conversion function,
and generate ‚ÄπT2‚Ä∫ instead.

As example, the conversion function \&lt;^ML&gt;‚ÄπC_Ast.main‚Ä∫ is particularly used to connect
the C11 front-end to the entry-point of AutoCorres in
‚ñ©‚Äπl4v/src/tools/c-parser/StrictCParser.ML‚Ä∫.

‚ñ™ ‚àó‚ÄπAt semantic back-ends execution time.‚Ä∫ The above points were dealing
with the cases where modification actions were all occurring before getting a final
\&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ value. But this does not mean it is forbidden to make
some slight adjustments once that resulting \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ value
obtained. In particular, it is the tasks of semantic back-ends to precisely work with
\&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ as starting point, and possibly translate it to another
different type. So letting a semantic back-end implement the mapping from ‚ÄπT1‚Ä∫ to
‚ÄπT2‚Ä∫ would mean here to first understand the back-end of interest's architecture, to
see where the necessary minimal modifications must be made.

By taking l4v as a back-end example, its integration with Isabelle/C first starts with translating
\&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ to l4v's default C99 AST. Then various analyses on the
obtained AST are performed in
üåê‚Äπhttps://github.com/seL4/l4v/tree/master/tools/c-parser‚Ä∫ (the reader interested
in the details can start by further exploring the ML files loaded by
üåê‚Äπhttps://github.com/seL4/l4v/blob/master/tools/c-parser/CTranslation.thy‚Ä∫). In
short, to implement the mapping from ‚ÄπT1‚Ä∫ to ‚ÄπT2‚Ä∫ in the back-end part,
one can either:
  ‚ñ™ modify the translation from \&lt;^ML_type&gt;‚ÄπC_Ast.CTranslUnit‚Ä∫ to C99,
  ‚ñ™ or modify the necessary ML files of interests in the l4v project.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ More generally, to better inspect the list of rule code really executed when a C code
is parsed, it might be helpful to proceed as in \&lt;^theory&gt;‚ÄπIsabelle_C.C1‚Ä∫, by activating
‚¨ö‚Äπdeclare[[C_parser_trace]]‚Ä∫. Then, the output window will display the
sequence of Shift Reduce actions associated to the ‚¨ö‚ÄπC‚Ä∫ command of
interest.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπKnown Limitations, Troubleshooting‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe Document Model of the Isabelle/PIDE (applying for Isabelle 2019)‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIntroduction‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Embedding C directives in C code is an act of common practice in numerous applications,
as well as largely highlighted in the C standard. As an example of frequently encountered
directives, ‚Äπ#include &lt;some_file.c&gt;‚Ä∫ is used to insert the content of
‚Äπsome_file.c‚Ä∫ at the place where it is written. In Isabelle/C, we can also write a C
code containing directives like ‚Äπ#include‚Ä∫, and generally the PIDE reporting of
directives is supported to a certain extent. Yet, the dynamic inclusion of arbitrary file with
‚Äπ#include‚Ä∫ is hurting a certain technological barrier. This is related to how the
document model of Isabelle 2019 is functioning, but also to the design decisions behind the
implementation of ‚¨ö‚ÄπC‚Äπ .. ‚Ä∫‚Ä∫. Thus, providing a complete
semantic implementation of ‚Äπ#include‚Ä∫ might be not as evident as usual, if not more
dangerous, i.e. ``something requiring a manual intervention in the source of Isabelle 2019''. In the
next part, we show why in our current implementation of Isabelle/C there is no way for user
programmed extensions to exploit implicit dependencies between sub-documents in pure ML: a
sub-document referred to via ‚Äπ#include &lt;some_file&gt;‚Ä∫ will not lead to a reevaluation of
a ‚¨ö‚ÄπC‚Äπ .. ‚Ä∫‚Ä∫ command whenever modified.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπEmbedding a language in Isabelle/PIDE‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
To clarify why the way a language being embedded in Isabelle is influencing the interaction between
a future parser of the language with the Isabelle's document model, we recall the two ``different''
ways of embedding a language in Isabelle/PIDE.

At its most basic form, the general syntactic scope of an Isabelle/Isar document can be seen as
being composed of two syntactic alternations of editing space: fragments of the inner syntax
language, themselves part of the more general outer syntax (the inner syntax is implemented as an
atomic entity of the outer language); see
üóè‚Äπ~~/src/Doc/Isar_Ref/Outer_Syntax.thy‚Ä∫. So strictly speaking, when attempting
to support a new language ‚ÄπL‚Ä∫ in Isabelle, there is always the question of fine-grain
estimating which subsets of ‚ÄπL‚Ä∫ will be represented in the outer syntax part, and if it
possibly remains any left subsets to be represented on the more inner (syntactic) part.

Generally, to answer this question, there are several criteria to consider:
  ‚ñ™ Are there any escaping symbols conflicting between ‚ÄπL‚Ä∫ and the outer
  (syntax) language, including for example the ASCII ‚ñ©‚Äπ"‚Ä∫ or
  ‚ñ©‚Äπ`‚Ä∫?
  ‚ñ™ Is ‚ÄπL‚Ä∫ a realistic language, i.e. more complex than any combinations of
  outer named tokens that can be ever covered in terms of expressivity power (where the list of
  outer named tokens is provided in üóè‚Äπ~~/src/Doc/Isar_Ref/Outer_Syntax.thy‚Ä∫)?
  ‚ñ™ Is it preferable of not altering the outer syntax language with too specific and
  challenging features of ‚ÄπL‚Ä∫? This is particularly true since in Isabelle 2019, there
  is no way of modifying the outer syntax without making the modifications irremediably happen on
  its source code.

For the above reasons, we have come up in Isabelle/C with the choice of making the full C language
be supported inside the inner syntax allocated space. In particular, this has become all the more
syntactically easy with the introduction of cartouches since Isabelle
2014.‚Åã‚ÄπFortunately, parsing tokens of C do not strongly conflict with cartouche
delimiter symbols. For example, it should not be ethically wrong in C to write an opening cartouche
symbol (possibly in a C comment) without writing any closing cartouche symbol afterwards. However,
we have not encountered such C code in our tested codebase, and it is a functionality implicitly
rejected by the current parser of Isabelle/C, as it is relying on Isabelle 2019's parser combinator
library for the lexing part.‚Ä∫ However, for the case of the C language, certain C directives
like ‚Äπ#include‚Ä∫ are meant to heavily interact with external files. In particular,
resources would be best utilized if we were taking advantage of the Isabelle's asynchronous document
model for such interaction task. Unfortunately, the inner syntax space only has a minimum
interaction with the document model, compared to the outer syntax one. Otherwise said, be it for
experimenting the inner syntax layer and see how far it can deal with the document layer, or
otherwise reimplementing parts of Isabelle/C in the outer syntax layer, the two solutions are
conducting to do modifications in the Isabelle 2019 source code. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Note that the language embedding space of ‚¨ö‚ÄπC‚Ä∫ closely
resembles to how ML sources are delimited within a ‚¨ö‚ÄπML‚Ä∫
command. Additionally, in ML, one can use antiquotations to also refer to external files
(particularly in formal comments). Still, the problem is still present in ML: referred files are not
loaded in the document model. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExamples‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  ‚ñ™ Commands declared as of type ‚Äπthy_decl‚Ä∫ in the theory header are scheduled
  to be executed once. Additionally, they are not tracking the content of file names provided in
  argument, so a change there will not trigger a reevaluation of the associated command. For
  example, even if the type of ‚¨ö‚ÄπML_file‚Ä∫ is not ‚Äπthy_decl‚Ä∫,
  nothing prevents one to set it with ‚Äπthy_decl‚Ä∫ as type. In particular, by doing so,
  it is no more possible to CTRL-hover-click on the file name written after
  ‚¨ö‚ÄπML_file‚Ä∫.
  ‚ñ™ To make a command ‚ÄπC‚Ä∫ track the content of ‚Äπfile‚Ä∫, whenever the
  file is changing, setting ‚ÄπC‚Ä∫ to be of type ‚Äπthy_load‚Ä∫ in the theory
  header is a first step, but not enough. To be effective, ‚Äπfile‚Ä∫ must also be loaded,
  by either explicitly opening it, or clicking on its name after the command. Examples of commands
  in this situation requiring a preliminary one-time-click include:
  ‚¨ö‚Äπexternal_file‚Ä∫, ‚¨ö‚Äπbibtex_file‚Ä∫,
  ‚¨ö‚ÄπML_file‚Ä∫.
  Internally, the click is bound to a Scala code invoking a request to make an asynchronous
  dependency to the newly opened document at ML side.
  ‚ñ™ In terms of recursivity, for the case of a chain of sub-documents of the form
  (a theory file containing: ‚¨ö‚ÄπC_file ‚Äπfile0.c‚Ä∫‚Ä∫)
  ‚Äπ‚üπ‚Ä∫
  (C file ‚ñ©‚Äπfile0.c‚Ä∫ containing: \&lt;^C&gt;‚Äπ#include &lt;file1.c&gt;‚Ä∫)
  ‚Äπ‚üπ‚Ä∫
  (C file ‚ñ©‚Äπfile1.c‚Ä∫ containing: \&lt;^C&gt;‚Äπ#include &lt;file2.c&gt;‚Ä∫)
  ‚Äπ‚üπ‚Ä∫
  (C file ‚ñ©‚Äπfile2.c‚Ä∫ containing: \&lt;^C&gt;‚Äπ#include &lt;file3.c&gt;‚Ä∫), we
  ideally expect a modification in ‚ñ©‚Äπfile3.c‚Ä∫ be taken into account in all
  ancestor files including the initial theory, provoking the associated command of the theory be
  reevaluated. However in C, directives resolving might be close to Turing-complete. For instance,
  one can also include files based on particular conditional situations: \&lt;^C&gt;‚Äπ#if _
    #include &lt;file1&gt;
  #else
    #include &lt;file2&gt;
    #include &lt;file3&gt;
  #endif‚Ä∫
  ‚ñ™ When a theory is depending on other theories (such as
  \&lt;^theory&gt;‚ÄπIsabelle_C.C_Eval‚Ä∫ depending on
  \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Language‚Ä∫ and
  \&lt;^theory&gt;‚ÄπIsabelle_C.C_Parser_Annotation‚Ä∫), modifying the list of theories in
  importation automatically triggers what the user is expecting: for example, the newly added
  theories are dynamically imported, any change by another external editor makes everything
  consequently propagated.

  Following the internal implementation of the document model engine, we basically distinguish two
  phases of document importation: either at start-up time, or dynamically on user requests. Although
  the case of start-up time can be handled in pure ML side, the language dedicated to express which
  Isabelle theory files to import is less powerful than the close-to-Turing-completeness
  expressivity of C directives. On the other hand, the dynamic importation of files on user requests
  seems to be performed (at the time of writing) through a too high level ML protocol, mostly called
  from Scala side. Due to the fact that Isabelle/C is currently implemented in pure ML, a solution
  also in pure ML would thus sound more natural (although we are not excluding solutions interacting
  with Scala, as long as the resulting can be implemented in Isabelle, preferably outside of its own
  source).‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπParsing Error versus Parsing Correctness‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ When trying to decide if the next parsing action is a Shift or Reduce action to
perform, the grammar simulator \&lt;^ML&gt;‚ÄπLALR_Parser_Eval.parse‚Ä∫ can actually decide to do
another action: ignore everything and immediately stop the simulation.

If the parser ever decides to stop, this can only be for two reasons:
‚ñ™ The parser is supposed to have correctly finished its parsing task, making it be in an
acceptance state. As acceptance states are encoded in the grammar, it is easy to find if this
information is correct, or if it has to be adjusted in more detail by inspecting
üåê‚Äπhttps://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y‚Ä∫
(üóè‚Äπgenerated/c_grammar_fun.grm.sml‚Ä∫).
‚ñ™ The parser seems to be unable to correctly finish its parsing task. In this case, the user
will see an error be explicitly raised by the prover IDE. However raising an error is just the
default behavior of Isabelle/C: the decision to whether raise interruptive errors ultimately depends
on how front-end commands are implemented (such as ‚¨ö‚ÄπC‚Ä∫,
‚¨ö‚ÄπC_file‚Ä∫, etc.). For instance, similarly as to how outer syntax commands
are implemented, we can imagine a tool implementing a kind of partial parsing, analyzing the longest
sequence of well-formed input, and discarding some strategic next set of faulty tokens with a well
suited informative message, so that the parsing process could be maximally repeated on what is
coming afterwards.

Currently, the default behavior of Isabelle/C is to raise the error defined in
\&lt;^ML&gt;‚ÄπC_Module.err‚Ä∫ at the very first opportunity ‚Åã‚ÄπAt the time of
writing it is: ‚àó‚ÄπNo matching grammar rule‚Ä∫.‚Ä∫. The possible solutions to
make the error disappear at the position the error is indicated can be detailed as follows:
  ‚ñ™ Modifying the C code in input would be a first solution whenever we suspect something is
  making it erroneous (and when we have a reason to believe that the grammar is behaving as it
  should).

  ‚ñ™ However, we could still get the above error in front of an input where one is usually
  expecting to see not causing a failure. In particular, there are several C features (such as C
  directives) explicitly left for semantic back-ends (pre-) processing, so in general not fully
  semantically processed at parsing time.

  For example, whereas the code \&lt;^C&gt;‚Äπ#define i int
  i a;‚Ä∫ succeeds, replacing its first line with the directive
  \&lt;^C&gt;‚Äπ#include &lt;file.c&gt;‚Ä∫ will not initially work, even if ‚Äπfile.c‚Ä∫
  contains \&lt;^C&gt;‚Äπ#define i int‚Ä∫, as the former directive has been left for semantic
  back-end treatment. One way of solving this would be to modify the C code in input for it to be
  already preprocessed (without directives, for example the C example of
  üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/TestSEL4.thy‚Ä∫ is already provided as
  preprocessed). Another way would be adding a specific new semantic back-end implementing the
  automation of the preprocessing task (as done in
  üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_TEC.thy‚Ä∫, where the
  back-end explicitly makes a call to ‚Äπcpp‚Ä∫ at run-time).

  ‚ñ™ Ultimately, modifying the grammar with new rules cancelling the exception would only work
  if the problem really relies on the grammar, as it was mentioned for the acceptance state.
  ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ In terms of parsing correctness, Isabelle/C provides at least two different parsers:
‚ñ™ a parser limited to C99/C11 code provided in üóÄ‚Äπ../C11-FrontEnd‚Ä∫ that can
parse certain liberal extensions out of the C
standard~‚Åã‚Äπüåê‚Äπhttp://hackage.haskell.org/package/language-c‚Ä∫‚Ä∫;
‚ñ™ and another parser accepting C99/C11/C18 code in üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/tree/C/C18-FrontEnd‚Ä∫ that
is close to the C standard while focusing on resolving ambiguities of the
standard~‚Åã‚Äπüåê‚Äπhttps://github.com/jhjourdan/C11parser‚Ä∫‚Ä∫~\cite{DBLP:journals/toplas/JourdanP17}. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Note that the two parsers are not accepting/rejecting the same range of arbitrary C
code. We have actually already encountered situations where an error is raised by one parser, while
a success is happening with the other parser (and vice-versa). Consequently, in front of a C code,
it can be a good recommendation to try out the parsing with all possible parsers of Isabelle/C. In
any cases, a failure in one or several activated parsers might not be necessarily harmful: it might
also indicate that a wrong parser has been selected, or a semantic back-end not yet supporting
aspects of the C code being parsed. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExporting C Files to the File-System‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ From the Isabelle/C side, the task is easy, just type:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">C_export_file</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ ... which does the trick and generates a file
‚ñ©‚ÄπC_Appendices.c‚Ä∫. But hold on --- where is it? Well, Isabelle/C uses since
version Isabelle2019 a virtual file-system. Exporting from it to the real file-system requires a few
mouse-clicks (unfortunately).

So activating the command ‚¨ö‚ÄπC_export_file‚Ä∫ leads to the output
‚ñ©‚ÄπSee theory exports "C/*/C_Appendices.c"‚Ä∫ (see
\autoref{fig:file-bro}), and clicking on the highlighted
‚ñ©‚Äπtheory exports‚Ä∫ lets Isabelle display a part of the virtual file-system
(see subwidget left). Activating it in the subwidget lets jEdit open it as an editable file, which
can be exported via ``‚ÄπFile ‚Üí Save As‚Ä¶‚Ä∫'' into the real
file-system. ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="README">
<div class="head"><h1>Theory README</h1>
<span class="command">theory</span> <span class="name">README</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Isabelle/C
 *
 * Copyright (c) 2018-2019 Universit√© Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Authors: Fr√©d√©ric Tuong, Burkhart Wolff *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>README</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIsabelle/C‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
Isabelle/C contains a C99/C11/C18 front-end support for Isabelle. The front-end is actually composed
of two possibly interchangeable parsers (from two different projects):

‚ñ™ üóÄ‚ÄπC11-FrontEnd‚Ä∫: üåê‚Äπhttps://hackage.haskell.org/package/language-c‚Ä∫
‚ñ™ üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/tree/C/C18-FrontEnd‚Ä∫:
  üåê‚Äπhttps://github.com/jhjourdan/C11parser‚Ä∫

At present, the recommended and default version is C11.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGetting started‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ A first installation step is:
‚ñ™ ‚ñ©‚Äπisabelle build -D‚Ä∫ üóÄ‚Äπ.‚Ä∫
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ which should work out of the box.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The following C examples or entry-points of documentation can be executed:

‚ñ™ ‚ñ©‚Äπisabelle jedit -d‚Ä∫ üóÄ‚Äπ.‚Ä∫ üóè‚ÄπC11-FrontEnd/examples/C0.thy‚Ä∫
‚ñ™ ‚ñ©‚Äπisabelle jedit -d‚Ä∫ üóÄ‚Äπ.‚Ä∫ üóè‚ÄπC11-FrontEnd/examples/C2.thy‚Ä∫
‚ñ™ ‚ñ©‚Äπisabelle jedit -d‚Ä∫ üóÄ‚Äπ.‚Ä∫ üóè‚ÄπC11-FrontEnd/examples/C1.thy‚Ä∫
‚ñ™ ‚ñ©‚Äπisabelle jedit -d‚Ä∫ üóÄ‚Äπ.‚Ä∫ üóè‚ÄπC11-FrontEnd/C_Appendices.thy‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚ñ™ The example üóè‚ÄπC11-FrontEnd/examples/C0.thy‚Ä∫ is basically used to
demonstrate the faithfulness of the C11 parser implementation.
‚ñ™ The example üóè‚ÄπC11-FrontEnd/examples/C2.thy‚Ä∫ shows common cases of C and
C editing support in PIDE; it also contains annotation commands without any semantics.
‚ñ™ The example üóè‚ÄπC11-FrontEnd/examples/C1.thy‚Ä∫ is a show-case for markup
generation and the use of bindings resulting from the static C environment.
‚ñ™ The example üóè‚ÄπC11-FrontEnd/C_Appendices.thy‚Ä∫ shows the use of
Isabelle/C documentation facilities.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
The AFP version of Isabelle/C does not include semantic back-ends (these are distributed by other
AFP submissions or available via the web; see below). The structure of üóÄ‚Äπ.‚Ä∫ has
been designed to create a directory ‚ÄπC11-BackEnds‚Ä∫ into which back-ends can be
installed. The structure of üóÄ‚Äπ.‚Ä∫ is actually similar as
üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c‚Ä∫: see for example
üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/tree/C/C11-BackEnds‚Ä∫ where several
back-ends can be copied and tried.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIsabelle/C/README‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
üóè‚ÄπREADME.md‚Ä∫ is automatically generated from üóè‚ÄπREADME.thy‚Ä∫
using üåê‚Äπhttps://gitlri.lri.fr/ftuong/isabelle_c/blob/C/README.sh‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Note that this shell-script requires the prior installation of
‚ñ©‚Äπpandoc‚Ä∫ (üåê‚Äπhttps://github.com/jgm/pandoc‚Ä∫).
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAuthors‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
‚ñ™ Fr√©d√©ric Tuong (üåê‚Äπhttps://www.lri.fr/~ftuong‚Ä∫)
‚ñ™ Burkhart Wolff (üåê‚Äπhttps://www.lri.fr/~wolff‚Ä∫)
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLicense‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
Isabelle/C is licensed under a 3-clause BSD-style license (where certain files are in the HPND
license compatible with the 3-clause BSD).

In more details:
‚ñ™ The generated files üóè‚ÄπC11-FrontEnd/generated/c_ast.ML‚Ä∫ and
  üóè‚ÄπC11-FrontEnd/generated/c_grammar_fun.grm‚Ä∫ are mixing several source code of
    different projects:
  ‚ñ™ In 3-clause BSD: the part representing the Haskell Language.C library.  
  ‚ñ™ In 2-clause BSD: the C99 AST in HOL (before reflection to SML) adapted from the original
    one in the L4.verified project.
  ‚ñ™ In 3-clause BSD: the HOL translation C11 to C99 from the Securify project.    
  ‚ñ™ In 3-clause BSD: any other binding and translations of meta-models from the Citadelle
    project.
‚ñ™ In 3-clause BSD: the two combined generators generating
  üóè‚ÄπC11-FrontEnd/generated/c_ast.ML‚Ä∫ based on some modified version of Haskabelle
  and Citadelle.
‚ñ™ In 3-clause BSD: the Happy modified generator generating
  üóè‚ÄπC11-FrontEnd/generated/c_grammar_fun.grm‚Ä∫
‚ñ™ In HPND: the ML-Yacc modified generator generating the two
  üóè‚ÄπC11-FrontEnd/generated/c_grammar_fun.grm.sig‚Ä∫ and
  üóè‚ÄπC11-FrontEnd/generated/c_grammar_fun.grm.sml‚Ä∫ (i.e., the ML-Yacc version of
  MLton).
‚ñ™ In HPND: the modified grammar library of ML-Yacc loaded in
  üóè‚ÄπC11-FrontEnd/src/C_Parser_Language.thy‚Ä∫.
‚ñ™ In 3-clause BSD: the remaining files in üóÄ‚ÄπC11-FrontEnd/src‚Ä∫ constituting
  Isabelle/C core implementation.
‚ñ™ Most examples in üóÄ‚ÄπC11-FrontEnd/examples‚Ä∫ are in 3-clause BSD, some are
  used for quotation purposes to test the Isabelle/C lexer (hyperlinks around each example detail
  their provenance).
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>