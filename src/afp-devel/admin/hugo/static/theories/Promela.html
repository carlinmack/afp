<div id="PromelaStatistics">
<div class="head">
<h1>Theory PromelaStatistics</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> PromelaStatistics
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../CAVA_Base/CAVA_Base.html">CAVA_Base.CAVA_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> PromelaStatistics <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‹
    structure PromelaStatistics = struct
      val active = Unsynchronized.ref false
      val parseTime = Unsynchronized.ref Time.zeroTime
      val time = Unsynchronized.ref Time.zeroTime

      fun is_active () = !active

      fun start () = (
            active := true; 
            if !parseTime = Time.zeroTime then () else parseTime := Time.- (Time.now (), !parseTime);
            time := Time.now ())
      fun start_parse () = (active := true; parseTime := Time.now())
      fun stop_timer () = (time := Time.- (Time.now (), !time))

      fun to_string () = let
        val t = Time.toMilliseconds (!time)
        val pt = Time.toMilliseconds (!parseTime)
      in
        (if pt = 0 then "" else 
        "Parsing time : " ^ IntInf.toString pt ^ "ms\n")
      ^ "Building time: " ^ IntInf.toString t ^ "ms\n"
      end
        
      val _ = Statistics.register_stat ("Promela",is_active,to_string)
    end
›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML PromelaStatistics

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hd</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">consts</span></span> 
  start <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> unit"</span></span>
  start_parse <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> unit"</span></span>
  stop_timer <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> unit"</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">start</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaStatistics.start"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">start_parse</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaStatistics.start'_parse"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stop_timer</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaStatistics.stop'_timer"</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> start start_parse stop_timer

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PromelaAST">
<div class="head">
<h1>Theory PromelaAST</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Abstract Syntax Tree"</span></span>
<span class="keyword1"><span class="command">theory</span></span> PromelaAST
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The abstract syntax tree is generated from the handwritten SML parser. 
  This theory only mirrors the data structures from the SML level to make them available in 
  Isabelle.
›</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Force everything in this context to start with AST. *)</span>
<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹
  Local_Theory.map_background_naming <span class="main">(</span>Name_Space.mandatory_path <span class="inner_quoted">"AST"</span><span class="main">)</span>
›</span> 

<span class="keyword1"><span class="command">datatype</span></span> binOp <span class="main">=</span> 
                 BinOpAdd
               <span class="main">|</span> BinOpSub
               <span class="main">|</span> BinOpMul
               <span class="main">|</span> BinOpDiv
               <span class="main">|</span> BinOpMod
               <span class="main">|</span> BinOpBitAnd
               <span class="main">|</span> BinOpBitXor
               <span class="main">|</span> BinOpBitOr 
               <span class="main">|</span> BinOpGr
               <span class="main">|</span> BinOpLe
               <span class="main">|</span> BinOpGEq
               <span class="main">|</span> BinOpLEq
               <span class="main">|</span> BinOpEq
               <span class="main">|</span> BinOpNEq
               <span class="main">|</span> BinOpShiftL
               <span class="main">|</span> BinOpShiftR
               <span class="main">|</span> BinOpAnd
               <span class="main">|</span> BinOpOr

<span class="keyword1"><span class="command">datatype</span></span> unOp <span class="main">=</span> 
                UnOpComp
              <span class="main">|</span> UnOpMinus
              <span class="main">|</span> UnOpNeg

<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> 
                ExprBinOp <span class="quoted">binOp</span> <span class="comment1">(*left*)</span> <span class="quoted">expr</span> <span class="comment1">(*right*)</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprUnOp <span class="quoted">unOp</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprCond <span class="comment1">(*cond*)</span> <span class="quoted">expr</span> <span class="comment1">(*exprTrue*)</span> <span class="quoted">expr</span> <span class="comment1">(*exprFalse*)</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprLen <span class="quoted">varRef</span>
              <span class="main">|</span> ExprPoll <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
              <span class="main">|</span> ExprRndPoll <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
              <span class="main">|</span> ExprVarRef <span class="quoted">varRef</span>
              <span class="main">|</span> ExprConst <span class="quoted">integer</span>
              <span class="main">|</span> ExprTimeOut
              <span class="main">|</span> ExprNP
              <span class="main">|</span> ExprEnabled <span class="quoted">expr</span>
              <span class="main">|</span> ExprPC <span class="quoted">expr</span>
              <span class="main">|</span> ExprRemoteRef <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                              <span class="comment1">(*num*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                              <span class="comment1">(*label*)</span> <span class="quoted">String.literal</span>
              <span class="main">|</span> ExprGetPrio <span class="quoted">expr</span>
              <span class="main">|</span> ExprSetPrio <span class="comment1">(*expr*)</span> <span class="quoted">expr</span> <span class="comment1">(*prio*)</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprFull <span class="quoted">varRef</span>
              <span class="main">|</span> ExprEmpty <span class="quoted">varRef</span>
              <span class="main">|</span> ExprNFull <span class="quoted">varRef</span>
              <span class="main">|</span> ExprNEmpty <span class="quoted">varRef</span>

   <span class="keyword2"><span class="keyword">and</span></span> varRef <span class="main">=</span> VarRef <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span> 
                       <span class="comment1">(*index*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                       <span class="comment1">(*next*)</span> <span class="quoted"><span class="quoted">"varRef option"</span></span>

   <span class="keyword2"><span class="keyword">and</span></span> recvArg <span class="main">=</span> RecvArgVar <span class="quoted">varRef</span>
               <span class="main">|</span> RecvArgEval <span class="quoted">expr</span>
               <span class="main">|</span> RecvArgConst <span class="quoted">integer</span>

<span class="keyword1"><span class="command">datatype</span></span> range <span class="main">=</span> 
                RangeFromTo <span class="comment1">(*var*)</span> <span class="quoted">varRef</span>
                            <span class="comment1">(*from*)</span> <span class="quoted">expr</span>
                             <span class="comment1">(*to*)</span>  <span class="quoted">expr</span>
               <span class="main">|</span> RangeIn <span class="comment1">(*var*)</span> <span class="quoted">varRef</span> <span class="comment1">(*inside*)</span> <span class="quoted">varRef</span>

<span class="keyword1"><span class="command">datatype</span></span> varType <span class="main">=</span> 
                   VarTypeBit
                 <span class="main">|</span> VarTypeBool
                 <span class="main">|</span> VarTypeByte
                 <span class="main">|</span> VarTypePid
                 <span class="main">|</span> VarTypeShort
                 <span class="main">|</span> VarTypeInt
                 <span class="main">|</span> VarTypeMType
                 <span class="main">|</span> VarTypeChan
                 <span class="main">|</span> VarTypeUnsigned
                 <span class="main">|</span> VarTypeCustom <span class="quoted">String.literal</span>

<span class="keyword1"><span class="command">datatype</span></span> varDecl <span class="main">=</span> 
                   VarDeclNum  <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                               <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                               <span class="comment1">(*init*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                 <span class="main">|</span> VarDeclChan <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                               <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                               <span class="comment1">(*capacityTypes*)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">*</span> varType list<span class="main">)</span> option"</span></span>
                 <span class="main">|</span> VarDeclUnsigned <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                                   <span class="comment1">(*bits*)</span> <span class="quoted">integer</span>
                                   <span class="comment1">(*init*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                 <span class="main">|</span> VarDeclMType <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                                <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                                <span class="comment1">(*init*)</span> <span class="quoted"><span class="quoted">"String.literal option"</span></span>


<span class="keyword1"><span class="command">datatype</span></span> decl <span class="main">=</span> 
                 Decl <span class="comment1">(*vis*)</span> <span class="quoted"><span class="quoted">"bool option"</span></span>
                     <span class="comment1">(*sort*)</span> <span class="quoted">varType</span>
                     <span class="comment1">(*decl*)</span> <span class="quoted"><span class="quoted">"varDecl list"</span></span>


<span class="keyword1"><span class="command">datatype</span></span> stmnt <span class="main">=</span> 
                 StmntIf <span class="quoted"><span class="quoted">"<span class="main">(</span>step list<span class="main">)</span> list"</span></span>
               <span class="main">|</span> StmntDo <span class="quoted"><span class="quoted">"<span class="main">(</span>step list<span class="main">)</span> list"</span></span>
               <span class="main">|</span> StmntFor <span class="quoted">range</span> <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntAtomic <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntDStep <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntSelect <span class="quoted">range</span>
               <span class="main">|</span> StmntSeq <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntSend <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
               <span class="main">|</span> StmntSortSend <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
               <span class="main">|</span> StmntRecv <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
               <span class="main">|</span> StmntRndRecv <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
               <span class="main">|</span> StmntRecvX <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
               <span class="main">|</span> StmntRndRecvX <span class="quoted">varRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span>
               <span class="main">|</span> StmntAssign <span class="quoted">varRef</span> <span class="quoted">expr</span>
               <span class="main">|</span> StmntIncr <span class="quoted">varRef</span>
               <span class="main">|</span> StmntDecr <span class="quoted">varRef</span>
               <span class="main">|</span> StmntElse
               <span class="main">|</span> StmntBreak
               <span class="main">|</span> StmntGoTo <span class="quoted">String.literal</span>
               <span class="main">|</span> StmntLabeled <span class="quoted">String.literal</span> <span class="quoted">stmnt</span>
               <span class="main">|</span> StmntPrintF <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
               <span class="main">|</span> StmntPrintM <span class="quoted">String.literal</span>
               <span class="main">|</span> StmntRun <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                          <span class="comment1">(*args*)</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
                          <span class="comment1">(*prio*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
               <span class="main">|</span> StmntAssert <span class="quoted">expr</span>
               <span class="main">|</span> StmntCond <span class="quoted">expr</span>
               <span class="main">|</span> StmntCall <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"varRef list"</span></span>
        
  <span class="keyword2"><span class="keyword">and</span></span> step <span class="main">=</span> StepStmnt <span class="quoted">stmnt</span> <span class="comment1">(*unless*)</span> <span class="quoted"><span class="quoted">"stmnt option"</span></span>
           <span class="main">|</span> StepDecl <span class="quoted">decl</span>
           <span class="main">|</span> StepXR <span class="quoted"><span class="quoted">"varRef list"</span></span>
           <span class="main">|</span> StepXS <span class="quoted"><span class="quoted">"varRef list"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> module <span class="main">=</span> 
                  ProcType <span class="comment1">(*active*)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer option<span class="main">)</span> option"</span></span>
                           <span class="comment1">(*name*)</span>   <span class="quoted">String.literal</span>
                           <span class="comment1">(*decls*)</span>  <span class="quoted"><span class="quoted">"decl list"</span></span>
                           <span class="comment1">(*prio*)</span>   <span class="quoted"><span class="quoted">"integer option"</span></span>
                           <span class="comment1">(*prov*)</span>   <span class="quoted"><span class="quoted">"expr option"</span></span>
                           <span class="comment1">(*seq*)</span>    <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> DProcType <span class="comment1">(*active*)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer option<span class="main">)</span> option"</span></span>
                            <span class="comment1">(*name*)</span>   <span class="quoted">String.literal</span>
                            <span class="comment1">(*decls*)</span>  <span class="quoted"><span class="quoted">"decl list"</span></span>
                            <span class="comment1">(*prio*)</span>   <span class="quoted"><span class="quoted">"integer option"</span></span>
                            <span class="comment1">(*prov*)</span>   <span class="quoted"><span class="quoted">"expr option"</span></span>
                            <span class="comment1">(*seq*)</span>    <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> Init <span class="comment1">(*prio*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span> <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> Never <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> Trace <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> NoTrace <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> Inline <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"String.literal list"</span></span> <span class="quoted"><span class="quoted">"step list"</span></span>
                <span class="main">|</span> TypeDef <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"decl list"</span></span>
                <span class="main">|</span> MType <span class="quoted"><span class="quoted">"String.literal list"</span></span>
                <span class="main">|</span> ModuDecl <span class="quoted">decl</span>
                <span class="main">|</span> Ltl <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span> <span class="comment1">(*formula*)</span> <span class="quoted">String.literal</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PromelaDatastructures">
<div class="head">
<h1>Theory PromelaDatastructures</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Data structures as used in Promela"</span></span>
<span class="keyword1"><span class="command">theory</span></span> PromelaDatastructures
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CAVA_Base/CAVA_Base.html">CAVA_Base.CAVA_Base</a>
  <a href="../CAVA_Base/Lexord_List.html">CAVA_Base.Lexord_List</a>
  <a href="PromelaAST.html">PromelaAST</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
  <a href="../Deriving/Compare_Instances.html">Deriving.Compare_Instances</a>
  <a href="../CAVA_Base/CAVA_Code_Target.html">CAVA_Base.CAVA_Code_Target</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">no_notation</span></span> test_bit <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">!!</span>"</span> 100<span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Syntax Tree \emph{after} preprocessing›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  From the plain AST stemming from the parser, we'd like to have one containing more information while also removing duplicated constructs. This is achieved in the preprocessing step.

  The additional information contains:
  \begin{itemize}
    \item variable type (including whether it represents a channel or not)
    \item global vs local variable
  \end{itemize}

  Also certain constructs are expanded (like for-loops) or different nodes in the
  AST are collapsed into one parametrized node (e.g.\ the different send-operations).

  This preprocessing phase also tries to detect certain static errors and will bail out with an exception if such is encountered.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> binOp <span class="main">=</span> BinOpAdd
               <span class="main">|</span> BinOpSub
               <span class="main">|</span> BinOpMul
               <span class="main">|</span> BinOpDiv
               <span class="main">|</span> BinOpMod
               <span class="main">|</span> BinOpGr
               <span class="main">|</span> BinOpLe
               <span class="main">|</span> BinOpGEq
               <span class="main">|</span> BinOpLEq
               <span class="main">|</span> BinOpEq
               <span class="main">|</span> BinOpNEq
               <span class="main">|</span> BinOpAnd
               <span class="main">|</span> BinOpOr

<span class="keyword1"><span class="command">datatype</span></span> unOp <span class="main">=</span> UnOpMinus
              <span class="main">|</span> UnOpNeg

<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> ExprBinOp <span class="quoted">binOp</span> <span class="comment1">(*left*)</span> <span class="quoted">expr</span> <span class="comment1">(*right*)</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprUnOp <span class="quoted">unOp</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprCond <span class="comment1">(*cond*)</span> <span class="quoted">expr</span> <span class="comment1">(*exprTrue*)</span> <span class="quoted">expr</span> <span class="comment1">(*exprFalse*)</span> <span class="quoted">expr</span>
              <span class="main">|</span> ExprLen <span class="quoted">chanRef</span>
              <span class="main">|</span> ExprVarRef <span class="quoted">varRef</span>
              <span class="main">|</span> ExprConst <span class="quoted">integer</span>
              <span class="main">|</span> ExprMConst <span class="quoted">integer</span> <span class="quoted">String.literal</span> <span class="comment1">(* MType replaced by constant *)</span>
              <span class="main">|</span> ExprTimeOut
              <span class="main">|</span> ExprFull <span class="quoted">chanRef</span>
              <span class="main">|</span> ExprEmpty <span class="quoted">chanRef</span>
              <span class="main">|</span> ExprPoll <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span> <span class="quoted">bool</span> <span class="comment1">(* sorted *)</span>

   <span class="keyword2"><span class="keyword">and</span></span> varRef <span class="main">=</span> VarRef <span class="comment1">(*global*)</span> <span class="quoted">bool</span> 
                       <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span> 
                       <span class="comment1">(*index*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> chanRef <span class="main">=</span> ChanRef <span class="quoted">varRef</span> <span class="comment1">― ‹explicit type for channels›</span>
   <span class="keyword2"><span class="keyword">and</span></span> recvArg <span class="main">=</span> RecvArgVar <span class="quoted">varRef</span>
               <span class="main">|</span> RecvArgEval <span class="quoted">expr</span>
               <span class="main">|</span> RecvArgConst <span class="quoted">integer</span>
               <span class="main">|</span> RecvArgMConst <span class="quoted">integer</span> <span class="quoted">String.literal</span>

<span class="keyword1"><span class="command">datatype</span></span> varType <span class="main">=</span> VTBounded <span class="quoted">integer</span> <span class="quoted">integer</span>
                 <span class="main">|</span> VTChan

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variable declarations at the beginning of a proctype or at global level.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> varDecl <span class="main">=</span> VarDeclNum <span class="comment1">(*bounds*)</span> <span class="quoted">integer</span> <span class="quoted">integer</span>
                              <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                              <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                              <span class="comment1">(*init*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                 <span class="main">|</span> VarDeclChan <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                               <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                               <span class="comment1">(*capacityTypes*)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">*</span> varType list<span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variable declarations during a proctype.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> procVarDecl <span class="main">=</span> ProcVarDeclNum  <span class="comment1">(*bounds*)</span> <span class="quoted">integer</span> <span class="quoted">integer</span>
                                       <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                                       <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>
                                       <span class="comment1">(*init*)</span> <span class="quoted"><span class="quoted">"expr option"</span></span>
                     <span class="main">|</span> ProcVarDeclChan <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                                       <span class="comment1">(*size*)</span> <span class="quoted"><span class="quoted">"integer option"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> procArg <span class="main">=</span> ProcArg <span class="quoted">varType</span> <span class="quoted">String.literal</span>

<span class="keyword1"><span class="command">datatype</span></span> stmnt <span class="main">=</span> StmntIf <span class="quoted"><span class="quoted">"<span class="main">(</span>step list<span class="main">)</span> list"</span></span>
               <span class="main">|</span> StmntDo <span class="quoted"><span class="quoted">"<span class="main">(</span>step list<span class="main">)</span> list"</span></span>
               <span class="main">|</span> StmntAtomic <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntSeq <span class="quoted"><span class="quoted">"step list"</span></span>
               <span class="main">|</span> StmntSend <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"expr list"</span></span> <span class="quoted">bool</span> <span class="comment1">(*sorted*)</span>
               <span class="main">|</span> StmntRecv <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span> <span class="quoted">bool</span> <span class="comment1">(*sorted*)</span> <span class="quoted">bool</span> <span class="comment1">(*remove?*)</span>
               <span class="main">|</span> StmntAssign <span class="quoted">varRef</span> <span class="quoted">expr</span>
               <span class="main">|</span> StmntElse
               <span class="main">|</span> StmntBreak
               <span class="main">|</span> StmntSkip
               <span class="main">|</span> StmntGoTo <span class="quoted">String.literal</span>
               <span class="main">|</span> StmntLabeled <span class="quoted">String.literal</span> <span class="quoted">stmnt</span>
               <span class="main">|</span> StmntRun <span class="comment1">(*name*)</span> <span class="quoted">String.literal</span>
                          <span class="comment1">(*args*)</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
               <span class="main">|</span> StmntCond <span class="quoted">expr</span>
               <span class="main">|</span> StmntAssert <span class="quoted">expr</span>
        
  <span class="keyword2"><span class="keyword">and</span></span> step <span class="main">=</span> StepStmnt <span class="quoted">stmnt</span> <span class="comment1">(*unless*)</span> <span class="quoted"><span class="quoted">"stmnt option"</span></span>
           <span class="main">|</span> StepDecl <span class="quoted"><span class="quoted">"procVarDecl list"</span></span>
           <span class="main">|</span> StepSkip

<span class="keyword1"><span class="command">datatype</span></span> proc <span class="main">=</span> ProcType <span class="comment1">(*active*)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer option<span class="main">)</span> option"</span></span>
                           <span class="comment1">(*name*)</span>   <span class="quoted">String.literal</span>
                           <span class="comment1">(*args*)</span>  <span class="quoted"><span class="quoted">"procArg list"</span></span>
                           <span class="comment1">(*decls*)</span> <span class="quoted"><span class="quoted">"varDecl list"</span></span>
                           <span class="comment1">(*seq*)</span>    <span class="quoted"><span class="quoted">"step list"</span></span>
              <span class="main">|</span> Init <span class="quoted"><span class="quoted">"varDecl list"</span></span> <span class="quoted"><span class="quoted">"step list"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ltl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="comment1">― ‹name:›</span> String.literal <span class="main">×</span> <span class="comment1">― ‹formula:›</span> String.literal"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> promela <span class="main">=</span> <span class="quoted"><span class="quoted">"varDecl list <span class="main">×</span> proc list <span class="main">×</span> ltl list"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preprocess the AST of the parser into our variant›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We setup some functionality for printing warning or even errors.

All those constants are logically <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">undefined</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but replaced by the parser
for something meaningful.›</span></span>
<span class="keyword1"><span class="command">consts</span></span> 
  warn <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> unit"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">with_warn</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main"><span class="bound">_</span></span> <span class="main">=</span> warn <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_warn</span> <span class="free"><span class="bound"><span class="entity">opt</span></span></span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">opt</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">()</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> warn <span class="free"><span class="bound"><span class="entity">msg</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>usc›</span></span></span></span>: "Unsupported Construct"›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">usc</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">::</span> String.literal<span class="main">)</span> <span class="main">≡</span> undefined"</span></span>

<span class="keyword1"><span class="command">definition</span></span>  <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">err</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">::</span> String.literal<span class="main">)</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">errv</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> err <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">abort</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">::</span> String.literal<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">abortv</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> abort <span class="main">(</span><span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> PromelaUtils <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‹
    structure PromelaUtils = struct
      exception UnsupportedConstruct of string
      exception StaticError of string
      exception RuntimeError of string
      fun warn msg = TextIO.print ("Warning: " ^ msg ^ "\n")
      fun usc  c   = raise (UnsupportedConstruct c)
      fun err  e   = raise (StaticError e)
      fun abort msg _ = raise (RuntimeError msg)
    end›</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">warn</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaUtils.warn"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">usc</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaUtils.usc"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">err</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaUtils.err"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">abort</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"PromelaUtils.abort"</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML PromelaUtils


<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hd</span><span class="antiquote">}</span></span></span>›</span> <span class="comment1">(* Test code-printing setup. If this fails, the setup is skewed. *)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The preprocessing is done for each type on its own.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">ppBinOp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.binOp <span class="main">⇒</span> binOp"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpAdd <span class="main">=</span> BinOpAdd"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpSub <span class="main">=</span> BinOpSub"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpMul <span class="main">=</span> BinOpMul"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpDiv <span class="main">=</span> BinOpDiv"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpMod <span class="main">=</span> BinOpMod"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpGr <span class="main">=</span> BinOpGr"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpLe <span class="main">=</span> BinOpLe"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpGEq <span class="main">=</span> BinOpGEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpLEq <span class="main">=</span> BinOpLEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpEq <span class="main">=</span> BinOpEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpNEq <span class="main">=</span> BinOpNEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpAnd <span class="main">=</span> BinOpAnd"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpOr <span class="main">=</span> BinOpOr"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpBitAnd <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''BinOpBitAnd''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpBitXor <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''BinOpBitXor''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpBitOr <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''BinOpBitOr''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpShiftL <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''BinOpShiftL''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppBinOp</span> AST.BinOpShiftR <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''BinOpShiftR''</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">ppUnOp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.unOp <span class="main">⇒</span> unOp"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppUnOp</span> AST.UnOpMinus <span class="main">=</span> UnOpMinus"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppUnOp</span> AST.UnOpNeg <span class="main">=</span> UnOpNeg"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppUnOp</span> AST.UnOpComp <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''UnOpComp''</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The data structure holding all information on variables we found so far.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> var_data <span class="main">=</span> <span class="quoted"><span class="quoted">"
     <span class="main">(</span>String.literal<span class="main">,</span> <span class="main">(</span>integer option <span class="main">×</span> bool<span class="main">)</span><span class="main">)</span> lm <span class="comment1">― ‹channels›</span>
     <span class="main">×</span> <span class="main">(</span>String.literal<span class="main">,</span> <span class="main">(</span>integer option <span class="main">×</span> bool<span class="main">)</span><span class="main">)</span> lm <span class="comment1">― ‹variables›</span>
     <span class="main">×</span> <span class="main">(</span>String.literal<span class="main">,</span> integer<span class="main">)</span> lm <span class="comment1">― ‹mtypes›</span>
     <span class="main">×</span> <span class="main">(</span>String.literal<span class="main">,</span> varRef<span class="main">)</span> lm <span class="comment1">― ‹aliases (used for inlines)›</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dealWithVar</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> String.literal
      <span class="main">⇒</span> <span class="main">(</span>String.literal <span class="main">⇒</span> integer option <span class="main">×</span> bool <span class="main">⇒</span> expr option <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> 
      <span class="main">⇒</span> <span class="main">(</span>String.literal <span class="main">⇒</span> integer option <span class="main">×</span> bool <span class="main">⇒</span> expr option <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> 
      <span class="main">⇒</span> <span class="main">(</span>integer <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dealWithVar</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">fC</span></span></span> <span class="free"><span class="bound"><span class="entity">fV</span></span></span> <span class="free"><span class="bound"><span class="entity">fM</span></span></span> <span class="main">≡</span> <span class="main">(</span> 
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">idx</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="bound">a</span> <span class="keyword1">of</span> 
                     None <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">,</span> None<span class="main">)</span> 
                   <span class="main">|</span> Some <span class="main">(</span>VarRef <span class="main"><span class="bound">_</span></span> <span class="bound">name</span> <span class="bound">idx</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">name</span><span class="main">,</span> <span class="bound">idx</span><span class="main">)</span> 
    <span class="keyword1">in</span>
    <span class="keyword1">case</span> lm.lookup <span class="bound">n</span> <span class="bound">m</span> <span class="keyword1">of</span> 
      Some <span class="bound">i</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">idx</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">fM</span></span></span> <span class="bound">i</span> 
                           <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Array subscript used on MType (via alias).''</span><span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="bound">n</span> <span class="bound">v</span> <span class="keyword1">of</span>
               Some <span class="bound">g</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">fV</span></span></span> <span class="bound">n</span> <span class="bound">g</span> <span class="bound">idx</span>
             <span class="main">|</span> None <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="bound">n</span> <span class="bound">c</span> <span class="keyword1">of</span>
                   Some <span class="bound">g</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">fC</span></span></span> <span class="bound">n</span> <span class="bound">g</span> <span class="bound">idx</span>
                 <span class="main">|</span> None <span class="main">⇒</span> err <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Unknown variable referenced: ''</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">enforceChan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">+</span> chanRef <span class="main">⇒</span> chanRef"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">enforceChan</span> <span class="main">(</span>Inl <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Channel expected. Got normal variable.''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">enforceChan</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">liftChan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">+</span> chanRef <span class="main">⇒</span> varRef"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">liftChan</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">liftChan</span> <span class="main">(</span>Inr <span class="main">(</span>ChanRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">resolveIdx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr option <span class="main">⇒</span> expr option <span class="main">⇒</span> expr option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resolveIdx</span> None None <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">resolveIdx</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span>  None <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">resolveIdx</span> None <span class="free"><span class="bound"><span class="entity">aliasIdx</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">aliasIdx</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">resolveIdx</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>   <span class="main"><span class="bound"><span class="entity">_</span></span></span>     <span class="main">=</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Array subscript used twice (via alias).''</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ppExpr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> AST.expr <span class="main">⇒</span> expr"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">ppVarRef</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> AST.varRef <span class="main">⇒</span> varRef <span class="main">+</span> chanRef"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">ppRecvArg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> AST.recvArg <span class="main">⇒</span> recvArg"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.VarRef <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> None<span class="main">)</span> <span class="main">=</span> dealWithVar <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
                    <span class="main">(</span><span class="main">λ</span><span class="bound">name</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">g</span><span class="main">)</span> <span class="bound">aIdx</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">idx</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="keyword1">in</span> 
                         Inr <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="bound">g</span> <span class="bound">name</span> <span class="main">(</span>resolveIdx <span class="bound">idx</span> <span class="bound">aIdx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">(</span><span class="main">λ</span><span class="bound">name</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">g</span><span class="main">)</span> <span class="bound">aIdx</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">idx</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="keyword1">in</span> 
                         Inl <span class="main">(</span>VarRef <span class="bound">g</span> <span class="bound">name</span> <span class="main">(</span>resolveIdx <span class="bound">idx</span> <span class="bound">aIdx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Variable expected. Got MType.''</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.VarRef <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Some <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     usc <span class="keyword1">STR</span> <span class="inner_quoted">''next operation on variables''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> AST.ExprTimeOut <span class="main">=</span> ExprTimeOut"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprConst <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> ExprConst <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprBinOp <span class="free"><span class="bound"><span class="entity">bo</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprBinOp <span class="main">(</span>ppBinOp <span class="free"><span class="bound"><span class="entity">bo</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprUnOp <span class="free"><span class="bound"><span class="entity">uo</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprUnOp <span class="main">(</span>ppUnOp <span class="free"><span class="bound"><span class="entity">uo</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprCond <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprCond <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprLen <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprLen <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprFull <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprFull <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprEmpty <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprEmpty <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(* the following two are special constructs in Promela for helping Partial Order Reductions
   we don't have such things (yet), so use simple negation *)</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprNFull <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprUnOp UnOpNeg <span class="main">(</span>ExprFull <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprNEmpty <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprUnOp UnOpNeg <span class="main">(</span>ExprEmpty <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprVarRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
          <span class="keyword1">let</span> <span class="bound">to_exp</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> ExprVarRef <span class="main">(</span>liftChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">in</span>
          <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
              AST.VarRef <span class="bound">name</span> None None <span class="main">⇒</span> 
                 dealWithVar <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="bound">name</span> 
                     <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">to_exp</span><span class="main">()</span><span class="main">)</span>
                     <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">to_exp</span><span class="main">()</span><span class="main">)</span>
                     <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> ExprMConst <span class="bound">i</span> <span class="bound">name</span><span class="main">)</span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">to_exp</span><span class="main">()</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprPoll <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprPoll <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="free">ppRecvArg</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprRndPoll <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprPoll <span class="main">(</span>enforceChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="free">ppRecvArg</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> True"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> AST.ExprNP <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprNP''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprEnabled <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprEnabled''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprPC <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprPC''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprRemoteRef <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprRemoteRef''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprGetPrio <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprGetPrio''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.ExprSetPrio <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''ExprSetPrio''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppRecvArg</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.RecvArgVar <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
          <span class="keyword1">let</span> <span class="bound">to_ra</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RecvArgVar <span class="main">(</span>liftChan <span class="main">(</span><span class="free">ppVarRef</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">in</span>
          <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
              AST.VarRef <span class="bound">name</span> None None <span class="main">⇒</span> 
                 dealWithVar <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="bound">name</span> 
                     <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">to_ra</span><span class="main">()</span><span class="main">)</span>
                     <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">to_ra</span><span class="main">()</span><span class="main">)</span>
                     <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> RecvArgMConst <span class="bound">i</span> <span class="bound">name</span><span class="main">)</span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">to_ra</span><span class="main">()</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppRecvArg</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.RecvArgEval <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> RecvArgEval <span class="main">(</span><span class="free">ppExpr</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppRecvArg</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.RecvArgConst <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> RecvArgConst <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">ppVarType</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.varType <span class="main">⇒</span> varType"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeBit <span class="main">=</span> VTBounded <span class="main">0</span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeBool <span class="main">=</span> VTBounded <span class="main">0</span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeByte <span class="main">=</span> VTBounded <span class="main">0</span> <span class="numeral">255</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypePid <span class="main">=</span> VTBounded <span class="main">0</span> <span class="numeral">255</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeShort <span class="main">=</span> VTBounded <span class="main">(</span><span class="main">-</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">15</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">15</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeInt <span class="main">=</span> VTBounded <span class="main">(</span><span class="main">-</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">31</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">31</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeMType <span class="main">=</span> VTBounded <span class="main">1</span> <span class="numeral">255</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeChan <span class="main">=</span> VTChan"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> AST.VarTypeUnsigned <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''VarTypeUnsigned''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarType</span> <span class="main">(</span>AST.VarTypeCustom <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''VarTypeCustom''</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ppVarDecl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> varType <span class="main">⇒</span> bool <span class="main">⇒</span> AST.varDecl <span class="main">⇒</span> var_data <span class="main">×</span> varDecl"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclNum <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
        Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> 
               Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv
                         <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
               <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">sze</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> 
                        VarDeclNum <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> 
                          <span class="main">(</span>map_option <span class="main">(</span>ppExpr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>AST.VarDeclNum <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Assiging num to non-num''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> VTChan <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">cap'</span> <span class="main">=</span> map_option <span class="main">(</span>apsnd <span class="main">(</span>map ppVarType<span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">of</span> 
        Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> 
               Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv 
                         <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
              <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">sze</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> 
                     VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="bound">cap'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>AST.VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Assiging chan to non-chan''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclMType <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">init</span> <span class="main">=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">mty</span><span class="main">.</span> 
     <span class="keyword1">case</span> lm.lookup <span class="bound">mty</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Unknown MType ''</span> <span class="bound">mty</span>
      <span class="main">|</span> Some <span class="bound">mval</span> <span class="main">⇒</span> ExprMConst <span class="bound">mval</span> <span class="bound">mty</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="keyword1">in</span>
            <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">of</span> 
              Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span> 
                       <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">sze</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> 
                    VarDeclNum <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="bound">init</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>AST.VarDeclMType <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">sze</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Assiging num to non-num''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppVarDecl</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>AST.VarDeclUnsigned <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     usc <span class="keyword1">STR</span> <span class="inner_quoted">''VarDeclUnsigned''</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ppProcVarDecl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> varType <span class="main">⇒</span> bool <span class="main">⇒</span> AST.varDecl <span class="main">⇒</span> var_data <span class="main">×</span> procVarDecl"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppProcVarDecl</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">ty</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> ppVarDecl <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">ty</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
       <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span> VarDeclNum <span class="bound">l</span> <span class="bound">h</span> <span class="bound">name</span> <span class="bound">sze</span> <span class="bound">init</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span> ProcVarDeclNum <span class="bound">l</span> <span class="bound">h</span> <span class="bound">name</span> <span class="bound">sze</span> <span class="bound">init</span><span class="main">)</span>
     <span class="main">|</span> <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span> VarDeclChan <span class="bound">name</span> <span class="bound">sze</span> None<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span> ProcVarDeclChan <span class="bound">name</span> <span class="bound">sze</span><span class="main">)</span>
     <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Channel initilizations only allowed at the beginning of proctypes.''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ppProcArg</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> varType <span class="main">⇒</span> bool <span class="main">⇒</span> AST.varDecl <span class="main">⇒</span> var_data <span class="main">×</span> procArg"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclNum <span class="free"><span class="bound"><span class="entity">name</span></span></span> None None<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
        Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
      <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> 
               Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv 
                          <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>None<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> 
                    ProcArg <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>AST.VarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid proctype arguments''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> VTChan <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> None None<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">of</span> 
        Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
      <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> 
               Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv
                          <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
             <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>None<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> ProcArg VTChan <span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>AST.VarDeclChan <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid proctype arguments''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
                       <span class="main">(</span>AST.VarDeclMType <span class="free"><span class="bound"><span class="entity">name</span></span></span> None None<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
        Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Duplicate variable ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> 
               Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> errv
                          <span class="keyword1">STR</span> <span class="inner_quoted">''Variable name clashes with alias: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
              <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>None<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">,</span> 
                     ProcArg <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>AST.VarDeclMType <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid proctype arguments''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppProcArg</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>AST.VarDeclUnsigned <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''VarDeclUnsigned''</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some preprocessing functions enrich the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">var_data</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> argument and hence return
a new updated one. When chaining multiple calls to such functions after another, we need to make
sure, the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">var_data</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is passed accordingly. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cvm_fold</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does exactly that for such a
function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and a list of nodes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">ss</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cvm_fold</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cvm_fold</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cvm</span><span class="main">,</span><span class="bound">ss</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> apsnd <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="bound">ss</span><span class="main">@</span><span class="main">[</span><span class="bound">s'</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">cvm</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> 
                             <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-cvm_fold_cong"><span class="command">lemma</span></span> cvm_fold_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">cvm</span> <span class="main">=</span> <span class="free">cvm'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">stepss</span> <span class="main">=</span> <span class="free">stepss'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">stepss</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">d</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">d</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cvm_fold <span class="free">g</span> <span class="free">cvm</span> <span class="free">stepss</span> <span class="main">=</span> cvm_fold <span class="free">g'</span> <span class="free">cvm'</span> <span class="free">stepss'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cvm_fold_def 
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> foldl_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">liftDecl</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">liftDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.Decl <span class="free"><span class="bound"><span class="entity">vis</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main"><span class="bound">_</span></span> <span class="main">=</span> the_warn <span class="free"><span class="bound"><span class="entity">vis</span></span></span> <span class="keyword1">STR</span> <span class="inner_quoted">''Visibility in declarations not supported. Ignored.''</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> ppVarType <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">in</span>
     cvm_fold <span class="main">(</span><span class="main">λ</span><span class="bound">cvm</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">cvm</span> <span class="bound">t</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ppDecl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> var_data <span class="main">⇒</span> AST.decl <span class="main">⇒</span> var_data <span class="main">×</span> varDecl list"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppDecl</span> <span class="main">=</span> liftDecl ppVarDecl"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ppDeclProc</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> AST.decl <span class="main">⇒</span> var_data <span class="main">×</span> procVarDecl list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppDeclProc</span> <span class="main">=</span> liftDecl ppProcVarDecl False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ppDeclProcArg</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">⇒</span> AST.decl <span class="main">⇒</span> var_data <span class="main">×</span> procArg list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppDeclProcArg</span> <span class="main">=</span> liftDecl ppProcArg False"</span></span>

<span class="comment1">(* increment *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">incr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">incr</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> StmntAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>ExprBinOp BinOpAdd <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>ExprConst <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(* decrement *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">decr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decr</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> StmntAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>ExprBinOp BinOpSub <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>ExprConst <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
   Transforms
     \verb+for (i : lb .. ub) steps+
   into 
\begin{verbatim} {
   i = lb;
   do
     :: i =&lt; ub -&gt; steps; i++
     :: else -&gt; break
   od
} \end{verbatim}
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">forFromTo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> expr <span class="main">⇒</span> expr <span class="main">⇒</span> step list <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">forFromTo</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i = lb›</span></span>›</span>
        <span class="bound">loop_pre</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntAssign <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i ≤ ub›</span></span>›</span>
        <span class="bound">loop_cond</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntCond 
                                  <span class="main">(</span>ExprBinOp BinOpLEq <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span><span class="main">)</span>
                                  None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i++›</span></span>›</span>
        <span class="bound">loop_incr</span> <span class="main">=</span> StepStmnt <span class="main">(</span>incr <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i ≤ ub -&gt; ...; i++›</span></span>›</span>
        <span class="bound">loop_body</span> <span class="main">=</span> <span class="bound">loop_cond</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="bound">loop_incr</span><span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>else -&gt; break›</span></span>›</span>
        <span class="bound">loop_abort</span> <span class="main">=</span> <span class="main">[</span>StepStmnt StmntElse None<span class="main">,</span> StepStmnt StmntBreak None<span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>do :: i ≤ ub -&gt; ... :: else -&gt; break od›</span></span>›</span>
        <span class="bound">loop</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntDo <span class="main">[</span><span class="bound">loop_body</span><span class="main">,</span> <span class="bound">loop_abort</span><span class="main">]</span><span class="main">)</span> None
      <span class="keyword1">in</span>
        StmntSeq <span class="main">[</span><span class="bound">loop_pre</span><span class="main">,</span> <span class="bound">loop</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
   Transforms (where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is an array with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> entries)
     \verb+for (i in a) steps+
   into
\begin{verbatim}{
   i = 0;
   do
     :: i &lt; N -&gt; steps; i++
     :: else -&gt; break
   od
}\end{verbatim}
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">forInArray</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> integer <span class="main">⇒</span> step list <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">forInArray</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i = 0›</span></span>›</span>
        <span class="bound">loop_pre</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntAssign <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span>ExprConst <span class="main">0</span><span class="main">)</span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i &lt; N›</span></span>›</span>
        <span class="bound">loop_cond</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntCond 
                                 <span class="main">(</span>ExprBinOp BinOpLe <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> 
                                    <span class="main">(</span>ExprConst <span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                                 None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i++›</span></span>›</span>
        <span class="bound">loop_incr</span> <span class="main">=</span> StepStmnt <span class="main">(</span>incr <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i &lt; N -&gt; ...; i++›</span></span>›</span>
        <span class="bound">loop_body</span> <span class="main">=</span> <span class="bound">loop_cond</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="bound">loop_incr</span><span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>else -&gt; break›</span></span>›</span>
        <span class="bound">loop_abort</span> <span class="main">=</span> <span class="main">[</span>StepStmnt StmntElse None<span class="main">,</span> StepStmnt StmntBreak None<span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>do :: i &lt; N -&gt; ... :: else -&gt; break od›</span></span>›</span>
        <span class="bound">loop</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntDo <span class="main">[</span><span class="bound">loop_body</span><span class="main">,</span> <span class="bound">loop_abort</span><span class="main">]</span><span class="main">)</span> None
      <span class="keyword1">in</span>
        StmntSeq <span class="main">[</span><span class="bound">loop_pre</span><span class="main">,</span> <span class="bound">loop</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
   Transforms (where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">c</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a channel)
     \verb+for (msg in c) steps+
   into 
\begin{verbatim}{
   byte :tmp: = 0;
   do
     :: :tmp: &lt; len(c) -&gt; 
          c?msg; c!msg;
          steps; 
          :tmp:++
     :: else -&gt; break
   od
}\end{verbatim}
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">forInChan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> chanRef <span class="main">⇒</span> step list <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">forInChan</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span>  
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>byte :tmp: = 0›</span></span>›</span>
        <span class="bound">tmpStr</span> <span class="main">=</span> <span class="keyword1">STR</span> <span class="inner_quoted">'':tmp:''</span><span class="main">;</span>
        <span class="bound">loop_pre</span> <span class="main">=</span> StepDecl 
                    <span class="main">[</span>ProcVarDeclNum <span class="main">0</span> <span class="numeral">255</span> <span class="bound">tmpStr</span> None <span class="main">(</span>Some <span class="main">(</span>ExprConst <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>
        <span class="bound">tmp</span> <span class="main">=</span> VarRef False <span class="bound">tmpStr</span> None<span class="main">;</span> 
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>:tmp: &lt; len(c)›</span></span>›</span>
        <span class="bound">loop_cond</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntCond 
                                 <span class="main">(</span>ExprBinOp BinOpLe <span class="main">(</span>ExprVarRef <span class="bound">tmp</span><span class="main">)</span> 
                                    <span class="main">(</span>ExprLen <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                              None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>:tmp:++›</span></span>›</span>
        <span class="bound">loop_incr</span> <span class="main">=</span> StepStmnt <span class="main">(</span>incr <span class="bound">tmp</span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>c?msg›</span></span>›</span>
        <span class="bound">recv</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntRecv <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">[</span>RecvArgVar <span class="free"><span class="bound"><span class="entity">msg</span></span></span><span class="main">]</span> False True<span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>c!msg›</span></span>›</span>
        <span class="bound">send</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntSend <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">[</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">msg</span></span></span><span class="main">]</span> False<span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>:tmp: &lt; len(c) -&gt; c?msg; c!msg; ...; :tmp:++›</span></span>›</span>
        <span class="bound">loop_body</span> <span class="main">=</span> <span class="main">[</span><span class="bound">loop_cond</span><span class="main">,</span> <span class="bound">recv</span><span class="main">,</span> <span class="bound">send</span><span class="main">]</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="bound">loop_incr</span><span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>else -&gt; break›</span></span>›</span>
        <span class="bound">loop_abort</span> <span class="main">=</span> <span class="main">[</span>StepStmnt StmntElse None<span class="main">,</span> StepStmnt StmntBreak None<span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>do :: :tmp: &lt; len(c) -&gt; ... :: else -&gt; break od›</span></span>›</span>
        <span class="bound">loop</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntDo <span class="main">[</span><span class="bound">loop_body</span><span class="main">,</span> <span class="bound">loop_abort</span><span class="main">]</span><span class="main">)</span> None
      <span class="keyword1">in</span>
        StmntSeq <span class="main">[</span><span class="bound">loop_pre</span><span class="main">,</span> <span class="bound">loop</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
   Transforms
     \verb+select (i : lb .. ub)+
   into 
\begin{verbatim}{
   i = lb;
   do
     :: i &lt; ub -&gt; i++
     :: break
   od
}\end{verbatim}
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">select</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varRef <span class="main">⇒</span> expr <span class="main">⇒</span> expr <span class="main">⇒</span> stmnt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">select</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i = lb›</span></span>›</span>
        <span class="bound">pre</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntAssign <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i &lt; ub›</span></span>›</span>
        <span class="bound">cond</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntCond <span class="main">(</span>ExprBinOp BinOpLe <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span><span class="main">)</span> 
                         None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i++›</span></span>›</span>
        <span class="bound">incr</span> <span class="main">=</span> StepStmnt <span class="main">(</span>incr <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> None<span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>i &lt; ub -&gt; i++›</span></span>›</span>
        <span class="bound">loop_body</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cond</span><span class="main">,</span> <span class="bound">incr</span><span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>break›</span></span>›</span>
        <span class="bound">loop_abort</span> <span class="main">=</span> <span class="main">[</span>StepStmnt StmntBreak None<span class="main">]</span><span class="main">;</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>do :: i &lt; ub -&gt; ... :: break od›</span></span>›</span>
        <span class="bound">loop</span> <span class="main">=</span> StepStmnt <span class="main">(</span>StmntDo <span class="main">[</span><span class="bound">loop_body</span><span class="main">,</span> <span class="bound">loop_abort</span><span class="main">]</span><span class="main">)</span> None
      <span class="keyword1">in</span>
        StmntSeq <span class="main">[</span><span class="bound">pre</span><span class="main">,</span> <span class="bound">loop</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> inlines <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>String.literal<span class="main">,</span> String.literal list <span class="main">×</span> <span class="main">(</span>var_data <span class="main">⇒</span> var_data <span class="main">×</span> step list<span class="main">)</span><span class="main">)</span> lm"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> stmnt_data <span class="main">=</span> 
  <span class="quoted"><span class="quoted">" bool <span class="main">×</span> varDecl list <span class="main">×</span> inlines <span class="main">×</span> var_data"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ppStep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmnt_data <span class="main">⇒</span> AST.step <span class="main">⇒</span> stmnt_data <span class="main">*</span> step"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">ppStmnt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmnt_data <span class="main">⇒</span> AST.stmnt <span class="main">⇒</span> stmnt_data <span class="main">*</span> stmnt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppStep</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.StepStmnt <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> <span class="free">ppStmnt</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> StepStmnt <span class="bound">s'</span> None<span class="main">)</span> 
             <span class="main">|</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">cvm''</span><span class="main">,</span><span class="bound">u'</span><span class="main">)</span> <span class="main">=</span> <span class="free">ppStmnt</span> <span class="bound">cvm'</span> <span class="bound">u</span> <span class="keyword1">in</span>
                            <span class="main">(</span><span class="bound">cvm''</span><span class="main">,</span> StepStmnt <span class="bound">s'</span> <span class="main">(</span>Some <span class="bound">u'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStep</span> <span class="main">(</span>False<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StepDecl <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">=</span> 
     map_prod <span class="main">(</span><span class="main">λ</span><span class="bound">cvm</span><span class="main">.</span> <span class="main">(</span>False<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="bound">cvm</span><span class="main">)</span><span class="main">)</span> StepDecl <span class="main">(</span>ppDeclProc <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStep</span> <span class="main">(</span>True<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StepDecl <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
             <span class="keyword1">let</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> <span class="bound">ps'</span><span class="main">)</span> <span class="main">=</span> ppDecl False <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> 
             <span class="keyword1">in</span> <span class="main">(</span><span class="main">(</span>True<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">@</span><span class="bound">ps'</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="bound">cvm'</span><span class="main">)</span><span class="main">,</span> StepSkip<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStep</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StepXR <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     with_warn <span class="keyword1">STR</span> <span class="inner_quoted">''StepXR not supported. Ignored.''</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StepSkip<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStep</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StepXS <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     with_warn <span class="keyword1">STR</span> <span class="inner_quoted">''StepXS not supported. Ignored.''</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StepSkip<span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntBreak<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntBreak<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntElse<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntElse<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntGoTo <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntGoTo <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntLabeled <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd <span class="main">(</span>StmntLabeled <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">ppStmnt</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntCond <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntCond <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntAssert <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntAssert <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntAssign <span class="main">(</span>liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntSend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntSend <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntSortSend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntSend <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> True<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntRecv <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppRecvArg <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> False True<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntRecvX <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntRecv <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppRecvArg <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> False False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntRndRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntRecv <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppRecvArg <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> True True<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntRndRecvX <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntRecv <span class="main">(</span>enforceChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                                  <span class="main">(</span>map <span class="main">(</span>ppRecvArg <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> True False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntRun <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> 
     <span class="keyword1">let</span> <span class="main"><span class="bound">_</span></span> <span class="main">=</span> the_warn <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">STR</span> <span class="inner_quoted">''Priorities for 'run' not supported. Ignored.''</span> <span class="keyword1">in</span>
    <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntRun <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>map <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntSeq <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd StmntSeq <span class="main">(</span>cvm_fold <span class="free">ppStep</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntAtomic <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd StmntAtomic <span class="main">(</span>cvm_fold <span class="free">ppStep</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntIf <span class="free"><span class="bound"><span class="entity">sss</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd StmntIf <span class="main">(</span>cvm_fold <span class="main">(</span>cvm_fold <span class="free">ppStep</span><span class="main">)</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">sss</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntDo <span class="free"><span class="bound"><span class="entity">sss</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd StmntDo <span class="main">(</span>cvm_fold <span class="main">(</span>cvm_fold <span class="free">ppStep</span><span class="main">)</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">sss</span></span></span><span class="main">)</span>"</span></span>

<span class="comment1">(* Replace i++ and i-- by i = i + 1 / i = i - 1 *)</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntIncr <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> incr <span class="main">(</span>liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntDecr <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> decr <span class="main">(</span>liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntPrintF <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     with_warn <span class="keyword1">STR</span> <span class="inner_quoted">''PrintF ignored''</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntSkip<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntPrintM <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
     with_warn <span class="keyword1">STR</span> <span class="inner_quoted">''PrintM ignored''</span> <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> StmntSkip<span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntFor 
                              <span class="main">(</span>AST.RangeFromTo <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span> 
                              <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">i</span> <span class="main">=</span> liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="bound">lb</span><span class="main">,</span><span class="bound">ub</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">,</span> ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span>
     <span class="keyword1">in</span>
       apsnd <span class="main">(</span>forFromTo <span class="bound">i</span> <span class="bound">lb</span> <span class="bound">ub</span><span class="main">)</span> <span class="main">(</span>cvm_fold <span class="free">ppStep</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntFor 
                              <span class="main">(</span>AST.RangeIn <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> 
                              <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span>
        <span class="bound">i</span> <span class="main">=</span> liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span><span class="bound">steps</span><span class="main">)</span> <span class="main">=</span> cvm_fold <span class="free">ppStep</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span>
     <span class="keyword1">in</span>
        <span class="keyword1">case</span> ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
         Inr <span class="bound">c</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> forInChan <span class="bound">i</span> <span class="bound">c</span> <span class="bound">steps</span><span class="main">)</span>
       <span class="main">|</span> Inl <span class="main">(</span>VarRef <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">(</span>Some <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Iterating over array-member.''</span>
       <span class="main">|</span> Inl <span class="main">(</span>VarRef <span class="main"><span class="bound">_</span></span> <span class="bound">name</span> None<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>
             <span class="keyword1">let</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="keyword1">in</span>
             <span class="keyword1">case</span> fst <span class="main">(</span>the <span class="main">(</span>lm.lookup <span class="bound">name</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">of</span>
              None <span class="main">⇒</span> err <span class="keyword1">STR</span> <span class="inner_quoted">''Iterating over non-array variable.''</span>
            <span class="main">|</span> Some <span class="bound">N</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> forInArray <span class="bound">i</span> <span class="bound">N</span> <span class="bound">steps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntSelect 
                              <span class="main">(</span>AST.RangeFromTo <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span>
       <span class="bound">i</span> <span class="main">=</span> liftChan <span class="main">(</span>ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="bound">lb</span><span class="main">,</span> <span class="bound">ub</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">,</span> ppExpr <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span>
     <span class="keyword1">in</span>
       <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span><span class="main">,</span> select <span class="bound">i</span> <span class="bound">lb</span> <span class="bound">ub</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntSelect <span class="main">(</span>AST.RangeIn <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     err <span class="keyword1">STR</span> <span class="inner_quoted">''\"in\" not allowed in select''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="main">(</span>AST.StmntCall <span class="free"><span class="bound"><span class="entity">macro</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">args</span> <span class="main">=</span> map <span class="main">(</span>liftChan <span class="main">∘</span> ppVarRef <span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">;</span>
       <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span>
     <span class="keyword1">in</span>
       <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">macro</span></span></span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> errv <span class="keyword1">STR</span> <span class="inner_quoted">''Calling unknown macro ''</span> <span class="free"><span class="bound"><span class="entity">macro</span></span></span>
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">names</span><span class="main">,</span><span class="bound">sF</span><span class="main">)</span> <span class="main">⇒</span>
          <span class="keyword1">if</span> length <span class="bound">names</span> <span class="main">≠</span> length <span class="bound">args</span> <span class="keyword1">then</span> 
             <span class="main">(</span>err <span class="keyword1">STR</span> <span class="inner_quoted">''Called macro with wrong number of arguments.''</span><span class="main">)</span> 
          <span class="keyword1">else</span>
             <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> lm.update <span class="bound">k</span> <span class="bound">v</span> <span class="bound">a</span><span class="main">)</span> <span class="bound">a</span> <span class="main">(</span>zip <span class="bound">names</span> <span class="bound">args</span><span class="main">)</span> <span class="keyword1">in</span>
             <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">,</span><span class="bound">steps</span><span class="main">)</span> <span class="main">=</span> <span class="bound">sF</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span> <span class="keyword1">in</span>
             <span class="main">(</span><span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">,</span> StmntSeq <span class="bound">steps</span><span class="main">)</span><span class="main">)</span>"</span></span>
         
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppStmnt</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.StmntDStep <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''StmntDStep''</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ppModule</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"var_data <span class="main">×</span> inlines <span class="main">⇒</span> AST.module 
      <span class="main">⇒</span> var_data <span class="main">×</span> inlines <span class="main">×</span> <span class="main">(</span>varDecl list <span class="main">+</span> proc <span class="main">+</span> ltl<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.ProcType <span class="free"><span class="bound"><span class="entity">act</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="free"><span class="bound"><span class="entity">prio</span></span></span> <span class="free"><span class="bound"><span class="entity">prov</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
        <span class="main"><span class="bound">_</span></span> <span class="main">=</span> the_warn <span class="free"><span class="bound"><span class="entity">prio</span></span></span> <span class="keyword1">STR</span> <span class="inner_quoted">''Priorities for procs not supported. Ignored.''</span><span class="main">;</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">=</span> the_warn <span class="free"><span class="bound"><span class="entity">prov</span></span></span> <span class="keyword1">STR</span> <span class="inner_quoted">''Priov (??) for procs not supported. Ignored.''</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> <span class="bound">args</span><span class="main">)</span> <span class="main">=</span> cvm_fold ppDeclProcArg <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">;</span>
        <span class="main">(</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">vars</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">,</span> <span class="bound">steps</span><span class="main">)</span> <span class="main">=</span> cvm_fold ppStep <span class="main">(</span>True<span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="bound">cvm'</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span>
     <span class="keyword1">in</span>
        <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span> Inr <span class="main">(</span>Inl <span class="main">(</span>ProcType <span class="free"><span class="bound"><span class="entity">act</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>concat <span class="bound">args</span><span class="main">)</span> <span class="bound">vars</span> <span class="bound">steps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.Init <span class="free"><span class="bound"><span class="entity">prio</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main"><span class="bound">_</span></span> <span class="main">=</span> the_warn <span class="free"><span class="bound"><span class="entity">prio</span></span></span> <span class="keyword1">STR</span> <span class="inner_quoted">''Priorities for procs not supported. Ignored.''</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">vars</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">,</span> <span class="bound">steps</span><span class="main">)</span> <span class="main">=</span> cvm_fold ppStep <span class="main">(</span>True<span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="keyword1">in</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span> Inr <span class="main">(</span>Inl <span class="main">(</span>Init <span class="bound">vars</span> <span class="bound">steps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.Ltl <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">formula</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span> Inr <span class="main">(</span>Inr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">formula</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.ModuDecl <span class="free"><span class="bound"><span class="entity">decl</span></span></span><span class="main">)</span> <span class="main">=</span> 
     apsnd <span class="main">(</span><span class="main">λ</span><span class="bound">ds</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span>Inl <span class="bound">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ppDecl True <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="free"><span class="bound"><span class="entity">decl</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.MType <span class="free"><span class="bound"><span class="entity">mtys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">num</span> <span class="main">=</span> integer_of_nat <span class="main">(</span>lm.size <span class="bound">m</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="bound">mty</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span><span class="bound">num</span><span class="main">)</span><span class="main">.</span> 
                    <span class="keyword1">let</span> <span class="bound">m'</span> <span class="main">=</span> lm.update <span class="bound">mty</span> <span class="bound">num</span> <span class="bound">m</span> 
                    <span class="keyword1">in</span> <span class="main">(</span><span class="bound">m'</span><span class="main">,</span><span class="bound">num</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">mtys</span></span></span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span><span class="bound">num</span><span class="main">)</span>
     <span class="keyword1">in</span>
         <span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">m'</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span> Inl <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">)</span> <span class="main">(</span>AST.Inline <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">stepF</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">cvm</span><span class="main">.</span> <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cvm</span><span class="main">)</span><span class="main">,</span><span class="bound">steps</span><span class="main">)</span> <span class="main">=</span> 
                          cvm_fold ppStep <span class="main">(</span>False<span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">inl</span></span></span><span class="main">,</span><span class="bound">cvm</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> 
                        <span class="keyword1">in</span> <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span><span class="bound">steps</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">in</span> <span class="keyword1">let</span> <span class="bound">inl</span> <span class="main">=</span> lm.update <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">,</span> <span class="bound">stepF</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">inl</span></span></span>
     <span class="keyword1">in</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cvm</span></span></span><span class="main">,</span><span class="bound">inl</span><span class="main">,</span> Inl<span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.DProcType <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''DProcType''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.Never <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''Never''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.Trace <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''Trace''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.NoTrace <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''NoTrace''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ppModule</span> <span class="free"><span class="bound"><span class="entity">cvm</span></span></span> <span class="main">(</span>AST.TypeDef <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> usc <span class="keyword1">STR</span> <span class="inner_quoted">''TypeDef''</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">preprocess</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.module list <span class="main">⇒</span> promela"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">preprocess</span> <span class="free"><span class="bound"><span class="entity">ms</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">dflt_vars</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_pid''</span><span class="main">,</span> <span class="main">(</span>None<span class="main">,</span> False<span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                    <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''__assert__''</span><span class="main">,</span> <span class="main">(</span>None<span class="main">,</span> True<span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                    <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_''</span><span class="main">,</span> <span class="main">(</span>None<span class="main">,</span> True<span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>
       <span class="bound">cvm</span> <span class="main">=</span> <span class="main">(</span>lm.empty<span class="main">()</span><span class="main">,</span> lm.to_map <span class="bound">dflt_vars</span><span class="main">,</span> lm.empty<span class="main">()</span><span class="main">,</span> lm.empty<span class="main">()</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">pr</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cvm</span><span class="main">,</span><span class="bound">inl</span><span class="main">,</span><span class="bound">vs</span><span class="main">,</span><span class="bound">ps</span><span class="main">,</span><span class="bound">ls</span><span class="main">)</span> <span class="bound">m</span><span class="main">.</span>
                            <span class="keyword1">let</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span> <span class="bound">inl'</span><span class="main">,</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">=</span> ppModule <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span><span class="bound">inl</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">in</span>
                            <span class="keyword1">case</span> <span class="bound">m'</span> <span class="keyword1">of</span>
                              Inl <span class="bound">v</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span><span class="bound">inl'</span><span class="main">,</span><span class="bound">vs</span><span class="main">@</span><span class="bound">v</span><span class="main">,</span><span class="bound">ps</span><span class="main">,</span><span class="bound">ls</span><span class="main">)</span>
                            <span class="main">|</span> Inr <span class="main">(</span>Inl <span class="bound">p</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span><span class="bound">inl'</span><span class="main">,</span><span class="bound">vs</span><span class="main">,</span><span class="bound">ps</span><span class="main">@</span><span class="main">[</span><span class="bound">p</span><span class="main">]</span><span class="main">,</span><span class="bound">ls</span><span class="main">)</span>
                            <span class="main">|</span> Inr <span class="main">(</span>Inr <span class="bound">l</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">cvm'</span><span class="main">,</span><span class="bound">inl'</span><span class="main">,</span><span class="bound">vs</span><span class="main">,</span><span class="bound">ps</span><span class="main">,</span><span class="bound">ls</span><span class="main">@</span><span class="main">[</span><span class="bound">l</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> 
                          <span class="main">(</span><span class="bound">cvm</span><span class="main">,</span> lm.empty<span class="main">()</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ms</span></span></span><span class="main">)</span>
       <span class="keyword1">in</span>
         <span class="bound">pr</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">extractLTL</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.module <span class="main">⇒</span> ltl option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">extractLTL</span> <span class="main">(</span>AST.Ltl <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">formula</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">formula</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">extractLTL</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> None"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">extractLTLs</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.module list <span class="main">⇒</span> <span class="main">(</span>String.literal<span class="main">,</span> String.literal<span class="main">)</span> lm"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">extractLTLs</span> <span class="main">[]</span> <span class="main">=</span> lm.empty<span class="main">()</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">extractLTLs</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ms</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> extractLTL <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> 
                           None <span class="main">⇒</span> <span class="free">extractLTLs</span> <span class="free"><span class="bound"><span class="entity">ms</span></span></span>
                         <span class="main">|</span> Some <span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span> <span class="main">⇒</span> lm.update <span class="bound">n</span> <span class="bound">f</span> <span class="main">(</span><span class="free">extractLTLs</span> <span class="free"><span class="bound"><span class="entity">ms</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lookupLTL</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"AST.module list <span class="main">⇒</span> String.literal <span class="main">⇒</span> String.literal option"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookupLTL</span> <span class="free"><span class="bound"><span class="entity">ast</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> lm.lookup <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span>extractLTLs <span class="free"><span class="bound"><span class="entity">ast</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The transition system›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The edges in our transition system consist of a condition (evaluated under the current environment) and an effect (modifying the current environment). 
  Further they may be atomic, \ie a whole row of such edges is taken before yielding a new state. 
  Additionally, they carry a priority: the edges are checked from highest to lowest priority, and if one edge on a higher level can be taken, the lower levels are ignored.

  The states of the system do not carry any information.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> edgeCond <span class="main">=</span> ECElse 
                  <span class="main">|</span> ECTrue
                  <span class="main">|</span> ECFalse 
                  <span class="main">|</span> ECExpr <span class="quoted">expr</span> 
                  <span class="main">|</span> ECRun <span class="quoted">String.literal</span> 
                  <span class="main">|</span> ECSend <span class="quoted">chanRef</span>
                  <span class="main">|</span> ECRecv <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span> <span class="quoted">bool</span> <span class="comment1">(* sorted *)</span>

<span class="keyword1"><span class="command">datatype</span></span> edgeEffect <span class="main">=</span> EEEnd 
                    <span class="main">|</span> EEId 
                    <span class="main">|</span> EEGoto
                    <span class="main">|</span> EEAssert <span class="quoted">expr</span> 
                    <span class="main">|</span> EEAssign <span class="quoted">varRef</span> <span class="quoted">expr</span> 
                    <span class="main">|</span> EEDecl <span class="quoted">procVarDecl</span>
                    <span class="main">|</span> EERun <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"expr list"</span></span>
                    <span class="main">|</span> EESend <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"expr list"</span></span> <span class="quoted">bool</span> <span class="comment1">(*sorted*)</span>
                    <span class="main">|</span> EERecv <span class="quoted">chanRef</span> <span class="quoted"><span class="quoted">"recvArg list"</span></span> <span class="quoted">bool</span> <span class="comment1">(*sorted*)</span> <span class="quoted">bool</span> <span class="comment1">(*remove*)</span>

<span class="keyword1"><span class="command">datatype</span></span> edgeIndex <span class="main">=</span> Index <span class="quoted">nat</span> <span class="main">|</span> LabelJump <span class="quoted">String.literal</span> <span class="quoted"><span class="quoted">"nat option"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> edgeAtomic <span class="main">=</span> NonAtomic <span class="main">|</span> Atomic <span class="main">|</span> InAtomic

<span class="keyword1"><span class="command">record</span></span> edge <span class="main">=</span> 
  cond   <span class="main">::</span> <span class="quoted">edgeCond</span>
  effect <span class="main">::</span> <span class="quoted">edgeEffect</span>
  target <span class="main">::</span> <span class="quoted">edgeIndex</span>
  prio   <span class="main">::</span> <span class="quoted">integer</span>
  atomic <span class="main">::</span> <span class="quoted">edgeAtomic</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isAtomic</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">isAtomic</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> atomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> Atomic <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inAtomic</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inAtomic</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> atomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> NonAtomic <span class="main">⇒</span> False <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> variable <span class="main">=</span> Var <span class="quoted">varType</span> <span class="quoted">integer</span>
                  <span class="main">|</span> VArray <span class="quoted">varType</span> <span class="quoted">nat</span> <span class="quoted"><span class="quoted">"integer iarray"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> channel <span class="main">=</span> Channel <span class="quoted">integer</span> <span class="quoted"><span class="quoted">"varType list"</span></span> <span class="quoted"><span class="quoted">"integer list list"</span></span>
                 <span class="main">|</span> HSChannel <span class="quoted"><span class="quoted">"varType list"</span></span> <span class="comment1">(* handshake channel *)</span>
                 <span class="main">|</span> InvChannel <span class="comment1">(* Invalid / closed channel *)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> var_dict <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>String.literal<span class="main">,</span> variable<span class="main">)</span> lm"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> labels   <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>String.literal<span class="main">,</span> nat<span class="main">)</span> lm"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> ltls     <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>String.literal<span class="main">,</span> String.literal<span class="main">)</span> lm"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> states   <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="comment1">― ‹prio:›</span> integer <span class="main">×</span> edge list<span class="main">)</span> iarray"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> channels <span class="main">=</span> <span class="quoted"><span class="quoted">"channel list"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> process  <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"nat <span class="comment1">― ‹offset›</span>
 <span class="main">×</span> edgeIndex <span class="comment1">― ‹start›</span>
 <span class="main">×</span> procArg list <span class="comment1">― ‹args›</span>
 <span class="main">×</span> varDecl list <span class="comment1">― ‹top decls›</span>"</span></span>

<span class="keyword1"><span class="command">record</span></span> program <span class="main">=</span>
  processes <span class="main">::</span> <span class="quoted"><span class="quoted">"process iarray"</span></span>
  labels <span class="main">::</span> <span class="quoted"><span class="quoted">"labels iarray"</span></span>
  states <span class="main">::</span> <span class="quoted"><span class="quoted">"states iarray"</span></span>
  proc_names <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal iarray"</span></span>
  proc_data <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>String.literal<span class="main">,</span> nat<span class="main">)</span> lm"</span></span>

<span class="keyword1"><span class="command">record</span></span> pState <span class="main">=</span> <span class="comment1">― ‹State of a process›</span>
  pid      <span class="main">::</span> <span class="quoted">nat</span>             <span class="comment1">― ‹Process identifier›</span>
  vars     <span class="main">::</span> <span class="quoted">var_dict</span>        <span class="comment1">― ‹Dictionary of variables›</span>
  pc       <span class="main">::</span> <span class="quoted">nat</span>             <span class="comment1">― ‹Program counter›</span>
  channels <span class="main">::</span> <span class="quoted"><span class="quoted">"integer list"</span></span>  <span class="comment1">― ‹List of channels created in the process. Used to close them on finalization.›</span>
  idx <span class="main">::</span> <span class="quoted">nat</span>                  <span class="comment1">― ‹Offset into the arrays of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type</span> program<span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> idx

<span class="keyword1"><span class="command">record</span></span> gState <span class="main">=</span> <span class="comment1">― ‹Global state›</span>
  vars      <span class="main">::</span> <span class="quoted">var_dict</span>      <span class="comment1">― ‹Global variables›</span>
  channels  <span class="main">::</span> <span class="quoted">channels</span>      <span class="comment1">― ‹Channels are by construction part of the global state, even when created in a process.›</span>
  timeout   <span class="main">::</span> <span class="quoted">bool</span>          <span class="comment1">― ‹Set to True if no process can take a transition.›</span>
  procs     <span class="main">::</span> <span class="quoted"><span class="quoted">"pState list"</span></span> <span class="comment1">― ‹List of all running processes. A process is removed from it, when there is no running one
                                 with a higher index.›</span>

<span class="keyword1"><span class="command">record</span></span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">=</span> <span class="quoted">gState</span> <span class="main">+</span> <span class="comment1">― ‹Additional internal infos›</span>
  handshake <span class="main">::</span> <span class="quoted">nat</span>
  hsdata    <span class="main">::</span> <span class="quoted"><span class="quoted">"integer list "</span></span> <span class="comment1">― ‹Data transferred via a handshake.›</span>
  exclusive <span class="main">::</span> <span class="quoted">nat</span>     <span class="comment1">― ‹Set to the PID of the process, which is in an exclusive (= atomic) state.›</span>
  else      <span class="main">::</span> <span class="quoted">bool</span>    <span class="comment1">― ‹Set to True for each process, if it can not take a transition. Used before timeout.›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Printing›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">printBinOp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"binOp <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpAdd <span class="main">=</span> <span class="inner_quoted">''+''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpSub <span class="main">=</span> <span class="inner_quoted">''-''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpMul <span class="main">=</span> <span class="inner_quoted">''*''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpDiv <span class="main">=</span> <span class="inner_quoted">''/''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpMod <span class="main">=</span> <span class="inner_quoted">''mod''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpGr <span class="main">=</span> <span class="inner_quoted">''&gt;''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpLe <span class="main">=</span> <span class="inner_quoted">''&lt;''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpGEq <span class="main">=</span> <span class="inner_quoted">''&gt;=''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpLEq <span class="main">=</span> <span class="inner_quoted">''=&lt;''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpEq <span class="main">=</span> <span class="inner_quoted">''==''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpNEq <span class="main">=</span> <span class="inner_quoted">''!=''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpAnd <span class="main">=</span> <span class="inner_quoted">''&amp;&amp;''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printBinOp</span> BinOpOr <span class="main">=</span> <span class="inner_quoted">''||''</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">printUnOp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unOp <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printUnOp</span> UnOpMinus <span class="main">=</span> <span class="inner_quoted">''-''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printUnOp</span> UnOpNeg <span class="main">=</span> <span class="inner_quoted">''!''</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printList</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> string <span class="main">⇒</span> string <span class="main">⇒</span> string <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printList</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">sep</span></span></span> <span class="main">=</span> <span class="main">(</span>
                     <span class="keyword1">let</span> <span class="bound">f'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">str</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">str</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span>
                                       <span class="keyword1">else</span> <span class="bound">str</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">sep</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span>
                     <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="main">(</span>foldl <span class="bound">f'</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-printList_cong"><span class="command">lemma</span></span> printList_cong <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">=</span> <span class="free">l'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sep</span> <span class="main">=</span> <span class="free">sep'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"printList <span class="free">f</span> <span class="free">xs</span> <span class="free">l</span> <span class="free">r</span> <span class="free">sep</span> <span class="main">=</span> printList <span class="free">f'</span> <span class="free">xs'</span> <span class="free">l'</span> <span class="free">r'</span> <span class="free">sep'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> printList_def
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> foldl_cong<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">printExpr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> expr <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">printFun</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> string <span class="main">⇒</span> chanRef <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">printVarRef</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> varRef <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">printChanRef</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> chanRef <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">printRecvArg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> recvArg <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> ExprTimeOut <span class="main">=</span> <span class="inner_quoted">''timeout''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprBinOp <span class="free"><span class="bound"><span class="entity">binOp</span></span></span> <span class="free"><span class="bound"><span class="entity">left</span></span></span> <span class="free"><span class="bound"><span class="entity">right</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">left</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' ''</span> <span class="main">@</span> printBinOp <span class="free"><span class="bound"><span class="entity">binOp</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' ''</span> <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">right</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprUnOp <span class="free"><span class="bound"><span class="entity">unOp</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> printUnOp <span class="free"><span class="bound"><span class="entity">unOp</span></span></span> <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprVarRef <span class="free"><span class="bound"><span class="entity">varRef</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printVarRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">varRef</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprConst <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprMConst <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> String.explode <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprCond <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="inner_quoted">''( (( ''</span> <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' )) -&gt; ''</span> 
     <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' : ''</span> 
     <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' )''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprLen <span class="free"><span class="bound"><span class="entity">chan</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printFun</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="inner_quoted">''len''</span> <span class="free"><span class="bound"><span class="entity">chan</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprEmpty <span class="free"><span class="bound"><span class="entity">chan</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printFun</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="inner_quoted">''empty''</span> <span class="free"><span class="bound"><span class="entity">chan</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprFull <span class="free"><span class="bound"><span class="entity">chan</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printFun</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="inner_quoted">''full''</span> <span class="free"><span class="bound"><span class="entity">chan</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ExprPoll <span class="free"><span class="bound"><span class="entity">chan</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="inner_quoted">''??''</span> <span class="keyword1">else</span> <span class="inner_quoted">''?''</span> <span class="keyword1">in</span>
     <span class="free">printChanRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">chan</span></span></span> <span class="main">@</span> <span class="bound">p</span> 
     <span class="main">@</span> printList <span class="main">(</span><span class="free">printRecvArg</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="inner_quoted">''[''</span> <span class="inner_quoted">'']''</span> <span class="inner_quoted">'', ''</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarRef</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>VarRef <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span> <span class="main">=</span> String.explode <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>VarRef <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">indx</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     String.explode <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">@</span> <span class="inner_quoted">''[''</span> <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">indx</span></span></span> <span class="main">@</span> <span class="inner_quoted">'']''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printChanRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ChanRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printVarRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printFun</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">fun</span></span></span> <span class="free"><span class="bound"><span class="entity">var</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">fun</span></span></span> <span class="main">@</span> <span class="inner_quoted">''(''</span> <span class="main">@</span> <span class="free">printChanRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">var</span></span></span> <span class="main">@</span> <span class="inner_quoted">'')''</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printRecvArg</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>RecvArgVar <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">printVarRef</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printRecvArg</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>RecvArgConst <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printRecvArg</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>RecvArgMConst <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> String.explode <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printRecvArg</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>RecvArgEval <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''eval(''</span> <span class="main">@</span> <span class="free">printExpr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">@</span> <span class="inner_quoted">'')''</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">printVarDecl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> procVarDecl <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> None None<span class="main">)</span> <span class="main">=</span> 
    String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' = 0''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' = ''</span> <span class="main">@</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> None<span class="main">)</span> <span class="main">=</span> 
    String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">''[''</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">@</span> <span class="inner_quoted">''] = 0''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">''[''</span><span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">@</span> <span class="inner_quoted">''] = ''</span> <span class="main">@</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclChan <span class="free"><span class="bound"><span class="entity">n</span></span></span> None<span class="main">)</span> <span class="main">=</span> 
    <span class="inner_quoted">''chan ''</span> <span class="main">@</span> String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printVarDecl</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ProcVarDeclChan <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    <span class="inner_quoted">''chan ''</span> <span class="main">@</span> String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">''[''</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">@</span> <span class="inner_quoted">'']''</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">printCond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> edgeCond <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> ECElse <span class="main">=</span> <span class="inner_quoted">''else''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> ECTrue <span class="main">=</span> <span class="inner_quoted">''true''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> ECFalse <span class="main">=</span> <span class="inner_quoted">''false''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ECRun <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''run ''</span> <span class="main">@</span> String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">''(...)''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ECExpr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ECSend <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> printChanRef <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">@</span> <span class="inner_quoted">''! ...''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printCond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>ECRecv <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> printChanRef <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">@</span> <span class="inner_quoted">''? ...''</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">printEffect</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> edgeEffect <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> EEEnd <span class="main">=</span> <span class="inner_quoted">''-- end --''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> EEId <span class="main">=</span> <span class="inner_quoted">''ID''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> EEGoto <span class="main">=</span> <span class="inner_quoted">''goto''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EEAssert <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''assert(''</span> <span class="main">@</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">@</span><span class="inner_quoted">'')''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EERun <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''run ''</span> <span class="main">@</span> String.explode <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">@</span> <span class="inner_quoted">''(...)''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EEAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">expr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     printVarRef <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">@</span> <span class="inner_quoted">'' = ''</span> <span class="main">@</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">expr</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EEDecl <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">=</span> printVarDecl <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EESend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="inner_quoted">''!!''</span> <span class="keyword1">else</span> <span class="inner_quoted">''!''</span> <span class="keyword1">in</span> 
     printChanRef <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">@</span> <span class="bound">s</span> <span class="main">@</span> printList <span class="main">(</span>printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="inner_quoted">''(''</span> <span class="inner_quoted">'')''</span> <span class="inner_quoted">'', ''</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printEffect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>EERecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="inner_quoted">''??''</span> <span class="keyword1">else</span> <span class="inner_quoted">''?''</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="inner_quoted">''(''</span><span class="main">,</span> <span class="inner_quoted">'')''</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="inner_quoted">''&lt;''</span><span class="main">,</span> <span class="inner_quoted">''&gt;''</span><span class="main">)</span> <span class="keyword1">in</span>
     printChanRef <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">@</span> <span class="bound">p</span> <span class="main">@</span> printList <span class="main">(</span>printRecvArg <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="bound">l</span> <span class="bound">r</span> <span class="inner_quoted">'', ''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">printIndex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> edgeIndex <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printIndex</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>integer_of_nat <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printIndex</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>LabelJump <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> String.explode <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printEdge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> edge <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printEdge</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">indx</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span>
       <span class="bound">tStr</span> <span class="main">=</span> printIndex <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>target <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">;</span>
       <span class="bound">pStr</span> <span class="main">=</span> <span class="keyword1">if</span> prio <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="inner_quoted">'' Prio: ''</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>prio <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">;</span>
       <span class="bound">atom</span> <span class="main">=</span> <span class="keyword1">if</span> isAtomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">then</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">@</span> <span class="inner_quoted">'' {A}''</span> <span class="keyword1">else</span> id<span class="main">;</span>
       <span class="bound">pEff</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">atom</span> <span class="main">(</span>printEffect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>effect <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">contStr</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="main">(</span>cond <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
                  ECTrue <span class="main">⇒</span> <span class="bound">pEff</span> <span class="main">()</span>
                <span class="main">|</span> ECFalse <span class="main">⇒</span> <span class="bound">pEff</span> <span class="main">()</span>
                <span class="main">|</span> ECSend <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">pEff</span><span class="main">()</span>
                <span class="main">|</span> ECRecv <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">⇒</span> <span class="bound">pEff</span><span class="main">()</span>
                <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>  <span class="bound">atom</span> <span class="main">(</span><span class="inner_quoted">''(( ''</span> <span class="main">@</span> printCond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>cond <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'' ))''</span><span class="main">)</span>
     <span class="keyword1">in</span>
       <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>integer_of_nat <span class="free"><span class="bound"><span class="entity">indx</span></span></span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'' ---&gt; ''</span> <span class="main">@</span> <span class="bound">tStr</span> <span class="main">@</span> <span class="inner_quoted">'' =&gt; ''</span> <span class="main">@</span> <span class="bound">contStr</span> <span class="main">@</span> <span class="bound">pStr</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printEdges</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> states <span class="main">⇒</span> string list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printEdges</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">=</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> map <span class="main">(</span>printEdge <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span><span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">!!</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                                 <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>IArray.length <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printLabels</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> labels <span class="main">⇒</span> string list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printLabels</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">=</span> lm.iterate <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="bound">res</span><span class="main">.</span> 
                                      <span class="main">(</span><span class="inner_quoted">''Label ''</span> <span class="main">@</span> String.explode <span class="bound">k</span> <span class="main">@</span> <span class="inner_quoted">'': ''</span> 
                                       <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>integer_of_nat <span class="bound">l</span><span class="main">)</span><span class="main">)</span> <span class="main">#</span> <span class="bound">res</span><span class="main">)</span> <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">printProcesses</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> program <span class="main">⇒</span> string list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printProcesses</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">=</span> lm.iterate <span class="main">(</span>proc_data <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> 
     <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">idx</span><span class="main">)</span> <span class="bound">res</span><span class="main">.</span>
            <span class="keyword1">let</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">start</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">idx</span> <span class="keyword1">in</span> 
            <span class="main">[]</span> <span class="main">#</span> <span class="main">(</span><span class="inner_quoted">''Process ''</span> <span class="main">@</span> String.explode <span class="bound">k</span><span class="main">)</span> <span class="main">#</span> <span class="main">[]</span> <span class="main">#</span> printEdges <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">idx</span><span class="main">)</span>
            <span class="main">@</span> <span class="main">[</span><span class="inner_quoted">''START ---&gt; ''</span> <span class="main">@</span> printIndex <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">start</span><span class="main">,</span> <span class="main">[]</span><span class="main">]</span> 
            <span class="main">@</span> printLabels <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>labels <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">idx</span><span class="main">)</span> <span class="main">@</span> <span class="bound">res</span><span class="main">)</span> <span class="main">[]</span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="comment1">(*section {* Instantiations *}
text {* Here instantiations for classes @{class linorder} and @{class hashable} are given for our datatypes.
As we include other structures, which sometime also lack those instantiations, this is done here too. *}
subsection {* Others *}
text {* The following lemmas are needed to make our hashing and linorder sound.

NB: It cannot be proven that 
@{prop "Assoc_List.update k v (Assoc_List.update k2 v2 ls) = Assoc_List.update k2 v2 (Assoc_List.update k v ls)"}

Hence our implementation becomes unsound when order of insertion is not fix. *}*)</span>

<span class="keyword1" id="PromelaDatastructures-AL_update_idem"><span class="command">lemma</span></span> AL_update_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Assoc_List.lookup <span class="free">ls</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Assoc_List.update <span class="free">k</span> <span class="free">v</span> <span class="free">ls</span> <span class="main">=</span> <span class="free">ls</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">lsl</span></span> <span class="keyword2"><span class="keyword">where</span></span> lsl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lsl</span> <span class="main">=</span> Assoc_List.impl_of <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">lsl</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.lookup_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"AList.update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v</span><span class="main">)</span> <span class="skolem">lsl</span> <span class="main">=</span> <span class="skolem">lsl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">lsl</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> lsl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.update_def Assoc_List.update_with_def Assoc_List_impl_of<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaDatastructures-AL_update_update_idem"><span class="command">lemma</span></span> AL_update_update_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Assoc_List.lookup <span class="free">ls</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Assoc_List.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>Assoc_List.update <span class="free">k</span> <span class="free">v2</span> <span class="free">ls</span><span class="main">)</span> <span class="main">=</span> <span class="free">ls</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">lsl</span></span> <span class="keyword2"><span class="keyword">where</span></span> lsl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lsl</span> <span class="main">=</span> Assoc_List.impl_of <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">lsl</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.lookup_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"AList.update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>AList.update_with_aux <span class="free">v2</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v2</span><span class="main">)</span> <span class="skolem">lsl</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">lsl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">lsl</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> lsl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Assoc_List.update_def Assoc_List_impl_of impl_of_update_with<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaDatastructures-AL_update_delete_idem"><span class="command">lemma</span></span> AL_update_delete_idem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Assoc_List.lookup <span class="free">ls</span> <span class="free">k</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Assoc_List.delete <span class="free">k</span> <span class="main">(</span>Assoc_List.update <span class="free">k</span> <span class="free">v</span> <span class="free">ls</span><span class="main">)</span> <span class="main">=</span> <span class="free">ls</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">lsl</span></span> <span class="keyword2"><span class="keyword">where</span></span> lsl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lsl</span> <span class="main">=</span> Assoc_List.impl_of <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">lsl</span> <span class="free">k</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.lookup_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"AList.delete_aux <span class="free">k</span> <span class="main">(</span>AList.update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v</span><span class="main">)</span> <span class="skolem">lsl</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">lsl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">lsl</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> lsl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.delete_def Assoc_List.update_def assoc_list.impl_of_inverse impl_of_update_with<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> assoc_list <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">,</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> assoc_list itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="main">≡</span> hashcode <span class="main">∘</span> Assoc_List.impl_of"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_assoc_list_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*
instantiation XXX :: (hashable_uint, hashable_uint) hashable
begin
  definition hashcode_XXX :: "('a, 'b) XXX ⇒ nat" 
    where "hashcode_XXX ≡ hashcode_nat"

  definition bounded_hashcode_XXX :: "nat ⇒ ('a, 'b) XXX ⇒ nat" 
    where "bounded_hashcode_XXX = bounded_hashcode_nat"

  definition def_hashmap_size_XXX :: "('a, 'b) XXX itself ⇒ nat" 
    where "def_hashmap_size_XXX ≡ def_hashmap_size_uint"

  instance
    apply standard
    unfolding def_hashmap_size_XXX_def bounded_hashcode_XXX_def
    using hashable_from_hashable_uint by auto
end
*)</span>

<span class="keyword1"><span class="command">instantiation</span></span> assoc_list <span class="main">::</span> <span class="main">(</span><span class="quoted">linorder</span><span class="main">,</span><span class="quoted">linorder</span><span class="main">)</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_assoc_list</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> assoc_list<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> assoc_list<span class="main">)</span> <span class="main">⟷</span> lexlist <span class="main">(</span>Assoc_List.impl_of <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">≤</span> lexlist <span class="main">(</span>Assoc_List.impl_of <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_assoc_list</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> assoc_list<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> assoc_list<span class="main">)</span> <span class="main">⟷</span> lexlist <span class="main">(</span>Assoc_List.impl_of <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">&lt;</span> lexlist <span class="main">(</span>Assoc_List.impl_of <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> assoc_list_ext lexlist_ext lexlist_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Other instantiations for types from Main *)</span>
<span class="comment1">(*instantiation iarray :: (linorder) linorder
begin
  definition [simp]: "less_eq_iarray (a :: 'a iarray) (b :: 'a iarray) ⟷ lexlist (IArray.list_of a) ≤ lexlist (IArray.list_of b)"
  definition [simp]: "less_iarray (a :: 'a iarray) (b :: 'a iarray) ⟷ lexlist (IArray.list_of a) &lt; lexlist (IArray.list_of b)"

  instance 
    apply standard 
    apply auto
    apply (metis iarray.exhaust list_of.simps lexlist_ext lexlist_def)
    done
end*)</span>
<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">iarray</span>

<span class="keyword1"><span class="command">instantiation</span></span> lexlist <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_lexlist</span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'a</span> lexlist itself<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">hashcode_lexlist</span></span> <span class="main">=</span> hashcode <span class="keyword1">o</span> unlex"</span></span>
  <span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> def_hashmap_size<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> lexlist<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_lexlist_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instead of operating on the list representation of an <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> IArray<span class="antiquote">}</span></span>, we walk it directly,
using the indices.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">walk_iarray'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> iarray <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">walk_iarray'</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">walk_iarray'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">y</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">!!</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
                                  <span class="keyword1">in</span> <span class="free">walk_iarray'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">y</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-walk_iarray'_Cons"><span class="command">lemma</span></span> walk_iarray'_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_iarray' <span class="free">f</span> <span class="main">(</span>IArray <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="free">l</span> <span class="main">(</span>Suc <span class="free">p</span><span class="main">)</span> <span class="main">=</span> walk_iarray' <span class="free">f</span> <span class="main">(</span>IArray <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="free">l</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">walk_iarray</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> iarray <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">walk_iarray</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> walk_iarray' <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>IArray.length <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">0</span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-walk_iarray_Cons"><span class="command">lemma</span></span> walk_iarray_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_iarray <span class="free">f</span> <span class="main">(</span>IArray <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> walk_iarray <span class="free">f</span> <span class="main">(</span>IArray <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_def walk_iarray'_Cons<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_iarray_append"><span class="command">lemma</span></span> walk_iarray_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_iarray <span class="free">f</span> <span class="main">(</span>IArray <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>walk_iarray <span class="free">f</span> <span class="main">(</span>IArray <span class="free">xs</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_Cons<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_iarray_foldl'"><span class="command">lemma</span></span> walk_iarray_foldl'<span class="main">:</span>
   <span class="quoted"><span class="quoted">"walk_iarray <span class="free">f</span> <span class="main">(</span>IArray <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> foldl <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_append<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_iarray_foldl"><span class="command">lemma</span></span> walk_iarray_foldl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_iarray <span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="main">=</span> foldl <span class="free">f</span> <span class="free">x</span> <span class="main">(</span>IArray.list_of <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_foldl'<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> iarray <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">h</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">h</span> <span class="main">*</span> <span class="numeral">33</span> <span class="main">+</span> hashcode <span class="bound">v</span><span class="main">)</span> <span class="main">0</span> <span class="main">(</span>IArray.list_of <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'a</span> iarray itself<span class="main">.</span> <span class="numeral">10</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_iarray_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="free">a</span> <span class="main">=</span> walk_iarray <span class="main">(</span><span class="main">λ</span><span class="bound">h</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">h</span> <span class="main">*</span> <span class="numeral">33</span> <span class="main">+</span> hashcode <span class="bound">v</span><span class="main">)</span> <span class="free">a</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_iarray_foldl<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Other instantiations for types from Main *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> array <span class="main">::</span> <span class="main">(</span><span class="quoted">linorder</span><span class="main">)</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_array</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> array<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> array<span class="main">)</span> <span class="main">⟷</span> lexlist <span class="main">(</span>list_of_array <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">≤</span> lexlist <span class="main">(</span>list_of_array <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_array</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> array<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> array<span class="main">)</span> <span class="main">⟷</span> lexlist <span class="main">(</span>list_of_array <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">&lt;</span> lexlist <span class="main">(</span>list_of_array <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> array.exhaust list_of_array.simps lexlist_ext lexlist_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Same for arrays from the ICF.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">walk_array'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> array <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">walk_array'</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">walk_array'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">y</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>array_get <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
                                  <span class="keyword1">in</span> <span class="free">walk_array'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">y</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-walk_array'_Cons"><span class="command">lemma</span></span> walk_array'_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_array' <span class="free">f</span> <span class="main">(</span>Array <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="free">l</span> <span class="main">(</span>Suc <span class="free">p</span><span class="main">)</span> <span class="main">=</span> walk_array' <span class="free">f</span> <span class="main">(</span>Array <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="free">l</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">walk_array</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> array <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">walk_array</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> walk_array' <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>array_length <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">0</span>"</span></span>

<span class="keyword1" id="PromelaDatastructures-walk_array_Cons"><span class="command">lemma</span></span> walk_array_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_array <span class="free">f</span> <span class="main">(</span>Array <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> walk_array <span class="free">f</span> <span class="main">(</span>Array <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_def walk_array'_Cons<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_array_append"><span class="command">lemma</span></span> walk_array_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_array <span class="free">f</span> <span class="main">(</span>Array <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>walk_array <span class="free">f</span> <span class="main">(</span>Array <span class="free">xs</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_Cons<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_array_foldl'"><span class="command">lemma</span></span> walk_array_foldl'<span class="main">:</span>
   <span class="quoted"><span class="quoted">"walk_array <span class="free">f</span> <span class="main">(</span>Array <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> foldl <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_append<span class="main">)</span>

<span class="keyword1" id="PromelaDatastructures-walk_array_foldl"><span class="command">lemma</span></span> walk_array_foldl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"walk_array <span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="main">=</span> foldl <span class="free">f</span> <span class="free">x</span> <span class="main">(</span>list_of_array <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_foldl'<span class="main">)</span>

<span class="comment1">(* TODO: Move to array.thy *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> array <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">h</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">h</span> <span class="main">*</span> <span class="numeral">33</span> <span class="main">+</span> hashcode <span class="bound">v</span><span class="main">)</span> <span class="main">0</span> <span class="main">(</span>list_of_array <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'a</span> array itself<span class="main">.</span> <span class="numeral">10</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_array_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="free">a</span> <span class="main">=</span> walk_array <span class="main">(</span><span class="main">λ</span><span class="bound">h</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">h</span> <span class="main">*</span> <span class="numeral">33</span> <span class="main">+</span> hashcode <span class="bound">v</span><span class="main">)</span> <span class="free">a</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_array_foldl<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*subsection {* Ours *}*)</span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">varType</span>
<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">variable</span>

<span class="keyword1"><span class="command">instantiation</span></span> varType <span class="main">::</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_varType</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span>varType itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">hashcode_varType</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">hashcode_varType</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">i1</span></span></span> <span class="free"><span class="bound"><span class="entity">i2</span></span></span><span class="main">)</span> <span class="main">=</span> hashcode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i2</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">hashcode_varType</span> VTChan <span class="main">=</span> <span class="numeral">23</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_varType_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> variable <span class="main">::</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_variable</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span>variable itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">hashcode_variable</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">hashcode_variable</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">i1</span></span></span> <span class="free"><span class="bound"><span class="entity">i2</span></span></span><span class="main">)</span> <span class="main">=</span> hashcode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i2</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">hashcode_variable</span> <span class="main">(</span>VArray <span class="free"><span class="bound"><span class="entity">i1</span></span></span> <span class="free"><span class="bound"><span class="entity">i2</span></span></span> <span class="free"><span class="bound"><span class="entity">ia</span></span></span><span class="main">)</span> <span class="main">=</span> hashcode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i2</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ia</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_variable_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">channel_to_tuple</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">channel_to_tuple</span> <span class="main">(</span>Channel <span class="free"><span class="bound"><span class="entity">io</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">iss</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">,</span><span class="free"><span class="bound"><span class="entity">io</span></span></span><span class="main">,</span>lexlist <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">,</span> lexlist <span class="main">(</span>map lexlist <span class="free"><span class="bound"><span class="entity">iss</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">channel_to_tuple</span> <span class="main">(</span>HSChannel <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="main">0</span><span class="main">,</span>lexlist <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">,</span> lexlist <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">channel_to_tuple</span> InvChannel <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">,</span>lexlist <span class="main">[]</span><span class="main">,</span> lexlist <span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> channel <span class="main">::</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_channel</span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟷</span> channel_to_tuple <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≤</span> channel_to_tuple <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_channel</span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟷</span> channel_to_tuple <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&lt;</span> channel_to_tuple <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">y</span></span></span></span></span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_inj_on 
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI lexlist_ext 
                <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Lex_inject lexlist_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> channel <span class="main">::</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_channel</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span>channel itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">hashcode_channel</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">hashcode_channel</span> <span class="main">(</span>Channel <span class="free"><span class="bound"><span class="entity">io</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">iss</span></span></span><span class="main">)</span> <span class="main">=</span> hashcode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">io</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">iss</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hashcode_channel</span> <span class="main">(</span>HSChannel <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">42</span> <span class="main">*</span> hashcode <span class="free"><span class="bound"><span class="entity">vs</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hashcode_channel</span> InvChannel <span class="main">=</span> <span class="numeral">4711</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_channel_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">pState2HASH</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pState2HASH</span> <span class="main">⦇</span> pid <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> pc <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> idx <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⦈</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> lexlist <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> pState.surjective<span class="main">)</span> <span class="operator">force</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1" id="PromelaDatastructures-pState2HASH_eq"><span class="command">lemma</span></span> pState2HASH_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pState2HASH <span class="free">x</span> <span class="main">=</span> pState2HASH <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lexlist_ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lexlist_def<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> pState_ext <span class="main">::</span> <span class="main">(</span><span class="quoted">linorder</span><span class="main">)</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_pState_ext</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> pState_ext<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> pState_ext<span class="main">)</span> <span class="main">⟷</span> pState2HASH <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> pState2HASH <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_pState_ext</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> pState_ext<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> pState_ext<span class="main">)</span> <span class="main">⟷</span> pState2HASH <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> pState2HASH <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pState2HASH_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> pState_ext <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_pState_ext</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span><span class="tfree">'a</span> pState_ext itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="main">≡</span> hashcode <span class="main">∘</span> pState2HASH"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_pState_ext_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">gState2HASH</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gState2HASH</span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⦈</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> lexlist <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> lexlist <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gState.surjective<span class="main">)</span> <span class="operator">force</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1" id="PromelaDatastructures-gState2HASH_eq"><span class="command">lemma</span></span> gState2HASH_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState2HASH <span class="free">x</span> <span class="main">=</span> gState2HASH <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lexlist_ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lexlist_def<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> gState_ext <span class="main">::</span> <span class="main">(</span><span class="quoted">linorder</span><span class="main">)</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_gState_ext</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> gState_ext<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> gState_ext<span class="main">)</span> <span class="main">⟷</span> gState2HASH <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> gState2HASH <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_gState_ext</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> gState_ext<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> gState_ext<span class="main">)</span> <span class="main">⟷</span> gState2HASH <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> gState2HASH <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gState2HASH_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> gState_ext <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">def_hashmap_size_gState_ext</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span><span class="tfree">'a</span> gState_ext itself<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="numeral">10</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="main">≡</span> hashcode <span class="main">∘</span> gState2HASH"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_gState_ext_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PromelaInvariants">
<div class="head">
<h1>Theory PromelaInvariants</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Invariants for Promela data structures"</span></span>
<span class="keyword1"><span class="command">theory</span></span> PromelaInvariants
<span class="keyword2"><span class="keyword">imports</span></span> <a href="PromelaDatastructures.html">PromelaDatastructures</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The different data structures used in the Promela implementation require different invariants,
  which are specified in this file. As there is no (useful) way of specifying \emph{correctness} of the implementation,
those invariants are tailored towards proving the finitness of the generated state-space. 
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="comment1">(*subsection {* Auxiliary lemmas *}*)</span>
<span class="keyword1" id="PromelaInvariants-foldli_set"><span class="command">lemma</span></span> foldli_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>foldli <span class="free">list</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(#)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span> <span class="main">∪</span> set <span class="free">list</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">list</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="PromelaInvariants-foldli_conj"><span class="command">lemma</span></span> foldli_conj<span class="main">:</span>
  <span class="quoted"><span class="quoted">"foldli <span class="free">list</span> id <span class="main">(</span><span class="main">λ</span><span class="bound">kv</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">kv</span><span class="main">)</span> <span class="free">b</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">list</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="comment1">(* Destroy the evil border of abstraction... *)</span>
<span class="keyword1" id="PromelaInvariants-lm_ball_Assoc_List_set"><span class="command">lemma</span></span> lm_ball_Assoc_List_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lm.ball <span class="free">m</span> <span class="free">P</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> Assoc_List.set <span class="free">m</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Assoc_List.set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">icf_rec_unf</span></span> lm_basic.g_ball_def 
    poly_map_iteratei_defs.iteratei_def it_to_it_def Assoc_List.iteratei_def
    foldli_conj<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-lm_to_list_Assoc_List_set"><span class="command">lemma</span></span> lm_to_list_Assoc_List_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>lm.to_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> Assoc_List.set <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Assoc_List.set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">icf_rec_unf</span></span> lm_basic.g_to_list_def 
    poly_map_iteratei_defs.iteratei_def it_to_it_def Assoc_List.iteratei_def 
    foldli_set<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-dom_lm_α_Assoc_List_set"><span class="command">lemma</span></span> dom_lm_α_Assoc_List_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>lm.α <span class="free">v</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">`</span> <span class="main">(</span>Assoc_List.set <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">icf_rec_unf</span></span> Assoc_List.lookup_def Assoc_List.set_def
    dom_map_of_conv_image_fst<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-ran_lm_α_Assoc_List_set"><span class="command">lemma</span></span> ran_lm_α_Assoc_List_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ran <span class="main">(</span>lm.α <span class="free">v</span><span class="main">)</span> <span class="main">=</span> snd <span class="main">`</span> <span class="main">(</span>Assoc_List.set <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">icf_rec_unf</span></span> Assoc_List.lookup_def Assoc_List.set_def 
    ran_distinct<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-lm_ball_eq_ran"><span class="command">lemma</span></span> lm_ball_eq_ran<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lm.ball <span class="free">v</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⟷</span> ran <span class="main">(</span>lm.α <span class="free">v</span><span class="main">)</span> <span class="main">⊆</span> Collect <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ran_lm_α_Assoc_List_set lm_ball_Assoc_List_set<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-lm_ball_lm_to_map_map_weaken"><span class="command">lemma</span></span> lm_ball_lm_to_map_map_weaken<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">`</span> set <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> lm.ball <span class="main">(</span>lm.to_map <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-Assoc_List_set_eq_lookup"><span class="command">lemma</span></span> Assoc_List_set_eq_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> Assoc_List.set <span class="free">vs</span> <span class="main">⟷</span> Assoc_List.lookup <span class="free">vs</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Assoc_List.lookup_def Assoc_List.set_def<span class="main">)</span> 

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Bounds›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finiteness requires that possible variable ranges are finite, as is the maximium number of processes.
  Currently, they are supplied here as constants. In a perfect world, they should be able to be set dynamically. 
›</span></span>

<span class="comment1">(* NB! Make sure those values coincide with the bounds definied in @{const ppVarType} *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_var_value</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_var_value</span> <span class="main">=</span> <span class="main">-</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">31</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">max_var_value</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">max_var_value</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="numeral">31</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-min_max_var_value_simps"><span class="command">lemma</span></span> min_max_var_value_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_var_value <span class="main">&lt;</span> max_var_value"</span></span>
  <span class="quoted"><span class="quoted">"min_var_value <span class="main">&lt;</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"min_var_value <span class="main">≤</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"max_var_value <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"max_var_value <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_var_value_def max_var_value_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">max_procs</span> <span class="main">≡</span> <span class="numeral">255</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">max_channels</span> <span class="main">≡</span> <span class="numeral">65535</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">max_array_size</span> <span class="main">=</span> <span class="numeral">65535</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Variables and similar›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">varType_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varType <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">varType_inv</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≥</span> min_var_value <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≤</span> max_var_value <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varType_inv</span> VTChan <span class="main">⟷</span> True"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">variable_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"variable <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">variable_inv</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> varType_inv <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">∈</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">variable_inv</span> <span class="main">(</span>VArray <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">sz</span></span></span> <span class="free"><span class="bound"><span class="entity">ar</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> varType_inv <span class="free"><span class="bound"><span class="entity">t</span></span></span> 
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">sz</span></span></span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> IArray.length <span class="free"><span class="bound"><span class="entity">ar</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">sz</span></span></span> 
    <span class="main">∧</span> set <span class="main">(</span>IArray.list_of <span class="free"><span class="bound"><span class="entity">ar</span></span></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">channel_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"channel <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">channel_inv</span> <span class="main">(</span>Channel <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≥</span> <span class="main">0</span> 
    <span class="main">∧</span> set <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">⊆</span> Collect varType_inv 
    <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">.</span> length <span class="bound">x</span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> 
    <span class="main">∧</span> set <span class="bound">x</span> <span class="main">⊆</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">channel_inv</span> <span class="main">(</span>HSChannel <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> set <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">⊆</span> Collect varType_inv <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">≤</span> max_array_size"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">channel_inv</span> InvChannel <span class="main">⟷</span> True"</span></span>

<span class="keyword1" id="PromelaInvariants-varTypes_finite"><span class="command">lemma</span></span> varTypes_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect varType_inv<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Collect <span class="main">(</span>varType_inv<span class="main">)</span> <span class="main">⊆</span> 
      <span class="main">{</span>VTChan<span class="main">}</span> 
    <span class="main">∪</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">h</span><span class="main">)</span><span class="main">.</span> VTBounded <span class="bound">l</span> <span class="bound">h</span><span class="main">)</span> 
      <span class="main">`</span> <span class="main">(</span><span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span> <span class="main">×</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaInvariants-variables_finite"><span class="command">lemma</span></span> variables_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect variable_inv<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?V1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">val</span><span class="main">)</span><span class="main">.</span> Var <span class="bound">t</span> <span class="bound">val</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">vt</span><span class="main">.</span> varType_inv <span class="bound">vt</span><span class="main">}</span> <span class="main">×</span> <span class="var">?mm</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?V2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">sz</span><span class="main">,</span><span class="bound">ar</span><span class="main">)</span><span class="main">.</span> VArray <span class="bound">t</span> <span class="bound">sz</span> <span class="bound">ar</span><span class="main">)</span> 
    <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">vt</span><span class="main">.</span> varType_inv <span class="bound">vt</span><span class="main">}</span> 
      <span class="main">×</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>max_array_size<span class="main">}</span> 
      <span class="main">×</span> <span class="main">{</span><span class="bound">ar</span><span class="main">.</span> IArray.length <span class="bound">ar</span> <span class="main">≤</span> max_array_size 
           <span class="main">∧</span> set <span class="main">(</span>IArray.list_of <span class="bound">ar</span><span class="main">)</span> <span class="main">⊆</span> <span class="var">?mm</span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?LS</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="skolem">A</span> <span class="main">∧</span> length <span class="bound">xs</span> <span class="main">≤</span> max_array_size <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?AS</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ar</span><span class="main">.</span> IArray.length <span class="bound">ar</span> <span class="main">≤</span> max_array_size 
      <span class="main">∧</span> set <span class="main">(</span>IArray.list_of <span class="bound">ar</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">A</span><span class="main">}</span>"</span></span>

    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?LS</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_lists_length_le<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?AS</span> <span class="main">⊆</span> IArray <span class="main">`</span> <span class="var">?LS</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"IArray.list_of <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> iarray.exhaust list_of.simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?AS</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> finite_arr <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Collect variable_inv <span class="main">⊆</span> <span class="main">(</span><span class="var">?V1</span> <span class="main">∪</span> <span class="var">?V2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> varTypes_finite finite_arr<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaInvariants-channels_finite"><span class="command">lemma</span></span> channels_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect channel_inv<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C1</span></span></span> <span class="main">=</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cap</span><span class="main">,</span><span class="bound">ts</span><span class="main">,</span><span class="bound">q</span><span class="main">)</span><span class="main">.</span> Channel <span class="bound">cap</span> <span class="bound">ts</span> <span class="bound">q</span><span class="main">)</span> 
     <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="main">0</span><span class="main">..</span>max_array_size<span class="main">}</span> 
      <span class="main">×</span> <span class="main">{</span><span class="bound">ts</span><span class="main">.</span> set <span class="bound">ts</span> <span class="main">⊆</span> Collect varType_inv <span class="main">∧</span> length <span class="bound">ts</span> <span class="main">≤</span> max_array_size<span class="main">}</span> 
      <span class="main">×</span> <span class="main">{</span><span class="bound">q</span><span class="main">.</span> set <span class="bound">q</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> set <span class="bound">x</span> <span class="main">⊆</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span> 
                        <span class="main">∧</span> length <span class="bound">x</span> <span class="main">≤</span> max_array_size<span class="main">}</span> 
            <span class="main">∧</span> length <span class="bound">q</span> <span class="main">≤</span> max_array_size<span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C2</span></span></span> <span class="main">=</span> 
    <span class="quoted"><span class="quoted">"HSChannel <span class="main">`</span> <span class="main">{</span><span class="bound">ts</span><span class="main">.</span> set <span class="bound">ts</span> <span class="main">⊆</span> Collect varType_inv <span class="main">∧</span> length <span class="bound">ts</span> <span class="main">≤</span> max_array_size<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C3</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>InvChannel<span class="main">}</span>"</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Collect channel_inv<span class="main">)</span> <span class="main">⊆</span> <span class="var">?C1</span> <span class="main">∪</span> <span class="var">?C2</span> <span class="main">∪</span> <span class="var">?C3</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_lists_length_le varTypes_finite<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To give an upper bound of variable names, we need a way to calculate it.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">procArgName</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"procArg <span class="main">⇒</span> String.literal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">procArgName</span> <span class="main">(</span>ProcArg <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">varDeclName</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varDecl <span class="main">⇒</span> String.literal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">varDeclName</span> <span class="main">(</span>VarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varDeclName</span> <span class="main">(</span>VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">procVarDeclName</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"procVarDecl <span class="main">⇒</span> String.literal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">procVarDeclName</span> <span class="main">(</span>ProcVarDeclNum <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">procVarDeclName</span> <span class="main">(</span>ProcVarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">edgeDecls</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> procVarDecl set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">edgeDecls</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> effect <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span>
      EEDecl <span class="bound">p</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span>
    <span class="main">|</span>  <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="PromelaInvariants-edgeDecls_finite"><span class="command">lemma</span></span> edgeDecls_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edgeDecls <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edgeDecls_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> edgeEffect.split<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">edgeSet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"states <span class="main">⇒</span> edge set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">edgeSet</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> set <span class="main">(</span>concat <span class="main">(</span>map snd <span class="main">(</span>IArray.list_of <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-edgeSet_finite"><span class="command">lemma</span></span> edgeSet_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edgeSet <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edgeSet_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">statesDecls</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"states <span class="main">⇒</span> procVarDecl set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">statesDecls</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>edgeDecls <span class="main">`</span> <span class="main">(</span>edgeSet <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">statesNames</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"states <span class="main">⇒</span> String.literal set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">statesNames</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> procVarDeclName <span class="main">`</span> statesDecls <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1" id="PromelaInvariants-statesNames_finite"><span class="command">lemma</span></span> statesNames_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>statesNames <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edgeSet_finite edgeDecls_finite statesNames_def statesDecls_def<span class="main">)</span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">process_names</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"states <span class="main">⇒</span> process <span class="main">⇒</span> String.literal set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">process_names</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span> <span class="main">=</span> 
      statesNames <span class="free"><span class="bound"><span class="entity">ss</span></span></span> 
    <span class="main">∪</span> procArgName <span class="main">`</span> set <span class="free"><span class="bound"><span class="entity">args</span></span></span> 
    <span class="main">∪</span> varDeclName <span class="main">`</span> set <span class="free"><span class="bound"><span class="entity">decls</span></span></span>
    <span class="main">∪</span> <span class="main">{</span><span class="keyword1">STR</span> <span class="inner_quoted">''_''</span><span class="main">,</span> <span class="keyword1">STR</span> <span class="inner_quoted">''__assert__''</span><span class="main">,</span> <span class="keyword1">STR</span> <span class="inner_quoted">''_pid''</span><span class="main">}</span>"</span></span> <span class="comment1">(* dunno if this is ok as a fixed set ... *)</span>

<span class="keyword1" id="PromelaInvariants-process_names_finite"><span class="command">lemma</span></span> process_names_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>process_names <span class="free">ss</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> statesNames_finite<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">vardict_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"states <span class="main">⇒</span> process <span class="main">⇒</span> var_dict <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vardict_inv</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> 
   <span class="main">⟷</span> lm.ball <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">k</span> <span class="main">∈</span> process_names <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> variable_inv <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-vardicts_finite"><span class="command">lemma</span></span> vardicts_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect <span class="main">(</span>vardict_inv <span class="free">ss</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Assoc_List.set <span class="main">`</span> Collect <span class="main">(</span>vardict_inv <span class="free">ss</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> 
           Pow <span class="main">(</span>process_names <span class="free">ss</span> <span class="free">p</span> <span class="main">×</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> variable_inv <span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm_ball_Assoc_List_set vardict_inv_def<span class="main">)</span>

  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> process_names_finite variables_finite
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_Assoc_List_set_image finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaInvariants-lm_to_map_vardict_inv"><span class="command">lemma</span></span> lm_to_map_vardict_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="bound">k</span> <span class="main">∈</span> process_names <span class="free">ss</span> <span class="free">proc</span> <span class="main">∧</span> variable_inv <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="main">(</span>lm.to_map <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> vardict_inv_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_of_SomeD<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariants of a process›</span></span>

<span class="comment1">(* The definition of a channel to be between -1 and max_channels definitly lacks the necessary abstraction ... *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pState_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> pState <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pState_inv</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> 
  <span class="main">⟷</span> pid <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≤</span> max_procs
    <span class="main">∧</span> pState.idx <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> 
    <span class="main">∧</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">=</span> IArray.length <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span>
    <span class="main">∧</span> pc <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&lt;</span> IArray.length <span class="main">(</span><span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">!!</span> pState.idx <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
    <span class="main">∧</span> set <span class="main">(</span>pState.channels <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">-</span><span class="main">1</span><span class="main">..&lt;</span>integer_of_nat max_channels<span class="main">}</span> 
    <span class="main">∧</span> length <span class="main">(</span>pState.channels <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">≤</span> max_channels
    <span class="main">∧</span> vardict_inv <span class="main">(</span><span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">!!</span> pState.idx <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> 
                  <span class="main">(</span><span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">!!</span> pState.idx <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> 
                  <span class="main">(</span>pState.vars <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-pStates_finite"><span class="command">lemma</span></span> pStates_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect <span class="main">(</span>pState_inv <span class="free">prog</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span>max_procs<span class="main">::</span>nat<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span>IArray.length <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P3</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span>Max <span class="main">(</span>IArray.length <span class="main">`</span> <span class="main">(</span>set <span class="main">(</span>IArray.list_of <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P4</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">cs</span><span class="main">.</span> set <span class="bound">cs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">-</span><span class="main">1</span><span class="main">..&lt;</span>integer_of_nat max_channels<span class="main">}</span> 
                  <span class="main">∧</span> length <span class="bound">cs</span> <span class="main">≤</span> max_channels<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P5</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="main">{..</span>IArray.length <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span><span class="main">}</span><span class="main">.</span> 
                Collect <span class="main">(</span>vardict_inv <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?P1</span> <span class="main">×</span> <span class="var">?P2</span> <span class="main">×</span> <span class="var">?P3</span> <span class="main">×</span> <span class="var">?P4</span> <span class="main">×</span> <span class="var">?P5</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">p</span><span class="main">.</span> pState_inv <span class="free">prog</span> <span class="bound">p</span><span class="main">}</span> <span class="main">⊆</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">pid</span><span class="main">,</span><span class="bound">idx</span><span class="main">,</span><span class="bound">pc</span><span class="main">,</span><span class="bound">channels</span><span class="main">,</span><span class="bound">vars</span><span class="main">)</span><span class="main">.</span> pState.make <span class="bound">pid</span> <span class="bound">vars</span> <span class="bound">pc</span> <span class="bound">channels</span> <span class="bound">idx</span><span class="main">)</span> <span class="main">`</span> <span class="var">?P</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pState_inv_def image_def <span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState.defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Record.split_simp_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>K <span class="inner_numeral">~1</span><span class="main">)</span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> less_imp_le<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?P4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_lists_length_le<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_cartesian_product <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vardicts_finite<span class="main">)</span>

  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> finite_subset<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> finite_imageI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Throughout the calculation of the semantic engine, a modified process is not necessarily part of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"procs <span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Hence we need to establish an additional constraint for the relation between a global and a process state.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cl_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cl_inv</span> <span class="free"><span class="bound"><span class="entity">gp</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">gp</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">⇒</span> 
      length <span class="main">(</span>pState.channels <span class="bound">p</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>gState.channels <span class="bound">g</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-cl_inv_lengthD"><span class="command">lemma</span></span> cl_inv_lengthD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>pState.channels <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cl_inv_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="PromelaInvariants-cl_invI"><span class="command">lemma</span></span> cl_invI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>pState.channels <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cl_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_trans"><span class="command">lemma</span></span> cl_inv_trans<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>channels <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>channels <span class="free">g'</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g'</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_vars_update"><span class="command">lemma</span></span> cl_inv_vars_update<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span> pState.vars_update <span class="free">vs</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span>gState.vars_update <span class="free">vs</span> <span class="free">g</span><span class="main">,</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_handshake_update"><span class="command">lemma</span></span> cl_inv_handshake_update<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">⦇</span>handshake <span class="main">:=</span> <span class="free">h</span><span class="main">⦈</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_hsdata_update"><span class="command">lemma</span></span> cl_inv_hsdata_update<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">⦇</span>hsdata <span class="main">:=</span> <span class="free">h</span><span class="main">⦈</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_procs_update"><span class="command">lemma</span></span> cl_inv_procs_update<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">⦇</span>procs <span class="main">:=</span> <span class="free">ps</span><span class="main">⦈</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-cl_inv_channels_update"><span class="command">lemma</span></span> cl_inv_channels_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>gState.channels_update <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span><span class="main">[</span><span class="free">i</span><span class="main">:=</span><span class="free">c</span><span class="main">]</span><span class="main">)</span> <span class="free">g</span><span class="main">,</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cl_inv_def 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariants of the global state›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">gState_inv</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be defined in a way to be applicable to both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">gState</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">gState<span class="hidden">⇩</span><sub>I</sub></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gState_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gState_inv</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
  <span class="main">⟷</span> length <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">≤</span> max_procs 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span> <span class="main">∈</span> set <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">.</span> pState_inv <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">p</span> <span class="main">∧</span> cl_inv <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> length <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">≤</span> max_channels
    <span class="main">∧</span> set <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">⊆</span> Collect channel_inv
    <span class="main">∧</span> lm.ball <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> variable_inv <span class="bound">v</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The set of global states adhering to the terms of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> gState_inv<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not finite.
But the set of all global states that can be constructed by the semantic engine from one starting state is. 
Thus we establish a progress relation, \ie all successors of a state <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> relate to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> under this specification.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gState_progress_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> gState_scheme<span class="main">)</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gState_progress_rel</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span><span class="main">.</span> gState_inv <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">g</span> <span class="main">∧</span> gState_inv <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">g'</span>
                                  <span class="main">∧</span> length <span class="main">(</span>channels <span class="bound">g</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>channels <span class="bound">g'</span><span class="main">)</span>
                                  <span class="main">∧</span> dom <span class="main">(</span>lm.α <span class="main">(</span>vars <span class="bound">g</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>lm.α <span class="main">(</span>vars <span class="bound">g'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_gState_invI1"><span class="command">lemma</span></span> gState_progress_rel_gState_invI1<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> <span class="main">⟹</span> gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_gState_invI2"><span class="command">lemma</span></span> gState_progress_rel_gState_invI2<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> <span class="main">⟹</span> gState_inv <span class="free">prog</span> <span class="free">g'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_relI"><span class="command">lemma</span></span> gState_progress_relI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>channels <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>channels <span class="free">g'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>lm.α <span class="main">(</span>vars <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>lm.α <span class="main">(</span>vars <span class="free">g'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gState_progress_rel_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_refl"><span class="command">lemma</span></span> gState_progress_refl<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gState_progress_rel_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="PromelaInvariants-refl_on_gState_progress_rel"><span class="command">lemma</span></span> refl_on_gState_progress_rel<span class="main">:</span>
  <span class="quoted"><span class="quoted">"refl_on <span class="main">(</span>Collect <span class="main">(</span>gState_inv <span class="free">prog</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-trans_gState_progress_rel"><span class="command">lemma</span></span> trans_gState_progress_rel<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"trans <span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> transI<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gState_progress_rel_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span> <span class="main">=</span> trans_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> transD<span class="main">]</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_trancl_id"><span class="command">lemma</span></span> gState_progress_rel_trancl_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">=</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_rtrancl_absorb"><span class="command">lemma</span></span> gState_progress_rel_rtrancl_absorb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span> <span class="main">=</span> gState_progress_rel <span class="free">prog</span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms refl_on_gState_progress_rel
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Image_absorb_rtrancl<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The main theorem: The set of all global states reachable from an initial state, is finite.
›</span></span>
<span class="keyword1" id="PromelaInvariants-gStates_finite"><span class="command">lemma</span></span> gStates_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"gState"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Image_empty_rtrancl_Image_id<span class="main">)</span> 
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">m</span><span class="main">.</span> dom <span class="main">(</span>lm.α <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>lm.α <span class="main">(</span>vars <span class="free">g</span><span class="main">)</span><span class="main">)</span> 
                 <span class="main">∧</span> ran <span class="main">(</span>lm.α <span class="bound">m</span><span class="main">)</span> <span class="main">⊆</span> Collect variable_inv <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">cs</span><span class="main">.</span> set <span class="bound">cs</span> <span class="main">⊆</span> Collect channel_inv 
                  <span class="main">∧</span> length <span class="bound">cs</span> <span class="main">≤</span> max_channels<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G4</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ps</span><span class="main">.</span> set <span class="bound">ps</span> <span class="main">⊆</span> Collect <span class="main">(</span>pState_inv <span class="free">prog</span><span class="main">)</span> 
                  <span class="main">∧</span> length <span class="bound">ps</span> <span class="main">≤</span> max_procs<span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span> <span class="main">×</span> <span class="var">?G2</span> <span class="main">×</span> <span class="var">?G3</span> <span class="main">×</span> <span class="var">?G4</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">vars</span><span class="main">,</span><span class="bound">chans</span><span class="main">,</span><span class="bound">t</span><span class="main">,</span><span class="bound">ps</span><span class="main">)</span><span class="main">.</span> gState.make <span class="bound">vars</span> <span class="bound">chans</span> <span class="bound">t</span> <span class="bound">ps</span><span class="main">)</span> <span class="main">`</span> <span class="var">?G</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="var">?G1</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">v'</span><span class="main">.</span> fst <span class="main">`</span> Assoc_List.set <span class="bound">v'</span> <span class="main">=</span> fst <span class="main">`</span> Assoc_List.set <span class="main">(</span>vars <span class="free">g</span><span class="main">)</span> 
                     <span class="main">∧</span> snd <span class="main">`</span> Assoc_List.set <span class="bound">v'</span> <span class="main">⊆</span> Collect variable_inv<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_lm_α_Assoc_List_set ran_lm_α_Assoc_List_set<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?X</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_Assoc_List_set_image<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> finite_subset<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Assoc_List.set <span class="main">`</span> <span class="var">?X</span> <span class="main">⊆</span> 
             Pow <span class="main">(</span>fst <span class="main">`</span> Assoc_List.set <span class="main">(</span>vars <span class="free">g</span><span class="main">)</span> <span class="main">×</span> Collect variable_inv<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> variables_finite dom_lm_α_Assoc_List_set<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span> <span class="main">⊆</span> 
           <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">vars</span><span class="main">,</span><span class="bound">chans</span><span class="main">,</span><span class="bound">t</span><span class="main">,</span><span class="bound">ps</span><span class="main">)</span><span class="main">.</span> gState.make <span class="bound">vars</span> <span class="bound">chans</span> <span class="bound">t</span> <span class="bound">ps</span><span class="main">)</span> <span class="main">`</span> <span class="var">?G</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def gState_inv_def gState.defs gState_progress_rel_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"vars <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm_ball_eq_ran<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"channels <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"timeout <span class="improper">x</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"procs <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> G1 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_lists_length_le channels_finite pStates_finite<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> gState_progress_rel_rtrancl_absorb<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_channels_update"><span class="command">lemma</span></span> gState_progress_rel_channels_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"channel_inv <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>channels <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span>gState.channels_update <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span><span class="main">[</span><span class="free">i</span><span class="main">:=</span><span class="free">c</span><span class="main">]</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> gState_progress_relI 
         <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def 
         <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_update_subset_insert<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-gState_progress_rel_channels_update_step"><span class="command">lemma</span></span> gState_progress_rel_channels_update_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"channel_inv <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>channels <span class="free">g'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span>gState.channels_update <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span><span class="main">[</span><span class="free">i</span><span class="main">:=</span><span class="free">c</span><span class="main">]</span><span class="main">)</span> <span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> step
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> gState_progress_rel_channels_update<span class="main">[</span><span class="operator">OF</span> this assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariants of the program›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Naturally, we need our program to also adhere to certain invariants. Else we can't show, that
  the generated states are correct according to the invariants above.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">program_inv</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">program_inv</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> 
  <span class="main">⟷</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>
    <span class="main">∧</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">=</span> IArray.length <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">s</span> <span class="main">∈</span> set <span class="main">(</span>IArray.list_of <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">.</span> IArray.length <span class="bound">s</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>
    <span class="main">∧</span> lm.ball <span class="main">(</span>proc_data <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> 
              <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">sidx</span><span class="main">)</span><span class="main">.</span> 
                    <span class="bound">sidx</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> 
                  <span class="main">∧</span> fst <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">sidx</span><span class="main">)</span> <span class="main">=</span> <span class="bound">sidx</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">sidx</span><span class="main">,</span><span class="bound">start</span><span class="main">,</span><span class="bound">procArgs</span><span class="main">,</span><span class="bound">args</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>IArray.list_of <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">.</span> 
        <span class="main">(</span><span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="bound">start</span> <span class="main">=</span> Index <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">sidx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaInvariants-program_inv_length_states"><span class="command">lemma</span></span> program_inv_length_states<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"IArray.length <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="free">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> program_inv_def<span class="main">)</span>

<span class="keyword1" id="PromelaInvariants-program_invI"><span class="command">lemma</span></span> program_invI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"IArray.length <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span> <span class="main">=</span> IArray.length <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">∈</span> set <span class="main">(</span>IArray.list_of <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span><span class="main">)</span> 
           <span class="main">⟹</span> <span class="main">0</span> <span class="main">&lt;</span> IArray.length <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">sidx</span><span class="main">.</span> <span class="bound">sidx</span> <span class="main">∈</span> ran <span class="main">(</span>lm.α <span class="main">(</span>proc_data <span class="free">prog</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">⟹</span> <span class="bound">sidx</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span> 
                  <span class="main">∧</span> fst <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="bound">sidx</span><span class="main">)</span> <span class="main">=</span> <span class="bound">sidx</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">sidx</span> <span class="bound">start</span> <span class="bound">procArgs</span> <span class="bound">args</span><span class="main">.</span> 
         <span class="main">(</span><span class="bound">sidx</span><span class="main">,</span><span class="bound">start</span><span class="main">,</span><span class="bound">procArgs</span><span class="main">,</span><span class="bound">args</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>IArray.list_of <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span><span class="main">)</span> 
         <span class="main">⟹</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="bound">start</span> <span class="main">=</span> Index <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="bound">sidx</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> program_inv_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm_ball_eq_ran<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Promela">
<div class="head">
<h1>Theory Promela</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Formalization of Promela semantics"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Promela
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="PromelaDatastructures.html">PromelaDatastructures</a>
  <a href="PromelaInvariants.html">PromelaInvariants</a>
  <a href="PromelaStatistics.html">PromelaStatistics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary›</span></span>

<span class="keyword1" id="Promela-mod_integer_le"><span class="command">lemma</span></span> mod_integer_le<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_pos_nonneg discrete not_less order.strict_trans2
    unique_euclidean_semiring_numeral_class.pos_mod_bound zero_le_one<span class="main">)</span>

<span class="keyword1" id="Promela-mod_integer_ge"><span class="command">lemma</span></span> mod_integer_ge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">≤</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.trans less_add_one order.strict_trans
    unique_euclidean_semiring_numeral_class.pos_mod_sign<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  After having defined the datastructures, we present in this theory how to construct the transition system and how to generate the successors of a state, \ie the real semantics of a Promela program.
  For the first task, we take the enriched AST as input, the second one operates on the transition system.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Misc Helpers›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_label</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> labels <span class="main">⇒</span> nat <span class="main">⇒</span> labels"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_label</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="keyword1">of</span> 
       None <span class="main">⇒</span> lm.update <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span>
     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Label given twice: ''</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_prio</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge list <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_prio</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">start</span></span></span> <span class="main">=</span> Min <span class="main">(</span><span class="main">(</span>prio <span class="main">`</span> set <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">start</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-min_prio_code"><span class="command">lemma</span></span> min_prio_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_prio <span class="free">es</span> <span class="free">start</span> <span class="main">=</span> fold  <span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">pri</span><span class="main">.</span> <span class="keyword1">if</span> prio <span class="bound">e</span> <span class="main">&lt;</span> <span class="bound">pri</span> <span class="keyword1">then</span> prio <span class="bound">e</span> <span class="keyword1">else</span> <span class="bound">pri</span><span class="main">)</span> <span class="free">es</span> <span class="free">start</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> Min.set_eq_fold <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="free">start</span> <span class="main">#</span> map prio <span class="free">es</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fold min <span class="main">(</span>map prio <span class="free">es</span><span class="main">)</span> <span class="free">start</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> fold <span class="main">(</span>min <span class="main">∘</span> prio<span class="main">)</span> <span class="free">es</span> <span class="free">start</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_map<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> fold  <span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">pri</span><span class="main">.</span> <span class="keyword1">if</span> prio <span class="bound">e</span> <span class="main">&lt;</span> <span class="bound">pri</span> <span class="keyword1">then</span> prio <span class="bound">e</span> <span class="keyword1">else</span> <span class="bound">pri</span><span class="main">)</span> <span class="free">es</span> <span class="free">start</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fold_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_prio_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">for_all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">for_all</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-for_all_code"><span class="command">lemma</span></span> for_all_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"for_all <span class="free">f</span> <span class="free">xs</span> <span class="main">⟷</span> foldli <span class="free">xs</span> id <span class="main">(</span><span class="main">λ</span><span class="bound">kv</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">f</span> <span class="bound">kv</span><span class="main">)</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> for_all_def foldli_conj<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_remove</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">×</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">find_remove</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> List.find <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">(</span>None<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>
                                            <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">,</span> List.remove1 <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-find_remove_code"><span class="command">lemma</span></span> find_remove_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"find_remove <span class="free">P</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"find_remove <span class="free">P</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="main">(</span>Some <span class="free">x</span><span class="main">,</span> <span class="free">xs</span><span class="main">)</span>
                           <span class="keyword1">else</span> apsnd <span class="main">(</span>Cons <span class="free">x</span><span class="main">)</span> <span class="main">(</span>find_remove <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_remove_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> find_SomeD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span> 

<span class="keyword1" id="Promela-find_remove_subset"><span class="command">lemma</span></span> find_remove_subset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"find_remove <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">res</span><span class="main">,</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">⟹</span> set <span class="free">xs'</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> find_remove_def
<span class="keyword1"><span class="command">using</span></span> set_remove1_subset
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Promela-find_remove_length"><span class="command">lemma</span></span> find_remove_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"find_remove <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">res</span><span class="main">,</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">⟹</span> length <span class="free">xs'</span> <span class="main">≤</span> length <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> find_remove_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">res</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Variable handling›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Handling variables, with their different scopes (global vs. local), 
  and their different types (array vs channel vs bounded) is one of the main challenges
  of the implementation. 
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lookupVar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"variable <span class="main">⇒</span> integer option <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookupVar</span> <span class="main">(</span>Var <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span> None <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lookupVar</span> <span class="main">(</span>Var <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Array used on var''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span><span class="main">0</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lookupVar</span> <span class="main">(</span>VArray <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span><span class="main">)</span> None <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span> <span class="main">!!</span> <span class="main">0</span>"</span></span> <span class="comment1">(* sic! *)</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lookupVar</span> <span class="main">(</span>VArray <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span> <span class="main">!!</span> nat_of_integer <span class="free"><span class="bound"><span class="entity">idx</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">checkVarValue</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"varType <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkVarValue</span> <span class="main">(</span>VTBounded <span class="free"><span class="bound"><span class="entity">lRange</span></span></span> <span class="free"><span class="bound"><span class="entity">hRange</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">hRange</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">≥</span> <span class="free"><span class="bound"><span class="entity">lRange</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span>
     <span class="keyword1">else</span> <span class="comment1">― ‹overflowing is well-defined and may actually be used (e.g. bool)›</span>
        <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">lRange</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> 
        <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">hRange</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="comment1">― ‹we do not want to implement C-semantics (ie type casts)›</span>
           abort <span class="keyword1">STR</span> <span class="inner_quoted">''Value overflow''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">lRange</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">checkVarValue</span> VTChan <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">&lt;</span> min_var_value <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">&gt;</span> max_var_value 
     <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Value overflow''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> 
     <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"variable_inv <span class="main">(</span>Var VTChan <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">type</span> <span class="main">::</span> <span class="quoted">varType</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"varType_inv <span class="free">type</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Promela-checkVarValue_bounded"><span class="command">lemma</span></span> checkVarValue_bounded<span class="main">:</span>
  <span class="quoted"><span class="quoted">"checkVarValue <span class="free">type</span> <span class="free">val</span> <span class="main">∈</span> <span class="main">{</span>min_var_value<span class="main">..</span>max_var_value<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹varType_inv <span class="free">type</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">type</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mod_integer_le mod_integer_ge<span class="main">)</span>

<span class="keyword1" id="Promela-checkVarValue_bounds"><span class="command">lemma</span></span> checkVarValue_bounds<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_var_value <span class="main">≤</span> checkVarValue <span class="free">type</span> <span class="free">val</span>"</span></span>
  <span class="quoted"><span class="quoted">"checkVarValue <span class="free">type</span> <span class="free">val</span> <span class="main">≤</span> max_var_value"</span></span>
  <span class="keyword1"><span class="command">using</span></span> checkVarValue_bounded <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">val</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Promela-checkVarValue_Var"><span class="command">lemma</span></span> checkVarValue_Var<span class="main">:</span>
  <span class="quoted"><span class="quoted">"variable_inv <span class="main">(</span>Var <span class="free">type</span> <span class="main">(</span>checkVarValue <span class="free">type</span> <span class="free">val</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹varType_inv <span class="free">type</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> checkVarValue_bounds<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">editVar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"variable <span class="main">⇒</span> integer option <span class="main">⇒</span> integer <span class="main">⇒</span> variable"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">editVar</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">)</span> None <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">=</span> Var <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="main">(</span>checkVarValue <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">editVar</span> <span class="main">(</span>Var <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Array used on var''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Var VTChan <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">editVar</span> <span class="main">(</span>VArray <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span><span class="main">)</span> None <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">lv</span> <span class="main">=</span> IArray.list_of <span class="free"><span class="bound"><span class="entity">vals</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">v'</span> <span class="main">=</span> <span class="bound">lv</span><span class="main">[</span><span class="main">0</span><span class="main">:=</span>checkVarValue <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">]</span> <span class="keyword1">in</span>
     VArray <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="main">(</span>IArray <span class="bound">v'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">editVar</span> <span class="main">(</span>VArray <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="free"><span class="bound"><span class="entity">vals</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">lv</span> <span class="main">=</span> IArray.list_of <span class="free"><span class="bound"><span class="entity">vals</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">v'</span> <span class="main">=</span> <span class="bound">lv</span><span class="main">[</span><span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">:=</span>checkVarValue <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">]</span> <span class="keyword1">in</span>
     VArray <span class="free"><span class="bound"><span class="entity">type</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="main">(</span>IArray <span class="bound">v'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-editVar_variable_inv"><span class="command">lemma</span></span> editVar_variable_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="main">(</span>editVar <span class="free">v</span> <span class="free">idx</span> <span class="free">val</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Var <span class="skolem">type</span> <span class="skolem">val</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"varType_inv <span class="skolem">type</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> Var <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">idx</span></span><span class="main">)</span> 
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> checkVarValue_Var 
             <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> checkVarValue.simps variable_inv.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>VArray <span class="skolem">type</span> <span class="skolem">siz</span> <span class="skolem">vals</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"varType_inv <span class="skolem">type</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">idx</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> assms VArray <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"IArray.list_of <span class="skolem">vals</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> checkVarValue_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">i</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> upd_cases <span class="main">=</span> in_set_upd_cases<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> l<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"IArray.list_of <span class="skolem">vals</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> i<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"nat_of_integer <span class="skolem">i</span>"</span></span><span class="main">]</span>

    <span class="keyword1"><span class="command">from</span></span> Some VArray assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">type</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> upd_cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mod_integer_le mod_integer_ge <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_var_value_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">getVar'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> String.literal <span class="main">⇒</span> integer option 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> integer option"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">getVar'</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
          <span class="keyword1">let</span> <span class="bound">vars</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="keyword1">then</span> gState.vars <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">else</span> pState.vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">in</span>
          map_option <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> lookupVar <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span> <span class="main">(</span>lm.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">vars</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">setVar'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> String.literal <span class="main">⇒</span> integer option 
      <span class="main">⇒</span> integer 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">setVar'</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="keyword1">then</span>
        <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="keyword1">STR</span> <span class="inner_quoted">''_''</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>''_''›</span></span> is a write-only scratch variable›</span>
        <span class="keyword1">else</span> <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>gState.vars <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
               None <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Unknown global variable: ''</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span>gState.vars <span class="main">:=</span> lm.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>editVar <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span> 
                                                       <span class="main">(</span>gState.vars <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">⦈</span>
                         <span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
     <span class="keyword1">else</span>
        <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>pState.vars <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Unknown proc variable: ''</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>pState.vars <span class="main">:=</span> lm.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>editVar <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">val</span></span></span><span class="main">)</span> 
                                                     <span class="main">(</span>pState.vars <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-setVar'_gState_inv"><span class="command">lemma</span></span> setVar'_gState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="main">(</span>fst <span class="main">(</span>setVar' <span class="free">gl</span> <span class="free">v</span> <span class="free">idx</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar'_def <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def lm.correct 
         <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> editVar_variable_inv 
         <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Promela-setVar'_gState_progress_rel"><span class="command">lemma</span></span> setVar'_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>setVar' <span class="free">gl</span> <span class="free">v</span> <span class="free">idx</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fact</span> setVar'_gState_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> setVar'_def lm.correct <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-vardict_inv_process_names"><span class="command">lemma</span></span> vardict_inv_process_names<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lm.lookup <span class="free">k</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> process_names <span class="free">ss</span> <span class="free">proc</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct vardict_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-vardict_inv_variable_inv"><span class="command">lemma</span></span> vardict_inv_variable_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lm.lookup <span class="free">k</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct vardict_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-vardict_inv_updateI"><span class="command">lemma</span></span> vardict_inv_updateI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="free">vs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> process_names <span class="free">ss</span> <span class="free">proc</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="main">(</span>lm.update <span class="free">x</span> <span class="free">v</span> <span class="free">vs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct vardict_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-update_vardict_inv"><span class="command">lemma</span></span> update_vardict_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lm.lookup <span class="free">k</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="free">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="main">(</span>lm.update <span class="free">k</span> <span class="free">x'</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> vardict_inv_updateI vardict_inv_process_names<span class="main">)</span>

<span class="keyword1" id="Promela-setVar'_pState_inv"><span class="command">lemma</span></span> setVar'_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>setVar' <span class="free">gl</span> <span class="free">v</span> <span class="free">idx</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar'_def <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits 
         <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState_inv_def
         <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> update_vardict_inv editVar_variable_inv vardict_inv_variable_inv<span class="main">)</span>

<span class="keyword1" id="Promela-setVar'_cl_inv"><span class="command">lemma</span></span> setVar'_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>setVar' <span class="free">gl</span> <span class="free">v</span> <span class="free">idx</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar'_def <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">withVar'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> String.literal <span class="main">⇒</span> integer option 
      <span class="main">⇒</span> <span class="main">(</span>integer <span class="main">⇒</span> <span class="tfree">'x</span><span class="main">)</span> 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> <span class="tfree">'x</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">withVar'</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>the <span class="main">(</span>getVar' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">withChannel'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> String.literal <span class="main">⇒</span> integer option 
      <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> channel <span class="main">⇒</span> <span class="tfree">'x</span><span class="main">)</span> 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> <span class="tfree">'x</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">withChannel'</span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span> 
     <span class="keyword1">let</span> <span class="bound">error</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Variable is not a channel: ''</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
                                <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">0</span> InvChannel<span class="main">)</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">abort</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Channel already closed / invalid: ''</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
                                <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">0</span> InvChannel<span class="main">)</span>
     <span class="keyword1">in</span> withVar' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> nat_of_integer <span class="bound">i</span> <span class="keyword1">in</span> 
                               <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">≥</span> length <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="bound">error</span> <span class="main">()</span> 
                               <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> channels <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">!</span> <span class="bound">i</span> <span class="keyword1">in</span>
                                    <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span>
                                      InvChannel <span class="main">⇒</span> <span class="bound">abort</span> <span class="main">()</span>
                                    <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span> <span class="bound">c</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Expressions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Expressions are free of side-effects. 

This is in difference to SPIN, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">run</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is an expression with side-effect. We treat <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">run</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a statement.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">trivCond</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">exprArith</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> expr <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">pollCheck</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> channel <span class="main">⇒</span> recvArg list <span class="main">⇒</span> bool 
                   <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">recvArgsCheck</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> recvArg list <span class="main">⇒</span> integer list 
                       <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprConst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprMConst <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> ExprTimeOut <span class="main">=</span> trivCond <span class="main">(</span>timeout <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprLen <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
                Channel <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="bound">q</span><span class="main">)</span> 
              <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">0</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprLen <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
      <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
              Channel <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="bound">q</span><span class="main">)</span> 
            <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">0</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprEmpty <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> Channel <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">q</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span> 
                     <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprEmpty <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> Channel <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">q</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span> 
                     <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprFull <span class="main">(</span>ChanRef<span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
               Channel <span class="bound">cap</span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="bound">q</span><span class="main">)</span> <span class="main">≥</span> <span class="bound">cap</span> 
             <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprFull <span class="main">(</span>ChanRef<span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
               Channel <span class="bound">cap</span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="bound">q</span><span class="main">)</span> <span class="main">≥</span> <span class="bound">cap</span> 
             <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprVarRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     withVar' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None id <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprVarRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     withVar' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span> id <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprUnOp UnOpMinus <span class="free"><span class="bound"><span class="entity">expr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">-</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">expr</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprUnOp UnOpNeg <span class="free"><span class="bound"><span class="entity">expr</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">expr</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="numeral">2</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpAdd <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpSub <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpMul <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpDiv <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span><span class="main">)</span> <span class="keyword1">div</span> <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpMod <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpGr <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">&gt;</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpLe <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">&lt;</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpGEq <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">≥</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpLEq <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">≤</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpEq <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">=</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpNEq <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">≠</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpAnd <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprBinOp BinOpOr <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">lexpr</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rexpr</span></span></span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprCond <span class="free"><span class="bound"><span class="entity">cexpr</span></span></span> <span class="free"><span class="bound"><span class="entity">texpr</span></span></span> <span class="free"><span class="bound"><span class="entity">fexpr</span></span></span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="keyword1">if</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">cexpr</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">texpr</span></span></span> 
      <span class="keyword1">else</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">fexpr</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprPoll <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> None <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="free">pollCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>ExprPoll <span class="main">(</span>ChanRef <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main">=</span> 
     trivCond <span class="main">(</span>withChannel' <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
       <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span> <span class="free">pollCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">pollCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> InvChannel <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> 
     abort <span class="keyword1">STR</span> <span class="inner_quoted">''Channel already closed / invalid.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">pollCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>HSChannel <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">pollCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>Channel <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> False
     <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="free">recvArgsCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">(</span>hd <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span>
     <span class="keyword1">else</span> List.find <span class="main">(</span><span class="free">recvArgsCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≠</span> None<span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">recvArgsCheck</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">=</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">recvArgsCheck</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>  <span class="main">[]</span> <span class="main">=</span> 
     abort <span class="keyword1">STR</span> <span class="inner_quoted">''Length mismatch on receiving.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">recvArgsCheck</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span>  <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> 
     abort <span class="keyword1">STR</span> <span class="inner_quoted">''Length mismatch on receiving.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">recvArgsCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>
       <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> 
          RecvArgConst <span class="bound">c</span> <span class="main">⇒</span> <span class="bound">c</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
        <span class="main">|</span> RecvArgMConst <span class="bound">c</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">c</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
        <span class="main">|</span> RecvArgVar <span class="bound">var</span> <span class="main">⇒</span> True
        <span class="main">|</span> RecvArgEval <span class="bound">e</span> <span class="main">⇒</span> <span class="free">exprArith</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">e</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">)</span> <span class="main">∧</span> <span class="free">recvArgsCheck</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> getVar'<span class="antiquote"><span class="antiquote">}</span></span></span></span> etc.\ do operate on name, index, \ldots directly. Lift them to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> VarRef<span class="antiquote"><span class="antiquote">}</span></span></span></span> instead.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">liftVar</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">liftVar</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>VarRef <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">argm</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> 
      <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">gl</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>map_option <span class="main">(</span>exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">idx</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">argm</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">getVar</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> liftVar <span class="main">(</span><span class="main">λ</span><span class="bound">gl</span> <span class="bound">v</span> <span class="bound">idx</span> <span class="bound">arg</span><span class="main">.</span> getVar' <span class="bound">gl</span> <span class="bound">v</span> <span class="bound">idx</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">setVar</span> <span class="main">=</span> liftVar setVar'"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">withVar</span> <span class="main">=</span> liftVar withVar'"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">withChannel</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">withChannel</span> <span class="main">(</span>ChanRef <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> liftVar withChannel' <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1" id="Promela-setVar_gState_progress_rel"><span class="command">lemma</span></span> setVar_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>setVar <span class="free">v</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setVar'_gState_progress_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> setVar_gState_inv <span class="main">=</span> 
  setVar_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-setVar_pState_inv"><span class="command">lemma</span></span> setVar_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>setVar <span class="free">v</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar_def 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setVar'_pState_inv assms<span class="main">)</span>

<span class="keyword1" id="Promela-setVar_cl_inv"><span class="command">lemma</span></span> setVar_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>setVar <span class="free">v</span> <span class="free">val</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> setVar_def 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setVar'_cl_inv assms<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Variable declaration›</span></span>

<span class="keyword1" id="Promela-channel_inv_code"><span class="command">lemma</span></span> channel_inv_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>Channel <span class="free">cap</span> <span class="free">ts</span> <span class="free">q</span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="free">cap</span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">cap</span> 
    <span class="main">∧</span> for_all varType_inv <span class="free">ts</span> 
    <span class="main">∧</span> length <span class="free">ts</span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> length <span class="free">q</span> <span class="main">≤</span> max_array_size 
    <span class="main">∧</span> for_all <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> length <span class="bound">x</span> <span class="main">=</span> length <span class="free">ts</span>  
                   <span class="main">∧</span> for_all <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≥</span> min_var_value 
                                 <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> max_var_value<span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="free">q</span>"</span></span> 
  <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>HSChannel <span class="free">ts</span><span class="main">)</span> 
  <span class="main">⟷</span> for_all varType_inv <span class="free">ts</span> <span class="main">∧</span> length <span class="free">ts</span> <span class="main">≤</span> max_array_size"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> for_all_def<span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">toVariable</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> varDecl <span class="main">⇒</span> String.literal <span class="main">*</span> variable <span class="main">*</span> channels"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">toVariable</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>VarDeclNum <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">hb</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">type</span> <span class="main">=</span> VTBounded <span class="free"><span class="bound"><span class="entity">lb</span></span></span> <span class="free"><span class="bound"><span class="entity">hb</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">if</span> <span class="main">¬</span> varType_inv <span class="bound">type</span> <span class="keyword1">then</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid var def (varType_inv failed): ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> 
                                       <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> Var VTChan <span class="main">0</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">else</span>
       <span class="keyword1">let</span> 
         <span class="bound">init</span> <span class="main">=</span> checkVarValue <span class="bound">type</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="keyword1">of</span> 
                                      None <span class="main">⇒</span> <span class="main">0</span> 
                                    <span class="main">|</span> Some <span class="bound">e</span> <span class="main">⇒</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">e</span><span class="main">)</span><span class="main">;</span>
         <span class="bound">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="keyword1">of</span> 
                None <span class="main">⇒</span> Var <span class="bound">type</span> <span class="bound">init</span> 
              <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> <span class="keyword1">if</span> nat_of_integer <span class="bound">s</span> <span class="main">≤</span> max_array_size 
                         <span class="keyword1">then</span> VArray <span class="bound">type</span> <span class="main">(</span>nat_of_integer <span class="bound">s</span><span class="main">)</span> 
                                          <span class="main">(</span>IArray.tabulate <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">init</span><span class="main">)</span><span class="main">)</span>
                         <span class="keyword1">else</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid var def (array too large): ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span>
                                      <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Var VTChan <span class="main">0</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">in</span>
           <span class="main">(</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">toVariable</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>VarDeclChan <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="free"><span class="bound"><span class="entity">types</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">size</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">1</span> <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> nat_of_integer <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">chans</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">types</span></span></span> <span class="keyword1">of</span> 
                  None <span class="main">⇒</span> <span class="main">[]</span>
                <span class="main">|</span> Some <span class="main">(</span><span class="bound">cap</span><span class="main">,</span> <span class="bound">tys</span><span class="main">)</span> <span class="main">⇒</span> 
                    <span class="keyword1">let</span> <span class="bound">C</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">cap</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> HSChannel <span class="bound">tys</span> 
                             <span class="keyword1">else</span> Channel <span class="bound">cap</span> <span class="bound">tys</span> <span class="main">[]</span><span class="main">)</span> <span class="keyword1">in</span>
                    <span class="keyword1">if</span> <span class="main">¬</span> channel_inv <span class="bound">C</span> 
                    <span class="keyword1">then</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid var def (channel_inv failed): ''</span> 
                                <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">)</span>
                    <span class="keyword1">else</span> replicate <span class="bound">size</span> <span class="bound">C</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">cidx</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">types</span></span></span> <span class="keyword1">of</span> 
                 None <span class="main">⇒</span> <span class="main">0</span> 
               <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">siz</span></span></span> <span class="keyword1">of</span> 
              None <span class="main">⇒</span> Var VTChan <span class="bound">cidx</span>
            <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> <span class="keyword1">if</span> nat_of_integer <span class="bound">s</span> <span class="main">≤</span> max_array_size 
                       <span class="keyword1">then</span> VArray VTChan <span class="main">(</span>nat_of_integer <span class="bound">s</span><span class="main">)</span> 
                                          <span class="main">(</span>IArray.tabulate <span class="main">(</span><span class="bound">s</span><span class="main">,</span> 
                                             <span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">cidx</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> 
                                                 <span class="keyword1">else</span> <span class="bound">i</span> <span class="main">+</span> <span class="bound">cidx</span><span class="main">)</span><span class="main">)</span>
                       <span class="keyword1">else</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid var def (array too large): ''</span> 
                                   <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Var VTChan <span class="main">0</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">in</span>
        <span class="main">(</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">chans</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-toVariable_variable_inv"><span class="command">lemma</span></span> toVariable_variable_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"variable_inv <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> checkVarValue_Var 
              <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> variable_inv.simps checkVarValue.simps varType_inv.simps 
              <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mod_integer_ge mod_integer_le <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_var_value_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms gState_inv_def 
               max_channels_def max_var_value_def min_var_value_def max_array_size_def<span class="main">)</span>
    <span class="keyword1"><span class="command">including</span></span> integer.lifting
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer'</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-toVariable_channels_inv"><span class="command">lemma</span></span> toVariable_channels_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> channel_inv <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Promela-toVariable_channels_inv'"><span class="command">lemma</span></span> toVariable_channels_inv'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">c</span><span class="main">.</span> channel_inv <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> toVariable_channels_inv
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv<span class="main">)</span>

<span class="keyword1" id="Promela-toVariable_variable_inv'"><span class="command">lemma</span></span> toVariable_variable_inv'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> <span class="main">⟹</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">)</span> <span class="main">⟹</span> variable_inv <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv fst_conv toVariable_variable_inv<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mkChannels</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> channels <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mkChannels</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">else</span> 
     <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> length <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
     <span class="keyword1">if</span> <span class="bound">l</span> <span class="main">+</span> length <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">&gt;</span> max_channels 
     <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Too much channels''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span>  <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="keyword1">let</span>
            <span class="bound">cs<span class="hidden">⇩</span><sub>p</sub></span> <span class="main">=</span> map integer_of_nat <span class="main">[</span><span class="bound">l</span><span class="main">..&lt;</span><span class="bound">l</span> <span class="main">+</span> length <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">]</span><span class="main">;</span>
            <span class="bound">g'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span>channels <span class="main">:=</span> channels <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">⦈</span><span class="main">;</span>
            <span class="bound">p'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>pState.channels <span class="main">:=</span> pState.channels <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="bound">cs<span class="hidden">⇩</span><sub>p</sub></span><span class="main">⦈</span>
          <span class="keyword1">in</span> 
            <span class="main">(</span><span class="bound">g'</span><span class="main">,</span> <span class="bound">p'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-mkChannels_gState_progress_rel"><span class="command">lemma</span></span> mkChannels_gState_progress_rel<span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> 
   <span class="main">⟹</span> set <span class="free">cs</span> <span class="main">⊆</span> Collect channel_inv 
   <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>mkChannels <span class="free">g</span> <span class="free">p</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkChannels_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span> 
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def gState.defs cl_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> mkChannels_gState_inv <span class="main">=</span> 
  mkChannels_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-mkChannels_pState_inv"><span class="command">lemma</span></span> mkChannels_pState_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span> 
   <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> 
   <span class="main">⟹</span> pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>mkChannels <span class="free">g</span> <span class="free">p</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkChannels_def
<span class="keyword1"><span class="command">including</span></span> integer.lifting
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState_inv_def pState.defs gState_inv_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cl_inv_lengthD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer'</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-mkChannels_cl_inv"><span class="command">lemma</span></span> mkChannels_cl_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv <span class="main">(</span>mkChannels <span class="free">g</span> <span class="free">p</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkChannels_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState.defs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> cl_inv_lengthD <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cl_invI<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mkVarChannel</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"varDecl 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>var_dict <span class="main">⇒</span> var_dict<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState 
         <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState<span class="main">)</span> 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mkVarChannel</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
         <span class="keyword1">let</span> 
             <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> <span class="main">=</span> toVariable <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
             <span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">p'</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
         <span class="keyword1">in</span>
            mkChannels <span class="bound">g'</span> <span class="bound">p'</span> <span class="bound">cs</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-mkVarChannel_gState_inv"><span class="command">lemma</span></span> mkVarChannel_gState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v'</span> <span class="bound">cs</span><span class="main">.</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> 
                 <span class="main">⟹</span> gState_inv <span class="free">prog</span> <span class="main">(</span>fst <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="main">(</span>fst <span class="main">(</span>mkVarChannel <span class="free">v</span> <span class="free">upd</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> mkVarChannel_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> varDecl.split prod.split
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkChannels_gState_inv
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> toVariable_channels_inv'<span class="main">)</span> 

<span class="keyword1" id="Promela-mkVarChannel_gState_progress_rel"><span class="command">lemma</span></span> mkVarChannel_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v'</span> <span class="bound">cs</span><span class="main">.</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> 
             <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>mkVarChannel <span class="free">v</span> <span class="free">upd</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">k</span><span class="main">,</span><span class="skolem">v'</span><span class="main">,</span><span class="skolem">cs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> <span class="free">upd</span> <span class="main">(</span>lm.update <span class="skolem">k</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> 1 assms <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv<span class="main">)</span>

  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> 1 2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span> fst <span class="main">(</span>mkChannels <span class="skolem">g'</span> <span class="skolem">p'</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkChannels_gState_progress_rel gState_progress_rel_gState_invI2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> *<span class="main"><span class="main">]</span></span>
              <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> toVariable_channels_inv'<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>mkChannels <span class="skolem">g'</span> <span class="skolem">p'</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mkVarChannel_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1" id="Promela-mkVarChannel_pState_inv"><span class="command">lemma</span></span> mkVarChannel_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v'</span> <span class="bound">cs</span><span class="main">.</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> 
                  <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v'</span> <span class="bound">cs</span><span class="main">.</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> 
                  <span class="main">⟹</span> pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>mkVarChannel <span class="free">v</span> <span class="free">upd</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> mkVarChannel_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> varDecl.split prod.split 
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkChannels_pState_inv<span class="main">)</span>

<span class="keyword1" id="Promela-mkVarChannel_cl_inv"><span class="command">lemma</span></span> mkVarChannel_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v'</span> <span class="bound">cs</span><span class="main">.</span> toVariable <span class="free">g</span> <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> 
                 <span class="main">⟹</span> cl_inv <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>lm.update <span class="bound">k</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>mkVarChannel <span class="free">v</span> <span class="free">upd</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> mkVarChannel_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> varDecl.split prod.splits 
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkChannels_cl_inv<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mkVarChannelProc</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"procVarDecl <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mkVarChannelProc</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">v'</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
              ProcVarDeclNum <span class="bound">lb</span> <span class="bound">hb</span> <span class="bound">name</span> <span class="bound">siz</span> <span class="bound">init</span> <span class="main">⇒</span> 
                  VarDeclNum <span class="bound">lb</span> <span class="bound">hb</span> <span class="bound">name</span> <span class="bound">siz</span> <span class="bound">init</span>
           <span class="main">|</span> ProcVarDeclChan <span class="bound">name</span> <span class="bound">siz</span> <span class="main">⇒</span> 
                 VarDeclChan <span class="bound">name</span> <span class="bound">siz</span> None<span class="main">;</span>
       <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> <span class="main">=</span> toVariable <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">v'</span> 
     <span class="keyword1">in</span> 
       mkVarChannel <span class="bound">v'</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-mkVarChannelProc_gState_progress_rel"><span class="command">lemma</span></span> mkVarChannelProc_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>mkVarChannelProc <span class="free">v</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkVarChannelProc_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_gState_progress_rel<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> mkVarChannelProc_gState_inv <span class="main">=</span> 
  mkVarChannelProc_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-toVariable_name"><span class="command">lemma</span></span> toVariable_name<span class="main">:</span>
  <span class="quoted"><span class="quoted">"toVariable <span class="free">g</span> <span class="free">p</span> <span class="main">(</span>VarDeclNum <span class="free">lb</span> <span class="free">hb</span> <span class="free">name</span> <span class="free">sz</span> <span class="free">init</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">name</span>"</span></span>
  <span class="quoted"><span class="quoted">"toVariable <span class="free">g</span> <span class="free">p</span> <span class="main">(</span>VarDeclChan <span class="free">name</span> <span class="free">sz</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">name</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> toVariable.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1" id="Promela-statesDecls_process_names"><span class="command">lemma</span></span> statesDecls_process_names<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> statesDecls <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="main">(</span>pState.idx <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"procVarDeclName <span class="free">v</span> <span class="main">∈</span> process_names <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="main">(</span>pState.idx <span class="free">p</span><span class="main">)</span><span class="main">)</span> 
                                           <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="main">(</span>pState.idx <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"processes <span class="free">prog</span> <span class="main">!!</span> <span class="main">(</span>pState.idx <span class="free">p</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> statesNames_def<span class="main">)</span>

<span class="keyword1" id="Promela-mkVarChannelProc_pState_inv"><span class="command">lemma</span></span> mkVarChannelProc_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> decl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> statesDecls <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="main">(</span>pState.idx <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>mkVarChannelProc <span class="free">v</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkVarChannelProc_def
<span class="keyword1"><span class="command">using</span></span> assms statesDecls_process_names<span class="main">[</span><span class="operator">OF</span> decl<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_pState_inv<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> toVariable_name 
         <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> procVarDecl.splits 
         <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> toVariable_variable_inv' vardict_inv_updateI
         <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-mkVarChannelProc_cl_inv"><span class="command">lemma</span></span> mkVarChannelProc_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>mkVarChannelProc <span class="free">v</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mkVarChannelProc_def <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_cl_inv<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Folding›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Fold over lists (and lists of lists) of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">step</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>/<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">stmnt</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. The folding functions are 
  doing a bit more than that, e.g.\ ensuring the offset into the program array is correct. 
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_fold'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_fold'</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="main">::</span> labels<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> 
             <span class="main">(</span><span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="main">::</span> edgeIndex<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="main">::</span> edgeIndex option<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">iB</span></span></span> <span class="main">=</span> 
     foldr <span class="main">(</span><span class="main">λ</span><span class="bound">step</span> <span class="main">(</span><span class="bound">pos</span><span class="main">,</span> <span class="bound">nxt</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">,</span> <span class="bound">es</span><span class="main">)</span><span class="main">.</span> 
              <span class="keyword1">let</span> <span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">enxt</span><span class="main">,</span><span class="bound">lbls</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">step</span> <span class="main">(</span><span class="bound">lbls</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="bound">pos</span><span class="main">,</span> <span class="bound">nxt</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">iB</span></span></span><span class="main">)</span>
              <span class="keyword1">in</span> <span class="main">(</span><span class="bound">pos</span> <span class="main">+</span> length <span class="bound">e</span><span class="main">,</span> <span class="bound">enxt</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">,</span> <span class="bound">es</span><span class="main">@</span><span class="bound">e</span><span class="main">)</span>
    <span class="main">)</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_fold</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_fold</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="free"><span class="bound"><span class="entity">iB</span></span></span> <span class="main">=</span> <span class="main">(</span>
         <span class="keyword1">let</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">nxt</span><span class="main">,</span><span class="bound">lbls</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">=</span> step_fold' <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="free"><span class="bound"><span class="entity">iB</span></span></span>
          <span class="keyword1">in</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">nxt</span><span class="main">,</span><span class="bound">lbls</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-step_fold'_cong"><span class="command">lemma</span></span> step_fold'_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">lbls</span> <span class="main">=</span> <span class="free">lbls'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pri</span> <span class="main">=</span> <span class="free">pri'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pos</span> <span class="main">=</span> <span class="free">pos'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">steps</span> <span class="main">=</span> <span class="free">steps'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">nxt</span> <span class="main">=</span> <span class="free">nxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">onxt</span> <span class="main">=</span> <span class="free">onxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">iB</span> <span class="main">=</span> <span class="free">iB'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">steps</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">x</span> <span class="bound">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"step_fold' <span class="free">g</span> <span class="free">steps</span> <span class="free">lbls</span> <span class="free">pri</span> <span class="free">pos</span> <span class="free">nxt</span> <span class="free">onxt</span> <span class="free">iB</span> <span class="main">=</span> 
         step_fold' <span class="free">g'</span> <span class="free">steps'</span> <span class="free">lbls'</span> <span class="free">pri'</span> <span class="free">pos'</span> <span class="free">nxt'</span> <span class="free">onxt'</span> <span class="free">iB'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> step_fold'_def 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> foldr_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Promela-step_fold_cong"><span class="command">lemma</span></span> step_fold_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">lbls</span> <span class="main">=</span> <span class="free">lbls'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pri</span> <span class="main">=</span> <span class="free">pri'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pos</span> <span class="main">=</span> <span class="free">pos'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">steps</span> <span class="main">=</span> <span class="free">steps'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">nxt</span> <span class="main">=</span> <span class="free">nxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">onxt</span> <span class="main">=</span> <span class="free">onxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">iB</span> <span class="main">=</span> <span class="free">iB'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">steps</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">x</span> <span class="bound">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"step_fold <span class="free">g</span> <span class="free">steps</span> <span class="free">lbls</span> <span class="free">pri</span> <span class="free">pos</span> <span class="free">nxt</span> <span class="free">onxt</span> <span class="free">iB</span> <span class="main">=</span> 
         step_fold <span class="free">g'</span> <span class="free">steps'</span> <span class="free">lbls'</span> <span class="free">pri'</span> <span class="free">pos'</span> <span class="free">nxt'</span> <span class="free">onxt'</span> <span class="free">iB'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> step_fold_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> step_fold'_cong<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">step_foldL_step</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_foldL_step</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">is</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">is</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">step_foldL_step</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">is</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">pos'</span><span class="main">,</span> <span class="bound">nxt'</span><span class="main">,</span> <span class="bound">lbls'</span><span class="main">,</span> <span class="bound">ss'</span><span class="main">)</span> <span class="main">=</span> step_fold' <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> False <span class="keyword1">in</span> 
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">nxt''</span><span class="main">,</span> <span class="bound">lbls''</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="bound">lbls'</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span><span class="bound">pos'</span><span class="main">,</span><span class="bound">nxt'</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span>True<span class="main">)</span> <span class="keyword1">in</span>
     <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> butlast <span class="bound">s'</span><span class="main">;</span> <span class="bound">s''</span> <span class="main">=</span> last <span class="bound">s'</span> <span class="keyword1">in</span>
     <span class="main">(</span><span class="bound">pos'</span> <span class="main">+</span> length <span class="bound">rs</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="bound">lbls''</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">@</span><span class="bound">ss'</span><span class="main">@</span><span class="bound">rs</span><span class="main">,</span> <span class="bound">s''</span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">is</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_foldL</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_foldL</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">stepss</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="main">=</span> 
     foldr <span class="main">(</span>step_foldL_step <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">stepss</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-step_foldL_step_cong"><span class="command">lemma</span></span> step_foldL_step_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pri</span> <span class="main">=</span> <span class="free">pri'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">onxt</span> <span class="main">=</span> <span class="free">onxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">=</span> <span class="free">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">d'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">s</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">x</span> <span class="bound">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"step_foldL_step <span class="free">g</span> <span class="free">pri</span> <span class="free">onxt</span> <span class="free">s</span> <span class="free">d</span> <span class="main">=</span> step_foldL_step <span class="free">g'</span> <span class="free">pri'</span> <span class="free">onxt'</span> <span class="free">s'</span> <span class="free">d'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> step_fold'_cong<span class="main">)</span>
  
<span class="keyword1" id="Promela-step_foldL_cong"><span class="command">lemma</span></span> step_foldL_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">lbls</span> <span class="main">=</span> <span class="free">lbls'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pri</span> <span class="main">=</span> <span class="free">pri'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pos</span> <span class="main">=</span> <span class="free">pos'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">stepss</span> <span class="main">=</span> <span class="free">stepss'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">nxt</span> <span class="main">=</span> <span class="free">nxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">onxt</span> <span class="main">=</span> <span class="free">onxt'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">stepss</span> <span class="main">⟹</span> <span class="bound">x'</span> <span class="main">∈</span> set <span class="bound">x</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">x'</span> <span class="bound">d</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">x'</span> <span class="bound">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"step_foldL <span class="free">g</span> <span class="free">stepss</span> <span class="free">lbls</span> <span class="free">pri</span> <span class="free">pos</span> <span class="free">nxt</span> <span class="free">onxt</span> <span class="main">=</span> 
         step_foldL <span class="free">g'</span> <span class="free">stepss'</span> <span class="free">lbls'</span> <span class="free">pri'</span> <span class="free">pos'</span> <span class="free">nxt'</span> <span class="free">onxt'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> step_foldL_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">stepss'</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> foldr_cong step_foldL_step_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Starting processes›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">modProcArg</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>procArg <span class="main">*</span> integer<span class="main">)</span> <span class="main">⇒</span> String.literal <span class="main">*</span> variable"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">modProcArg</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
       <span class="main">(</span>ProcArg <span class="bound">ty</span> <span class="bound">name</span><span class="main">,</span> <span class="bound">val</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> varType_inv <span class="bound">ty</span> 
                                <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">init</span> <span class="main">=</span> checkVarValue <span class="bound">ty</span> <span class="bound">val</span> 
                                     <span class="keyword1">in</span> <span class="main">(</span><span class="bound">name</span><span class="main">,</span> Var <span class="bound">ty</span> <span class="bound">init</span><span class="main">)</span>
                                <span class="keyword1">else</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid proc arg (varType_inv failed)''</span> 
                                            <span class="bound">name</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="bound">name</span><span class="main">,</span> Var VTChan <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">emptyProc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"pState"</span></span>
  <span class="comment1">― ‹The empty process.›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">emptyProc</span> <span class="main">=</span> <span class="main">⦇</span>pid <span class="main">=</span> <span class="main">0</span><span class="main">,</span> vars <span class="main">=</span> lm.empty <span class="main">()</span><span class="main">,</span> pc <span class="main">=</span> <span class="main">0</span><span class="main">,</span> channels <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> idx <span class="main">=</span> <span class="main">0</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Promela-vardict_inv_empty"><span class="command">lemma</span></span> vardict_inv_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vardict_inv <span class="free">ss</span> <span class="free">proc</span> <span class="main">(</span>lm.empty<span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> vardict_inv_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct<span class="main">)</span>

<span class="keyword1" id="Promela-emptyProc_cl_inv"><span class="command">lemma</span></span> emptyProc_cl_inv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span> emptyProc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def emptyProc_def<span class="main">)</span>

<span class="keyword1" id="Promela-emptyProc_pState_inv"><span class="command">lemma</span></span> emptyProc_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> emptyProc"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"IArray.length <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="main">0</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> program_inv_length_states<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> program_inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pState_inv_def program_inv_def emptyProc_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vardict_inv_empty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">mkProc</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState
    <span class="main">⇒</span> String.literal <span class="main">⇒</span> expr list <span class="main">⇒</span> process <span class="main">⇒</span> nat 
    <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mkProc</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">sidx</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">start</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">argDecls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">pidN</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="bound">start</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">start</span></span></span> <span class="keyword1">of</span> 
                   Index <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">x</span>
                 <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Process start is not index: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> 
     <span class="keyword1">in</span>
      <span class="comment1">― ‹sanity check›</span>
      <span class="keyword1">if</span> length <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="main">≠</span> length <span class="free"><span class="bound"><span class="entity">argDecls</span></span></span> 
      <span class="keyword1">then</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Signature mismatch: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span>emptyProc<span class="main">)</span><span class="main">)</span>
      <span class="keyword1">else</span>
        <span class="keyword1">let</span>
          <span class="comment1">― ‹evaluate args (in the context of the calling process)›</span>
          <span class="bound">eArgs</span> <span class="main">=</span> map <span class="main">(</span>exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">;</span>
        
          <span class="comment1">― ‹replace the init part of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>argDecls›</span></span>›</span>
          <span class="bound">argVars</span> <span class="main">=</span> map modProcArg <span class="main">(</span>zip <span class="free"><span class="bound"><span class="entity">argDecls</span></span></span> <span class="bound">eArgs</span><span class="main">)</span><span class="main">;</span>
        
          <span class="comment1">― ‹add <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>_pid›</span></span> to vars›</span>
          <span class="bound">pidI</span> <span class="main">=</span> integer_of_nat <span class="free"><span class="bound"><span class="entity">pidN</span></span></span><span class="main">;</span>
          <span class="bound">argVars</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_pid''</span><span class="main">,</span> Var <span class="main">(</span>VTBounded <span class="main">0</span> <span class="bound">pidI</span><span class="main">)</span> <span class="bound">pidI</span><span class="main">)</span><span class="main">#</span><span class="bound">argVars</span><span class="main">;</span>
          <span class="bound">argVars</span> <span class="main">=</span> lm.to_map <span class="bound">argVars</span><span class="main">;</span>
        
          <span class="comment1">― ‹our new process›</span>
          <span class="bound">p</span> <span class="main">=</span> <span class="main">⦇</span> pid <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pidN</span></span></span><span class="main">,</span> vars <span class="main">=</span> <span class="bound">argVars</span><span class="main">,</span> pc <span class="main">=</span> <span class="bound">start</span><span class="main">,</span> channels <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> idx <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">sidx</span></span></span> <span class="main">⦈</span>
        <span class="keyword1">in</span>
          <span class="comment1">― ‹apply the declarations›</span>
          foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> mkVarChannel <span class="bound">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="bound">g</span> <span class="bound">p</span><span class="main">)</span> 
                <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> 
                <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-mkProc_gState_progress_rel"><span class="command">lemma</span></span> mkProc_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>mkProc <span class="free">g</span> <span class="free">p</span> <span class="free">name</span> <span class="free">args</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="free">pidN</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span>  
          gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sidx'</span></span> <span class="skolem"><span class="skolem">start</span></span> <span class="skolem"><span class="skolem">argDecls</span></span> <span class="skolem"><span class="skolem">decls</span></span>  <span class="keyword2"><span class="keyword">where</span></span> 
    p<span class="main">:</span> <span class="quoted"><span class="quoted">"processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">sidx'</span><span class="main">,</span> <span class="skolem">start</span><span class="main">,</span> <span class="skolem">argDecls</span><span class="main">,</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> mkVarChannel <span class="bound">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="bound">g</span> <span class="bound">p</span><span class="main">)</span> 
                         <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="skolem">decls</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">decls</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">d</span> <span class="skolem">decls</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>mkVarChannel <span class="skolem">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g'</span> <span class="main">=</span> fst <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> g_g'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span><span class="main">,</span><span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mkVarChannel_gState_progress_rel<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> g_g'<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def new<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms p <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mkProc_gState_inv <span class="main">=</span> 
  mkProc_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-mkProc_pState_inv"><span class="command">lemma</span></span> mkProc_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pidN</span> <span class="main">≤</span> max_procs"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">pidN</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sidx</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="main">=</span> <span class="free">sidx</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>mkProc <span class="free">g</span> <span class="free">p</span> <span class="free">name</span> <span class="free">args</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="free">pidN</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sidx'</span></span> <span class="skolem"><span class="skolem">start</span></span> <span class="skolem"><span class="skolem">argDecls</span></span> <span class="skolem"><span class="skolem">decls</span></span>  <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">sidx'</span><span class="main">,</span> <span class="skolem">start</span><span class="main">,</span> <span class="skolem">argDecls</span><span class="main">,</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> 
    p_def<span class="main">:</span> <span class="quoted"><span class="quoted">"processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span> <span class="main">=</span> <span class="main">(</span><span class="free">sidx</span><span class="main">,</span> <span class="skolem">start</span><span class="main">,</span> <span class="skolem">argDecls</span><span class="main">,</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span> 
           <span class="quoted"><span class="quoted">"IArray.list_of <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span> <span class="main">!</span> <span class="free">sidx</span> <span class="main">=</span> <span class="main">(</span><span class="free">sidx</span><span class="main">,</span> <span class="skolem">start</span><span class="main">,</span> <span class="skolem">argDecls</span><span class="main">,</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">sidx</span><span class="main">,</span><span class="skolem">start</span><span class="main">,</span><span class="skolem">argDecls</span><span class="main">,</span><span class="skolem">decls</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>IArray.list_of <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> nth_mem<span class="main">)</span>
  
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">start</span> <span class="main">=</span> Index <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> program_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">hence</span></span> P_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">⦇</span>
                   pid <span class="main">=</span> <span class="free">pidN</span><span class="main">,</span>
                   vars <span class="main">=</span> lm.to_map
                          <span class="main">(</span><span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_pid''</span><span class="main">,</span> Var <span class="main">(</span>VTBounded <span class="main">0</span> <span class="main">(</span>integer_of_nat <span class="free">pidN</span><span class="main">)</span><span class="main">)</span> 
                             <span class="main">(</span>integer_of_nat <span class="free">pidN</span><span class="main">)</span><span class="main">)</span> 
                          <span class="main">#</span> map modProcArg <span class="main">(</span>zip <span class="skolem">argDecls</span> <span class="main">(</span>map <span class="main">(</span>exprArith <span class="free">g</span> <span class="free">p</span><span class="main">)</span> <span class="free">args</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                   pc <span class="main">=</span> <span class="skolem">s</span><span class="main">,</span> channels <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> idx <span class="main">=</span> <span class="free">sidx</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pState_inv_def
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> program_inv_def<span class="main">]</span>
    <span class="keyword1"><span class="command">including</span></span> integer.lifting
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> lm_to_map_vardict_inv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_procs_def max_var_value_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer'</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer'</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_var_value_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer'</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_var_value_def max_procs_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer'</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> set_zip_leftD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> modProcArg_def 
                   <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> procArg.splits if_splits 
                   <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> modProcArg_def 
                    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> procArg.splits if_splits 
                    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> variable_inv.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> checkVarValue_Var<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> p_def <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"varDeclName <span class="main">`</span> set <span class="skolem">decls</span> <span class="main">⊆</span> 
      process_names <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹gState_inv <span class="free">prog</span> <span class="free">g</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
    F_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="main">⟦</span> pState_inv <span class="free">prog</span> <span class="bound">p</span><span class="main">;</span> <span class="free">sidx</span> <span class="main">=</span> pState.idx <span class="bound">p</span><span class="main">;</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">⟧</span>
                <span class="main">⟹</span> pState_inv <span class="free">prog</span> 
                   <span class="main">(</span>snd <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> mkVarChannel <span class="bound">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="bound">g</span> <span class="bound">p</span><span class="main">)</span> 
                               <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="skolem">decls</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">decls</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">d</span> <span class="skolem">ds</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> 
      decl<span class="main">:</span> <span class="quoted"><span class="quoted">"varDeclName <span class="skolem">d</span> <span class="main">∈</span> process_names <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> pState.idx <span class="skolem">p</span><span class="main">)</span> 
                                           <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> pState.idx <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>mkVarChannel <span class="skolem">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> snd <span class="main">...</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">g'</span> <span class="main">=</span> fst <span class="main">...</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv fst_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="skolem">p'</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_pState_inv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> vardict_inv_updateI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">d</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> toVariable_name<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> toVariable_name<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> toVariable_variable_inv'<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> p' Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pState.idx <span class="skolem">p'</span> <span class="main">=</span> <span class="free">sidx</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mkVarChannel_def mkChannels_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> new Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_cl_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> g' Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="skolem">g'</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_gState_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"varDeclName <span class="main">`</span> set <span class="skolem">ds</span> <span class="main">⊆</span>
          process_names <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> 
    <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> 
         <span class="main">(</span>snd <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> mkVarChannel <span class="bound">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="bound">g</span> <span class="bound">p</span><span class="main">)</span> 
                     <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Cons.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p'</span></span> <span class="quoted"><span class="skolem">g'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_def s cl_inv_def 
             <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> F_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> P_inv<span class="main"><span class="main">]</span></span><span class="main">)</span> 
       <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> emptyProc_pState_inv assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Promela-mkProc_cl_inv"><span class="command">lemma</span></span> mkProc_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>mkProc <span class="free">g</span> <span class="free">p</span> <span class="free">name</span> <span class="free">args</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span><span class="main">)</span> <span class="free">pidN</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> IArray.sub_def <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sidx'</span></span> <span class="skolem"><span class="skolem">start</span></span> <span class="skolem"><span class="skolem">argDecls</span></span> <span class="skolem"><span class="skolem">decls</span></span>  
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"processes <span class="free">prog</span> <span class="main">!!</span> <span class="free">sidx</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">sidx'</span><span class="main">,</span> <span class="skolem">start</span><span class="main">,</span> <span class="skolem">argDecls</span><span class="main">,</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> 
    P_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">v</span><span class="main">.</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="main">⦇</span>pid <span class="main">=</span> <span class="free">pidN</span><span class="main">,</span> vars <span class="main">=</span> <span class="bound">v</span><span class="main">,</span> pc <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> channels <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> idx <span class="main">=</span> <span class="skolem">sidx'</span> <span class="main">⦈</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> cl_inv<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">⟹</span> 
         cl_inv <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">d</span><span class="main">.</span> mkVarChannel <span class="bound">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="bound">g</span> <span class="bound">p</span><span class="main">)</span> 
                       <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">decls</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">d</span> <span class="skolem">ds</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>mkVarChannel <span class="skolem">d</span> <span class="main">(</span>apsnd <span class="main">∘</span> pState.vars_update<span class="main">)</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannel_cl_inv<span class="main">)</span>
    
    <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">OF</span> P_inv<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">declare</span></span> mkProc.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">runProc</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> expr list <span class="main">⇒</span> program 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> pState 
      <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme <span class="main">*</span> pState"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">runProc</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> length <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">≥</span> max_procs 
     <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Too many processes''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">pid</span> <span class="main">=</span> length <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="keyword1">in</span>
          <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>proc_data <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
            None <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''No such process: ''</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> 
                          <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
          <span class="main">|</span> Some <span class="bound">proc_idx</span> <span class="main">⇒</span> 
               <span class="keyword1">let</span> <span class="main">(</span><span class="bound">g'</span><span class="main">,</span> <span class="bound">proc</span><span class="main">)</span> <span class="main">=</span> mkProc <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="main">(</span>processes <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> <span class="bound">proc_idx</span><span class="main">)</span> <span class="bound">pid</span>
               <span class="keyword1">in</span> <span class="main">(</span><span class="bound">g'</span><span class="main">⦇</span>procs <span class="main">:=</span> procs <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="bound">proc</span><span class="main">]</span><span class="main">⦈</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-runProc_gState_progress_rel"><span class="command">lemma</span></span> runProc_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>runProc <span class="free">name</span> <span class="free">args</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>procs <span class="free">g</span><span class="main">)</span> <span class="main">&lt;</span> max_procs"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IArray.sub_def <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lm.lookup <span class="free">name</span> <span class="main">(</span>proc_data <span class="free">prog</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">proc_idx</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">proc_idx</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>processes <span class="free">prog</span><span class="main">)</span>"</span></span> 
             <span class="quoted"><span class="quoted">"fst <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="skolem">proc_idx</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">proc_idx</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct program_inv_def<span class="main">)</span>
      
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> mkProc <span class="free">g</span> <span class="free">p</span> <span class="free">name</span> <span class="free">args</span> <span class="main">(</span>processes <span class="free">prog</span> <span class="main">!!</span> <span class="skolem">proc_idx</span><span class="main">)</span> <span class="main">(</span>length <span class="main">(</span>procs <span class="free">g</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> g'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">g'</span> <span class="main">=</span> fst <span class="main">...</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> snd <span class="main">...</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv fst_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms g' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> "</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkProc_gState_progress_rel<span class="main">)</span>

    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> * assms True p' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="skolem">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkProc_pState_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> assms new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkProc_cl_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> True Some new assms
      <span class="keyword1"><span class="command">unfolding</span></span> runProc_def gState_progress_rel_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> 
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> runProc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> runProc_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> runProc_gState_inv <span class="main">=</span> 
  runProc_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-runProc_pState_id"><span class="command">lemma</span></span> runProc_pState_id<span class="main">:</span>
  <span class="quoted"><span class="quoted">"snd <span class="main">(</span>runProc <span class="free">name</span> <span class="free">args</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> runProc_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split prod.split<span class="main">)</span>

<span class="keyword1" id="Promela-runProc_pState_inv"><span class="command">lemma</span></span> runProc_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>runProc <span class="free">name</span> <span class="free">args</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms runProc_pState_id<span class="main">)</span>

<span class="keyword1" id="Promela-runProc_cl_inv"><span class="command">lemma</span></span> runProc_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>runProc <span class="free">name</span> <span class="free">args</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"runProc <span class="free">name</span> <span class="free">args</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> runProc_gState_progress_rel<span class="main">[</span><span class="operator">OF</span> assms<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">name</span></span> <span class="quoted"><span class="free">args</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"length <span class="main">(</span>channels <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>channels <span class="skolem">g'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> * runProc_pState_id <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>›</span></span> * cl_inv_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹AST to edges›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ast <span class="main">=</span> <span class="quoted"><span class="quoted">"AST.module list"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, the AST is translated into the transition system.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Handling atomic blocks is non-trivial. Therefore, we do this in an extra pass:
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">lp</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">hp</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are the positions of the start and the end of
  the atomic block. Every edge pointing into this range is therefore marked as 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Atomic</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. If they are pointing somewhere else, they are set to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">InAtomic</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  meaning: they start \emph{in} an atomic block, but leave it afterwards.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">atomize</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> edge list <span class="main">⇒</span> edge list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">atomize</span> <span class="free"><span class="bound"><span class="entity">lp</span></span></span> <span class="free"><span class="bound"><span class="entity">hp</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">es</span><span class="main">.</span> 
     <span class="keyword1">let</span> <span class="bound">e'</span> <span class="main">=</span> <span class="keyword1">case</span> target <span class="bound">e</span> <span class="keyword1">of</span>
                 LabelJump <span class="main"><span class="bound">_</span></span> None <span class="main">⇒</span> 
                    <span class="comment1">― ‹Labels are checked again later on, when they›</span>
                    <span class="comment1">― ‹are going to be resolved. Hence it is safe to say›</span>
                    <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>atomic›</span></span> here, especially as the later algorithm›</span>
                    <span class="comment1">― ‹relies on targets in atomic blocks to be marked as such.›</span>
                    <span class="bound">e</span><span class="main">⦇</span> atomic <span class="main">:=</span> InAtomic <span class="main">⦈</span>
                <span class="main">|</span> LabelJump <span class="main"><span class="bound">_</span></span> <span class="main">(</span>Some <span class="bound">via</span><span class="main">)</span> <span class="main">⇒</span> 
                    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">lp</span></span></span> <span class="main">≤</span> <span class="bound">via</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">hp</span></span></span> <span class="main">≥</span> <span class="bound">via</span> <span class="keyword1">then</span> <span class="bound">e</span><span class="main">⦇</span> atomic <span class="main">:=</span> Atomic <span class="main">⦈</span> 
                    <span class="keyword1">else</span> <span class="bound">e</span><span class="main">⦇</span> atomic <span class="main">:=</span> InAtomic <span class="main">⦈</span>
                <span class="main">|</span> Index <span class="bound">p'</span> <span class="main">⇒</span> 
                    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">lp</span></span></span> <span class="main">≤</span> <span class="bound">p'</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">hp</span></span></span> <span class="main">≥</span> <span class="bound">p'</span> <span class="keyword1">then</span> <span class="bound">e</span><span class="main">⦇</span> atomic <span class="main">:=</span> Atomic <span class="main">⦈</span>
                    <span class="keyword1">else</span> <span class="bound">e</span><span class="main">⦇</span> atomic <span class="main">:=</span> InAtomic <span class="main">⦈</span>
      <span class="keyword1">in</span> <span class="bound">e'</span><span class="main">#</span><span class="bound">es</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">skip</span> <span class="comment1">― ‹No-(edge)›</span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">skip</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECExpr <span class="main">(</span>ExprConst <span class="main">1</span><span class="main">)</span><span class="main">,</span> 
       effect <span class="main">=</span> EEId<span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
       atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
   The AST is walked backwards. This allows to know the next state directly.

   Parameters used:
   \begin{description}
      \item[lbls] Map of Labels
      \item[pri] Current priority
      \item[pos] Current position in the array
      \item[nxt] Next state
      \item[onxt] Previous 'next state' (where to jump after a 'do')
      \item[inBlock] Needed for certain constructs to calculate the layout of the array
   \end{description}
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">stepToState</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"step 
      <span class="main">⇒</span> <span class="main">(</span>labels <span class="main">*</span> integer <span class="main">*</span> nat <span class="main">*</span> edgeIndex <span class="main">*</span> edgeIndex option <span class="main">*</span> bool<span class="main">)</span> 
      <span class="main">⇒</span> edge list list <span class="main">*</span> edgeIndex <span class="main">*</span> labels"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">stmntToState</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"stmnt 
      <span class="main">⇒</span> <span class="main">(</span>labels <span class="main">*</span> integer <span class="main">*</span> nat <span class="main">*</span> edgeIndex <span class="main">*</span> edgeIndex option <span class="main">*</span> bool<span class="main">)</span> 
      <span class="main">⇒</span> edge list list <span class="main">*</span> edgeIndex <span class="main">*</span> labels"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stepToState</span> <span class="main">(</span>StepStmnt <span class="free"><span class="bound"><span class="entity">s</span></span></span> None<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">data</span></span></span> <span class="main">=</span> <span class="free">stmntToState</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">data</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stepToState</span> <span class="main">(</span>StepStmnt <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span>
        <span class="comment1">― ‹the <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>unless›</span></span> part›</span>
        <span class="main">(</span><span class="bound">ues</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">lbls'</span><span class="main">)</span> <span class="main">=</span> <span class="free">stmntToState</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> True<span class="main">)</span><span class="main">;</span>
        <span class="bound">u</span> <span class="main">=</span> last <span class="bound">ues</span><span class="main">;</span> <span class="bound">ues</span> <span class="main">=</span> butlast <span class="bound">ues</span><span class="main">;</span>
        <span class="bound">pos'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="main">+</span> length <span class="bound">ues</span><span class="main">;</span>
    
        <span class="comment1">― ‹find minimal current priority›</span>
        <span class="bound">pri</span> <span class="main">=</span> min_prio <span class="bound">u</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">;</span>

        <span class="comment1">― ‹the guarded part --›</span>
        <span class="comment1">― ‹priority is decreased, because there is now a new unless part with›</span>
        <span class="comment1">― ‹higher prio›</span>
        <span class="main">(</span><span class="bound">ses</span><span class="main">,</span><span class="bound">spos</span><span class="main">,</span><span class="bound">lbls''</span><span class="main">)</span> <span class="main">=</span> <span class="free">stmntToState</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="bound">lbls'</span><span class="main">,</span> <span class="bound">pri</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="bound">pos'</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> False<span class="main">)</span><span class="main">;</span>
 
        <span class="comment1">― ‹add an edge to the unless part for each generated state›</span>
        <span class="bound">ses</span> <span class="main">=</span> map <span class="main">(</span>List.append <span class="bound">u</span><span class="main">)</span> <span class="bound">ses</span>
     <span class="keyword1">in</span>
        <span class="main">(</span><span class="bound">ues</span><span class="main">@</span><span class="bound">ses</span><span class="main">,</span><span class="bound">spos</span><span class="main">,</span><span class="bound">lbls''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stepToState</span> <span class="main">(</span>StepDecl <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> 
     <span class="keyword1">let</span> <span class="bound">edgeF</span> <span class="main">=</span> <span class="main">λ</span><span class="bound">d</span> <span class="main">(</span><span class="bound">lbls</span><span class="main">,</span><span class="bound">pri</span><span class="main">,</span><span class="bound">pos</span><span class="main">,</span><span class="bound">nxt</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> 
        <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECTrue<span class="main">,</span> effect <span class="main">=</span> EEDecl <span class="bound">d</span><span class="main">,</span> target <span class="main">=</span> <span class="bound">nxt</span><span class="main">,</span> 
             prio <span class="main">=</span> <span class="bound">pri</span><span class="main">,</span> atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="bound">pos</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span>
     <span class="keyword1">in</span> 
        step_fold <span class="bound">edgeF</span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> False<span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stepToState</span> StepSkip <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntAtomic <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">es</span><span class="main">,</span><span class="bound">pos'</span><span class="main">,</span><span class="bound">lbls'</span><span class="main">)</span> <span class="main">=</span> step_fold <span class="free">stepToState</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">let</span> <span class="bound">es'</span> <span class="main">=</span> map <span class="main">(</span>atomize <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="main">+</span> length <span class="bound">es</span><span class="main">)</span><span class="main">)</span> <span class="bound">es</span> <span class="keyword1">in</span>
    <span class="main">(</span><span class="bound">es'</span><span class="main">,</span> <span class="bound">pos'</span><span class="main">,</span> <span class="bound">lbls'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntLabeled <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
         <span class="main">(</span><span class="bound">es</span><span class="main">,</span> <span class="bound">pos'</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span> <span class="main">=</span> <span class="free">stmntToState</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span><span class="main">;</span>
         
         <span class="comment1">― ‹We don't resolve goto-chains. If the labeled stmnt returns only a jump,›</span>
         <span class="comment1">― ‹use this goto state.›</span>
         <span class="bound">lpos</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="bound">pos'</span> <span class="keyword1">of</span> Index <span class="bound">p</span> <span class="main">⇒</span> <span class="bound">p</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">;</span>
         <span class="bound">lbls'</span> <span class="main">=</span> add_label <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">lbls</span> <span class="bound">lpos</span>
     <span class="keyword1">in</span>
       <span class="main">(</span><span class="bound">es</span><span class="main">,</span> <span class="bound">pos'</span><span class="main">,</span> <span class="bound">lbls'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntDo <span class="free"><span class="bound"><span class="entity">stepss</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span>
       <span class="comment1">― ‹construct the different branches›</span>
       <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>nxt›</span></span> in those branches points current pos (it is a loop after all)›</span>
       <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>onxt›</span></span> then is the current <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>nxt›</span></span> (needed for break, f.ex.)›</span>
       <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">lbls</span><span class="main">,</span><span class="bound">es</span><span class="main">,</span><span class="bound">is</span><span class="main">)</span> <span class="main">=</span> step_foldL <span class="free">stepToState</span> <span class="free"><span class="bound"><span class="entity">stepss</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> 
                                     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span>Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">)</span><span class="main">;</span>

       <span class="comment1">― ‹put the branch starting points (<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>is›</span></span>) into the array›</span>
       <span class="bound">es'</span> <span class="main">=</span> concat <span class="bound">is</span> <span class="main">#</span> <span class="bound">es</span>
    <span class="keyword1">in</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span> <span class="keyword1">then</span> 
           <span class="comment1">― ‹inside another DO or IF or UNLESS›</span>
           <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>⟶›</span></span> append branches again, so they can be consumed›</span>
           <span class="main">(</span><span class="bound">es'</span> <span class="main">@</span> <span class="main">[</span>concat <span class="bound">is</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span>
      <span class="keyword1">else</span> 
          <span class="main">(</span><span class="bound">es'</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span>
   <span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntIf <span class="free"><span class="bound"><span class="entity">stepss</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">pos</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">lbls</span><span class="main">,</span><span class="bound">es</span><span class="main">,</span><span class="bound">is</span><span class="main">)</span> <span class="main">=</span> step_foldL <span class="free">stepToState</span> <span class="free"><span class="bound"><span class="entity">stepss</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> 
     <span class="keyword1">in</span> <span class="main">(</span><span class="bound">es</span> <span class="main">@</span> <span class="main">[</span>concat <span class="bound">is</span><span class="main">]</span><span class="main">,</span> Index <span class="bound">pos</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntSeq <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span><span class="main">)</span> <span class="main">=</span> 
     step_fold <span class="free">stepToState</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span> <span class="free"><span class="bound"><span class="entity">inBlock</span></span></span>"</span></span>


<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECTrue<span class="main">,</span> effect <span class="main">=</span> EEAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntAssert <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECTrue<span class="main">,</span> effect <span class="main">=</span> EEAssert <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntCond <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECExpr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span> effect <span class="main">=</span> EEId<span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> StmntElse <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECElse<span class="main">,</span> effect <span class="main">=</span> EEId<span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> StmntBreak <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span>Some <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECTrue<span class="main">,</span> effect <span class="main">=</span> EEGoto<span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> StmntBreak <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span>None<span class="main">,</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
   abort <span class="keyword1">STR</span> <span class="inner_quoted">''Misplaced break''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span>Index <span class="main">0</span><span class="main">,</span>lm.empty<span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntRun <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">onxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECRun <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">,</span> effect <span class="main">=</span> EERun <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntGoTo <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECTrue<span class="main">,</span> effect <span class="main">=</span> EEGoto<span class="main">,</span> target <span class="main">=</span> LabelJump <span class="free"><span class="bound"><span class="entity">l</span></span></span> None<span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> LabelJump <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntSend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECSend <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> effect <span class="main">=</span> EESend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> <span class="main">(</span>StmntRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">[</span><span class="main">[</span><span class="main">⦇</span>cond <span class="main">=</span> ECRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">,</span> effect <span class="main">=</span> EERecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span><span class="main">,</span> target <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">nxt</span></span></span><span class="main">,</span> prio <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pri</span></span></span><span class="main">,</span> 
        atomic <span class="main">=</span> NonAtomic <span class="main">⦈</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> Index <span class="free"><span class="bound"><span class="entity">pos</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span><span class="main">)</span>"</span></span>

<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">stmntToState</span> StmntSkip <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> skip <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Setup›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">endState</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="comment1">― ‹An extra state added to each process marking its end.›</span>
  <span class="quoted"><span class="quoted">"<span class="free">endState</span> <span class="main">=</span> <span class="main">[</span><span class="main">⦇</span> cond <span class="main">=</span> ECFalse<span class="main">,</span> effect <span class="main">=</span> EEEnd<span class="main">,</span> target <span class="main">=</span> Index <span class="main">0</span><span class="main">,</span> prio <span class="main">=</span> <span class="main">0</span><span class="main">,</span> 
                  atomic <span class="main">=</span> NonAtomic<span class="main">⦈</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">resolveLabel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> labels <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resolveLabel</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> lm.lookup <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="keyword1">of</span> 
       None <span class="main">⇒</span> abortv <span class="keyword1">STR</span> <span class="inner_quoted">''Unresolved label: ''</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>
     <span class="main">|</span> Some <span class="bound">pos</span> <span class="main">⇒</span> <span class="bound">pos</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">resolveLabels</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge list list <span class="main">⇒</span> labels <span class="main">⇒</span> edge list <span class="main">⇒</span> edge list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resolveLabels</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">resolveLabels</span> <span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="bound">check_atomic</span> <span class="main">=</span> <span class="main">λ</span><span class="bound">pos</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∧</span> inAtomic <span class="bound">e</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="main">!</span> <span class="bound">pos</span><span class="main">)</span> True <span class="keyword1">in</span>
    <span class="keyword1">case</span> target <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> 
      Index <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> 
    <span class="main">|</span> LabelJump <span class="bound">l</span> None <span class="main">⇒</span> 
         <span class="keyword1">let</span> <span class="bound">pos</span> <span class="main">=</span> resolveLabel <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="keyword1">in</span>
           <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⦇</span>target <span class="main">:=</span> Index <span class="bound">pos</span><span class="main">,</span> 
              atomic <span class="main">:=</span> <span class="keyword1">if</span> inAtomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">then</span>
                           <span class="keyword1">if</span> <span class="bound">check_atomic</span> <span class="bound">pos</span> <span class="keyword1">then</span> Atomic 
                           <span class="keyword1">else</span> InAtomic
                        <span class="keyword1">else</span> NonAtomic <span class="main">⦈</span>
     <span class="main">|</span> LabelJump <span class="bound">l</span> <span class="main">(</span>Some <span class="bound">via</span><span class="main">)</span> <span class="main">⇒</span> 
          <span class="keyword1">let</span> <span class="bound">pos</span> <span class="main">=</span> resolveLabel <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="keyword1">in</span>
            <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⦇</span>target <span class="main">:=</span> Index <span class="bound">pos</span><span class="main">,</span>
               <span class="comment1">― ‹NB: <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>isAtomic›</span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>inAtomic›</span></span>, cf <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>atomize()›</span></span>›</span>
               atomic <span class="main">:=</span> <span class="keyword1">if</span> isAtomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">then</span>
                            <span class="keyword1">if</span> <span class="bound">check_atomic</span> <span class="bound">pos</span> <span class="main">∧</span> <span class="bound">check_atomic</span> <span class="bound">via</span> <span class="keyword1">then</span> Atomic
                            <span class="keyword1">else</span> InAtomic
                         <span class="keyword1">else</span> atomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">⦈</span>
   <span class="main">)</span> <span class="main">#</span> <span class="main">(</span><span class="free">resolveLabels</span> <span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="free"><span class="bound"><span class="entity">lbls</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">calculatePrios</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge list list <span class="main">⇒</span> <span class="main">(</span>integer <span class="main">*</span> edge list<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">calculatePrios</span> <span class="free"><span class="bound"><span class="entity">ess</span></span></span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">es</span><span class="main">.</span> <span class="main">(</span>min_prio <span class="bound">es</span> <span class="main">0</span><span class="main">,</span> <span class="bound">es</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ess</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">toStates</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"step list <span class="main">⇒</span> states <span class="main">*</span> edgeIndex <span class="main">*</span> labels"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">toStates</span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> 
       <span class="main">(</span><span class="bound">states</span><span class="main">,</span><span class="bound">pos</span><span class="main">,</span><span class="bound">lbls</span><span class="main">)</span> <span class="main">=</span> step_fold stepToState <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="main">(</span>lm.empty<span class="main">()</span><span class="main">)</span> 
                                     <span class="main">0</span> <span class="main">1</span> <span class="main">(</span>Index <span class="main">0</span><span class="main">)</span> None False<span class="main">;</span>
       <span class="bound">pos</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">pos</span> <span class="keyword1">of</span> 
                Index <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">pos</span> 
              <span class="main">|</span> LabelJump <span class="bound">l</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Index <span class="main">(</span>resolveLabel <span class="bound">l</span> <span class="bound">lbls</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">states</span> <span class="main">=</span> endState <span class="main">#</span> <span class="bound">states</span><span class="main">;</span>
       <span class="bound">states</span> <span class="main">=</span> map <span class="main">(</span>resolveLabels <span class="bound">states</span> <span class="bound">lbls</span><span class="main">)</span> <span class="bound">states</span><span class="main">;</span>
       <span class="bound">states</span> <span class="main">=</span> calculatePrios <span class="bound">states</span>
    <span class="keyword1">in</span>
    <span class="keyword1">case</span> <span class="bound">pos</span> <span class="keyword1">of</span> Index <span class="bound">s</span> <span class="main">⇒</span> 
          <span class="keyword1">if</span> <span class="bound">s</span> <span class="main">&lt;</span> length <span class="bound">states</span> <span class="keyword1">then</span> <span class="main">(</span>IArray <span class="bound">states</span><span class="main">,</span> <span class="bound">pos</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span>
          <span class="keyword1">else</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Start index out of bounds''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span>IArray <span class="bound">states</span><span class="main">,</span> Index <span class="main">0</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-toStates_inv"><span class="command">lemma</span></span> toStates_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"toStates <span class="free">steps</span> <span class="main">=</span> <span class="main">(</span><span class="free">ss</span><span class="main">,</span><span class="free">start</span><span class="main">,</span><span class="free">lbls</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="free">start</span> <span class="main">=</span> Index <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">&lt;</span> IArray.length <span class="free">ss</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"IArray.length <span class="free">ss</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> toStates_def calculatePrios_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits edgeIndex.splits if_splits<span class="main">)</span>

<span class="comment1">(* returns: states * is_active * name * labels * process *)</span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">toProcess</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> proc <span class="main">⇒</span> states <span class="main">*</span> nat <span class="main">*</span> String.literal <span class="main">*</span> <span class="main">(</span>labels <span class="main">*</span> process<span class="main">)</span>"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">toProcess</span> <span class="free"><span class="bound"><span class="entity">sidx</span></span></span> <span class="main">(</span>ProcType <span class="free"><span class="bound"><span class="entity">act</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span>
       <span class="main">(</span><span class="bound">states</span><span class="main">,</span> <span class="bound">start</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span> <span class="main">=</span> toStates <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">;</span>
       <span class="bound">act</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">act</span></span></span> <span class="keyword1">of</span> 
                None <span class="main">⇒</span> <span class="main">0</span> 
              <span class="main">|</span> Some None <span class="main">⇒</span> <span class="main">1</span> 
              <span class="main">|</span> Some <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">⇒</span> nat_of_integer <span class="bound">x</span><span class="main">)</span>
     <span class="keyword1">in</span>
        <span class="main">(</span><span class="bound">states</span><span class="main">,</span> <span class="bound">act</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">,</span> <span class="bound">lbls</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">sidx</span></span></span><span class="main">,</span> <span class="bound">start</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">toProcess</span> <span class="free"><span class="bound"><span class="entity">sidx</span></span></span> <span class="main">(</span>Init <span class="free"><span class="bound"><span class="entity">decls</span></span></span> <span class="free"><span class="bound"><span class="entity">steps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">states</span><span class="main">,</span> <span class="bound">start</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">)</span> <span class="main">=</span> toStates <span class="free"><span class="bound"><span class="entity">steps</span></span></span> <span class="keyword1">in</span> 
      <span class="main">(</span><span class="bound">states</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="keyword1">STR</span> <span class="inner_quoted">'':init:''</span><span class="main">,</span> <span class="bound">lbls</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">sidx</span></span></span><span class="main">,</span> <span class="bound">start</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">decls</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-toProcess_sidx"><span class="command">lemma</span></span> toProcess_sidx<span class="main">:</span>
  <span class="quoted"><span class="quoted">"toProcess <span class="free">sidx</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">ss</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">n</span><span class="main">,</span><span class="free">l</span><span class="main">,</span><span class="free">idx</span><span class="main">,</span><span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">idx</span> <span class="main">=</span> <span class="free">sidx</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Promela-toProcess_states_nonempty"><span class="command">lemma</span></span> toProcess_states_nonempty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"toProcess <span class="free">sidx</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">ss</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">n</span><span class="main">,</span><span class="free">l</span><span class="main">,</span><span class="free">idx</span><span class="main">,</span><span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> IArray.length <span class="free">ss</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> toStates_inv<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Promela-toProcess_start"><span class="command">lemma</span></span> toProcess_start<span class="main">:</span>
  <span class="quoted"><span class="quoted">"toProcess <span class="free">sidx</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">ss</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">n</span><span class="main">,</span><span class="free">l</span><span class="main">,</span><span class="free">idx</span><span class="main">,</span><span class="free">start</span><span class="main">,</span><span class="free">r</span><span class="main">)</span> 
   <span class="main">⟹</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="free">start</span> <span class="main">=</span> Index <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">&lt;</span> IArray.length <span class="free">ss</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> toStates_inv<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1" id="Promela-toProcess_startE"><span class="command">lemma</span></span> toProcess_startE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"toProcess <span class="free">sidx</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">ss</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">n</span><span class="main">,</span><span class="free">l</span><span class="main">,</span><span class="free">idx</span><span class="main">,</span><span class="free">start</span><span class="main">,</span><span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">start</span> <span class="main">=</span> Index <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">&lt;</span> IArray.length <span class="free">ss</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> toProcess_start<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The main construction function. Takes an AST 
  and returns  an initial state, 
  and the program (= transition system).
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">setUp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast <span class="main">⇒</span> program <span class="main">×</span> gState"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">setUp</span> <span class="free"><span class="bound"><span class="entity">ast</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span>
       <span class="main">(</span><span class="bound">decls</span><span class="main">,</span> <span class="bound">procs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> preprocess <span class="free"><span class="bound"><span class="entity">ast</span></span></span><span class="main">;</span>
       <span class="bound">assertVar</span> <span class="main">=</span> Var <span class="main">(</span>VTBounded <span class="main">0</span> <span class="main">1</span><span class="main">)</span> <span class="main">0</span><span class="main">;</span>
 
       <span class="bound">pre_procs</span> <span class="main">=</span> map <span class="main">(</span>case_prod toProcess<span class="main">)</span> <span class="main">(</span>List.enumerate <span class="main">1</span> <span class="bound">procs</span><span class="main">)</span><span class="main">;</span>

       <span class="bound">procs</span> <span class="main">=</span> IArray <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> Index <span class="main">0</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> <span class="bound">p</span><span class="main">)</span> <span class="bound">pre_procs</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">labels</span> <span class="main">=</span> IArray <span class="main">(</span>lm.empty<span class="main">()</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">l</span><span class="main">)</span> <span class="bound">pre_procs</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">states</span> <span class="main">=</span> IArray <span class="main">(</span>IArray <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span><span class="main">]</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">pre_procs</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">names</span> <span class="main">=</span> IArray <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''invalid''</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">n</span><span class="main">)</span> <span class="bound">pre_procs</span><span class="main">)</span><span class="main">;</span>

       <span class="bound">proc_data</span> <span class="main">=</span> lm.to_map <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">idx</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">idx</span><span class="main">)</span><span class="main">)</span> <span class="bound">pre_procs</span><span class="main">)</span><span class="main">;</span>
       
       <span class="bound">prog</span> <span class="main">=</span> <span class="main">⦇</span> processes <span class="main">=</span> <span class="bound">procs</span><span class="main">,</span> labels <span class="main">=</span> <span class="bound">labels</span><span class="main">,</span> states <span class="main">=</span> <span class="bound">states</span><span class="main">,</span> 
                 proc_names <span class="main">=</span> <span class="bound">names</span><span class="main">,</span> proc_data <span class="main">=</span> <span class="bound">proc_data</span> <span class="main">⦈</span><span class="main">;</span>
     
       <span class="bound">g</span> <span class="main">=</span> <span class="main">⦇</span> vars <span class="main">=</span> lm.sng <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''__assert__''</span><span class="main">)</span> <span class="bound">assertVar</span><span class="main">,</span> 
              channels <span class="main">=</span> <span class="main">[</span>InvChannel<span class="main">]</span><span class="main">,</span> timeout <span class="main">=</span> False<span class="main">,</span> procs <span class="main">=</span> <span class="main">[]</span> <span class="main">⦈</span><span class="main">;</span>
       <span class="bound">g'</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">d</span><span class="main">.</span> 
                    fst <span class="main">(</span>mkVarChannel <span class="bound">d</span> <span class="main">(</span>apfst <span class="main">∘</span> gState.vars_update<span class="main">)</span> <span class="bound">g</span> emptyProc<span class="main">)</span>
                  <span class="main">)</span> <span class="bound">g</span> <span class="bound">decls</span><span class="main">;</span>
       <span class="bound">g''</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">name</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> 
                    foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">name</span><span class="main">.</span> 
                              fst <span class="main">(</span>runProc <span class="bound">name</span> <span class="main">[]</span> <span class="bound">prog</span> <span class="bound">g</span> emptyProc<span class="main">)</span>
                          <span class="main">)</span> <span class="bound">g</span> <span class="main">(</span>replicate <span class="bound">a</span> <span class="bound">name</span><span class="main">)</span>
                   <span class="main">)</span> <span class="bound">g'</span> <span class="bound">pre_procs</span>
      <span class="keyword1">in</span>
       <span class="main">(</span><span class="bound">prog</span><span class="main">,</span> <span class="bound">g''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-setUp_program_inv'"><span class="command">lemma</span></span> setUp_program_inv'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"program_inv <span class="main">(</span>fst <span class="main">(</span>setUp <span class="free">ast</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> program_invI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setUp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setUp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setUp_def o_def  
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits 
             <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> toProcess_states_nonempty<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 4 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> setUp_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lm.correct o_def in_set_enumerate_eq nth_enumerate_eq 
            <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Misc.ran_map_of<span class="main"><span class="main">]</span></span> toProcess_sidx 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="comment1">(* TODO: Change name Misc.ran_map_of ⟶ ran_map_of_ss, as it collides 
      with AList.ran_map_of *)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 5 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setUp_def o_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> toProcess_sidx<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> toProcess_start<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_enumerate_eq nth_enumerate_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Promela-setUp_program_inv"><span class="command">lemma</span></span> setUp_program_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"setUp <span class="free">ast</span> <span class="main">=</span> <span class="main">(</span><span class="free">prog</span><span class="main">,</span><span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms setUp_program_inv' 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv<span class="main">)</span>

<span class="keyword1" id="Promela-setUp_gState_inv"><span class="command">lemma</span></span> setUp_gState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"setUp <span class="free">ast</span> <span class="main">=</span> <span class="main">(</span><span class="free">prog</span><span class="main">,</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> p_INV<span class="main">:</span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> setUp_program_inv<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">prog</span> <span class="main">::</span> <span class="quoted">program</span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"program_inv <span class="skolem">prog</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span> vars <span class="main">=</span> lm.sng <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''__assert__''</span><span class="main">)</span> <span class="main">(</span>Var <span class="main">(</span>VTBounded <span class="main">0</span> <span class="main">1</span><span class="main">)</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> 
                 channels <span class="main">=</span> <span class="main">[</span>InvChannel<span class="main">]</span><span class="main">,</span> timeout <span class="main">=</span> False<span class="main">,</span> procs <span class="main">=</span> <span class="main">[]</span> <span class="main">⦈</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted">"gState_inv <span class="skolem">prog</span> <span class="var">?g</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def max_channels_def lm_correct max_var_value_def<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">decls</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="skolem">prog</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="skolem">prog</span> <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">d</span><span class="main">.</span>  
                   fst <span class="main">(</span>mkVarChannel <span class="bound">d</span> <span class="main">(</span>apfst <span class="main">∘</span> gState.vars_update<span class="main">)</span> <span class="bound">g</span> emptyProc<span class="main">)</span>
                  <span class="main">)</span> <span class="skolem">g</span> <span class="skolem">decls</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> mkVarChannel_gState_inv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">σ</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> toVariable_variable_inv'<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def lm.correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> g2 <span class="main">=</span> this<span class="main">[</span><span class="operator">OF</span> g1<span class="main">]</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">pre_procs</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="skolem">prog</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="skolem">prog</span> <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">name</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> 
                 foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">name</span><span class="main">.</span> 
                         fst <span class="main">(</span>runProc <span class="bound">name</span> <span class="main">[]</span> <span class="skolem">prog</span> <span class="bound">g</span> emptyProc<span class="main">)</span>
                       <span class="main">)</span> <span class="bound">g</span> <span class="main">(</span>replicate <span class="bound">a</span> <span class="bound">name</span><span class="main">)</span>
              <span class="main">)</span> <span class="skolem">g</span> <span class="skolem">pre_procs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> runProc_gState_inv emptyProc_pState_inv *<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">OF</span> g2<span class="main">]</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> g_INV <span class="main">=</span> this

  <span class="keyword1"><span class="command">from</span></span> assms p_INV <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> setUp_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> g_INV<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Semantic Engine›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  After constructing the transition system, we are missing the final part:
  The successor function on this system. We use SPIN-nomenclature and call it
  \emph{semantic engine}.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">assertVar</span> <span class="main">≡</span> VarRef True <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''__assert__''</span><span class="main">)</span> None"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Evaluation of Edges›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">evalRecvArgs</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"recvArg list <span class="main">⇒</span> integer list <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> pState <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">*</span> pState"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalRecvArgs</span> <span class="main">[]</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalRecvArgs</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>  <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> 
     abort <span class="keyword1">STR</span> <span class="inner_quoted">''Length mismatch on receiving.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalRecvArgs</span> <span class="main">[]</span>  <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> 
     abort <span class="keyword1">STR</span> <span class="inner_quoted">''Length mismatch on receiving.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalRecvArgs</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="main">=</span>
       <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> 
          RecvArgVar <span class="bound">var</span> <span class="main">⇒</span> setVar <span class="bound">var</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>
        <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>
     <span class="keyword1">in</span> <span class="free">evalRecvArgs</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="bound">g</span> <span class="bound">l</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">evalCond</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"edgeCond <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> pState <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> ECTrue <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> ECFalse <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> <span class="main">(</span>ECExpr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> <span class="main">(</span>ECRun <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> length <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">255</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> ECElse <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> <span class="main">(</span>ECSend <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> 
     withChannel <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">c</span><span class="main">.</span>
       <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
         Channel <span class="bound">cap</span> <span class="main"><span class="bound">_</span></span> <span class="bound">q</span> <span class="main">⇒</span> integer_of_nat <span class="main">(</span>length <span class="bound">q</span><span class="main">)</span> <span class="main">&lt;</span> <span class="bound">cap</span> 
       <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalCond</span> <span class="main">(</span>ECRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> 
     withChannel <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">c</span><span class="main">.</span> 
       <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span>
         HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> handshake <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> recvArgsCheck <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">(</span>hsdata <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> pollCheck <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">evalHandshake</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"edgeCond <span class="main">⇒</span> nat <span class="main">⇒</span>  gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> pState <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalHandshake</span> <span class="main">(</span>ECRecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
    <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="main">0</span> 
     <span class="main">∨</span> withChannel <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
                             HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> 
                           <span class="main">|</span> Channel <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalHandshake</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">evalEffect</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"edgeEffect <span class="main">⇒</span> program <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> pState <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">*</span> pState"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> EEEnd <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> EEId <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> EEGoto <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EEAssign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> setVar <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EEDecl <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> mkVarChannelProc <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EERun <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> runProc <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EEAssert <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">if</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">0</span> 
     <span class="keyword1">then</span> setVar assertVar <span class="main">1</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
     <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EESend <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> withChannel <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">c</span><span class="main">.</span> 
     <span class="keyword1">let</span> 
       <span class="bound">ab</span> <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Length mismatch on sending.''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">es</span> <span class="main">=</span> map <span class="main">(</span>exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span>
     <span class="keyword1">in</span>
       <span class="keyword1">if</span> <span class="main">¬</span> for_all <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≥</span> min_var_value <span class="main">∧</span> <span class="bound">x</span> <span class="main">≤</span> max_var_value<span class="main">)</span> <span class="bound">es</span> 
       <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid Channel''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>
       <span class="keyword1">else</span>
          <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
            Channel <span class="bound">cap</span> <span class="bound">ts</span> <span class="bound">q</span> <span class="main">⇒</span> 
              <span class="keyword1">if</span> length <span class="bound">ts</span> <span class="main">≠</span> length <span class="bound">es</span> <span class="main">∨</span> <span class="main">¬</span> <span class="main">(</span>length <span class="bound">q</span> <span class="main">&lt;</span> max_array_size<span class="main">)</span> 
              <span class="keyword1">then</span> <span class="bound">ab</span><span class="main">()</span>
              <span class="keyword1">else</span> <span class="keyword1">let</span>
                     <span class="bound">q'</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="bound">q</span><span class="main">@</span><span class="main">[</span><span class="bound">es</span><span class="main">]</span>
                          <span class="keyword1">else</span> <span class="keyword1">let</span>
                            <span class="bound">q</span> <span class="main">=</span> map lexlist <span class="bound">q</span><span class="main">;</span>
                            <span class="bound">q'</span> <span class="main">=</span> insort <span class="main">(</span>lexlist <span class="bound">es</span><span class="main">)</span> <span class="bound">q</span>
                          <span class="keyword1">in</span> map unlex <span class="bound">q'</span><span class="main">;</span>
                     <span class="bound">g</span> <span class="main">=</span> gState.channels_update <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> 
                              <span class="bound">cs</span><span class="main">[</span> <span class="bound">i</span> <span class="main">:=</span> Channel <span class="bound">cap</span> <span class="bound">ts</span> <span class="bound">q'</span> <span class="main">]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>
                   <span class="keyword1">in</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>
          <span class="main">|</span> HSChannel <span class="bound">ts</span> <span class="main">⇒</span>
              <span class="keyword1">if</span> length <span class="bound">ts</span> <span class="main">≠</span> length <span class="bound">es</span> <span class="keyword1">then</span> <span class="bound">ab</span><span class="main">()</span>
              <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span>hsdata <span class="main">:=</span> <span class="bound">es</span><span class="main">,</span> handshake <span class="main">:=</span> <span class="bound">i</span><span class="main">⦈</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>
          <span class="main">|</span> InvChannel <span class="main">⇒</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Trying to send on invalid channel''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">evalEffect</span> <span class="main">(</span>EERecv <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> withChannel <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">c</span><span class="main">.</span> 
     <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> 
       Channel <span class="bound">cap</span> <span class="bound">ts</span> <span class="bound">qs</span> <span class="main">⇒</span>
          <span class="keyword1">if</span> <span class="bound">qs</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Recv from empty channel''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1">else</span>
             <span class="keyword1">let</span>
               <span class="main">(</span><span class="bound">q'</span><span class="main">,</span> <span class="bound">qs'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">srt</span></span></span> <span class="keyword1">then</span> <span class="main">(</span>hd <span class="bound">qs</span><span class="main">,</span> tl <span class="bound">qs</span><span class="main">)</span>
                           <span class="keyword1">else</span> apfst the <span class="main">(</span>find_remove <span class="main">(</span>recvArgsCheck <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="bound">qs</span><span class="main">)</span><span class="main">;</span>
               <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="main">=</span> evalRecvArgs <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="bound">q'</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span>
               <span class="bound">g</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">rem</span></span></span> 
                   <span class="keyword1">then</span> gState.channels_update <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="bound">cs</span><span class="main">[</span> <span class="bound">i</span> <span class="main">:=</span> Channel <span class="bound">cap</span> <span class="bound">ts</span> <span class="bound">qs'</span><span class="main">]</span><span class="main">)</span> <span class="bound">g</span>
                   <span class="keyword1">else</span> <span class="bound">g</span>
                     <span class="comment1">― ‹messages are not removed -- so no need to update anything›</span>
             <span class="keyword1">in</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
      <span class="main">|</span> HSChannel <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> 
             <span class="keyword1">let</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="main">=</span> evalRecvArgs <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">(</span>hsdata <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span>
             <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> <span class="bound">g</span><span class="main">⦇</span> handshake <span class="main">:=</span> <span class="main">0</span><span class="main">,</span> hsdata <span class="main">:=</span> <span class="main">[]</span> <span class="main">⦈</span>
             <span class="keyword1">in</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
      <span class="main">|</span> InvChannel <span class="main">⇒</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Receiving on invalid channel''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>
   <span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1" id="Promela-statesDecls_effect"><span class="command">lemma</span></span> statesDecls_effect<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ef</span> <span class="main">∈</span> effect <span class="main">`</span> edgeSet <span class="free">ss</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">ef</span> <span class="main">=</span> EEDecl <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> statesDecls <span class="free">ss</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> edgeSet <span class="free">ss</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ef</span> <span class="main">=</span> effect <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> statesDecls_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edgeDecls_def 
             <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">e</span></span><span class="main"><span class="main">]</span></span> 
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> edgeEffect.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Promela-evalRecvArgs_pState_inv"><span class="command">lemma</span></span> evalRecvArgs_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>evalRecvArgs <span class="free">rargs</span> <span class="free">xs</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rargs</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">r</span> <span class="skolem">rs</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>RecvArgVar <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span>  new<span class="main">:</span> <span class="quoted"><span class="quoted">"setVar <span class="skolem">v</span> <span class="skolem">x</span> <span class="skolem">g</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> snd <span class="main">(</span>setVar <span class="skolem">v</span> <span class="skolem">x</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"4"</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> setVar_pState_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"4.IH"</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> RecvArgVar new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Promela-evalRecvArgs_pState_inv'"><span class="command">lemma</span></span> evalRecvArgs_pState_inv'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"evalRecvArgs <span class="free">rargs</span> <span class="free">xs</span> <span class="free">g</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">g'</span><span class="main">,</span> <span class="free">p'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms evalRecvArgs_pState_inv 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv<span class="main">)</span>

<span class="keyword1" id="Promela-evalRecvArgs_gState_progress_rel"><span class="command">lemma</span></span> evalRecvArgs_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>evalRecvArgs <span class="free">rargs</span> <span class="free">xs</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rargs</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">r</span> <span class="skolem">rs</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>RecvArgVar <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"setVar <span class="skolem">v</span> <span class="skolem">x</span> <span class="skolem">g</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g'</span> <span class="main">=</span> fst <span class="main">(</span>setVar <span class="skolem">v</span> <span class="skolem">x</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"4"</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span><span class="main">,</span> <span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> setVar_gState_progress_rel<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="skolem">g'</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gState_progress_rel_gState_invI2<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="quoted">"4.IH"</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> RecvArgVar new <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> evalRecvArgs_gState_inv <span class="main">=</span> 
  evalRecvArgs_gState_progress_rel<span class="main">[</span><span class="operator">THEN</span> gState_progress_rel_gState_invI2<span class="main">]</span>

<span class="keyword1" id="Promela-evalRecvArgs_cl_inv"><span class="command">lemma</span></span> evalRecvArgs_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>evalRecvArgs <span class="free">rargs</span> <span class="free">xs</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rargs</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">r</span> <span class="skolem">rs</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>RecvArgVar <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">with</span></span> 4 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span>setVar <span class="skolem">v</span> <span class="skolem">x</span> <span class="skolem">g</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> setVar_cl_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"4.IH"</span> RecvArgVar <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Promela-evalEffect_pState_inv"><span class="command">lemma</span></span> evalEffect_pState_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> effect <span class="main">`</span> edgeSet <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> pState.idx <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="main">(</span>snd <span class="main">(</span>evalEffect <span class="free">e</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EEDecl <span class="skolem">d</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> statesDecls <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> pState.idx <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> statesDecls_effect 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> assms EEDecl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> IArray.sub_def 
             <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mkVarChannelProc_pState_inv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EESend <span class="skolem">c</span> <span class="skolem">es</span> <span class="skolem">srt</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"ChanRef <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> EESend assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EERecv <span class="skolem">c</span> <span class="skolem">es</span> <span class="skolem">srt</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"ChanRef <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> EERecv assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span>  
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def 
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits channel.split 
             <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> evalRecvArgs_pState_inv'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> setVar_pState_inv runProc_pState_inv<span class="main">)</span>

<span class="keyword1" id="Promela-evalEffect_gState_progress_rel"><span class="command">lemma</span></span> evalEffect_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> fst <span class="main">(</span>evalEffect <span class="free">e</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> EEAssert 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> setVar_gState_progress_rel<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> EEAssign 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> setVar_gState_progress_rel<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> EEDecl 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mkVarChannelProc_gState_progress_rel<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> EERun 
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> runProc_gState_progress_rel<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EESend <span class="skolem">c</span> <span class="skolem">es</span> <span class="skolem">srt</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ChanRef <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> chanRef.exhaust<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">idx</span></span> <span class="keyword2"><span class="keyword">where</span></span> idx<span class="main">:</span> <span class="quoted"><span class="quoted">"nat_of_integer <span class="main">(</span>the <span class="main">(</span>getVar <span class="skolem">v</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">idx</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> idx' <span class="main">=</span> idx<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">unfolded</span> getVar_def<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">idx</span> <span class="main">&lt;</span> length <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True 
    <span class="keyword1"><span class="command">note</span></span> DEF <span class="main">=</span> True EESend v idx' assms
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"gState.channels <span class="free">g</span> <span class="main">!</span> <span class="skolem">idx</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span><span class="main">)</span> 
      <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span> <span class="main">∈</span> set <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nth_mem<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> channel_inv.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> Channel DEF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> 
           <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def for_all_def
                 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split 
                 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> gState_progress_rel_channels_update<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> HSChannel <span class="keyword1"><span class="command">with</span></span> DEF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> 
           <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def gState_progress_rel_def 
                       gState_inv_def
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> InvChannel <span class="keyword1"><span class="command">with</span></span> DEF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> EESend idx' v assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EERecv <span class="skolem">c</span> <span class="skolem">rs</span> <span class="skolem">srt</span> <span class="skolem">rem</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ChanRef <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> chanRef.exhaust<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">idx</span></span> <span class="keyword2"><span class="keyword">where</span></span> idx<span class="main">:</span> <span class="quoted"><span class="quoted">"nat_of_integer <span class="main">(</span>the <span class="main">(</span>getVar <span class="skolem">v</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">idx</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> idx' <span class="main">=</span> idx<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">unfolded</span> getVar_def<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">idx</span> <span class="main">&lt;</span> length <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True 
    <span class="keyword1"><span class="command">note</span></span> DEF <span class="main">=</span> True EERecv v idx' assms
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"gState.channels <span class="free">g</span> <span class="main">!</span> <span class="skolem">idx</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> channel_inv.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span><span class="main">)</span> 
      <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span> <span class="main">∈</span> set <span class="main">(</span>gState.channels <span class="free">g</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nth_mem<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> c_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> channel_inv.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">res</span></span> <span class="skolem"><span class="skolem">q'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        <span class="quoted"><span class="quoted">"apfst the <span class="main">(</span>find_remove <span class="main">(</span>recvArgsCheck <span class="free">g</span> <span class="free">p</span> <span class="skolem">rs</span><span class="main">)</span> <span class="skolem">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">res</span><span class="main">,</span> <span class="skolem">q'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span> <span class="main">=</span> snd <span class="main">(</span>find_remove <span class="main">(</span>recvArgsCheck <span class="free">g</span> <span class="free">p</span> <span class="skolem">rs</span><span class="main">)</span> <span class="skolem">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apfst_def map_prod_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> find_remove_subset find_remove_length <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"set <span class="skolem">q'</span> <span class="main">⊆</span> set <span class="skolem">q</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">q'</span> <span class="main">≤</span> length <span class="skolem">q</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> surjective_pairing<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">with</span></span> c_inv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="skolem">q'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> channel_inv.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>tl <span class="skolem">q</span><span class="main">)</span> <span class="main">⊆</span> set <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> tl_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> c_inv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"channel_inv <span class="main">(</span>Channel <span class="skolem">cap</span> <span class="skolem">ts</span> <span class="main">(</span>tl <span class="skolem">q</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> channel_inv.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">}</span></span> 
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">res</span> <span class="skolem">g'</span> <span class="skolem">p'</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"evalRecvArgs <span class="skolem">rs</span> <span class="skolem">res</span> <span class="free">g</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">with</span></span> evalRecvArgs_gState_progress_rel assms <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>channels <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>channels <span class="skolem">g'</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def<span class="main">)</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Channel DEF
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def for_all_def 
                    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split prod.split
                    <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> fstE 
                    <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evalRecvArgs_gState_progress_rel 
                            gState_progress_rel_channels_update_step<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> HSChannel 
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"evalRecvArgs <span class="skolem">rs</span> <span class="main">(</span>hsdata <span class="free">g</span><span class="main">)</span> <span class="free">g</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">p'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.exhaust<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fstE <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evalRecvArgs_gState_progress_rel<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="skolem">g'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span><span class="main">,</span><span class="skolem">g'</span><span class="main">⦇</span>handshake <span class="main">:=</span> <span class="main">0</span><span class="main">,</span> hsdata <span class="main">:=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_progress_rel_def gState_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="skolem">g'</span><span class="main">⦇</span>handshake <span class="main">:=</span> <span class="main">0</span><span class="main">,</span> hsdata <span class="main">:=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">with</span></span> DEF HSChannel * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def for_all_def 
                           <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split prod.split<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> InvChannel <span class="keyword1"><span class="command">with</span></span> DEF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> EERecv idx' v assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Promela-evalEffect_cl_inv"><span class="command">lemma</span></span> evalEffect_cl_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cl_inv  <span class="main">(</span>evalEffect <span class="free">e</span> <span class="free">prog</span> <span class="free">g</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> EERun <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> runProc_cl_inv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EESend <span class="skolem">c</span> <span class="skolem">es</span> <span class="skolem">srt</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"ChanRef <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> EESend assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split
             <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cl_inv_channels_update<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EERecv <span class="skolem">c</span> <span class="skolem">es</span> <span class="skolem">srt</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"ChanRef <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> EERecv assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> withChannel'_def withVar'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> channel.split prod.split
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cl_inv_channels_update<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> evalRecvArgs_cl_inv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setVar_cl_inv mkVarChannelProc_cl_inv<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Executable edges›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To find a successor global state, we first need to find all those edges which are executable
  (\ie the condition evaluates to true).
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> choices <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edge <span class="main">*</span> pState<span class="main">)</span> list"</span></span>
  <span class="comment1">― ‹A choice is an executable edge and the process it belongs to.›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">getChoices</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> pState <span class="main">⇒</span> edge list <span class="main">⇒</span> choices"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">getChoices</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">E</span> <span class="bound">e</span><span class="main">.</span> 
      <span class="keyword1">if</span> evalHandshake <span class="main">(</span>cond <span class="bound">e</span><span class="main">)</span> <span class="main">(</span>handshake <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> evalCond <span class="main">(</span>cond <span class="bound">e</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> 
      <span class="keyword1">then</span> <span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">#</span><span class="bound">E</span>
      <span class="keyword1">else</span> <span class="bound">E</span><span class="main">)</span> <span class="main">[]</span>"</span></span>

<span class="keyword1" id="Promela-getChoices_sub_edges_fst"><span class="command">lemma</span></span> getChoices_sub_edges_fst<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fst <span class="main">`</span> set <span class="main">(</span>getChoices <span class="free">g</span> <span class="free">p</span> <span class="free">es</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">es</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> getChoices_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Promela-getChoices_sub_edges"><span class="command">lemma</span></span> getChoices_sub_edges<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>getChoices <span class="free">g</span> <span class="free">p</span> <span class="free">es</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">∈</span> set <span class="free">es</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> getChoices_sub_edges_fst
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Promela-getChoices_p_snd"><span class="command">lemma</span></span> getChoices_p_snd<span class="main">:</span>
  <span class="quoted"><span class="quoted">"snd <span class="main">`</span> set <span class="main">(</span>getChoices <span class="free">g</span> <span class="free">p</span> <span class="free">es</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">p</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> getChoices_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Promela-getChoices_p"><span class="command">lemma</span></span> getChoices_p<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>getChoices <span class="free">g</span> <span class="free">p</span> <span class="free">es</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> getChoices_p_snd
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sort_by_pri</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sort_by_pri</span> <span class="free"><span class="bound"><span class="entity">min_pri</span></span></span> <span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">es</span> <span class="bound">e</span><span class="main">.</span> 
      <span class="keyword1">let</span> <span class="bound">idx</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>abs <span class="main">(</span>prio <span class="bound">e</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">idx</span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">min_pri</span></span></span> 
         <span class="keyword1">then</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Invalid priority''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">es</span><span class="main">)</span>
         <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">ep</span> <span class="main">=</span> <span class="bound">e</span> <span class="main">#</span> <span class="main">(</span><span class="bound">es</span> <span class="main">!</span> <span class="bound">idx</span><span class="main">)</span> <span class="keyword1">in</span> <span class="bound">es</span><span class="main">[</span><span class="bound">idx</span> <span class="main">:=</span> <span class="bound">ep</span><span class="main">]</span>
      <span class="main">)</span> <span class="main">(</span>replicate <span class="main">(</span><span class="free"><span class="bound"><span class="entity">min_pri</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">edges</span></span></span>"</span></span>

<span class="keyword1" id="Promela-sort_by_pri_edges'"><span class="command">lemma</span></span> sort_by_pri_edges'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">edges</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>sort_by_pri <span class="free">min_pri</span> <span class="free">edges</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> sort_by_pri_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="bound">σ</span><span class="main">.</span> set <span class="bound">x</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> length <span class="bound">σ</span> <span class="main">=</span> <span class="free">min_pri</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> foldl_rule_aux_P<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_update_subset_insert<span class="main"><span class="main">]</span></span> 
               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-sort_by_pri_edges"><span class="command">lemma</span></span> sort_by_pri_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">edges</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">es</span> <span class="main">∈</span> set <span class="main">(</span>sort_by_pri <span class="free">min_pri</span> <span class="free">edges</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">es</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> sort_by_pri_edges'<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Promela-sort_by_pri_length"><span class="command">lemma</span></span> sort_by_pri_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>sort_by_pri <span class="free">min_pri</span> <span class="free">edges</span><span class="main">)</span> <span class="main">=</span> <span class="free">min_pri</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sort_by_pri_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux_P <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> length <span class="bound">σ</span> <span class="main">=</span> <span class="free">min_pri</span> <span class="main">+</span> <span class="main">1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
   <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">executable</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"states iarray <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> choices nres"</span></span>
  <span class="comment1">― ‹Find all executable edges›</span>
 <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">executable</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span> <span class="bound">procs</span> <span class="main">=</span> procs <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">in</span>
      nfoldli <span class="bound">procs</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span> <span class="bound">E</span><span class="main">.</span>
        <span class="keyword1">if</span> <span class="main">(</span>exclusive <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> exclusive <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> pid <span class="bound">p</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">let</span> <span class="main">(</span><span class="bound">min_pri</span><span class="main">,</span> <span class="bound">edges</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> <span class="main">!!</span> pc <span class="bound">p</span><span class="main">;</span>
            ASSERT<span class="main">(</span>set <span class="bound">edges</span> <span class="main">⊆</span> edgeSet <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

            <span class="main">(</span><span class="bound">E'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> 
               <span class="keyword1">if</span> <span class="bound">min_pri</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">E</span><span class="main">,</span><span class="bound">brk</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="bound">brk</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">ELSE</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                     <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span>gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="main">:=</span> <span class="bound">ELSE</span><span class="main">⦈</span><span class="main">;</span>
                         <span class="bound">E</span> <span class="main">=</span> getChoices <span class="bound">g</span> <span class="bound">p</span> <span class="bound">edges</span>
                     <span class="keyword1">in</span>
                         <span class="keyword1">if</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">(</span>
                            <span class="keyword1">if</span> <span class="main">¬</span> <span class="bound">ELSE</span> <span class="keyword1">then</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span> <span class="main">0</span><span class="main">::</span>nat<span class="main">,</span> True<span class="main">)</span>
                            <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
                         <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="bound">ELSE</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="main">0</span><span class="main">::</span>nat<span class="main">,</span> False<span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">let</span> <span class="bound">min_pri</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>abs <span class="bound">min_pri</span><span class="main">)</span><span class="main">;</span>
                  <span class="keyword1">let</span> <span class="bound">pri_edges</span> <span class="main">=</span> sort_by_pri <span class="bound">min_pri</span> <span class="bound">edges</span><span class="main">;</span>
                  ASSERT <span class="main">(</span><span class="main">∀</span><span class="bound">es</span> <span class="main">∈</span> set <span class="bound">pri_edges</span><span class="main">.</span> 
                             set <span class="bound">es</span> <span class="main">⊆</span> edgeSet <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                  <span class="keyword1">let</span> <span class="bound">pri_edges</span> <span class="main">=</span> IArray <span class="bound">pri_edges</span><span class="main">;</span>

                  <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">E</span><span class="main">,</span><span class="bound">pri</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="bound">pri</span> <span class="main">≤</span> <span class="bound">min_pri</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">pri</span><span class="main">,</span> <span class="bound">ELSE</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                     <span class="keyword1">let</span> <span class="bound">es</span> <span class="main">=</span> <span class="bound">pri_edges</span> <span class="main">!!</span> <span class="bound">pri</span><span class="main">;</span>
                     <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span>gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="main">:=</span> <span class="bound">ELSE</span><span class="main">⦈</span><span class="main">;</span>
                     <span class="keyword1">let</span> <span class="bound">E</span> <span class="main">=</span> getChoices <span class="bound">g</span> <span class="bound">p</span> <span class="bound">es</span><span class="main">;</span>
                     <span class="keyword1">if</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">(</span>
                         <span class="keyword1">if</span> <span class="main">¬</span> <span class="bound">ELSE</span> <span class="keyword1">then</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span><span class="bound">pri</span><span class="main">,</span>True<span class="main">)</span>
                         <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span> <span class="bound">pri</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
                     <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">E</span><span class="main">,</span> <span class="bound">pri</span><span class="main">,</span> <span class="bound">ELSE</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> False<span class="main">)</span>
                <span class="main">}</span><span class="main">;</span> 
            RETURN <span class="main">(</span><span class="bound">E'</span><span class="main">@</span><span class="bound">E</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="bound">E</span>
      <span class="main">)</span> <span class="main">[]</span>
 <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">while_rel1</span> <span class="main">=</span> 
          measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> 
  <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> 
  <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">¬</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-wf_while_rel1"><span class="command">lemma</span></span> wf_while_rel1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"wf while_rel1"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> while_rel1_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">while_rel2</span> <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="main">=</span> 
          measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> 
  <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span> 
  <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">¬</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-wf_while_rel2"><span class="command">lemma</span></span> wf_while_rel2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"wf <span class="main">(</span>while_rel2 <span class="free">mp</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> while_rel2_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Promela-executable_edgeSet"><span class="command">lemma</span></span> executable_edgeSet<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">ss</span> <span class="main">=</span> states <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"executable <span class="free">ss</span> <span class="free">g</span> 
    <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">cs</span><span class="main">.</span> 
                    <span class="bound">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span><span class="free">ss</span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> 
                  <span class="main">∧</span> pState_inv <span class="free">prog</span> <span class="bound">p</span> 
                  <span class="main">∧</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> executable_def
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
              I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">cs</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">cs</span><span class="main">.</span> 
                              <span class="bound">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span><span class="free">ss</span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> 
                            <span class="main">∧</span> pState_inv <span class="free">prog</span> <span class="bound">p</span> 
                            <span class="main">∧</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> p l1 l2 σ e p'<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="improper">p</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edgeSet_def pState_inv_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"IArray.list_of 
                               <span class="main">(</span>IArray.list_of <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span> <span class="main">!</span> pState.idx <span class="improper">p</span><span class="main">)</span> <span class="main">!</span> pc <span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nth_mem<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> wf_while_rel1 WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
                 I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">cs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">cs</span><span class="main">.</span> 
                                  <span class="bound">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span><span class="free">ss</span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> 
                                <span class="main">∧</span> pState_inv <span class="free">prog</span> <span class="bound">p</span> 
                                <span class="main">∧</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>"</span></span> 
                 <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">while_rel1</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while_rel1_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> getChoices_p<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span>  getChoices_sub_edges <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> sort_by_pri_edges <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> min_pri pri_edges<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">cs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">cs</span><span class="main">.</span> 
                                  <span class="bound">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span><span class="free">ss</span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> 
                                <span class="main">∧</span> pState_inv <span class="free">prog</span> <span class="bound">p</span> 
                                <span class="main">∧</span> cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>"</span></span> 
              <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"while_rel2 <span class="main">(</span>nat_of_integer <span class="main">(</span>abs <span class="improper">min_pri</span><span class="main">)</span><span class="main">)</span>"</span></span> 
               <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> WHILET_rule<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_while_rel2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while_rel2_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> diff_less_mono lessI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> idx' else e p'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> getChoices_p<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> getChoices_sub_edges<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> 
             <span class="quoted"><span class="quoted">"sort_by_pri <span class="main">(</span>nat_of_integer <span class="main">¦</span><span class="improper">min_pri</span><span class="main">¦</span><span class="main">)</span> <span class="improper">pri_edges</span> <span class="main">!</span> <span class="improper">idx'</span> 
                 <span class="main">∈</span> set <span class="main">(</span>sort_by_pri <span class="main">(</span>nat_of_integer <span class="main">¦</span><span class="improper">min_pri</span><span class="main">¦</span><span class="main">)</span> <span class="improper">pri_edges</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms gState_inv_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_by_pri_length<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-executable_edgeSet'"><span class="command">lemma</span></span> executable_edgeSet'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"executable <span class="main">(</span>states <span class="free">prog</span><span class="main">)</span> <span class="free">g</span> 
  <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">cs</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">cs</span><span class="main">.</span> 
                  <span class="bound">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span><span class="main">(</span>states <span class="free">prog</span><span class="main">)</span> <span class="main">!!</span> pState.idx <span class="bound">p</span><span class="main">)</span> 
                <span class="main">∧</span> pState_inv <span class="free">prog</span> <span class="bound">p</span> 
                <span class="main">∧</span> cl_inv<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> executable_edgeSet<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ss <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"states <span class="free">prog</span>"</span></span><span class="main">]</span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> executable_refine<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?ex</span> <span class="free">s</span> <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> executable <span class="free">s</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> executable_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span><span class="main">)</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">executable_impl</span> <span class="keyword2"><span class="keyword">for</span></span> s g <span class="keyword2"><span class="keyword">uses</span></span> executable_refine

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Successor calculation›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">to<span class="hidden">⇩</span><sub>I</sub></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">to<span class="hidden">⇩</span><sub>I</sub></span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⦈</span> 
     <span class="main">=</span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> False<span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> 
          handshake <span class="main">=</span> <span class="main">0</span><span class="main">,</span> hsdata <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> exclusive <span class="main">=</span> <span class="main">0</span><span class="main">,</span> gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="main">=</span> False <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gState.cases<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> gState.ext_inject<span class="main">)</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">function</span></span> <span class="quoted">"<span class="entity">from<span class="hidden">⇩</span><sub>I</sub></span>"</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">from<span class="hidden">⇩</span><sub>I</sub></span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⦈</span> 
       <span class="main">=</span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gState.surjective<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> gState.ext_inject<span class="main">)</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">reset<span class="hidden">⇩</span><sub>I</sub></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reset<span class="hidden">⇩</span><sub>I</sub></span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> 
             handshake <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span><span class="main">,</span> hsdata <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">hsd</span></span></span><span class="main">,</span> exclusive <span class="main">=</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">,</span> gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="main">=</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⦈</span> 
        <span class="main">=</span> <span class="main">⦇</span> gState.vars <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> channels <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ch</span></span></span><span class="main">,</span> timeout <span class="main">=</span> False<span class="main">,</span> procs <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> 
             handshake <span class="main">=</span> <span class="main">0</span><span class="main">,</span> hsdata <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">hsd</span></span></span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">,</span> exclusive <span class="main">=</span> <span class="main">0</span><span class="main">,</span> 
             gState<span class="hidden">⇩</span><sub>I</sub>.else <span class="main">=</span> False <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span>  gState<span class="hidden">⇩</span><sub>I</sub>.surjective unit.exhaust<span class="main">)</span>
   <span class="main">(</span><span class="operator">metis</span> gState.select_convs gState<span class="hidden">⇩</span><sub>I</sub>.select_convs<span class="main">)</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1" id="Promela-gState_inv_to"><span class="command">lemma</span></span> gState_inv_to<span class="hidden">⇩</span><sub>I</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> <span class="main">=</span> gState_inv <span class="free">prog</span> <span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-gState_inv_from"><span class="command">lemma</span></span> gState_inv_from<span class="hidden">⇩</span><sub>I</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> <span class="main">=</span> gState_inv <span class="free">prog</span> <span class="main">(</span>from<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span>

<span class="keyword1" id="Promela-gState_inv_reset"><span class="command">lemma</span></span> gState_inv_reset<span class="hidden">⇩</span><sub>I</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span> <span class="main">=</span> gState_inv <span class="free">prog</span> <span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gState_inv_I_simps <span class="main">=</span> 
  gState_inv_to<span class="hidden">⇩</span><sub>I</sub> gState_inv_from<span class="hidden">⇩</span><sub>I</sub> gState_inv_reset<span class="hidden">⇩</span><sub>I</sub>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">removeProcs</span> 
  <span class="comment1">― ‹Remove ended processes, if there is no running one with a higher pid.›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">removeProcs</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="bound">p</span> <span class="main">(</span><span class="bound">dead</span><span class="main">,</span><span class="bound">sd</span><span class="main">,</span><span class="bound">ps</span><span class="main">,</span><span class="bound">dcs</span><span class="main">)</span><span class="main">.</span> 
           <span class="keyword1">if</span> <span class="bound">dead</span> <span class="main">∧</span> pc <span class="bound">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>True<span class="main">,</span> True<span class="main">,</span> <span class="bound">ps</span><span class="main">,</span> pState.channels <span class="bound">p</span> <span class="main">@</span> <span class="bound">dcs</span><span class="main">)</span>
           <span class="keyword1">else</span> <span class="main">(</span>False<span class="main">,</span> <span class="bound">sd</span><span class="main">,</span> <span class="bound">p</span><span class="main">#</span><span class="bound">ps</span><span class="main">,</span> <span class="bound">dcs</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">(</span>True<span class="main">,</span> False<span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>


<span class="keyword1" id="Promela-removeProcs_subset'"><span class="command">lemma</span></span> removeProcs_subset'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>removeProcs <span class="free">ps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">ps</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> removeProcs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> foldr_conv_foldl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux_P<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">ps'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> set <span class="bound">ps'</span> <span class="main">⊆</span> set <span class="free">ps</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> p<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">p</span> <span class="main">=</span> <span class="improper">x</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> set_rev<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-removeProcs_length'"><span class="command">lemma</span></span> removeProcs_length'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>removeProcs <span class="free">ps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> length <span class="free">ps</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> removeProcs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> foldr_conv_foldl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux_P<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">ps'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="bound">ps''</span><span class="main">.</span> length <span class="bound">ps'</span> <span class="main">+</span> length <span class="bound">ps''</span> <span class="main">≤</span> length <span class="free">ps</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-removeProcs_subset"><span class="command">lemma</span></span> removeProcs_subset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"removeProcs <span class="free">ps</span> <span class="main">=</span> <span class="main">(</span><span class="free">dead</span><span class="main">,</span><span class="free">sd</span><span class="main">,</span><span class="free">ps'</span><span class="main">,</span><span class="free">dcs</span><span class="main">)</span> <span class="main">⟹</span> set <span class="free">ps'</span> <span class="main">⊆</span> set <span class="free">ps</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> removeProcs_subset'
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv snd_conv<span class="main">)</span>

<span class="keyword1" id="Promela-removeProcs_length"><span class="command">lemma</span></span> removeProcs_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"removeProcs <span class="free">ps</span> <span class="main">=</span> <span class="main">(</span><span class="free">dead</span><span class="main">,</span><span class="free">sd</span><span class="main">,</span><span class="free">ps'</span><span class="main">,</span><span class="free">dcs</span><span class="main">)</span> <span class="main">⟹</span> length <span class="free">ps'</span> <span class="main">≤</span> length <span class="free">ps</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> removeProcs_length'
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv snd_conv<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cleanChans</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer list <span class="main">⇒</span> channels <span class="main">⇒</span> channels"</span></span> 
  <span class="comment1">― ‹Mark channels of closed processes as invalid.›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cleanChans</span> <span class="free"><span class="bound"><span class="entity">dchans</span></span></span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">=</span> snd <span class="main">(</span>foldl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">cs</span><span class="main">)</span> <span class="bound">c</span><span class="main">.</span> 
       <span class="keyword1">if</span> List.member <span class="free"><span class="bound"><span class="entity">dchans</span></span></span> <span class="bound">i</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">cs</span><span class="main">@</span><span class="main">[</span>InvChannel<span class="main">]</span><span class="main">)</span>
       <span class="keyword1">else</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">cs</span><span class="main">@</span><span class="main">[</span><span class="bound">c</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-cleanChans_channel_inv"><span class="command">lemma</span></span> cleanChans_channel_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">cs</span> <span class="main">⊆</span> Collect channel_inv"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>cleanChans <span class="free">dchans</span> <span class="free">cs</span><span class="main">)</span> <span class="main">⊆</span> Collect channel_inv"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> cleanChans_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> foldl_rule_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-cleanChans_length"><span class="command">lemma</span></span> cleanChans_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>cleanChans <span class="free">dchans</span> <span class="free">cs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">cs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cleanChans_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> foldl_rule_aux_P<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
       I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cs'</span><span class="main">)</span> <span class="bound">cs''</span><span class="main">.</span> length <span class="bound">cs'</span> <span class="main">+</span> length <span class="bound">cs''</span> <span class="main">=</span> length <span class="free">cs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
   <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">checkDeadProcs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gState_scheme <span class="main">⇒</span> <span class="tfree">'a</span> gState_scheme"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkDeadProcs</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">(</span> 
     <span class="keyword1">let</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">soDied</span><span class="main">,</span> <span class="bound">procs</span><span class="main">,</span> <span class="bound">dchans</span><span class="main">)</span> <span class="main">=</span> removeProcs <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
     <span class="keyword1">if</span> <span class="bound">soDied</span> <span class="keyword1">then</span>
         <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦇</span> procs <span class="main">:=</span> <span class="bound">procs</span><span class="main">,</span> channels <span class="main">:=</span> cleanChans <span class="bound">dchans</span> <span class="main">(</span>channels <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">⦈</span>
     <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-checkDeadProcs_gState_progress_rel"><span class="command">lemma</span></span> checkDeadProcs_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> checkDeadProcs <span class="free">g</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms cleanChans_length<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"channels <span class="free">g</span>"</span></span><span class="main">]</span> 
      cleanChans_channel_inv<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"channels <span class="free">g</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> checkDeadProcs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> removeProcs_length<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> removeProcs_subset<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits prod.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-gState_progress_rel_exclusive"><span class="command">lemma</span></span> gState_progress_rel_exclusive<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
   <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> <span class="free">g'</span><span class="main">⦇</span>exclusive <span class="main">:=</span> <span class="free">p</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  gState_progress_rel_def gState_inv_def cl_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">applyEdge</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> edge <span class="main">⇒</span> pState <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> <span class="main">⇒</span> gState<span class="hidden">⇩</span><sub>I</sub> nres"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">applyEdge</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    
         <span class="keyword1">let</span> <span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">p'</span><span class="main">)</span> <span class="main">=</span> evalEffect <span class="main">(</span>effect <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
         ASSERT <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">;</span>
         ASSERT <span class="main">(</span>pState_inv <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">p'</span><span class="main">)</span><span class="main">;</span> 
         ASSERT <span class="main">(</span>cl_inv <span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">p'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

         <span class="keyword1">let</span> <span class="bound">p''</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> target <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> Index <span class="bound">t</span> <span class="main">⇒</span> 
                     <span class="keyword1">if</span> <span class="bound">t</span> <span class="main">&lt;</span> IArray.length <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> pState.idx <span class="bound">p'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="bound">p'</span><span class="main">⦇</span>pc <span class="main">:=</span> <span class="bound">t</span><span class="main">⦈</span>
                     <span class="keyword1">else</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Edge target out of bounds''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">p'</span><span class="main">)</span>
                   <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>  abort <span class="keyword1">STR</span> <span class="inner_quoted">''Edge target not Index''</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">p'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
         ASSERT <span class="main">(</span>pState_inv <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">p''</span><span class="main">)</span><span class="main">;</span>

         <span class="keyword1">let</span> <span class="bound">g''</span> <span class="main">=</span> <span class="bound">g'</span><span class="main">⦇</span>procs <span class="main">:=</span> list_update <span class="main">(</span>procs <span class="bound">g'</span><span class="main">)</span> <span class="main">(</span>pid <span class="bound">p''</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="bound">p''</span><span class="main">⦈</span><span class="main">;</span>
         ASSERT <span class="main">(</span><span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">g''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">;</span>

         <span class="keyword1">let</span> <span class="bound">g'''</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> isAtomic <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">∧</span> handshake <span class="bound">g''</span> <span class="main">=</span> <span class="main">0</span> 
                     <span class="keyword1">then</span> <span class="bound">g''</span><span class="main">⦇</span> exclusive <span class="main">:=</span> pid <span class="bound">p''</span> <span class="main">⦈</span> 
                     <span class="keyword1">else</span> <span class="bound">g''</span><span class="main">)</span><span class="main">;</span>
         ASSERT <span class="main">(</span><span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">g'''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">;</span>
         
         <span class="keyword1">let</span> <span class="bound">g<span class="hidden">⇩</span><sub>f</sub></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> pc <span class="bound">p''</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> checkDeadProcs <span class="bound">g'''</span> <span class="keyword1">else</span> <span class="bound">g'''</span><span class="main">)</span><span class="main">;</span>
         ASSERT <span class="main">(</span><span class="main">(</span><span class="bound">g'''</span><span class="main">,</span><span class="bound">g<span class="hidden">⇩</span><sub>f</sub></span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span><span class="main">;</span>
         RETURN <span class="bound">g<span class="hidden">⇩</span><sub>f</sub></span> <span class="main">}</span>"</span></span>

<span class="keyword1" id="Promela-applyEdge_gState_progress_rel"><span class="command">lemma</span></span> applyEdge_gState_progress_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pState_inv <span class="free">prog</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cl_inv <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> edgeSet <span class="main">(</span>states <span class="free">prog</span> <span class="main">!!</span> pState.idx <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"applyEdge <span class="free">prog</span> <span class="free">e</span> <span class="free">p</span> <span class="free">g</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">g'</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> applyEdge_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> fstE <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evalEffect_gState_progress_rel<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sndE <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evalEffect_pState_inv<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subst<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> evalEffect_cl_inv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"target <span class="free">e</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pState_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> gState_progress_rel_gState_invI2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"target <span class="free">e</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def  
                <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_update_subset_insert<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def 
                <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_update_subset_insert<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> gState_progress_relI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def 
                <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_update_subset_insert<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> gState_progress_rel_exclusive<span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> checkDeadProcs_gState_progress_rel<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> gState_progress_rel_trans<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> applyEdge_refine<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?ae</span> <span class="free">prog</span> <span class="free">e</span> <span class="free">p</span> <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> applyEdge <span class="free">prog</span> <span class="free">e</span> <span class="free">p</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> applyEdge_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span><span class="main">)</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">applyEdge_impl</span> <span class="keyword2"><span class="keyword">for</span></span> e p g <span class="keyword2"><span class="keyword">uses</span></span> applyEdge_refine

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nexts</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> gState <span class="main">⇒</span> gState ls nres"</span></span>
  <span class="comment1">― ‹The successor function›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nexts</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">f</span> <span class="main">=</span> from<span class="hidden">⇩</span><sub>I</sub><span class="main">;</span>
       <span class="bound">g</span> <span class="main">=</span> to<span class="hidden">⇩</span><sub>I</sub> <span class="free"><span class="bound"><span class="entity">g</span></span></span>
     <span class="keyword1">in</span>

        REC <span class="main">(</span><span class="main">λ</span><span class="bound">D</span> <span class="bound">g</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">E</span> <span class="main">←</span> executable <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="bound">g</span><span class="main">;</span>
          <span class="keyword1">if</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> 
            <span class="keyword1">if</span> handshake <span class="bound">g</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span>
              <span class="comment1">― ‹HS not possible -- remove current step›</span>
              RETURN <span class="main">(</span>ls.empty<span class="main">()</span><span class="main">)</span> 
            <span class="keyword1">else</span> <span class="keyword1">if</span> exclusive <span class="bound">g</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span>
              <span class="comment1">― ‹Atomic blocks -- just return current state›</span>
              RETURN <span class="main">(</span>ls.sng <span class="main">(</span><span class="bound">f</span> <span class="bound">g</span><span class="main">)</span><span class="main">)</span> 
            <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span> timeout <span class="bound">g</span> <span class="keyword1">then</span>
              <span class="comment1">― ‹Set timeout›</span>
              <span class="bound">D</span> <span class="main">(</span><span class="bound">g</span><span class="main">⦇</span>timeout <span class="main">:=</span> True<span class="main">⦈</span><span class="main">)</span>
            <span class="keyword1">else</span> 
              <span class="comment1">― ‹If all else fails: stutter›</span>
              RETURN <span class="main">(</span>ls.sng <span class="main">(</span><span class="bound">f</span> <span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="bound">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1">else</span>
             <span class="comment1">― ‹Setting the internal variables (exclusive, handshake, ...) to 0›</span>
             <span class="comment1">― ‹is safe -- they are either set by the edges, or not thought›</span>
             <span class="comment1">― ‹to be used outside executable.›</span>
             <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> reset<span class="hidden">⇩</span><sub>I</sub> <span class="bound">g</span> <span class="keyword1">in</span>
             nfoldli <span class="bound">E</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="bound">G</span><span class="main">.</span>
                 applyEdge <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">e</span> <span class="bound">p</span> <span class="bound">g</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">g'</span><span class="main">.</span>
                 <span class="keyword1">if</span> handshake <span class="bound">g'</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> isAtomic <span class="bound">e</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="bound">G<span class="hidden">⇩</span><sub>R</sub></span> <span class="main">←</span> <span class="bound">D</span> <span class="bound">g'</span><span class="main">;</span>
                    <span class="keyword1">if</span> ls.isEmpty <span class="bound">G<span class="hidden">⇩</span><sub>R</sub></span> <span class="main">∧</span> handshake <span class="bound">g'</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span>
                       <span class="comment1">― ‹this only happens if the next step is a handshake, which fails›</span>
                       <span class="comment1">― ‹hence we stay at the current state›</span>
                       RETURN <span class="main">(</span>ls.ins <span class="main">(</span><span class="bound">f</span> <span class="bound">g'</span><span class="main">)</span> <span class="bound">G</span><span class="main">)</span>
                    <span class="keyword1">else</span>
                       RETURN <span class="main">(</span>ls.union <span class="bound">G<span class="hidden">⇩</span><sub>R</sub></span> <span class="bound">G</span><span class="main">)</span>
                 <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span>ls.ins <span class="main">(</span><span class="bound">f</span> <span class="bound">g'</span><span class="main">)</span> <span class="bound">G</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls.empty<span class="main">()</span><span class="main">)</span>
         <span class="main">}</span><span class="main">)</span> <span class="bound">g</span>
         <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">G</span><span class="main">.</span> <span class="keyword1">if</span> ls.isEmpty <span class="bound">G</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>ls.sng <span class="main">(</span><span class="bound">f</span> <span class="bound">g</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> RETURN <span class="bound">G</span><span class="main">)</span>
<span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-gState_progress_rel_intros"><span class="command">lemma</span></span> gState_progress_rel_intros<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">gI'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
       <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> from<span class="hidden">⇩</span><sub>I</sub> <span class="free">gI'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">gI</span><span class="main">,</span> <span class="free">gI'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
       <span class="main">⟹</span> <span class="main">(</span><span class="free">gI</span><span class="main">,</span> reset<span class="hidden">⇩</span><sub>I</sub> <span class="free">gI'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">gI'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
       <span class="main">⟹</span> <span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">gI'</span><span class="main">⦇</span>timeout <span class="main">:=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gState_progress_rel_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">gI'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">gI</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Promela-gState_progress_rel_step_intros"><span class="command">lemma</span></span> gState_progress_rel_step_intros<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
      <span class="main">⟹</span> <span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="free">g'</span><span class="main">,</span> <span class="free">g''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
      <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span> from<span class="hidden">⇩</span><sub>I</sub> <span class="free">g''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
      <span class="main">⟹</span> <span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="free">g'</span><span class="main">,</span> <span class="free">g''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span> 
      <span class="main">⟹</span> <span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">g''</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gState_progress_rel_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">g'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">g''</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_def cl_inv_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Promela-cl_inv_reset"><span class="command">lemma</span></span> cl_inv_reset<span class="hidden">⇩</span><sub>I</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cl_inv<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> cl_inv<span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> refine_helpers <span class="main">=</span> 
  gState_progress_rel_intros gState_progress_rel_step_intros cl_inv_reset<span class="hidden">⇩</span><sub>I</sub>


<span class="keyword1" id="Promela-nexts_SPEC"><span class="command">lemma</span></span> nexts_SPEC<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nexts <span class="free">prog</span> <span class="free">g</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">gs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">g'</span> <span class="main">∈</span> ls.α <span class="bound">gs</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> nexts_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> REC_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
           pre<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">g'</span><span class="main">.</span> <span class="main">(</span>to<span class="hidden">⇩</span><sub>I</sub> <span class="free">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gState_inv_to<span class="hidden">⇩</span><sub>I</sub><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> executable_edgeSet'<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> gState_progress_rel_gState_invI2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
             I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span>  <span class="main">∀</span><span class="bound">g'</span> <span class="main">∈</span> ls.α <span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span><span class="main"><span class="main">]</span></span> 
          order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> applyEdge_gState_progress_rel<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refine_helpers <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rprems</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refine_helpers <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rprems</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refine_helpers <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Promela-RETURN_dRETURN"><span class="command">lemma</span></span> RETURN_dRETURN<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RETURN <span class="free">f</span> <span class="main">≤</span> <span class="free">f'</span> <span class="main">⟹</span> nres_of <span class="main">(</span>dRETURN <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> nres_of_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Promela-executable_dRETURN"><span class="command">lemma</span></span> executable_dRETURN<span class="main">:</span>
  <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span>dRETURN <span class="main">(</span>executable_impl <span class="free">prog</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> executable <span class="free">prog</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> executable_impl.refine
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RETURN_dRETURN<span class="main">)</span>

<span class="keyword1" id="Promela-applyEdge_dRETURN"><span class="command">lemma</span></span> applyEdge_dRETURN<span class="main">:</span>
  <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span>dRETURN <span class="main">(</span>applyEdge_impl <span class="free">prog</span> <span class="free">e</span> <span class="free">p</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> applyEdge <span class="free">prog</span> <span class="free">e</span> <span class="free">p</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> applyEdge_impl.refine
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RETURN_dRETURN<span class="main">)</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> nexts_code_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="var">?nexts</span> <span class="free">prog</span> <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> nexts <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nexts_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span> the_resI executable_dRETURN applyEdge_dRETURN<span class="main">)</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">nexts_code_aux</span> <span class="keyword2"><span class="keyword">for</span></span> prog g <span class="keyword2"><span class="keyword">uses</span></span> nexts_code_aux
<span class="keyword1"><span class="command">prepare_code_thms</span></span> nexts_code_aux_def

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Handle non-termination›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A Promela model may include non-terminating parts. Therefore we cannot guarantee, that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> nexts<span class="antiquote"><span class="antiquote">}</span></span></span></span> will actually terminate.
  To avoid having to deal with this in the model checker, we fail in case of non-termination.
›</span></span>

<span class="comment1">(* TODO: Integrate such a concept into refine_transfer! *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">SUCCEED_abort</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SUCCEED_abort</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="free"><span class="bound"><span class="entity">dm</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span> 
     <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> 
       RES <span class="bound">X</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">X</span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> Code.abort <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">dm</span></span></span><span class="main">)</span> <span class="keyword1">else</span> RES <span class="bound">X</span>
     <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dSUCCEED_abort</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dSUCCEED_abort</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="free"><span class="bound"><span class="entity">dm</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> 
       dSUCCEEDi <span class="main">⇒</span> Code.abort <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">dm</span></span></span><span class="main">)</span>
     <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ref_succeed</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ref_succeed</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">=</span>SUCCEED <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span><span class="main">=</span>SUCCEED<span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-dSUCCEED_abort_SUCCEED_abort"><span class="command">lemma</span></span> dSUCCEED_abort_SUCCEED_abort<span class="main">:</span>
   <span class="quoted"><span class="quoted">"<span class="main">⟦</span> RETURN <span class="free">dm'</span> <span class="main">≤</span> <span class="free">dm</span><span class="main">;</span> ref_succeed <span class="main">(</span>nres_of <span class="free">m'</span><span class="main">)</span> <span class="free">m</span> <span class="main">⟧</span> 
       <span class="main">⟹</span> nres_of <span class="main">(</span>dSUCCEED_abort <span class="free">msg</span> <span class="main">(</span>dRETURN <span class="free">dm'</span><span class="main">)</span> <span class="main">(</span><span class="free">m'</span><span class="main">)</span><span class="main">)</span> 
           <span class="main">≤</span> SUCCEED_abort <span class="free">msg</span> <span class="free">dm</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> dSUCCEED_abort_def SUCCEED_abort_def ref_succeed_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dres.splits nres.splits<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The final successor function now incorporates:
  \begin{enumerate}
    \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Promela.nexts<span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item handling of non-termination
  \end{enumerate}›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nexts_code</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">nexts_code</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> 
     the_res <span class="main">(</span>dSUCCEED_abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''The Universe is broken!''</span><span class="main">)</span> 
                             <span class="main">(</span>dRETURN <span class="main">(</span>ls.sng <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span> 
                             <span class="main">(</span>nexts_code_aux <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-nexts_code_SPEC"><span class="command">lemma</span></span> nexts_code_SPEC<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g'</span> <span class="main">∈</span> ls.α <span class="main">(</span>nexts_code <span class="free">prog</span> <span class="free">g</span><span class="main">)</span> 
         <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> nexts_code_def
<span class="keyword1"><span class="command">unfolding</span></span> dSUCCEED_abort_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">using</span></span> order_trans<span class="main">[</span><span class="operator">OF</span> nexts_code_aux.refine nexts_SPEC<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">,</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dres.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Finiteness of the state space›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">reachable_states</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">P</span> <span class="main">::</span> <span class="quoted">program</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">g<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">::</span> <span class="quoted">gState</span> <span class="comment1">― ‹start state›</span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">g<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∈</span> <span class="free">reachable_states</span> <span class="free">P</span> <span class="free">g<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∈</span> <span class="free">reachable_states</span> <span class="free">P</span> <span class="free">g<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> ls.α <span class="main">(</span>nexts_code <span class="free">P</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> 
                               <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="free">reachable_states</span> <span class="free">P</span> <span class="free">g<span class="hidden">⇩</span><sub>s</sub></span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> reachable_states_induct<span class="main">[</span><span class="operator">case_names</span> init step<span class="main">]</span> <span class="main">=</span> 
  reachable_states.induct<span class="main">[</span><span class="operator">split_format</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">complete</span><span class="main"><span class="main">)</span></span><span class="main">]</span>

<span class="keyword1" id="Promela-reachable_states_finite"><span class="command">lemma</span></span> reachable_states_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"program_inv <span class="free">prog</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"gState_inv <span class="free">prog</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>reachable_states <span class="free">prog</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ gStates_finite<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">INV</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">INV</span> <span class="skolem">g'</span> <span class="main">⟷</span> <span class="skolem">g'</span> <span class="main">∈</span> <span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span> <span class="main">∧</span> gState_inv <span class="free">prog</span> <span class="skolem">g'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">g'</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g'</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g'</span> <span class="main">∈</span> reachable_states <span class="free">prog</span> <span class="free">g</span> <span class="main">⟹</span> <span class="skolem">INV</span> <span class="skolem">g'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_states_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> init <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INV_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">g</span> <span class="skolem">g'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> step<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span><span class="main">,</span> <span class="skolem">g'</span><span class="main">)</span> <span class="main">∈</span> gState_progress_rel <span class="free">prog</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> nexts_code_SPEC<span class="main">[</span><span class="operator">OF</span> _ <span class="quoted"><span class="quoted">‹program_inv <span class="free">prog</span>›</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> INV_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> INV_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
   <span class="keyword1"><span class="command">}</span></span>

  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"reachable_states <span class="free">prog</span> <span class="free">g</span> <span class="main">⊆</span> 
        <span class="main">(</span>gState_progress_rel <span class="free">prog</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">g</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> INV_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Traces›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When trying to generate a lasso, we have a problem: We only have a list of global
states. But what are the transitions to come from one to the other?

This problem shall be tackled by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">replay</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>: Given two states, it generates a list of
transitions that was taken.›</span></span>

<span class="comment1">(* Give a list of edges that lead from g<span class="hidden">⇩</span><sub>1</sub> to g<span class="hidden">⇩</span><sub>2</sub> *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">replay</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> gState <span class="main">⇒</span> gState <span class="main">⇒</span> choices nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">replay</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
       <span class="bound">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> to<span class="hidden">⇩</span><sub>I</sub> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">;</span>
       <span class="bound">check</span> <span class="main">=</span> <span class="main">λ</span><span class="bound">g</span><span class="main">.</span> from<span class="hidden">⇩</span><sub>I</sub> <span class="bound">g</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>2</sub></span></span></span>
     <span class="keyword1">in</span>
       <span class="keyword1">REC<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">D</span> <span class="bound">g</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">E</span> <span class="main">←</span> executable <span class="main">(</span>states <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="bound">g</span><span class="main">;</span>
       <span class="keyword1">if</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> 
         <span class="keyword1">if</span> <span class="bound">check</span> <span class="bound">g</span> <span class="keyword1">then</span> RETURN <span class="main">[]</span>
         <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span> timeout <span class="bound">g</span> <span class="keyword1">then</span> <span class="bound">D</span> <span class="main">(</span><span class="bound">g</span><span class="main">⦇</span>timeout <span class="main">:=</span> True<span class="main">⦈</span><span class="main">)</span>
         <span class="keyword1">else</span> abort <span class="keyword1">STR</span> <span class="inner_quoted">''Stuttering should not occur on replay''</span> 
                    <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="main">[]</span><span class="main">)</span>
       <span class="keyword1">else</span>
          <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> reset<span class="hidden">⇩</span><sub>I</sub> <span class="bound">g</span> <span class="keyword1">in</span>
          nfoldli <span class="bound">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">E</span><span class="main">.</span> <span class="bound">E</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span>
             applyEdge <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">e</span> <span class="bound">p</span> <span class="bound">g</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">g'</span><span class="main">.</span>
               <span class="keyword1">if</span> handshake <span class="bound">g'</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> isAtomic <span class="bound">e</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                 <span class="bound">E<span class="hidden">⇩</span><sub>R</sub></span> <span class="main">←</span> <span class="bound">D</span> <span class="bound">g'</span><span class="main">;</span>
                 <span class="keyword1">if</span> <span class="bound">E<span class="hidden">⇩</span><sub>R</sub></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span>
                    <span class="keyword1">if</span> <span class="bound">check</span> <span class="bound">g'</span> <span class="keyword1">then</span> RETURN <span class="main">[</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">]</span> <span class="keyword1">else</span> RETURN <span class="main">[]</span>
                 <span class="keyword1">else</span>
                    RETURN <span class="main">(</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">#</span> <span class="bound">E<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">check</span> <span class="bound">g'</span> <span class="keyword1">then</span> RETURN <span class="main">[</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">]</span> <span class="keyword1">else</span> RETURN <span class="main">[]</span><span class="main">)</span>
             <span class="main">)</span> <span class="main">[]</span>
       <span class="main">}</span><span class="main">)</span> <span class="bound">g<span class="hidden">⇩</span><sub>1</sub></span>
<span class="main">)</span>"</span></span>

<span class="keyword1" id="Promela-abort_refine"><span class="command">lemma</span></span> abort_refine<span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="free">f</span> <span class="main">()</span><span class="main">)</span> <span class="main">≤</span> <span class="free">F</span> <span class="main">()</span> <span class="main">⟹</span> nres_of <span class="main">(</span>abort <span class="free">s</span> <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> abort <span class="free">s</span> <span class="free">F</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">()</span> <span class="main">≠</span> dSUCCEED <span class="main">⟹</span> abort <span class="free">s</span> <span class="free">f</span> <span class="main">≠</span> dSUCCEED"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> replay_code_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?replay</span> <span class="free">prog</span> <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">≤</span> replay <span class="free">prog</span> <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> replay_def applyEdge_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span> the_resI executable_dRETURN<span class="main">)</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">replay_code</span> <span class="keyword2"><span class="keyword">for</span></span> prog g<span class="hidden">⇩</span><sub>1</sub> g<span class="hidden">⇩</span><sub>2</sub> <span class="keyword2"><span class="keyword">uses</span></span> replay_code_aux
<span class="keyword1"><span class="command">prepare_code_thms</span></span> replay_code_def

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Printing of traces›</span></span>
<span class="comment1">(* Might go to another theory *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">procDescr</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> program <span class="main">⇒</span> pState <span class="main">⇒</span> string"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">procDescr</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
     <span class="keyword1">let</span> 
        <span class="bound">name</span> <span class="main">=</span> String.explode <span class="main">(</span>proc_names <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">!!</span> pState.idx <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">;</span>
        <span class="bound">id</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>integer_of_nat <span class="main">(</span>pid <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">in</span>
        <span class="bound">name</span> <span class="main">@</span> <span class="inner_quoted">'' (''</span> <span class="main">@</span> <span class="bound">id</span> <span class="main">@</span> <span class="inner_quoted">'')''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printInitial</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> program <span class="main">⇒</span> gState <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printInitial</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="main">=</span> <span class="main">(</span>
       <span class="keyword1">let</span> <span class="bound">psS</span> <span class="main">=</span> printList <span class="main">(</span>procDescr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="main">(</span>procs <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">[]</span> <span class="inner_quoted">''  ''</span> <span class="keyword1">in</span>
       <span class="inner_quoted">''Initially running: ''</span> <span class="main">@</span> <span class="bound">psS</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">lf</span> <span class="main">≡</span> <span class="keyword1">CHR</span> <span class="numeral">0x0A</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">printConfig</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> program <span class="main">⇒</span> gState option <span class="main">⇒</span> gState <span class="main">⇒</span> string"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printConfig</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> None <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="main">=</span> printInitial <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">printConfig</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="main">(</span>
           <span class="keyword1">let</span> <span class="bound">eps</span> <span class="main">=</span> replay_code <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="keyword1">in</span>
           <span class="keyword1">let</span> <span class="bound">print</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> procDescr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">p</span> <span class="main">@</span> <span class="inner_quoted">'': ''</span> <span class="main">@</span> printEdge <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>pc <span class="bound">p</span><span class="main">)</span> <span class="bound">e</span><span class="main">)</span>
           <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">eps</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="keyword1">then</span> <span class="inner_quoted">''    -- stutter --''</span>
              <span class="keyword1">else</span> printList <span class="bound">print</span> <span class="bound">eps</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">(</span>lf<span class="main">#</span><span class="inner_quoted">''    ''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">printConfigFromAST</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> printConfig <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">o</span> fst <span class="keyword1">o</span> setUp"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code export›</span></span>

<span class="keyword1"><span class="command">code_identifier</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"PromelaInvariants"</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Promela
<span class="main">|</span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"PromelaDatastructures"</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Promela

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">executable_triv</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> executable_impl <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">apply_triv</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">ep</span></span></span> <span class="main">=</span> applyEdge_impl <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">ep</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">ep</span></span></span><span class="main">)</span> <span class="main">(</span>reset<span class="hidden">⇩</span><sub>I</sub> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">setUp</span></span> <span class="quoted"><span class="quoted">printProcesses</span></span> <span class="quoted"><span class="quoted">printConfigFromAST</span></span> <span class="quoted"><span class="quoted">nexts_code</span></span> <span class="quoted"><span class="quoted">executable_triv</span></span> <span class="quoted"><span class="quoted">apply_triv</span></span>
  <span class="quoted"><span class="quoted">extractLTLs</span></span> <span class="quoted"><span class="quoted">lookupLTL</span></span>
  <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">setUp</span></span> <span class="quoted"><span class="quoted">printProcesses</span></span> <span class="quoted"><span class="quoted">printConfigFromAST</span></span> <span class="quoted"><span class="quoted">nexts_code</span></span> <span class="quoted"><span class="quoted">executable_triv</span></span> <span class="quoted"><span class="quoted">apply_triv</span></span> 
  <span class="quoted"><span class="quoted">extractLTLs</span></span> <span class="quoted"><span class="quoted">lookupLTL</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> SML 
  <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">‹Promela.sml›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PromelaLTL">
<div class="head">
<h1>Theory PromelaLTL</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"LTL integration"</span></span>
<span class="keyword1"><span class="command">theory</span></span> PromelaLTL
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Promela.html">Promela</a>
  <a href="../LTL/LTL.html">LTL.LTL</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We have a semantic engine for Promela. But we need to have 
an integration with LTL -- more specificly, we must know when a proposition
is true in a global state. This is achieved in this theory.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹LTL optimization›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For efficiency reasons, we do not store the whole <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on the labels
of a system automaton, but <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. This index then is used to look up the
corresponding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> APs <span class="main">=</span> <span class="quoted"><span class="quoted">"expr iarray"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">ltlc_aps_list'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ltlc <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> True_ltlc <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> False_ltlc <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Prop_ltlc <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> List.member <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Not_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Next_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Final_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Global_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>And_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Or_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Implies_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Until_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>Release_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>WeakUntil_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list'</span> <span class="main">(</span>StrongRelease_ltlc <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">ltlc_aps_list'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaLTL-ltlc_aps_list'_correct"><span class="command">lemma</span></span> ltlc_aps_list'_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>ltlc_aps_list' <span class="free">φ</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> atoms_ltlc <span class="free">φ</span> <span class="main">∪</span> set <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_member<span class="main">)</span>

<span class="keyword1" id="PromelaLTL-ltlc_aps_list'_distinct"><span class="command">lemma</span></span> ltlc_aps_list'_distinct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="free">l</span> <span class="main">⟹</span> distinct <span class="main">(</span>ltlc_aps_list' <span class="free">φ</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_member<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ltlc_aps_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ltlc <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ltlc_aps_list</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">=</span> ltlc_aps_list' <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">[]</span>"</span></span>

<span class="keyword1" id="PromelaLTL-ltlc_aps_list_correct"><span class="command">lemma</span></span> ltlc_aps_list_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>ltlc_aps_list <span class="free">φ</span><span class="main">)</span> <span class="main">=</span> atoms_ltlc <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ltlc_aps_list_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ltlc_aps_list'_correct<span class="main">)</span>

<span class="keyword1" id="PromelaLTL-ltlc_aps_list_distinct"><span class="command">lemma</span></span> ltlc_aps_list_distinct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>ltlc_aps_list <span class="free">φ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ltlc_aps_list_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ltlc_aps_list'_distinct<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">idx'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> nat option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idx'</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">idx'</span> <span class="free"><span class="bound"><span class="entity">ctr</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Some <span class="free"><span class="bound"><span class="entity">ctr</span></span></span> <span class="keyword1">else</span> <span class="free">idx'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ctr</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main">=</span> idx' <span class="main">0</span>"</span></span>

<span class="keyword1" id="PromelaLTL-idx'_correct"><span class="command">lemma</span></span> idx'_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"idx' <span class="free">ctr</span> <span class="free">xs</span> <span class="free">y</span> <span class="main">=</span> Some <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">≥</span> <span class="free">ctr</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">+</span> <span class="free">ctr</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="free">ctr</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">ctr</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="free">y</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span><span class="main">-</span><span class="skolem">ctr</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ctr</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> length<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">y</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">ctr</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">ctr</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">ctr</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> less <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span><span class="main">-</span><span class="skolem">ctr</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span><span class="main">≠</span><span class="skolem">ctr</span>›</span></span> length <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span><span class="main">-</span><span class="skolem">ctr</span> <span class="main">&lt;</span> length<span class="main">(</span><span class="free">y</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span><span class="main">-</span><span class="skolem">ctr</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> A * <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> True Cons <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False 
    <span class="keyword1"><span class="command">from</span></span> Cons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> Cons.IH False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"idx' <span class="main">(</span>Suc <span class="skolem">ctr</span><span class="main">)</span> <span class="skolem">xs</span> <span class="free">y</span> <span class="main">=</span> Some <span class="skolem">n</span> <span class="main">⟷</span> Suc <span class="skolem">ctr</span> <span class="main">≤</span> <span class="skolem">n</span> <span class="main">∧</span> <span class="skolem">n</span> <span class="main">&lt;</span> length <span class="skolem">xs</span> <span class="main">+</span> Suc <span class="skolem">ctr</span> <span class="main">∧</span> <span class="skolem">xs</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> Suc <span class="skolem">ctr</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="PromelaLTL-idx_correct"><span class="command">lemma</span></span> idx_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"idx <span class="free">xs</span> <span class="free">y</span> <span class="main">=</span> Some <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> idx'_correct<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> idx_def<span class="main">)</span>

<span class="keyword1" id="PromelaLTL-idx_dom"><span class="command">lemma</span></span> idx_dom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>idx <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> idx_correct assms in_set_conv_nth<span class="main">)</span>

<span class="keyword1" id="PromelaLTL-idx_image_self"><span class="command">lemma</span></span> idx_image_self<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>the <span class="main">∘</span> idx <span class="free">xs</span><span class="main">)</span> <span class="main">`</span> set <span class="free">xs</span> <span class="main">=</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> in_set_conv_nth <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">with</span></span> idx_correct<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"idx <span class="free">xs</span> <span class="skolem">x</span> <span class="main">=</span> Some <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>idx <span class="free">xs</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> n <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>the <span class="main">∘</span> idx <span class="free">xs</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> 
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> nth_mem <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> <span class="skolem">n</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"idx <span class="free">xs</span> <span class="skolem">x</span> <span class="main">=</span> Some <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> idx_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>idx <span class="free">xs</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">(</span>the <span class="main">∘</span> idx <span class="free">xs</span><span class="main">)</span> <span class="main">`</span> set <span class="free">xs</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">xs</span>›</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaLTL-idx_ran"><span class="command">lemma</span></span> idx_ran<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span>idx <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ran_is_image<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> M<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"idx <span class="free">xs</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> idx_image_self<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> idx_dom<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="PromelaLTL-idx_inj_on_dom"><span class="command">lemma</span></span> idx_inj_on_dom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>idx <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>dom <span class="main">(</span>idx <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> idx_dom assms in_set_conv_nth idx_correct
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ltl_convert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr ltlc <span class="main">⇒</span> APs <span class="main">×</span> nat ltlc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ltl_convert</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">let</span> <span class="bound">APs</span> <span class="main">=</span> ltlc_aps_list <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">;</span>
          <span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">=</span> map_ltlc <span class="main">(</span>the <span class="main">∘</span> idx <span class="bound">APs</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span>
      <span class="keyword1">in</span> <span class="main">(</span>IArray <span class="bound">APs</span><span class="main">,</span> <span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaLTL-ltl_convert_correct"><span class="command">lemma</span></span> ltl_convert_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ltl_convert <span class="free">φ</span> <span class="main">=</span> <span class="main">(</span><span class="free">APs</span><span class="main">,</span> <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atoms_ltlc <span class="free">φ</span> <span class="main">=</span> set <span class="main">(</span>IArray.list_of <span class="free">APs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P1</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"atoms_ltlc <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">=</span> <span class="main">{..&lt;</span>IArray.length <span class="free">APs</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P2</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">=</span> map_ltlc <span class="main">(</span>the <span class="main">∘</span> idx <span class="main">(</span>IArray.list_of <span class="free">APs</span><span class="main">)</span><span class="main">)</span> <span class="free">φ</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P3</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>IArray.list_of <span class="free">APs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?APs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"IArray.list_of <span class="free">APs</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> APs_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?APs</span> <span class="main">=</span> ltlc_aps_list <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ltl_convert_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">with</span></span> ltlc_aps_list_correct <span class="keyword3"><span class="command">show</span></span> APs_set<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?P1</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?P3</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ltl_convert_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"atoms_ltlc <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">=</span> <span class="main">(</span>the <span class="main">∘</span> idx <span class="var">?APs</span><span class="main">)</span> <span class="main">`</span> atoms_ltlc <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ltl_convert_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltlc.set_map<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> APs_def ltlc_aps_list_distinct <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"distinct <span class="var">?APs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> idx_image_self<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> APs_set
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?P2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prepare</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">×</span> <span class="main">(</span>program <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">⇒</span> ast <span class="main">⇒</span> expr ltlc <span class="main">⇒</span> <span class="main">(</span>program <span class="main">×</span> APs <span class="main">×</span> gState<span class="main">)</span> <span class="main">×</span> nat ltlc"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prepare</span> <span class="free"><span class="bound"><span class="entity">cfg</span></span></span> <span class="free"><span class="bound"><span class="entity">ast</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">≡</span>
      <span class="keyword1">let</span> 
         <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span> <span class="main">=</span> Promela.setUp <span class="free"><span class="bound"><span class="entity">ast</span></span></span><span class="main">;</span>
         <span class="main">(</span><span class="bound">APs</span><span class="main">,</span><span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span> <span class="main">=</span> PromelaLTL.ltl_convert <span class="free"><span class="bound"><span class="entity">φ</span></span></span>
      <span class="keyword1">in</span> 
         <span class="main">(</span><span class="main">(</span><span class="bound">prog</span><span class="main">,</span> <span class="bound">APs</span><span class="main">,</span> <span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PromelaLTL-prepare_instrument"><span class="command">lemma</span></span> prepare_instrument<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"prepare <span class="free">cfg</span> <span class="free">ast</span> <span class="free">φ</span> <span class="main">≡</span> 
    <span class="keyword1">let</span>
         <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">printF</span><span class="main">)</span> <span class="main">=</span> <span class="free">cfg</span><span class="main">;</span>
         <span class="main"><span class="bound">_</span></span> <span class="main">=</span> PromelaStatistics.start <span class="main">()</span><span class="main">;</span> 
         <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span> <span class="main">=</span> Promela.setUp <span class="free">ast</span><span class="main">;</span>
         <span class="main"><span class="bound">_</span></span> <span class="main">=</span> <span class="bound">printF</span> <span class="bound">prog</span><span class="main">;</span>
         <span class="main">(</span><span class="bound">APs</span><span class="main">,</span><span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span> <span class="main">=</span> PromelaLTL.ltl_convert <span class="free">φ</span><span class="main">;</span>
         <span class="main"><span class="bound">_</span></span> <span class="main">=</span> PromelaStatistics.stop_timer <span class="main">()</span>
      <span class="keyword1">in</span> 
         <span class="main">(</span><span class="main">(</span><span class="bound">prog</span><span class="main">,</span> <span class="bound">APs</span><span class="main">,</span> <span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prepare_def<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">prepare</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Language of a Promela program›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">propValid</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"APs <span class="main">⇒</span> gState <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">propValid</span> <span class="free"><span class="bound"><span class="entity">APs</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> IArray.length <span class="free"><span class="bound"><span class="entity">APs</span></span></span> <span class="main">∧</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> emptyProc <span class="main">(</span><span class="free"><span class="bound"><span class="entity">APs</span></span></span><span class="main">!!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_E</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">⇒</span> <span class="main">(</span>gState <span class="main">×</span> gState<span class="main">)</span> set"</span></span>
  <span class="comment1">― ‹Transition relation of a promela program›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_E</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span><span class="main">.</span> <span class="bound">g'</span> <span class="main">∈</span> ls.α <span class="main">(</span>nexts_code <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="bound">g</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_E_ltl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">×</span> APs <span class="main">⇒</span> <span class="main">(</span>gState <span class="main">×</span> gState<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_E_ltl</span> <span class="main">=</span> promela_E <span class="main">∘</span> fst"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_is_run'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">×</span> gState <span class="main">⇒</span> gState word <span class="main">⇒</span> bool"</span></span>
  <span class="comment1">― ‹Predicate defining runs of promela programs›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_is_run'</span> <span class="free"><span class="bound"><span class="entity">progg</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">progg</span></span></span> <span class="keyword1">in</span> 
           <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="bound">g<span class="hidden">⇩</span><sub>0</sub></span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">∈</span> ls.α <span class="main">(</span>nexts_code <span class="bound">prog</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">promela_is_run</span> <span class="main">≡</span> promela_is_run' <span class="main">∘</span> setUp"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_is_run_ltl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">×</span> APs <span class="main">×</span> gState <span class="main">⇒</span> gState word <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">promela_is_run_ltl</span> <span class="free"><span class="bound"><span class="entity">promg</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">APs</span><span class="main">,</span><span class="bound">g</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">promg</span></span></span> <span class="keyword1">in</span> promela_is_run' <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">g</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_props</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"gState <span class="main">⇒</span> expr set"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_props</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">e</span><span class="main">.</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> emptyProc <span class="bound">e</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_props_ltl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"APs <span class="main">⇒</span> gState <span class="main">⇒</span> nat set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_props_ltl</span> <span class="free"><span class="bound"><span class="entity">APs</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> Collect <span class="main">(</span>propValid <span class="free"><span class="bound"><span class="entity">APs</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_language</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast <span class="main">⇒</span> expr set word set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_language</span> <span class="free"><span class="bound"><span class="entity">ast</span></span></span> <span class="main">≡</span> <span class="main">{</span>promela_props <span class="main">∘</span> <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> promela_is_run <span class="free"><span class="bound"><span class="entity">ast</span></span></span> <span class="bound">r</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">promela_language_ltl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"program <span class="main">×</span> APs <span class="main">×</span> gState <span class="main">⇒</span> nat set word set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">promela_language_ltl</span> <span class="free"><span class="bound"><span class="entity">promg</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">prog</span><span class="main">,</span><span class="bound">APs</span><span class="main">,</span><span class="bound">g</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">promg</span></span></span> <span class="keyword1">in</span> 
                    <span class="main">{</span>promela_props_ltl <span class="bound">APs</span> <span class="main">∘</span> <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> promela_is_run_ltl <span class="free"><span class="bound"><span class="entity">promg</span></span></span> <span class="bound">r</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="PromelaLTL-promela_props_ltl_map_aprops"><span class="command">lemma</span></span> promela_props_ltl_map_aprops<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ltl_convert <span class="free">φ</span> <span class="main">=</span> <span class="main">(</span><span class="free">APs</span><span class="main">,</span><span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"promela_props_ltl <span class="free">APs</span> <span class="main">=</span> 
          map_props <span class="main">(</span>idx <span class="main">(</span>IArray.list_of <span class="free">APs</span><span class="main">)</span><span class="main">)</span> <span class="main">∘</span> promela_props"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?APs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"IArray.list_of <span class="free">APs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?idx</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"idx <span class="var">?APs</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> ltl_convert_correct assms <span class="keyword1"><span class="command">have</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="var">?APs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext set_eqI iffI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> promela_props_ltl <span class="free">APs</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"propValid <span class="free">APs</span> <span class="skolem">g</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> promela_props_ltl_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> IArray.length <span class="free">APs</span>"</span></span> <span class="quoted"><span class="quoted">"exprArith <span class="skolem">g</span> emptyProc <span class="main">(</span><span class="free">APs</span><span class="main">!!</span><span class="skolem">i</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> propValid_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">APs</span><span class="main">!!</span><span class="skolem">i</span> <span class="main">∈</span> promela_props <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> promela_props_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> idx_correct l D <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?idx</span> <span class="main">(</span><span class="free">APs</span><span class="main">!!</span><span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">(</span>map_props <span class="var">?idx</span> <span class="main">∘</span> promela_props<span class="main">)</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> o_def map_props_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">(</span>map_props <span class="var">?idx</span> <span class="main">∘</span> promela_props<span class="main">)</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∈</span> promela_props <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?idx</span> <span class="skolem">p</span> <span class="main">=</span> Some <span class="skolem">i</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> map_props_def o_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> expr<span class="main">:</span> <span class="quoted"><span class="quoted">"exprArith <span class="skolem">g</span> emptyProc <span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> promela_props_def<span class="main">)</span>
  
    <span class="keyword1"><span class="command">from</span></span> D p_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> IArray.length <span class="free">APs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">APs</span> <span class="main">!!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> idx_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> expr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"propValid <span class="free">APs</span> <span class="skolem">g</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> propValid_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> promela_props_ltl <span class="free">APs</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> promela_props_ltl_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaLTL-promela_run_in_language_iff"><span class="command">lemma</span></span> promela_run_in_language_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> conv<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl_convert <span class="free">φ</span> <span class="main">=</span> <span class="main">(</span><span class="free">APs</span><span class="main">,</span><span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"promela_props <span class="main">∘</span> <span class="free">ξ</span> <span class="main">∈</span> language_ltlc <span class="free">φ</span> 
          <span class="main">⟷</span> promela_props_ltl <span class="free">APs</span> <span class="main">∘</span> <span class="free">ξ</span> <span class="main">∈</span> language_ltlc <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">⟷</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?APs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"IArray.list_of <span class="free">APs</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> conv <span class="keyword1"><span class="command">have</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="var">?APs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_convert_correct<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> conv <span class="keyword1"><span class="command">have</span></span> APs<span class="main">:</span> <span class="quoted"><span class="quoted">"atoms_ltlc <span class="free">φ</span> <span class="main">⊆</span> dom <span class="main">(</span>idx <span class="var">?APs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> idx_dom ltl_convert_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> map_semantics <span class="main">=</span> map_semantics_ltlc<span class="main">[</span><span class="operator">OF</span> idx_inj_on_dom<span class="main"><span class="main">[</span></span><span class="operator">OF</span> D<span class="main"><span class="main">]</span></span> APs<span class="main">]</span>
                       promela_props_ltl_map_aprops<span class="main">[</span><span class="operator">OF</span> conv<span class="main">]</span>
                       ltl_convert_correct<span class="main">[</span><span class="operator">OF</span> conv<span class="main">]</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">⟷</span> <span class="main">(</span>promela_props <span class="main">∘</span> <span class="free">ξ</span><span class="main">)</span> <span class="keyword1">⊨<span class="hidden">⇩</span><sub>c</sub></span> <span class="free">φ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> language_ltlc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⟷</span> <span class="main">(</span>promela_props_ltl <span class="free">APs</span> <span class="main">∘</span> <span class="free">ξ</span><span class="main">)</span> <span class="keyword1">⊨<span class="hidden">⇩</span><sub>c</sub></span> <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> map_semantics
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⟷</span> <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> language_ltlc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="PromelaLTL-promela_language_sub_iff"><span class="command">lemma</span></span> promela_language_sub_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> conv<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl_convert <span class="free">φ</span> <span class="main">=</span> <span class="main">(</span><span class="free">APs</span><span class="main">,</span><span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> setUp<span class="main">:</span> <span class="quoted"><span class="quoted">"setUp <span class="free">ast</span> <span class="main">=</span> <span class="main">(</span><span class="free">prog</span><span class="main">,</span><span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"promela_language_ltl <span class="main">(</span><span class="free">prog</span><span class="main">,</span><span class="free">APs</span><span class="main">,</span><span class="free">g</span><span class="main">)</span> <span class="main">⊆</span> language_ltlc <span class="free">φ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟷</span> promela_language <span class="free">ast</span> <span class="main">⊆</span> language_ltlc <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> promela_run_in_language_iff<span class="main">[</span><span class="operator">OF</span> conv<span class="main">]</span> setUp
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> promela_language_ltl_def promela_language_def promela_is_run_ltl_def<span class="main">)</span>


<span class="comment1">(* from PromelaDatastructures *)</span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> abort abortv 
                  err errv
                  usc
                  warn the_warn with_warn

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> idx idx'
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PromelaLTLConv">
<div class="head">
<h1>Theory PromelaLTLConv</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> PromelaLTLConv
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Promela.html">Promela</a>
  <a href="../LTL/LTL.html">LTL.LTL</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proposition types and conversion›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹LTL formulae and propositions are also generated by an SML parser.
Hence we have the same setup as for Promela itself: Mirror the data structures and
(sometimes) map them to new ones.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory is intended purely to be used by frontend code to convert
from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>propc›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>expr›</span></span></span></span>. The other theories work on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly.

While we could of course convert directly, that would introduce yet a semantic level.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> binOp <span class="main">=</span> Eq <span class="main">|</span> Le <span class="main">|</span> LEq <span class="main">|</span> Gr <span class="main">|</span> GEq

<span class="keyword1"><span class="command">datatype</span></span> ident <span class="main">=</span> Ident <span class="quoted"><span class="quoted">"String.literal"</span></span> <span class="quoted"><span class="quoted">"integer option"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> propc <span class="main">=</span> CProp <span class="quoted">ident</span>
               <span class="main">|</span> BProp <span class="quoted">binOp</span> <span class="quoted">ident</span> <span class="quoted">ident</span>
               <span class="main">|</span> BExpProp <span class="quoted">binOp</span> <span class="quoted">ident</span> <span class="quoted">integer</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">identConv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ident <span class="main">⇒</span> varRef"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">identConv</span> <span class="main">(</span>Ident <span class="free"><span class="bound"><span class="entity">name</span></span></span> None<span class="main">)</span> <span class="main">=</span> VarRef True <span class="free"><span class="bound"><span class="entity">name</span></span></span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">identConv</span> <span class="main">(</span>Ident <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> VarRef True <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">(</span>Some <span class="main">(</span>ExprConst <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ident2expr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ident <span class="main">⇒</span> expr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ident2expr</span> <span class="main">=</span> ExprVarRef <span class="main">∘</span> identConv"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">binOpConv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"binOp <span class="main">⇒</span> PromelaDatastructures.binOp"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">binOpConv</span> Eq <span class="main">=</span> BinOpEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">binOpConv</span> Le <span class="main">=</span> BinOpLe"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">binOpConv</span> LEq <span class="main">=</span> BinOpLEq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">binOpConv</span> Gr <span class="main">=</span> BinOpGr"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">binOpConv</span> GEq <span class="main">=</span> BinOpGEq"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">propc2expr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"propc <span class="main">⇒</span> expr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">propc2expr</span> <span class="main">(</span>CProp <span class="free"><span class="bound"><span class="entity">ident</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprBinOp BinOpEq <span class="main">(</span>ident2expr <span class="free"><span class="bound"><span class="entity">ident</span></span></span><span class="main">)</span> <span class="main">(</span>ExprConst <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">propc2expr</span> <span class="main">(</span>BProp <span class="free"><span class="bound"><span class="entity">bop</span></span></span> <span class="free"><span class="bound"><span class="entity">il</span></span></span> <span class="free"><span class="bound"><span class="entity">ir</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprBinOp <span class="main">(</span>binOpConv <span class="free"><span class="bound"><span class="entity">bop</span></span></span><span class="main">)</span> <span class="main">(</span>ident2expr <span class="free"><span class="bound"><span class="entity">il</span></span></span><span class="main">)</span> <span class="main">(</span>ident2expr <span class="free"><span class="bound"><span class="entity">ir</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">propc2expr</span> <span class="main">(</span>BExpProp <span class="free"><span class="bound"><span class="entity">bop</span></span></span> <span class="free"><span class="bound"><span class="entity">il</span></span></span> <span class="free"><span class="bound"><span class="entity">ir</span></span></span><span class="main">)</span> <span class="main">=</span> 
     ExprBinOp <span class="main">(</span>binOpConv <span class="free"><span class="bound"><span class="entity">bop</span></span></span><span class="main">)</span> <span class="main">(</span>ident2expr <span class="free"><span class="bound"><span class="entity">il</span></span></span><span class="main">)</span> <span class="main">(</span>ExprConst <span class="free"><span class="bound"><span class="entity">ir</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ltl_conv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"propc ltlc <span class="main">⇒</span> expr ltlc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ltl_conv</span> <span class="main">=</span> map_ltlc propc2expr"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">printPropc</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>integer <span class="main">⇒</span> char list<span class="main">)</span> <span class="main">⇒</span> propc <span class="main">⇒</span> char list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">printPropc</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> printExpr <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>propc2expr <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The semantics of a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">propc</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is given just for reference.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">evalPropc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"gState <span class="main">⇒</span> propc <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalPropc</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⟷</span> exprArith <span class="free"><span class="bound"><span class="entity">g</span></span></span> emptyProc <span class="main">(</span>propc2expr <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="All_Of_Promela">
<div class="head">
<h1>Theory All_Of_Promela</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> All_Of_Promela
<span class="keyword2"><span class="keyword">imports</span></span> <a href="PromelaStatistics.html">PromelaStatistics</a> <a href="Promela.html">Promela</a> <a href="PromelaLTL.html">PromelaLTL</a> <a href="PromelaLTLConv.html">PromelaLTLConv</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>