<div id="MonadSE">
<div class="head"><h1>Theory MonadSE</h1>
<span class="command">theory</span> <span class="name">MonadSE</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*****************************************************************************
 * Clean
 *                                                                            
 * HOL-TestGen --- theorem-prover based test case generation
 *                 http://www.brucker.ch/projects/hol-testgen/
 *                                                                            
 * Copyright (c) 2005-2007 ETH Zurich, Switzerland
 *               2009-2017 Univ. Paris-Sud, France 
 *               2009-2012 Achim D. Brucker, Germany
 *               2015-2017 University Sheffield, UK
 *               2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Monads --- a base testing theory for sequential computations.
 * This file is part of HOL-TestGen.
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MonadSE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>        
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition : Standard State Exception Monads›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹State exception monads in our sense are a direct, pure formulation
of automata with a partial transition function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition : Core Types and Operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'o</span><span class="delimiter">,</span><span> </span><span class="tfree">'σ</span><span class="delimiter">)</span><span> </span><span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'σ ⇀ ('o × 'σ)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* = 'σ ⇒ ('o × 'σ)option *)</span></span></span></span></span><span>       
</span><span>      
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bind_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('o,'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('o ⇒ ('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒ ('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"bind_SE f g = (λσ. case f σ of None ⇒ None 
                                        | Some (out, σ') ⇒ g out σ')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>bind_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"bind<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>    </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"_bind_SE"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn,('o,'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>,('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2 _ ← _; _)"</span></span></span><span> </span><span class="delimiter">[</span><span>5</span><span class="delimiter">,</span><span>8</span><span class="delimiter">,</span><span>8</span><span class="delimiter">]</span><span>8</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"x ← f; g"</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST bind_SE f (% x . g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'o ⇒ ('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(result _)"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"unit_SE e = (λσ. Some(e,σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>   </span><span>unit_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we prove the required Monad-laws›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_right_unit</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ← m; result x) = m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"m σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_left_unit</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ← result c; P x) = P c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_assoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y ← (x ← m; k x); h y) = (x ← m; (y ← k x; h y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"m σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition : More Operators and their Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fail_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"fail_SE = (λσ. None)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">notation</span></span><span>   </span><span>fail_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assert_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ (bool, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"assert_SE P = (λσ. if P σ then Some(True,σ) else None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>   </span><span>assert_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assume_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"assume_SE P = (λσ. if ∃σ . P σ then Some((), SOME σ . P σ) else None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>   </span><span>assume_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_left_fail_SE</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ← fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>; P x) = fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fail_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We also provide a "Pipe-free" - variant of the bind operator.
Just a "standard" programming sequential operator without output frills.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Eliminate/Modify this. Is a consequence of the Monad-Instantiation. *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bind_SE'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('β, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('β, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";-"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"f ;- g = (_ ← f ; g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_assoc'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((m;- k);- h ) = (m;- (k;- h))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_left_unit'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((result c);- P) = P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_left_fail_SE'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>;- P) = fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_right_unit'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m;- (result ())) = m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>          
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The bind-operator in the state-exception monad yields already
       a semantics for the concept of an input sequence on the meta-level:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>     </span><span>syntax_test</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(o1 ← f1 ; o2 ← f2; result (post o1 o2)) = X"</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>yield<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a  ⇒ 'b) ⇒  ('b,'a ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"yield<span class="hidden">⇩</span><sub>C</sub> f ≡ (λσ. Some(f σ, σ))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>try_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('o,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('o option,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ioprog = (λσ. case ioprog σ of
                                      None ⇒ Some(None, σ)
                                    | Some(outs, σ') ⇒ Some(Some outs, σ'))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In contrast, mbind as a failure safe operator can roughly be seen 
       as a foldr on bind - try:
       m1 ; try m2 ; try m3; ... Note, that the rough equivalence only holds for
       certain predicates in the sequence - length equivalence modulo None,
       for example. However, if a conditional is added, the equivalence
       can be made precise:›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹On this basis, a symbolic evaluation scheme can be established
  that reduces mbind-code to try\_SE\_code and ite-cascades.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>alt_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>, ('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"(f ⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> g) = (λ σ. case f σ of None ⇒ g σ
                                      | Some H ⇒ Some H)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>malt_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> list ⇒ ('o, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"malt_SE S = foldr alt_SE S fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>   </span><span>malt_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>malt_SE_mt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> [] = fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>malt_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>malt_SE_cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (a # S) = (a ⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> S))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>malt_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition : Programming Operators and their Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> = unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ()"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool, ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>, ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"if_SE c E F = (λσ. if c σ then E σ else F σ)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>    </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"_if_SE"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool,('o,'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>,('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> _ then _ else _fi)"</span></span></span><span> </span><span class="delimiter">[</span><span>5</span><span class="delimiter">,</span><span>8</span><span class="delimiter">,</span><span>8</span><span class="delimiter">]</span><span>8</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond then T1 else T2 fi)"</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST if_SE cond T1 T2"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of a Monadic While›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Prerequisites›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>replicator</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('a, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>, nat] ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"^^^"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"f ^^^ 0      = (result ())"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ^^^ (Suc n) = (f ;- f ^^^  n)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>replicator2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('a, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>, nat, ('b, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('b, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"^:^"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"(f ^:^ 0) M      = (M )"</span></span></span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ^:^ (Suc n)) M = (f ;- ((f ^:^  n) M))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹First Step : Establishing an embedding between partial functions and relations›</span></span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* plongement *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Mon2Rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('σ × 'σ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Mon2Rel f = {(x, y). (f x = Some((), y))}"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ressortir *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Rel2Mon</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" ('σ × 'σ) set ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rel2Mon S = (λ σ. if ∃σ'. (σ, σ') ∈ S then Some((), SOME σ'. (σ, σ') ∈ S) else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mon2Rel_Rel2Mon_id</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>det</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"single_valued R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Mon2Rel ∘ Rel2Mon) R = R"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span> </span><span>Mon2Rel_def</span><span> </span><span>Rel2Mon_def</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃σ'. (a, σ') ∈ R"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>some_eq_ex</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>det</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>single_valued_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rel2Mon_Id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Rel2Mon ∘ Mon2Rel) x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span> </span><span>Mon2Rel_def</span><span> </span><span>Rel2Mon_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>contrapos_pp</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>HOL.not_sym</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_valued_Mon2Rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued (Mon2Rel B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_def</span><span> </span><span>Mon2Rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Second Step : Proving an induction principle allowing to establish that lfp remains
       deterministic›</span></span></span><span> 
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A little complete partial order theory due to Tobias Nipkow *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ 'a set) ⇒ bool"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"chain S = (∀i. S i ⊆ S(Suc i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain S ==&gt; S i ≤ S j ∨ S j ≤ S i"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>chain_def</span><span> </span><span>le_cases</span><span> </span><span>lift_Suc_mono_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cont</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a set =&gt; 'b set) =&gt; bool"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"cont f = (∀S. chain S ⟶ f(UN n. S n) = (UN n. f(S n)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_if_cont</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'b set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cont f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊆ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn::nat. if n=0 then a else b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain ?S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ⊆ b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>chain_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f(UN n. ?S n) = (UN n. f(?S n))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cont_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(UN n. ?S n) = b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ⊆ b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(UN n. f(?S n)) = f a ∪ f b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a ⊆ f b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_upper1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chain_iterates</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain(λn. (f^^n) {})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ^^ n) {} ⊆ (f ^^ Suc n) {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>chain_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfp_if_cont</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cont f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp f =  (⋃n. (f ^^ n) {})"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?U"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp f ⊆ ?U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ?U = (UN n. (f^^Suc n){})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chain_iterates</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_if_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (f^^0){} ∪ …"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?U"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>funpow.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>funpow_0</span><span> </span><span>old.nat.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ?U ⊆ ?U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>p</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f p ⊆ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f^^n){} ⊆ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>monoD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_if_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>Suc</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f p ⊆ p›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?U ⊆ lfp f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lfp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_valued_UN_chain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(!!n. single_valued (S n))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued(UN n. S n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ S n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>chain_total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>m</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_valued_lfp</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ ('a × 'a) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cont f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r. single_valued r ⟹ single_valued (f r)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued(lfp f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lfp_if_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>single_valued_UN_chain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>chain_iterates</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_if_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued ((f ^^ n) {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Third Step: Definition of the Monadic While ‹ ››</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool,('σ × 'σ) set] ⇒ (('σ × 'σ) set ⇒ ('σ × 'σ) set)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"Γ b cd = (λcw. {(s,t). if b s then (s, t) ∈ cd O cw else s = t})"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool, (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"while_SE c B ≡ (Rel2Mon(lfp(Γ c (Mon2Rel B))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>    </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"_while_SE"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool, (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> _ do _ od)"</span></span></span><span> </span><span class="delimiter">[</span><span>8</span><span class="delimiter">,</span><span>8</span><span class="delimiter">]</span><span>8</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> c do b od"</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST while_SE c b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cont_Γ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (Γ c b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cont_def</span><span> </span><span>Γ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The fixpoint theory now allows us to establish that the lfp constructed over
       @{term Mon2Rel} remains deterministic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>single_valued_lfp_Mon2Rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued (lfp(Γ c (Mon2Rel B)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>single_valued_lfp</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_Γ</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Γ_def</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>single_valued_Mon2Rel</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">]</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rel2Mon_if</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Rel2Mon {(s, t). if b s then (s, t) ∈ Mon2Rel c O lfp (Γ b (Mon2Rel c)) else s = t} σ =
  (if b σ then Rel2Mon (Mon2Rel c O lfp (Γ b (Mon2Rel c))) σ else Some ((), σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Rel2Mon_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rel2Mon_homomorphism</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>determ_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>determ_Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_valued Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"Rel2Mon (X O Y) = (Rel2Mon X) ;- (Rel2Mon Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>relational_partial_next_in_O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x E F. (∃y. (x, y) ∈ (E O F)) ⟹ (∃y. (x, y) ∈ E)"</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>some_eq_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ X x y . single_valued X ⟹ (x, y) ∈ X ⟹ (SOME y. (x, y) ∈ X) = y"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Rel2Mon_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">" ∃ σ'. (σ, σ') ∈ X O Y"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>HOL.if_True</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>relational_partial_next_in_O</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_relcomp</span><span> </span><span>some_eq_intro</span><span> </span><span>determ_X</span><span> </span><span>determ_Y</span><span> </span><span>relcomp.relcompI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Putting everything together, the theory of embedding and the invariance of
       determinism of the while-body, gives us the usual unfold-theorem:›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>while_SE_unfold</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b do c od) = (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b then (c ;- (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b do c od)) else result () fi)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>while_SE_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>lfp_unfold</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_if_cont</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>cont_Γ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Γ_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Rel2Mon_if</span><span> </span><span>Rel2Mon_homomorphism</span><span> </span><span>bind_SE'_def</span><span> </span><span>Rel2Mon_Id</span><span> </span><span class="delimiter">[</span><span>simplified</span><span> </span><span>comp_def</span><span class="delimiter">]</span><span> 
</span><span>                  </span><span>single_valued_Mon2Rel</span><span> </span><span>single_valued_lfp_Mon2Rel</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" f σ = g σ ⟹  (x ← f ; M x)σ = (x ← g ; M x)σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind'_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" f σ = g σ ⟹  (f ;- M )σ = (g ;- M )σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_True</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λ x. True) then c else d fi) = c"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>MonadSE.if_SE_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_False</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λ x. False) then c else d fi) = d"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>MonadSE.if_SE_def</span><span class="delimiter">)</span><span> 
</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f σ = g σ ⟹ 
                           (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> f then c else d fi) σ = 
                           (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> g then c else d fi) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_SE_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_skip</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λ x. False) do c od) = skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span>subst</span><span> </span><span>MonadSE.while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>MonadSE.if_SE_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span></pre>
</div>
</div><div id="Seq_MonadSE">
<div class="head"><h1>Theory Seq_MonadSE</h1>
<span class="command">theory</span> <span class="name">Seq_MonadSE</span><br/>
<span class="keyword">imports</span> <a href="MonadSE.html"><span class="name">MonadSE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Seq_MonadSE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>MonadSE</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Chaining Monadic Computations : Definitions of Multi-bind Operators ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹  In order to express execution sequences inside \HOL --- rather
than arguing over a certain pattern of terms on the meta-level --- and
in order to make our theory amenable to formal reasoning over execution sequences, 
we represent them as lists of input and generalize the bind-operator
of the state-exception monad accordingly. The approach is straightforward,
but comes with a price: we have to encapsulate all input and output data
into one type, and restrict ourselves to  a uniform step function.
Assume that we have a typed interface to a module with
the operations $op_1$, $op_2$, \ldots, $op_n$ with the inputs 
$\iota_1$, $\iota_2$, \ldots, $\iota_n$ (outputs are treated analogously).
Then we can encode for this interface the general input - type:
\begin{displaymath}
\texttt{datatype}\ \texttt{in}\ =\ op_1\ ::\ \iota_1\ |\ ...\ |\ \iota_n
\end{displaymath}
Obviously, we loose some type-safety in this approach; we have to express
that in traces only \emph{corresponding} input and output belonging to the 
same operation will occur; this form of side-conditions have to be expressed
inside \HOL. From the user perspective, this will not make much difference,
since junk-data resulting from too weak typing can be ruled out by adopted
front-ends. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Note that the subsequent notion of a test-sequence allows the io stepping 
function (and the special case of a program under test) to stop execution 
\emph{within} the sequence; such premature terminations are characterized by an 
output list which is shorter than the input list. 

Intuitively, ‹mbind› corresponds to a sequence of operation calls, separated by
";", in Java. The operation calls may fail (raising an exception), which means that
the state is maintained and the exception can still be caught at the end of the 
execution sequence.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>    </span><span>mbind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ι list  ⇒  ('ι ⇒ ('o,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒ ('o list,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind [] iostep σ = Some([], σ)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind (a#S) iostep σ = 
                (case iostep a σ of 
                     None   ⇒ Some([], σ)
                  |  Some (out, σ') ⇒ (case mbind S iostep σ' of 
                                          None    ⇒ Some([out],σ') 
                                        | Some(outs,σ'') ⇒ Some(out#outs,σ'')))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>mbind</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* future name: mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This definition is fail-safe; in case of an exception, the current state is maintained,
       the computation as a whole is marked as success.
       Compare to the fail-strict variant ‹mbind'›:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind_unit</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"mbind [] f = (result [])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The characteristic property of @{term mbind} --- which distinguishes it from 
       ‹mbind› defined in the sequel --- is that it never fails; it ``swallows'' internal
       errors occuring during the computation.›</span></span></span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind_nofailure</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"mbind S f σ ≠ None"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In contrast, we define a fail-strict sequential execution operator.
He has more the characteristic to fail globally whenever one of its operation
steps fails.

Intuitively speaking, ‹mbind'› corresponds to an execution of operations 
where a results in a System-Halt. Another interpretation of ‹mbind'› is to
view it as a kind of @{term foldl} foldl over lists via @{term bind<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>}.›</span></span></span><span> 
</span><span> 
</span><span class="keyword1"><span class="command">fun</span></span><span>    </span><span>mbind'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ι list  ⇒  ('ι ⇒ ('o,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒ ('o list,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind' [] iostep σ = Some([], σ)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mbind' (a#S) iostep σ = 
                (case iostep a σ of 
                     None   ⇒ None
                  |  Some (out, σ') ⇒ (case mbind' S iostep σ' of 
                                          None    ⇒ None   ― ‹fail-strict› 
                                        | Some(outs,σ'') ⇒ Some(out#outs,σ'')))"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>mbind'</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* future name: mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind'_unit</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"mbind' [] f = (result [])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind'_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(x ← mbind' (a#S) F; M x) = (a ← (F a); (x ← mbind' S F; M (a # x)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>mbind'.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* use only more abstract definitions *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next ‹mbind› sequential execution operator is called 
Fail-Purge. He has more the characteristic to never fail, just "stuttering" 
above operation steps that fail. Another alternative in modeling.›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>    </span><span>mbind''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ι list  ⇒  ('ι ⇒ ('o,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒ ('o list,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind'' [] iostep σ = Some([], σ)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mbind'' (a#S) iostep σ = 
                (case iostep a σ of 
                     None           ⇒ mbind'' S iostep σ
                  |  Some (out, σ') ⇒ (case mbind'' S iostep σ' of 
                                          None    ⇒ None   ― ‹does not occur› 
                                        | Some(outs,σ'') ⇒ Some(out#outs,σ'')))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>mbind''</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* future name: mbind<span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub> *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span>  </span><span>mbind''.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* use only more abstract definitions *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹mbind' as failure strict operator can be seen as a foldr on bind -
       if the types would match \ldots›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition : Miscellaneous Operators and their Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind_try</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x ← mbind (a#S) F; M x) = 
   (a' ← try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>(F a); 
      if a' = None 
      then (M [])
      else (x ← mbind S F; M (the a' # x)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>try_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"F a x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>try_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind S F b"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span></pre>
</div>
</div><div id="Symbex_MonadSE">
<div class="head"><h1>Theory Symbex_MonadSE</h1>
<span class="command">theory</span> <span class="name">Symbex_MonadSE</span><br/>
<span class="keyword">imports</span> <a href="Seq_MonadSE.html"><span class="name">Seq_MonadSE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Symbex_MonadSE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Seq_MonadSE</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition and Properties of Valid Execution Sequences›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A key-notion in our framework is the \emph{valid} execution
sequence, \ie{} a sequence that:
\begin{enumerate}
\item terminates (not obvious since while),
\item results in a final @{term True},
\item does not fail globally (but recall the FailSave and FailPurge
      variants of @{term mbind}-operators, that handle local exceptions in
      one or another way).
\end{enumerate}
Seen from an automata perspective (where the monad - operations correspond to
the step function), valid execution sequences can be used to model ``feasible paths''
across an automaton.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_SE</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'σ ⇒ (bool,'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨"</span></span></span><span> </span><span>15</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ m) = (m σ ≠ None ∧ fst(the (m σ)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This notation consideres failures as valid -- a definition
inspired by I/O conformance.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Valid Execution Sequences and their Symbolic Execution›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_unit_SE</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (result P)) = (P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_unit_SE'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ<span class="hidden">⇩</span><sub>0</sub> ⊨ (λσ. Some (f σ, σ))) = (f σ<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_fail_SE</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) = False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>fail_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_fail_SE'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(σ<span class="hidden">⇩</span><sub>0</sub> ⊨ (λσ. None))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following the rules are in a sense the heart of the entire symbolic execution approach›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>exec_bind_SE_failure</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"A σ = None ⟹ ¬(σ ⊨ ((s ← A ; M s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>exec_bind_SE_failure2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"A σ = None ⟹ ¬(σ ⊨ ((A ;- M)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"A σ = Some(b,σ') ⟹ (σ ⊨ ((s ← A ; M s))) = (σ' ⊨ (M b))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind_SE_success2</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"A σ = Some(b,σ') ⟹ (σ ⊨ ((A ;- M))) = (σ' ⊨ M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span>bind_SE'_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind_SE_success'</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* atomic boolean Monad "Query Functions" *)</span></span></span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">"M σ = Some(f σ,σ) ⟹  (σ ⊨ M) = f σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind_SE_success''</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ((s ← A ; M s)) ⟹  ∃ v σ'. the(A σ) = (v,σ') ∧ σ' ⊨ (M v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>the</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"snd aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind_SE_success'''</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ((s ← A ; M s)) ⟹  ∃ a. (A σ) = Some a ∧ (snd a) ⊨ (M (fst a))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>the</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"snd aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>exec_bind_SE_success''''</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ((s ← A ; M s)) ⟹  ∃ v σ'. A σ = Some(v,σ') ∧ σ' ⊨ (M v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>the</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"snd aa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_bind_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" f σ = g σ ⟹ (σ ⊨ (x ← f ; M x)) = (σ ⊨ (x ← g ; M x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>valid_SE_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_bind'_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" f σ = g σ ⟹ (σ ⊨ f ;- M) = (σ ⊨ g ;- M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>valid_SE_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Recall \verb+mbind_unit+ for the base case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind_mt</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( s ←  mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s))) = P [] "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind_mtE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ( s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s)) ⟹ (P [] ⟹ Q) ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_mbind_mt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind'_mt</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s))) = P [] "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind'_mtE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ( s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s)) ⟹ (P [] ⟹ Q) ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_mbind'_mt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind''_mt</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s))) = P [] "</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mbind''.simps</span><span> </span><span>valid_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_mbind''_mtE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ( s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> [] f; unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P s)) ⟹ (P [] ⟹ Q) ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_mbind''_mt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFSave_failure</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None ⟹ 
   (σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ; M s)) =  (σ ⊨ (M []))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFStop_failure</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None ⟹ 
   (σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> (a#S) ioprog ; M s)) =  (False)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_bind_SE_failure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFPurge_failure</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None ⟹ 
   (σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ; M s)) = (σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> (S) ioprog ; M s))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> </span><span>mbind''.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFSave_success</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some(b,σ') ⟹ 
   (σ  ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ; M s)) = 
   (σ' ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog ; M (b#s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog σ'"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFStop_success</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some(b,σ') ⟹ 
   (σ  ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> (a#S) ioprog ; M s)) = 
   (σ' ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S ioprog ; M (b#s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S ioprog σ'"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>mbind'.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFPurge_success</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some(b,σ') ⟹ 
   (σ  ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ; M s)) = 
   (σ' ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog ; M (b#s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog σ'"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>mbind''.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFSave</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub>  (a#S) ioprog ; return (P s))) =
    (case ioprog a σ of
       None ⇒ (σ  ⊨ (return (P [])))
     | Some(b,σ') ⇒ (σ'  ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub>  S ioprog ; return (P (b#s)))))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>exec_mbindFSave_failure</span><span>  </span><span>exec_mbindFSave_success</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind_eq_sexec</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b σ'. f a σ = Some(b,σ') ⟹ 
             (os ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S f; P (b#os)) = (os ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S f; P' (b#os))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>       </span><span class="string"><span class="delete"><span class="delete">"( a ← f a;  x ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S f; P (a # x)) σ = 
             ( a ← f a;  x ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S f; P'(a # x)) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a σ = None"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind_eq_sexec'</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b σ'. f a σ = Some(b,σ') ⟹ 
             (P (b))σ' = (P' (b))σ'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>       </span><span class="string"><span class="delete"><span class="delete">"( a ← f a;  P (a)) σ = 
             ( a ← f a;  P'(a)) σ"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a σ = None"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_SE_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind'_concat</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(os ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> (S@T) f; P os) = (os ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S f; os' ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> T f; P (os @ os'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>S</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>σ</span><span> </span><span>P</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>Cons.hyps</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mbind_eq_sexec'</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_suffix_inv</span><span> </span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ( _ ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> xs istep; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P)) 
               ⟹ ∀σ. P σ ⟶ (σ ⊨ (_ ← istep x; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P)))
               ⟹ σ ⊨ ( _ ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> (xs @ [x]) istep; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (P))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mbind'_concat</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"P bb"</span></span></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"P bb"</span></span></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Universal splitting and symbolic execution rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFSave_E</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ;  (P s)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None ⟹ (σ ⊨ (P [])) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ b σ'. ioprog a σ = Some(b,σ') ⟹ (σ' ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog;(P (b#s)))) ⟹ Q "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ"</span></span></span><span class="delimiter">)</span><span>  
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ass</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>ioprog1</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFSave_failure</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>aa</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some aa"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"out"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>some</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>ioprog1</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFSave_success</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next rule reveals the particular interest in deduction;
       as an elimination rule, it allows for a linear conversion of a validity judgement
       @{term "mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub>"} over an input list @{term "S"} into a constraint system; without any 
       branching ... Symbolic execution can even be stopped tactically whenever 
       @{term "ioprog a σ = Some(b,σ')"} comes to a contradiction.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFStop_E</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> (a#S) ioprog ; (P s)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b σ'. ioprog a σ = Some(b,σ') ⟹ (σ'⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> S ioprog;(P(b#s)))) ⟹ Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ"</span></span></span><span class="delimiter">)</span><span>  
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>σ</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">=</span><span>S</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>P</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFStop_failure</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>aa</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some aa"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"out"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>some</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>ioprog1</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFStop_success</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_mbindFPurge_E</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> (a#S) ioprog ;  (P s)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None ⟹ (σ ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog;(P (s)))) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ b σ'. ioprog a σ = Some(b,σ') ⟹ (σ' ⊨ (s ← mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub> S ioprog;(P (b#s)))) ⟹ Q "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ"</span></span></span><span class="delimiter">)</span><span>  
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = None"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ass</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>ioprog1</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFPurge_failure</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>aa</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ioprog a σ = Some aa"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"out"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>some</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>ass</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>ioprog1</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exec_mbindFPurge_success</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_disch1</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" P σ ⟹ (σ ⊨ (x ← assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P; M x)) = (σ ⊨ (M True))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_disch2</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" ¬ P σ ⟹ ¬ (σ ⊨ (x ← assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; M s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_disch3</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" ¬ P σ ⟹ ¬ (σ ⊨ (assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_disch4</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" P σ ⟹  (σ ⊨ (assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_simp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P) = P σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assert_disch3</span><span> </span><span>assert_disch4</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>assert_D</span><span> </span><span class="delimiter">=</span><span> </span><span>assert_simp</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* legacy *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_bind_simp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (x ← assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P; M x)) = (P σ ∧ (σ ⊨ (M True)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>valid_SE_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>HOL.if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>assert_bindD</span><span> </span><span class="delimiter">=</span><span> </span><span>assert_bind_simp</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* legacy *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assume_D</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (_ ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P; M)) ⟹ ∃ σ. (P σ ∧ (σ ⊨ M) )"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span> </span><span>assume_SE_def</span><span> </span><span>valid_SE_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>HOL.if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Eps P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Hilbert_Choice.someI</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assume_E</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span>  </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ( _ ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P; M) "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>**</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ σ. P σ ⟹ σ ⊨ M  ⟹ Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>*</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>assume_D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assume_E'</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span>  </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ;- M"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>**</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ σ. P σ ⟹ σ ⊨ M  ⟹ Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>*</span><span class="delimiter">[</span><span>simplified</span><span> </span><span class="string"><span class="delete"><span class="delete">"bind_SE'_def"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>assume_D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These two rule prove that the SE Monad in connection with the notion of valid sequence
is actually sufficient for a representation of a Boogie-like language. The SBE monad with explicit
sets of states --- to be shown below --- is strictly speaking not necessary (and will therefore
be discontinued in the development).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_D1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ ⟹ (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi)) = (σ ⊨ B<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_D1'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ ⟹ (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = (σ ⊨ (B<span class="hidden">⇩</span><sub>1</sub>;-M))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>valid_SE_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_D2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P σ ⟹ (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi)) = (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_D2'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P σ ⟹ (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>;-M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>valid_SE_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_split_asm</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi)) = ((P σ ∧ (σ ⊨ B<span class="hidden">⇩</span><sub>1</sub>)) ∨ (¬ P σ ∧ (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_D1</span><span> </span><span>if_SE_D2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_split_asm'</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = ((P σ ∧ (σ ⊨ B<span class="hidden">⇩</span><sub>1</sub>;-M)) ∨ (¬ P σ ∧ (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>;-M)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_D1'</span><span> </span><span>if_SE_D2'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_split</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi)) = ((P σ ⟶ (σ ⊨ B<span class="hidden">⇩</span><sub>1</sub>)) ∧ (¬ P σ ⟶ (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_D1</span><span> </span><span>if_SE_D2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_split'</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = ((P σ ⟶ (σ ⊨ B<span class="hidden">⇩</span><sub>1</sub>;-M)) ∧ (¬ P σ ⟶ (σ ⊨ B<span class="hidden">⇩</span><sub>2</sub>;-M)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_D1'</span><span> </span><span>if_SE_D2'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_execE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ((if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi))"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ  ⟹ σ ⊨ (B<span class="hidden">⇩</span><sub>1</sub>) ⟹ Q"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P σ⟹ σ ⊨ (B<span class="hidden">⇩</span><sub>2</sub>) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>A</span><span> </span><span class="delimiter">[</span><span>simplified</span><span> </span><span>if_SE_split</span><span class="delimiter">]</span><span class="delimiter">,</span><span>cases</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_execE'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ ((if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ  ⟹ σ ⊨ (B<span class="hidden">⇩</span><sub>1</sub>;-M) ⟹ Q"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P σ⟹ σ ⊨ (B<span class="hidden">⇩</span><sub>2</sub>;-M) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>A</span><span> </span><span class="delimiter">[</span><span>simplified</span><span> </span><span>if_SE_split'</span><span class="delimiter">]</span><span class="delimiter">,</span><span>cases</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_while</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ((while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b do c od) ;- M)) = 
 (σ ⊨ ((if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b then c ;- (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> b do c od) else unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ()fi) ;- M))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE'_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_whileD</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_while</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_execE''</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi) ;- M 
⟹ (P σ ⟹ σ ⊨ B<span class="hidden">⇩</span><sub>1</sub> ;- M ⟹ Q) 
⟹ (¬ P σ ⟹ σ ⊨ B<span class="hidden">⇩</span><sub>2</sub> ;- M ⟹ Q) 
⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>if_SE_execE'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque (x::bool) = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_SE_execE''_pos</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi) ;- M 
⟹ (P σ ⟹ σ ⊨ B<span class="hidden">⇩</span><sub>1</sub> ;- M ⟹ Q) 
⟹ (opaque (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi) ;- M) ⟹ Q) 
⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>opaque_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ m) = (case (m σ) of None  ⇒ False | (Some (x,y))  ⇒ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m σ = None"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>not_None_eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* for the moment no good idea to state the case where the body eventually crashes. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P  σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  (x=X) ∧ Q x σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. ∃ X. σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  x=X ∧ Q x σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_sequence_rule</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀ X σ<span class="hidden">⇩</span><sub>1</sub>. (σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ'. (σ=σ') ∧  P σ) ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  (x=X) ∧ (σ=σ<span class="hidden">⇩</span><sub>1</sub>) ∧ Q x σ)))
               ∧ 
               (σ<span class="hidden">⇩</span><sub>1</sub> ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  (σ=σ<span class="hidden">⇩</span><sub>1</sub>) ∧ Q x σ) ; y  ← M'; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  R x y σ)))
       ⟹
               σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ'. (σ=σ') ∧  P σ) ; x  ← M; y  ← M'; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (R x y))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>impE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>assume_D</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>impE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_SE_def</span><span> </span><span>assume_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>bind_SE_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span> </span><span>HOL.if_split_asm</span><span> </span><span>Option.option.split</span><span> </span><span>Option.option.split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ X. σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ.  x=X ∧ Q x σ))
       ⟹ 
            σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. Q x σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_SE_def</span><span> </span><span>assume_SE_def</span><span> </span><span>assert_SE_def</span><span> </span><span>bind_SE_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span> </span><span>HOL.if_split_asm</span><span> </span><span>Option.option.split</span><span> </span><span>Option.option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ;- M) = (σ ⊨ M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_skipD</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_skip</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Test-Refinements will be stated in terms of the failsave @{term mbind}, opting 
       more generality. The following lemma allows for an  optimization both in 
       test execution as well as in symbolic execution for an important special case of
       the post-codition: Whenever the latter has the constraint that the length of input and 
       output sequence equal each other (that is to say: no failure occured), failsave mbind
       can be reduced to failstop mbind ...›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbindFSave_vs_mbindFStop</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (os ← (mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> ιs ioprog); result(length ιs = length os ∧ P ιs os))) = 
   (σ ⊨ (os ← (mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> ιs ioprog); result(P ιs os)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>P</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"ιs"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mbind_try</span><span> </span><span>try_SE_def</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Seq_MonadSE.mbind.simps</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ιs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">,</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>Cons.hyps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"ioprog a σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>exec_mbindFSave_failure</span><span> </span><span>exec_mbindFStop_failure</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>split_paired_all</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Seq_MonadSE.mbind.simps</span><span> </span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>exec_mbindFSave_success</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λιs s. P (a # ιs) (aa # s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* heureka ! *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub>_vs_mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ ι σ. ioprog ι σ ≠ None"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (os ← (mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> ιs ioprog); P os)) = 
            (σ ⊨ (os ← (mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> ιs ioprog); P os))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"ιs"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ιs</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.hyps</span><span>                           
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ S f σ. mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> S f σ ≠ None "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀σ. mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> ιs ioprog σ = mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> ιs ioprog σ"</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>ιs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seq_MonadSE.mbind'.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λσ . ioprog a σ ≠ None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>A</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span>  </span><span class="string"><span class="delete"><span class="delete">"out"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ιs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ioprog</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>σ'</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>not_None_eq</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span>   </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λ a b c. a # (fst c)) out σ' (aa, b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λ a b c. (snd c)) out σ' (aa, b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>exec_bind_SE_success</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Some (aa, b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>  </span><span>trans</span><span class="delimiter">,</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>C</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span>  </span><span>exec_bind_SE_success</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span>  </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Some (aa, b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>  </span><span>trans</span><span class="delimiter">,</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Miscellaneous›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>unit_SE</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(result _)"</span></span></span><span> </span><span>8</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span></pre>
</div>
</div><div id="Clean">
<div class="head"><h1>Theory Clean</h1>
<span class="command">theory</span> <span class="name">Clean</span><br/>
<span class="keyword">imports</span> <a href="Symbex_MonadSE.html"><span class="name">Symbex_MonadSE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Clean --- a basic abstract ("shallow") programming language for test and proof.
 * Burkhart Wolff, Frédéric Tuong and Chantal Keller, LRI, Univ. Paris-Saclay, France
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Clean Language›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Clean</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Symbex_MonadSE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"global_vars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_vars_test"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"returns"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_vars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"variant"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function_spec"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rec_function_spec"</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean (pronounced as: ``C lean'' or ``Céline'' [selin]) is a minimalistic imperative language 
with C-like control-flow operators based on a shallow embedding into the ``State Exception Monads'' theory 
formalized in 🗏‹MonadSE.thy›. It strives for a type-safe notation of program-variables, an
incremental construction of the typed state-space in order to facilitate incremental verification
and open-world extensibility to new type definitions intertwined with the program
definition.

It comprises:
\begin{itemize}
\item C-like control flow with \&lt;^term&gt;‹break› and \&lt;^term&gt;‹return›,
\item global variables,
\item function calls (seen as monadic executions) with side-effects, recursion
      and local variables,
\item parameters are modeled via functional abstractions 
      (functions are monads); a passing of parameters to local variables
      might be added later,
\item direct recursive function calls,
\item cartouche syntax for ‹λ›-lifted update operations supporting global and local variables.
\end{itemize}

Note that Clean in its current version is restricted to ∗‹monomorphic› global and local variables
as well as function parameters. This limitation will be overcome at a later stage. The construction
in itself, however, is deeply based on parametric polymorphism (enabling structured proofs over
extensible records as used in languages of the ML family
🌐‹http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf›
and Haskell 🌐‹https://www.schoolofhaskell.com/user/fumieval/extensible-records›).
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ @{footnote ‹sdf›}, @{file "$ISABELLE_HOME/src/Pure/ROOT.ML"}›</span></span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A High-level Description of the Clean Memory Model›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A Simple Typed Memory Model of Clean: An Introduction ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Clean is based on a ``no-frills'' state-exception monad 
⬚‹type_synonym ('o, 'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> = ‹'σ ⇀ ('o × 'σ)›› with the 
usual definitions of \&lt;^term&gt;‹bind› and \&lt;^term&gt;‹unit›.
In this language, sequence operators, conditionals and loops can be integrated. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹From a concrete program, the underlying state ⬚‹'σ› is ∗‹incrementally› constructed by a
sequence of extensible record definitions:
▸ Initially, an internal control state is defined to give semantics to \&lt;^term&gt;‹break› and
 \&lt;^term&gt;‹return› statements:
  \begin{isar}
        record control_state =  break_val  :: bool   return_val :: bool
  \end{isar}
  ⬚‹control_state› represents the $\sigma_0$ state.
▸ Any global variable definition block with definitions $a_1 : \tau_1$ $\dots$ $a_n : \tau_n$  
  is translated into a record extension:
  \begin{isar}
        record σ$_{n+1}$ = σ$_n$    +    a$_1$ :: $\tau_1$; ...; $a_n$ :: $\tau_n$
  \end{isar}
▸ Any local variable definition block (as part of a procedure declaration) 
  with definitions $a_1 : \tau_1$ $\dots$ $a_n : \tau_n$ is translated into the record extension:
  \begin{isar}
        record σ$_{n+1}$ = σ$_n$    +    a$_1$ :: $\tau_1$ list; ...; $a_n$ :: $\tau_n$ list; result :: $\tau_{result-type}$ list; 
  \end{isar}
  where the \&lt;^typ&gt;‹_ list›-lifting is used to model a ∗‹stack› of local variable instances
  in case of direct recursions and the \&lt;^term&gt;‹result_value› used for the value of the \&lt;^term&gt;‹return›
  statement.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The ⬚‹record› package creates an ⬚‹'σ› extensible record type 
⬚‹'σ control_state_ext› where the ⬚‹'σ› stands for extensions that are subsequently ``stuffed'' in
them. Furthermore, it generates definitions for the constructor, accessor and update functions and
automatically derives a number of theorems over them (e.g., ``updates on different fields commute'',
``accessors on a record are surjective'', ``accessors yield the value of the last update''). The
collection of these theorems constitutes the ∗‹memory model› of Clean, providing an incrementally 
extensible state-space for global and local program variables. In contrast to axiomatizations
of memory models, our generated state-spaces might be ``wrong'' in the sense that they do not 
reflect the operational behaviour of a particular compiler or a sufficiently large portion of the 
C language; however, it is by construction ∗‹logically consistent› since it is
impossible to derive falsity from the entire set of conservative extension schemes used in their
construction. A particular advantage of the incremental state-space construction is that it
supports incremental verification and interleaving of program definitions with theory development.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Formally Modeling Control-States  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The control state is the ``root'' of all extensions for local and global variable
spaces in Clean. It contains just the information of the current control-flow: a \&lt;^term&gt;‹break› occurred
(meaning all commands till the end of the control block will be skipped) or a \&lt;^term&gt;‹return› occurred
(meaning all commands till the end of the current function body will be skipped).›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">record</span></span><span>  </span><span>control_state</span><span> </span><span class="delimiter">=</span><span> 
</span><span>            </span><span>break_status</span><span>  </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>            </span><span>return_status</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* break quits innermost while or for, return quits an entire execution sequence. *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>break</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ('σ_ext) control_state_ext) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"break ≡ (λ σ. Some((), σ ⦇ break_status := True ⦈))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unset_break_status</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ('σ_ext) control_state_ext) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"unset_break_status ≡ (λ σ. Some((), σ ⦇ break_status := False ⦈))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_return_status</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" (unit, ('σ_ext) control_state_ext) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"set_return_status = (λ σ. Some((), σ ⦇ return_status := True ⦈))"</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unset_return_status</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ('σ_ext) control_state_ext) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"unset_return_status  = (λ σ. Some((), σ ⦇ return_status := False ⦈))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exec_stop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ_ext) control_state_ext ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"exec_stop = (λ σ. break_status σ ∨ return_status σ )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_stop1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"break_status σ ⟹ exec_stop σ"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exec_stop_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_stop2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"return_status σ ⟹ exec_stop σ"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exec_stop_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ On the basis of the control-state, assignments, conditionals and loops are reformulated
  into \&lt;^term&gt;‹break›-aware and \&lt;^term&gt;‹return›-aware versions as shown in the definitions of
  \&lt;^term&gt;‹assign› and \&lt;^term&gt;‹if_C› (in this theory file, see below). ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For Reasoning over Clean programs, we need the notion of independance of an
     update from the control-block: ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>control_independence</span><span> </span><span class="delimiter">::</span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">"(('b⇒'b)⇒'a control_state_scheme ⇒ 'a control_state_scheme) ⇒ bool"</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"♯"</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ upd ≡ (∀σ T b. break_status (upd T σ) = break_status σ 
                                 ∧ return_status (upd T σ) = return_status σ
                                 ∧ upd T (σ⦇ return_status := b ⦈) = (upd T σ)⦇ return_status := b ⦈
                                 ∧ upd T (σ⦇ break_status := b ⦈) = (upd T σ)⦇ break_status := b ⦈) "</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_stop_vs_control_independence</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"♯ upd ⟹ exec_stop (upd f σ) = exec_stop σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span> </span><span>exec_stop_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_stop_vs_control_independence'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"♯ upd ⟹ (upd f (σ ⦇ return_status := b ⦈)) = (upd f σ)⦇ return_status := b ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span> </span><span>exec_stop_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_stop_vs_control_independence''</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"♯ upd ⟹ (upd f (σ ⦇ break_status := b ⦈)) = (upd f σ) ⦇ break_status := b ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span> </span><span>exec_stop_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An Example for Global Variable Declarations.›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We present the above definition of the incremental construction of the state-space in more
detail via an example construction.

Consider a global variable ‹A› representing an array of integer. This 
∗‹global variable declaration› corresponds to the effect of the following
record declaration:

⬚‹record state0 = control_state + A :: "int list"›

which is later extended by another global variable, say, ‹B› representing a real
described in the Cauchy Sequence form @{typ "nat ⇒ (int × int)"} as follows:

⬚‹record state1 = state0 + B :: "nat ⇒ (int × int)"›.

A further extension would be needed if a (potentially recursive) function ‹f› with some local
variable ‹tmp› is defined:
⬚‹record state2 = state1 + tmp :: "nat stack" result_value :: "nat stack" ›, where the ‹stack›
needed for modeling recursive instances is just a synonym for ‹list›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ The Assignment Operations (embedded in State-Exception Monad) ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Based on the global variable states, we define   \&lt;^term&gt;‹break›-aware and \&lt;^term&gt;‹return›-aware 
version of the assignment. The trick to do this in a generic ∗‹and› type-safe way is to provide
the generated accessor and update functions (the ``lens'' representing this global variable,
cf. @{cite "Foster2009BidirectionalPL" and "DBLP:journals/toplas/FosterGMPS07" and
"DBLP:conf/ictac/FosterZW16"}) to the generic assign operators. This pair of accessor and update
carries all relevant semantic and type information of this particular variable and ∗‹characterizes›
this variable semantically. Specific syntactic support~⁋‹via the Isabelle concept of
cartouche: 🌐‹https://isabelle.in.tum.de/doc/isar-ref.pdf›› will hide away the syntactic overhead and permit a human-readable
form of assignments or expressions accessing the underlying state. ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>syntax_assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('α  ⇒ int) ⇒ int ⇒ term"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">":="</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('σ_ext) control_state_scheme  ⇒ 
                       ('σ_ext) control_state_scheme) ⇒ 
                       (unit,('σ_ext) control_state_scheme)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"assign f = (λσ. if exec_stop σ then Some((), σ) else Some((), f σ))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>  </span><span>assign_global</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a  ⇒ 'a ) ⇒ 'σ_ext control_state_scheme ⇒ 'σ_ext control_state_scheme)
                              ⇒ ('σ_ext control_state_scheme ⇒  'a)
                              ⇒ (unit,'σ_ext control_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"assign_global upd rhs = assign(λσ. ((upd) (λ_. rhs σ)) σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An update of the variable ‹A› based on the state of the previous example is done 
by @{term [source = true] ‹assign_global A_upd (λσ. list_update (A σ) (i) (A σ ! j))›}
representing ‹A[i] = A[j]›; arbitrary nested updates can be constructed accordingly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Local variable spaces work analogously; except that they are represented by a stack
in order to support individual instances in case of function recursion. This requires
automated generation of specific push- and pop operations used to model the effect of
entering or leaving a function block (to be discussed later).›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>      </span><span>map_hd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a) ⇒ 'a list ⇒ 'a list"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_hd f [] = []"</span></span></span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_hd f (a#S) = f a # S"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_map_hd</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"tl (map_hd f S) = tl S"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>map_hd.elims</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_nth = (λi f l. list_update l i (f (l ! i)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>  </span><span>assign_local</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a list ⇒ 'a list) 
                                 ⇒ 'σ_ext control_state_scheme ⇒ 'σ_ext control_state_scheme)
                             ⇒ ('σ_ext control_state_scheme ⇒  'a)
                             ⇒ (unit,'σ_ext control_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"assign_local upd rhs = assign(λσ. ((upd o map_hd) (%_. rhs σ)) σ)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Semantically, the difference between ∗‹global› and ∗‹local› is rather unimpressive as the 
     following lemma shows. However, the distinction matters for the pretty-printing setup of Clean.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assign_local upd rhs = assign_global (upd o map_hd) rhs "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assign_local_def</span><span> </span><span>assign_global_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The ‹return› command in C-like languages is represented basically by an assignment to a local
variable ‹result_value› (see below in the Clean-package generation), plus some setup of 
\&lt;^term&gt;‹return_status›. Note that a \&lt;^term&gt;‹return› may appear after a \&lt;^term&gt;‹break› and should have no effect
in this case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>return<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a list ⇒ 'a list) ⇒ 'σ_ext control_state_scheme ⇒ 'σ_ext control_state_scheme)
                      ⇒ ('σ_ext control_state_scheme ⇒  'a)
                      ⇒ (unit,'σ_ext control_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"return<span class="hidden">⇩</span><sub>C</sub> upd rhs =(λσ. if exec_stop σ then Some((), σ) 
                                                else (assign_local upd rhs ;- set_return_status) σ)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Example for a Local Variable Space›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Consider the usual operation ‹swap› defined in some free-style syntax as follows:
@{cartouche [display] ‹
  function_spec swap (i::nat,j::nat)
  local_vars   tmp :: int 
  defines      " ‹ tmp  := A ! i› ;-
                 ‹ A[i] := A ! j› ;- 
                 ‹ A[j] := tmp› "›}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ 
For the fantasy syntax  ‹tmp := A ! i›, we can construct the following semantic code:
@{term [source = true] ‹assign_local tmp_update (λσ. (A σ) ! i )›} where ‹tmp_update› is the
update operation generated by the ⬚‹record›-package, which is generated while treating local variables
of ‹swap›. By the way, a stack for ‹return›-values is also generated in order to give semantics
to a ‹return› operation: it is syntactically equivalent to the assignment of 
the result variable  in the local state (stack). It sets the \&lt;^term&gt;‹return_val› flag.

The management of the local state space requires function-specific ‹push› and ‹pop› operations,
for which suitable definitions are generated as well:

@{cartouche [display]
‹definition push_local_swap_state :: "(unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
   where   "push_local_swap_state σ = 
                     Some((),σ⦇local_swap_state.tmp := undefined # local_swap_state.tmp σ,
                               local_swap_state.result_value := undefined # 
                                                                  local_swap_state.result_value σ  ⦈)"

 definition pop_local_swap_state :: "(unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
   where   "pop_local_swap_state σ = 
                    Some(hd(local_swap_state.result_value σ), 
                         σ⦇local_swap_state.tmp:= tl( local_swap_state.tmp σ) ⦈)"›}
where ‹result_value› is the stack for potential result values (not needed in the concrete
example ‹swap›).
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Global and Local State Management via Extensible Records ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the sequel, we present the automation of the state-management as schematically discussed
in the previous section; the declarations of global and local variable blocks are constructed by 
subsequent extensions of @{typ "'a control_state_scheme"}, defined above.›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

structure StateMgt_core = 
struct

val control_stateT = Syntax.parse_typ @{context} "control_state"
val control_stateS = @{typ "('a)control_state_scheme"};

fun optionT t = Type(@{type_name "Option.option"},[t]);
fun MON_SE_T res state = state --&gt; optionT(HOLogic.mk_prodT(res,state));

fun merge_control_stateS (@{typ "('a)control_state_scheme"},t) = t
   |merge_control_stateS (t, @{typ "('a)control_state_scheme"}) = t
   |merge_control_stateS (t, t') = if (t = t') then t else error"can not merge Clean state"

datatype var_kind = global_var of typ | local_var of typ

fun type_of(global_var t) = t | type_of(local_var t) = t

type state_field_tab = var_kind Symtab.table

structure Data = Generic_Data
(
  type T                      = (state_field_tab * typ (* current extensible record *)) 
  val  empty                  = (Symtab.empty,control_stateS)
  val  extend                 = I
  fun  merge((s1,t1),(s2,t2)) = (Symtab.merge (op =)(s1,s2),merge_control_stateS(t1,t2))
);


val get_data                   = Data.get o Context.Proof;
val map_data                   = Data.map;
val get_data_global            = Data.get o Context.Theory;
val map_data_global            = Context.theory_map o map_data;

val get_state_type             = snd o get_data
val get_state_type_global      = snd o get_data_global
val get_state_field_tab        = fst o get_data
val get_state_field_tab_global = fst o get_data_global
fun upd_state_type f           = map_data (fn (tab,t) =&gt; (tab, f t))
fun upd_state_type_global f    = map_data_global (fn (tab,t) =&gt; (tab, f t))

fun fetch_state_field (ln,X)   = let val a::b:: _  = rev (Long_Name.explode ln) in ((b,a),X) end;

fun filter_name name ln        = let val ((a,b),X) = fetch_state_field ln
                                 in  if a = name then SOME((a,b),X) else NONE end;

fun filter_attr_of name thy    = let val tabs = get_state_field_tab_global thy
                                 in  map_filter (filter_name name) (Symtab.dest tabs) end;

fun is_program_variable name thy = Symtab.defined((fst o get_data_global) thy) name

fun is_global_program_variable name thy = case Symtab.lookup((fst o get_data_global) thy) name of
                                             SOME(global_var _) =&gt; true
                                           | _ =&gt; false

fun is_local_program_variable name thy = case Symtab.lookup((fst o get_data_global) thy) name of
                                             SOME(local_var _) =&gt; true
                                           | _ =&gt; false

fun declare_state_variable_global f field thy  =  
             let val Const(name,ty) = Syntax.read_term_global thy field
             in  (map_data_global (apfst (Symtab.update_new(name,f ty))) (thy)
                 handle Symtab.DUP _ =&gt; error("multiple declaration of global var"))
             end;

fun declare_state_variable_local f field ctxt  = 
             let val Const(name,ty) = Syntax.read_term_global  (Context.theory_of ctxt) field
             in  (map_data (apfst (Symtab.update_new(name,f ty)))(ctxt)
                 handle Symtab.DUP _ =&gt; error("multiple declaration of global var"))
             end;

end›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Block-Structures›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ On the managed local state-spaces, it is now straight-forward to define the semantics for 
a ‹block› representing the necessary management of local variable instances:
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"  (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                     ⇒ (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>  
                     ⇒ ('α, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                     ⇒ ('α, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"block<span class="hidden">⇩</span><sub>C</sub> push core pop ≡ (          ― ‹assumes break and return unset › 
                                   push ;-   ― ‹create new instances of local variables › 
                                   core ;-   ― ‹execute the body ›
                                   unset_break_status ;-    ― ‹unset a potential break ›
                                   unset_return_status;-    ― ‹unset a potential return break ›
                                   (x ← pop;           ― ‹restore previous local var instances ›
                                    unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>(x)))"</span></span></span><span>        </span><span class="comment">― ‹yield the return value ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Based on this definition, the running ‹swap› example is represented as follows:

@{cartouche [display]
‹definition swap_core :: "nat × nat ⇒  (unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap_core  ≡ (λ(i,j). ((assign_local tmp_update (λσ. A σ ! i ))   ;-
                            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;- 
                            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ)))))" 

definition swap :: "nat × nat ⇒  (unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "swap ≡ λ(i,j). block<span class="hidden">⇩</span><sub>C</sub> push_local_swap_state (swap_core (i,j)) pop_local_swap_state"
›}

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Call Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹It is now straight-forward to define the semantics of a generic call --- 
which is simply a monad execution that is \&lt;^term&gt;‹break›-aware and \&lt;^term&gt;‹return›-aware.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( 'α ⇒ ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒
                       ((('σ_ext) control_state_ext) ⇒ 'α) ⇒                        
                      ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> = (λσ. if exec_stop σ then Some(undefined, σ) else M (A<span class="hidden">⇩</span><sub>1</sub> σ) σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that this presentation assumes a uncurried format of the arguments. The 
question arises if this is the right approach to handle calls of operation with multiple arguments.
Is it better to go for an some appropriate currying principle? Here are 
 some more experimental variants for curried operations...
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>call_0<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"call_0<span class="hidden">⇩</span><sub>C</sub> M = (λσ. if exec_stop σ then Some(undefined, σ) else M σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The generic version using tuples is identical with @{term ‹call_1<span class="hidden">⇩</span><sub>C</sub>›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( 'α ⇒ ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒
                       ((('σ_ext) control_state_ext) ⇒ 'α) ⇒                        
                      ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>                                                      
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"call_1<span class="hidden">⇩</span><sub>C</sub>  = call<span class="hidden">⇩</span><sub>C</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>call_2<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( 'α ⇒ 'β ⇒ ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒
                       ((('σ_ext) control_state_ext) ⇒ 'α) ⇒                        
                       ((('σ_ext) control_state_ext) ⇒ 'β) ⇒      
                      ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"call_2<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub> = (λσ. if exec_stop σ then Some(undefined, σ) else M (A<span class="hidden">⇩</span><sub>1</sub> σ) (A<span class="hidden">⇩</span><sub>2</sub> σ) σ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>call_3<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( 'α ⇒ 'β ⇒  'γ ⇒ ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>) ⇒
                       ((('σ_ext) control_state_ext) ⇒ 'α) ⇒                        
                       ((('σ_ext) control_state_ext) ⇒ 'β) ⇒      
                       ((('σ_ext) control_state_ext) ⇒ 'γ) ⇒      
                      ('ρ, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"call_3<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub> A<span class="hidden">⇩</span><sub>3</sub> = (λσ. if exec_stop σ then Some(undefined, σ) 
                                                   else M (A<span class="hidden">⇩</span><sub>1</sub> σ) (A<span class="hidden">⇩</span><sub>2</sub> σ) (A<span class="hidden">⇩</span><sub>3</sub> σ) σ)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* and 4 and 5 and ... *)</span></span></span></span></span><span>                        
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Some Term-Coding Functions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we add a number of advanced HOL-term constructors in the style of 
@{ML_structure "HOLogic"} from the Isabelle/HOL libraries. They incorporate the construction
of types during term construction in a bottom-up manner. Consequently, the leafs of such
terms should always be typed, and anonymous loose-@{ML "Bound"} variables avoided.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
(* HOLogic extended *)

fun mk_None ty = let val none = \&lt;^const_name&gt;‹Option.option.None›
                     val none_ty = ty --&gt; Type(\&lt;^type_name&gt;‹option›,[ty])
                in  Const(none, none_ty)
                end;

fun mk_Some t = let val some = \&lt;^const_name&gt;‹Option.option.Some› 
                    val ty = fastype_of t
                    val some_ty = ty --&gt; Type(\&lt;^type_name&gt;‹option›,[ty])
                in  Const(some, some_ty) $ t
                end;

fun dest_listTy (Type(\&lt;^type_name&gt;‹List.list›, [T])) = T;

fun mk_hdT t = let val ty = fastype_of t 
               in  Const(\&lt;^const_name&gt;‹List.hd›, ty --&gt; (dest_listTy ty)) $ t end

fun mk_tlT t = let val ty = fastype_of t 
               in  Const(\&lt;^const_name&gt;‹List.tl›, ty --&gt; ty) $ t end


fun  mk_undefined (@{typ "unit"}) = Const (\&lt;^const_name&gt;‹Product_Type.Unity›, \&lt;^typ&gt;‹unit›)
    |mk_undefined t               = Const (\&lt;^const_name&gt;‹HOL.undefined›, t)

fun meta_eq_const T = Const (\&lt;^const_name&gt;‹Pure.eq›, T --&gt; T --&gt; propT);

fun mk_meta_eq (t, u) = meta_eq_const (fastype_of t) $ t $ u;

fun   mk_pat_tupleabs [] t = t
    | mk_pat_tupleabs [(s,ty)] t = absfree(s,ty)(t)
    | mk_pat_tupleabs ((s,ty)::R) t = HOLogic.mk_case_prod(absfree(s,ty)(mk_pat_tupleabs R t));

fun read_constname ctxt n = fst(dest_Const(Syntax.read_term ctxt n))

fun wfrecT order recs = 
    let val funT = domain_type (fastype_of recs)
        val aTy  = domain_type funT
        val ordTy = HOLogic.mk_setT(HOLogic.mk_prodT (aTy,aTy))
    in Const(\&lt;^const_name&gt;‹Wfrec.wfrec›, ordTy --&gt; (funT --&gt; funT) --&gt; funT) $ order $ recs end


›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹And here comes the core of the ⬚‹Clean›-State-Management: the module that provides the 
functionality for the commands keywords ⬚‹global_vars›, ⬚‹local_vars›  and ⬚‹local_vars_test›.
Note that the difference between ⬚‹local_vars› and ⬚‹local_vars_test› is just a technical one:
⬚‹local_vars› can only be used inside a Clean function specification, made with the ⬚‹function_spec›
command. On the other hand, ⬚‹local_vars_test› is defined as a global Isar command for test purposes. 

A particular feature of the local-variable management is the provision of definitions for \&lt;^term&gt;‹push›
and \&lt;^term&gt;‹pop› operations --- encoded as \&lt;^typ&gt;‹('o, 'σ) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>› operations --- which are vital for
the function specifications defined below.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
structure StateMgt = 
struct

open StateMgt_core

val result_name = "result_value"

fun get_result_value_conf name thy = 
        let val  S = filter_attr_of name thy
        in  hd(filter (fn ((_,b),_) =&gt; b = result_name) S) 
            handle Empty =&gt; error "internal error: get_result_value_conf " end; 


fun mk_lookup_result_value_term name sty thy =
    let val ((prefix,name),local_var(Type("fun", [_,ty]))) = get_result_value_conf name thy;
        val long_name = Sign.intern_const thy (prefix^"."^name)
        val term = Const(long_name, sty --&gt; ty)
    in  mk_hdT (term $ Free("σ",sty)) end


fun  map_to_update sty is_pop thy ((struct_name, attr_name), local_var (Type("fun",[_,ty]))) term = 
       let val tlT = if is_pop then Const(\&lt;^const_name&gt;‹List.tl›, ty --&gt; ty)
                     else Const(\&lt;^const_name&gt;‹List.Cons›, dest_listTy ty --&gt; ty --&gt; ty)
                          $ mk_undefined (dest_listTy ty)
           val update_name = Sign.intern_const  thy (struct_name^"."^attr_name^"_update")
       in (Const(update_name, (ty --&gt; ty) --&gt; sty --&gt; sty) $ tlT) $ term end
   | map_to_update _ _ _ ((_, _),_) _ = error("internal error map_to_update")     

fun mk_local_state_name binding = 
       Binding.prefix_name "local_" (Binding.suffix_name "_state" binding)  
fun mk_global_state_name binding = 
       Binding.prefix_name "global_" (Binding.suffix_name "_state" binding)  

fun construct_update is_pop binding sty thy = 
       let val long_name = Binding.name_of( binding)
           val attrS = StateMgt_core.filter_attr_of long_name thy
       in  fold (map_to_update sty is_pop thy) (attrS) (Free("σ",sty)) end

fun cmd (decl, spec, prems, params) = #2 oo Specification.definition' decl params prems spec

fun mk_push_name binding = Binding.prefix_name "push_" binding

fun push_eq binding  name_op rty sty lthy = 
         let val mty = MON_SE_T rty sty 
             val thy = Proof_Context.theory_of lthy
             val term = construct_update false binding sty thy
         in  mk_meta_eq((Free(name_op, mty) $ Free("σ",sty)), 
                         mk_Some ( HOLogic.mk_prod (mk_undefined rty,term)))
                          
         end;

fun mk_push_def binding sty lthy =
    let val name_pushop =  mk_push_name binding
        val rty = \&lt;^typ&gt;‹unit›
        val eq = push_eq binding  (Binding.name_of name_pushop) rty sty lthy
        val mty = StateMgt_core.MON_SE_T rty sty 
        val args = (SOME(name_pushop, SOME mty, NoSyn), (Binding.empty_atts,eq),[],[])
    in cmd args true lthy  end;

fun mk_pop_name binding = Binding.prefix_name "pop_"  binding

fun pop_eq  binding name_op rty sty lthy = 
         let val mty = MON_SE_T rty sty 
             val thy = Proof_Context.theory_of lthy
             val res_access = mk_lookup_result_value_term (Binding.name_of binding) sty thy
             val term = construct_update true binding  sty thy                 
         in  mk_meta_eq((Free(name_op, mty) $ Free("σ",sty)), 
                         mk_Some ( HOLogic.mk_prod (res_access,term)))                          
         end;


fun mk_pop_def binding rty sty lthy = 
    let val mty = StateMgt_core.MON_SE_T rty sty 
        val name_op =  mk_pop_name binding
        val eq = pop_eq binding (Binding.name_of name_op) rty sty lthy
        val args = (SOME(name_op, SOME mty, NoSyn),(Binding.empty_atts,eq),[],[])
    in cmd args true lthy
    end;


fun read_parent NONE ctxt = (NONE, ctxt)
  | read_parent (SOME raw_T) ctxt =
       (case Proof_Context.read_typ_abbrev ctxt raw_T of
        Type (name, Ts) =&gt; (SOME (Ts, name), fold Variable.declare_typ Ts ctxt)
      | T =&gt; error ("Bad parent record specification: " ^ Syntax.string_of_typ ctxt T));


fun read_fields raw_fields ctxt =
  let
    val Ts = Syntax.read_typs ctxt (map (fn (_, raw_T, _) =&gt; raw_T) raw_fields);
    val fields = map2 (fn (x, _, mx) =&gt; fn T =&gt; (x, T, mx)) raw_fields Ts;
    val ctxt' = fold Variable.declare_typ Ts ctxt;
  in (fields, ctxt') end;

fun parse_typ_'a ctxt binding = 
  let val ty_bind =  Binding.prefix_name "'a " (Binding.suffix_name "_scheme" binding)
  in case Syntax.parse_typ ctxt (Binding.name_of ty_bind) of
       Type (s, _) =&gt; Type (s, [@{typ "'a::type"}])
     | _ =&gt; error ("Unexpected type" ^ Position.here ⌂)
  end

fun add_record_cmd0 read_fields overloaded is_global_kind raw_params binding raw_parent raw_fields thy =
  let
    val ctxt = Proof_Context.init_global thy;
    val params = map (apsnd (Typedecl.read_constraint ctxt)) raw_params;
    val ctxt1 = fold (Variable.declare_typ o TFree) params ctxt;
    val (parent, ctxt2) = read_parent raw_parent ctxt1;
    val (fields, ctxt3) = read_fields raw_fields ctxt2;
    fun lift (a,b,c) =  (a, HOLogic.listT b, c)
    val fields' = if is_global_kind then fields else map lift fields
    val params' = map (Proof_Context.check_tfree ctxt3) params;
    val declare = StateMgt_core.declare_state_variable_global
    fun upd_state_typ thy = let val ctxt = Proof_Context.init_global thy
                                val ty = Syntax.parse_typ ctxt (Binding.name_of binding)
                            in  StateMgt_core.upd_state_type_global(K ty)(thy) end
    fun insert_var ((f,_,_), thy) =           
            if is_global_kind   
            then declare StateMgt_core.global_var (Binding.name_of f) thy
            else declare StateMgt_core.local_var  (Binding.name_of f) thy
    fun define_push_pop thy = 
            if not is_global_kind 
            then let val sty = parse_typ_'a (Proof_Context.init_global thy) binding;
                     val rty = dest_listTy (#2(hd(rev fields')))
                 in thy

                    |&gt; Named_Target.theory_map (mk_push_def binding sty) 
                    |&gt; Named_Target.theory_map (mk_pop_def  binding rty sty) 
                                                            
                 end
            else thy
  in thy |&gt; Record.add_record overloaded (params', binding) parent fields' 
         |&gt; (fn thy =&gt;  List.foldr insert_var (thy) (fields'))
         |&gt; upd_state_typ
         |&gt; define_push_pop 
  end;



fun typ_2_string_raw (Type(s,[TFree _])) = if String.isSuffix "_scheme" s
                                            then Long_Name.base_name(unsuffix "_scheme" s)
                                            else Long_Name.base_name(unsuffix "_ext" s)
                                          
   |typ_2_string_raw (Type(s,_)) = 
                         error ("Illegal parameterized state type - not allowed in Clean:"  ^ s) 
   |typ_2_string_raw _ = error  "Illegal state type - not allowed in Clean." 
                                  
             
fun new_state_record0 add_record_cmd is_global_kind (((raw_params, binding), res_ty), raw_fields) thy =
    let val binding = if is_global_kind 
                      then mk_global_state_name binding
                      else mk_local_state_name binding
        val raw_parent = SOME(typ_2_string_raw (StateMgt_core.get_state_type_global thy))
        val pos = Binding.pos_of binding
        fun upd_state_typ thy =
          StateMgt_core.upd_state_type_global (K (parse_typ_'a (Proof_Context.init_global thy) binding)) thy
        val result_binding = Binding.make(result_name,pos)
        val raw_fields' = case res_ty of 
                            NONE =&gt; raw_fields
                          | SOME res_ty =&gt; raw_fields @ [(result_binding,res_ty, NoSyn)]
    in  thy |&gt; add_record_cmd {overloaded = false} is_global_kind 
                              raw_params binding raw_parent raw_fields' 
            |&gt; upd_state_typ 

    end

val add_record_cmd    = add_record_cmd0 read_fields;
val add_record_cmd'   = add_record_cmd0 pair;

val new_state_record  = new_state_record0 add_record_cmd
val new_state_record' = new_state_record0 add_record_cmd'

val _ =
  Outer_Syntax.command 
      \&lt;^command_keyword&gt;‹global_vars›   
      "define global state record"
      ((Parse.type_args_constrained -- Parse.binding)
    -- Scan.succeed NONE
    -- Scan.repeat1 Parse.const_binding
    &gt;&gt; (Toplevel.theory o new_state_record true));
;

val _ =
  Outer_Syntax.command 
      \&lt;^command_keyword&gt;‹local_vars_test›  
      "define local state record"
      ((Parse.type_args_constrained -- Parse.binding) 
    -- (Parse.typ &gt;&gt; SOME)
    -- Scan.repeat1 Parse.const_binding
    &gt;&gt; (Toplevel.theory o new_state_record false))
;
end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Syntactic Sugar supporting ‹λ›-lifting for Global and Local Variables ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure Clean_Syntax_Lift =
struct
  local
    fun mk_local_access X = Const (@{const_name "Fun.comp"}, dummyT) 
                            $ Const (@{const_name "List.list.hd"}, dummyT) $ X
  in
    fun app_sigma db tm ctxt = case tm of
        Const(name, _) =&gt; if StateMgt_core.is_global_program_variable name (Proof_Context.theory_of ctxt) 
                          then tm $ (Bound db) (* lambda lifting *)
                          else if StateMgt_core.is_local_program_variable name (Proof_Context.theory_of ctxt) 
                               then (mk_local_access tm) $ (Bound db) (* lambda lifting local *)
                               else tm              (* no lifting *)
      | Free _ =&gt; tm
      | Var _ =&gt; tm
      | Bound n =&gt; if n &gt; db then Bound(n + 1) else Bound n 
      | Abs (x, ty, tm') =&gt; Abs(x, ty, app_sigma (db+1) tm' ctxt)
      | t1 $ t2 =&gt; (app_sigma db t1 ctxt) $ (app_sigma db t2 ctxt)

    fun scope_var name =
      Proof_Context.theory_of
      #&gt; (fn thy =&gt;
            if StateMgt_core.is_global_program_variable name thy then SOME true
            else if StateMgt_core.is_local_program_variable name thy then SOME false
            else NONE)

    fun assign_update var = var ^ Record.updateN

    fun transform_term0 abs scope_var tm =
      case tm of
         Const (@{const_name "Clean.syntax_assign"}, _)
         $ (t1 as Const ("_type_constraint_", _) $ Const (name, ty))
         $ t2 =&gt;
            Const ( case scope_var name of
                      SOME true =&gt; @{const_name "assign_global"}
                    | SOME false =&gt; @{const_name "assign_local"}
                    | NONE =&gt; raise TERM ("mk_assign", [t1])
                  , dummyT)
            $ Const(assign_update name, ty)
            $ abs t2
       | _ =&gt; abs tm

    fun transform_term ctxt sty =
      transform_term0
        (fn tm =&gt; Abs ("σ", sty, app_sigma 0 tm ctxt))
        (fn name =&gt; scope_var name ctxt)

    fun transform_term' ctxt = transform_term ctxt dummyT

    fun string_tr ctxt content args =
      let fun err () = raise TERM ("string_tr", args)
      in
        (case args of
          [(Const (@{syntax_const "_constrain"}, _)) $ (Free (s, _)) $ p] =&gt;
            (case Term_Position.decode_position p of
              SOME (pos, _) =&gt; Symbol_Pos.implode (content (s, pos))
                            |&gt; Syntax.parse_term ctxt
                            |&gt; transform_term ctxt (StateMgt_core.get_state_type ctxt)
                            |&gt; Syntax.check_term ctxt
            | NONE =&gt; err ())
        | _ =&gt; err ())
      end
  end
end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_cartouche_string"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"cartouche_position ⇒ string"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  [(@{syntax_const "_cartouche_string"},
    (fn ctxt =&gt; Clean_Syntax_Lift.string_tr ctxt (Symbol_Pos.cartouche_content o Symbol_Pos.explode)))]
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Support for (direct recursive) Clean Function Specifications ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Based on the machinery for the State-Management and  implicitly cooperating with the 
cartouches for assignment syntax, the function-specification ⬚‹function_spec›-package coordinates:
▸ the parsing and type-checking of parameters,
▸ the parsing and type-checking of pre and post conditions in MOAL notation
  (using ‹λ›-lifting cartouches and implicit reference to parameters, pre and post states),
▸ the parsing local variable section with the local-variable space generation,
▸ the parsing of the body in this extended variable space,
▸ and optionally the support of measures for recursion proofs.

The reader interested in details is referred to the 🗏‹../examples/Quicksort_concept.thy›-example,
accompanying this distribution.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>old</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"old x = x"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ 
structure Function_Specification_Parser  = 
  struct

    type funct_spec_src = {    
        binding:  binding,                         (* name *)
        params: (binding*string) list,             (* parameters and their type*)
        ret_type: string,                          (* return type; default unit *)
        locals: (binding*string*mixfix)list,       (* local variables *)
        pre_src: string,                           (* precondition src *)
        post_src: string,                          (* postcondition src *)
        variant_src: string option,                       (* variant src *)
        body_src: string * Position.T              (* body src *)
      }

    type funct_spec_sem = {    
        params: (binding*typ) list,                (* parameters and their type*)
        ret_ty: typ,                               (* return type *)
        pre: term,                                 (* precondition  *)
        post: term,                                (* postcondition  *)
        variant: term option                       (* variant  *)
      }


    val parse_arg_decl = Parse.binding -- (Parse.$$$ "::" |-- Parse.typ)

    val parse_param_decls = Args.parens (Parse.enum "," parse_arg_decl)
      
    val parse_returns_clause = Scan.optional (\&lt;^keyword&gt;‹returns› |--  Parse.typ) "unit"
 
    val locals_clause = (Scan.optional ( \&lt;^keyword&gt;‹local_vars› 
                                        -- (Scan.repeat1 Parse.const_binding)) ("", []))
    
    val parse_proc_spec = (
          Parse.binding 
       -- parse_param_decls
       -- parse_returns_clause
       --| \&lt;^keyword&gt;‹pre›             -- Parse.term 
       --| \&lt;^keyword&gt;‹post›            -- Parse.term 
       -- (Scan.option  ( \&lt;^keyword&gt;‹variant› |-- Parse.term))
       -- (Scan.optional( \&lt;^keyword&gt;‹local_vars› |-- (Scan.repeat1 Parse.const_binding))([]))
       --| \&lt;^keyword&gt;‹defines›         -- (Parse.position (Parse.term)) 
      ) &gt;&gt; (fn ((((((((binding,params),ret_ty),pre_src),post_src),variant_src),locals)),body_src) =&gt; 
        {
          binding = binding, 
          params=params, 
          ret_type=ret_ty, 
          pre_src=pre_src, 
          post_src=post_src, 
          variant_src=variant_src,
          locals=locals,
          body_src=body_src} : funct_spec_src
        )

   fun read_params params ctxt =
     let
       val Ts = Syntax.read_typs ctxt (map snd params);
     in (Ts, fold Variable.declare_typ Ts ctxt) end;
   
   fun read_result ret_ty ctxt = 
          let val [ty] = Syntax.read_typs ctxt [ret_ty]
              val ctxt' = Variable.declare_typ ty ctxt           
          in  (ty, ctxt') end

   fun read_function_spec ({ params, ret_type, variant_src, ...} : funct_spec_src) ctxt =
       let val (params_Ts, ctxt') = read_params params ctxt
           val (rty, ctxt'') = read_result ret_type ctxt' 
           val variant = Option.map (Syntax.read_term ctxt'')  variant_src
       in ({params = (params, params_Ts), ret_ty = rty,variant = variant},ctxt'') end 


   fun check_absence_old term = 
            let fun test (s,ty) = if s = @{const_name "old"} andalso fst (dest_Type ty) = "fun"
                                  then error("the old notation is not allowed here!")  
                                  else false
            in  exists_Const test term end
   
   fun transform_old sty term = 
       let fun  transform_old0 (Const(@{const_name "old"}, Type ("fun", [_,_])) $ term ) 
                              = (case term of
                                  (Const(s,ty) $ Bound x) =&gt;  (Const(s,ty) $ Bound (x+1))
                                | _ =&gt; error("illegal application of the old notation."))
               |transform_old0 (t1 $ t2) = transform_old0 t1 $ transform_old0 t2
               |transform_old0 (Abs(s,ty,term)) = Abs(s,ty,transform_old0 term) 
               |transform_old0 term = term
       in  Abs("σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>", sty, transform_old0 term) end
   
   fun define_cond binding f_sty transform_old src_suff check_absence_old params src ctxt = 
       let val src' = case transform_old (Syntax.read_term ctxt src) of 
                        Abs(nn, sty_pre, term) =&gt; mk_pat_tupleabs (map (apsnd #2) params) (Abs(nn,sty_pre(* sty root ! !*),term))
                      | _ =&gt; error ("define abstraction for result" ^ Position.here ⌂)
           val bdg = Binding.suffix_name src_suff binding
           val _ = check_absence_old src'
           val eq =  mk_meta_eq(Free(Binding.name_of bdg, HOLogic.mk_tupleT(map (#2 o #2) params) --&gt; f_sty HOLogic.boolT),src')
           val args = (SOME(bdg,NONE,NoSyn), (Binding.empty_atts,eq),[],[]) 
       in  StateMgt.cmd args true ctxt end

   fun define_precond binding sty =
     define_cond binding (fn boolT =&gt; sty --&gt; boolT) I "_pre" check_absence_old

   fun define_postcond binding rty sty =
     define_cond binding (fn boolT =&gt; sty --&gt; sty --&gt; rty --&gt; boolT) (transform_old sty) "_post" I

   fun define_body_core binding args_ty sty params body =
       let val bdg_core = Binding.suffix_name "_core" binding
           val bdg_core_name = Binding.name_of bdg_core

           val umty = args_ty --&gt; StateMgt.MON_SE_T @{typ "unit"} sty

           val eq = mk_meta_eq(Free (bdg_core_name, umty),mk_pat_tupleabs(map(apsnd #2)params) body)
           val args_core =(SOME (bdg_core, SOME umty, NoSyn), (Binding.empty_atts, eq), [], [])

       in StateMgt.cmd args_core true
       end 
 
   fun define_body_main {recursive = x:bool} binding rty sty params variant_src _ ctxt = 
       let val push_name = StateMgt.mk_push_name (StateMgt.mk_local_state_name binding)
           val pop_name = StateMgt.mk_pop_name (StateMgt.mk_local_state_name binding)
           val bdg_core = Binding.suffix_name "_core" binding
           val bdg_core_name = Binding.name_of bdg_core
           val bdg_rec_name = Binding.name_of(Binding.suffix_name "_rec" binding)
           val bdg_ord_name = Binding.name_of(Binding.suffix_name "_order" binding)

           val args_ty = HOLogic.mk_tupleT (map (#2 o #2) params)
           val params' = map (apsnd #2) params
           val rmty = StateMgt_core.MON_SE_T rty sty 

           val umty = StateMgt.MON_SE_T @{typ "unit"} sty
           val argsProdT = HOLogic.mk_prodT(args_ty,args_ty)
           val argsRelSet = HOLogic.mk_setT argsProdT
           val measure_term = case variant_src of
                                 NONE =&gt; Free(bdg_ord_name,args_ty --&gt; HOLogic.natT)
                               | SOME str =&gt; (Syntax.read_term ctxt str |&gt; mk_pat_tupleabs params')
           val measure =  Const(@{const_name "Wellfounded.measure"}, (args_ty --&gt; HOLogic.natT)
                                                                     --&gt; argsRelSet )
                          $ measure_term
           val lhs_main = if x andalso is_none variant_src
                          then Free(Binding.name_of binding, (args_ty --&gt; HOLogic.natT)
                                                                       --&gt; args_ty --&gt; rmty) $
                                         Free(bdg_ord_name, args_ty --&gt; HOLogic.natT)
                          else Free(Binding.name_of binding, args_ty --&gt; rmty)
           val rhs_main = mk_pat_tupleabs params'
                          (Const(@{const_name "Clean.block<span class="hidden">⇩</span><sub>C</sub>"}, umty --&gt; umty  --&gt; rmty --&gt; rmty)
                          $ Const(read_constname ctxt (Binding.name_of push_name),umty)
                          $ (Const(read_constname ctxt bdg_core_name, args_ty --&gt; umty)  
                             $ HOLogic.mk_tuple (map Free params'))
                          $ Const(read_constname ctxt (Binding.name_of pop_name),rmty))
           val rhs_main_rec = wfrecT 
                              measure 
                              (Abs(bdg_rec_name, (args_ty --&gt; umty) , 
                                   mk_pat_tupleabs params'
                                   (Const(@{const_name "Clean.block<span class="hidden">⇩</span><sub>C</sub>"}, umty--&gt;umty--&gt;rmty--&gt;rmty)
                                   $ Const(read_constname ctxt (Binding.name_of push_name),umty)
                                   $ (Const(read_constname ctxt bdg_core_name,
                                            (args_ty --&gt; umty) --&gt; args_ty --&gt; umty)  
                                      $ (Bound (length params))
                                      $ HOLogic.mk_tuple (map Free params'))
                                   $ Const(read_constname ctxt (Binding.name_of pop_name),rmty))))
           val eq_main = mk_meta_eq(lhs_main, if x then rhs_main_rec else rhs_main )
           val args_main = (SOME(binding,NONE,NoSyn), (Binding.empty_atts,eq_main),[],[]) 
       in  ctxt |&gt; StateMgt.cmd args_main true 
       end 


   fun checkNsem_function_spec {recursive = false} ({variant_src=SOME _, ...}) _ = 
                               error "No measure required in non-recursive call"
      |checkNsem_function_spec (isrec as {recursive = _:bool}) 
                               (args as {binding, ret_type, variant_src, locals, body_src, pre_src, post_src, ...} : funct_spec_src)
                               thy =
       let val (theory_map, thy') =
             Named_Target.theory_map_result
               (K (fn f =&gt; Named_Target.theory_map o f))
               (read_function_spec args
               #&gt; uncurry (fn {params=(params, Ts),ret_ty,variant = _} =&gt;
                            pair (fn f =&gt;
                                  Proof_Context.add_fixes (map2 (fn (b, _) =&gt; fn T =&gt; (b, SOME T, NoSyn)) params Ts)
                                    (* this declares the parameters of a function specification
                                       as Free variables (overrides a possible constant declaration)
                                       and assigns the declared type to them *)
                                  #&gt; uncurry (fn params' =&gt; f (@{map 3} (fn b' =&gt; fn (b, _) =&gt; fn T =&gt; (b',(b,T))) params' params Ts) ret_ty))))
                thy
       in  thy' |&gt; theory_map
                     let val sty_old = StateMgt_core.get_state_type_global thy'
                     in fn params =&gt; fn ret_ty =&gt;
                         define_precond binding sty_old params pre_src
                      #&gt; define_postcond binding ret_ty sty_old params post_src end
                |&gt; StateMgt.new_state_record false ((([],binding), SOME ret_type),locals)
                |&gt; theory_map
                         (fn params =&gt; fn ret_ty =&gt; fn ctxt =&gt; 
                          let val sty = StateMgt_core.get_state_type ctxt
                              val args_ty = HOLogic.mk_tupleT (map (#2 o #2) params)
                              val mon_se_ty = StateMgt_core.MON_SE_T ret_ty sty
                              val ctxt' =
                                if #recursive isrec then
                                  Proof_Context.add_fixes 
                                    [(binding, SOME (args_ty --&gt; mon_se_ty), NoSyn)] ctxt |&gt; #2
                                else
                                  ctxt
                              val body = Syntax.read_term ctxt' (fst body_src)
                          in  ctxt' |&gt; define_body_core binding args_ty sty params body
                          end)
                |&gt; theory_map
                         (fn params =&gt; fn ret_ty =&gt; fn ctxt =&gt; 
                          let val sty = StateMgt_core.get_state_type ctxt
                              val body = Syntax.read_term ctxt (fst body_src)
                          in  ctxt |&gt; define_body_main isrec binding ret_ty sty params variant_src body
                          end)
        end

  
   val _ =
     Outer_Syntax.command 
         \&lt;^command_keyword&gt;‹function_spec›   
         "define Clean function specification"
         (parse_proc_spec &gt;&gt; (Toplevel.theory o checkNsem_function_spec {recursive = false}));
   
   val _ =
     Outer_Syntax.command 
         \&lt;^command_keyword&gt;‹rec_function_spec›   
         "define recursive Clean function specification"
         (parse_proc_spec &gt;&gt; (Toplevel.theory o checkNsem_function_spec {recursive = true}));
       
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Rest of Clean: Break/Return aware Version of If, While, etc.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('σ_ext) control_state_ext ⇒ bool, 
                      ('β, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>, 
                      ('β, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('β, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"if_C c E F = (λσ. if exec_stop σ 
                              then Some(undefined, σ)  ― ‹state unchanged, return arbitrary›
                              else if c σ then E σ else F σ)"</span></span></span><span>     
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>    </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"_if_SECLEAN"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool,('o,'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>,('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ ('o','σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>C</sub> _ then _ else _fi)"</span></span></span><span> </span><span class="delimiter">[</span><span>5</span><span class="delimiter">,</span><span>8</span><span class="delimiter">,</span><span>8</span><span class="delimiter">]</span><span>8</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(if<span class="hidden">⇩</span><sub>C</sub> cond then T1 else T2 fi)"</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST Clean.if_C cond T1 T2"</span></span></span><span>
</span><span>
</span><span>          
</span><span>          
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('σ_ext) control_state_ext ⇒ bool) 
                        ⇒ (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> 
                        ⇒ (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"while_C c B ≡ (λσ. if exec_stop σ then Some((), σ)
                               else ((MonadSE.while_SE (λ σ. ¬exec_stop σ ∧ c σ) B) ;- 
                                     unset_break_status) σ)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">syntax</span></span><span>    </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"_while_C"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['σ ⇒ bool, (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>] ⇒ (unit, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span> 
</span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(while<span class="hidden">⇩</span><sub>C</sub> _ do _ od)"</span></span></span><span> </span><span class="delimiter">[</span><span>8</span><span class="delimiter">,</span><span>8</span><span class="delimiter">]</span><span>8</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"while<span class="hidden">⇩</span><sub>C</sub> c do b od"</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST Clean.while_C c b"</span></span></span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  
</span><span>  </span></pre>
</div>
</div><div id="Hoare_MonadSE">
<div class="head"><h1>Theory Hoare_MonadSE</h1>
<span class="command">theory</span> <span class="name">Hoare_MonadSE</span><br/>
<span class="keyword">imports</span> <a href="Symbex_MonadSE.html"><span class="name">Symbex_MonadSE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Basic Hoare Calculus for the State Exception Monad 
 *
 * Authors : Burkhart Wolff
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hoare_MonadSE</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Symbex_MonadSE</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Hoare›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('α ⇒ 'σ ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⦃(1_)⦄/ (_)/ ⦃(1_)⦄)"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M ⦃Q⦄ ≡ (∀σ. P σ ⟶ (case M σ of None =&gt; False | Some(x, σ') =&gt; Q x σ'))"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⦃(1_)⦄/ (_)/†)"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M † ≡ (∀σ. P σ ⟶ (case M σ of None =&gt; True | _ =&gt; False))"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic rules›</span></span></span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⦃P⦄ skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⦃λ_. P⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> †"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>fail_SE_def</span><span> </span><span>unit_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ⦃λ _ _. True⦄"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>assert_SE_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_conseq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect P ⊆ Collect Q ⟹ ⦃P⦄ assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> Q ⦃λ _ _. True⦄"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>assert_SE_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assume_conseq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ σ. Q σ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> Q ⦃λ _ . Q⦄"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>assume_SE_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span class="delimiter">:</span><span> </span><span>someI2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹assignment missing in the calculus because this is viewed as a state specific  
       operation, definable for concrete instances of @{typ "'σ"}.›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generalized and special sequence rules›</span></span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The decisive idea is to factor out the post-condition on the results of @{term M} :›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    ⦃P⦄ M ⦃λx σ. x∈A ∧ Q x σ⦄
   ⟹ ∀x∈A. ⦃Q x⦄ M' x ⦃R⦄ 
   ⟹ ⦃P⦄ x ← M; M' x ⦃R⦄"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_irpt_l</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M †  ⟹ ⦃P⦄ x ← M; M' x †"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_irpt_r</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M ⦃λx σ. x∈A ∧ Q x σ⦄ ⟹ ∀x∈A. ⦃Q x⦄ M' x †  ⟹ ⦃P⦄ x ← M; M' x †"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>        
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M ⦃λ_. Q ⦄ ⟹ ⦃Q⦄ M' ⦃R⦄ ⟹ ⦃P⦄ M;- M' ⦃R⦄"</span></span></span><span>     
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>bind_SE_def</span><span> </span><span>bind_SE'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_irpt_l'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M † ⟹ ⦃P⦄ M;- M' †"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>bind_SE'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_irpt_r'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M ⦃λ_. Q ⦄ ⟹ ⦃Q⦄ M' † ⟹ ⦃P⦄ M;- M' †"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>bind_SE_def</span><span> </span><span>bind_SE'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Generalized and special consequence rules›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consequence</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    Collect P ⊆ Collect P'
   ⟹ ⦃P'⦄ M ⦃λx σ. x∈A ∧ Q' x σ⦄ 
   ⟹ ∀ x∈A. Collect(Q' x) ⊆ Collect (Q x)
   ⟹ ⦃P⦄ M ⦃λx σ. x∈A ∧ Q x σ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.option.split_asm</span><span> </span><span>Option.option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consequence_unit</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ σ. P σ ⟶ P' σ)"</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃P'⦄ M ⦃λx::unit. λ σ.  Q' σ⦄"</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">" (⋀ σ. Q'  σ ⟶ Q  σ)"</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ M ⦃λx σ. Q σ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx σ. Q  σ) = (λx::unit. λ σ. x∈UNIV ∧ Q  σ) "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span>  </span><span>P'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"P'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"%_. Q'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>consequence</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_mono</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_mono</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consequence_irpt</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    Collect P ⊆ Collect P'
   ⟹ ⦃P'⦄ M †
   ⟹ ⦃P⦄  M †"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consequence_mt_swap</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃λ_. False⦄ M †) = (⦃λ_. False⦄ M ⦃P⦄)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Condition rules›</span></span></span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    ⦃λσ. P σ ∧ cond σ⦄ M ⦃Q⦄
   ⟹ ⦃λσ. P σ ∧ ¬ cond σ⦄ M' ⦃Q⦄  
   ⟹ ⦃P⦄if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond then M else M' fi⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_irpt</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    ⦃λσ. P σ ∧ cond σ⦄ M †
   ⟹ ⦃λσ. P σ ∧ ¬ cond σ⦄ M' †  
   ⟹ ⦃P⦄if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond then M else M' fi †"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Note that the other four combinations can be directly derived via
       the @{thm consequence_mt_swap} rule.›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹While rules›</span></span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The only non-trivial proof is, of course, the while loop rule. Note
that non-terminating loops were mapped to @{term None} following the principle
that our monadic state-transformers represent partial functions in the mathematical 
sense.›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. cond σ ∧ P σ⦄  M ⦃λ_. P⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>measure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. cond σ ∧ P σ ⟶ M σ ≠ None ∧ f(snd(the(M σ))) &lt; ((f σ)::nat) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>        </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od ⦃λ_ σ. ¬cond σ ∧ P σ⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. ∀ σ. P σ ∧ f σ ≤ n ⟶  
                     (case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ of 
                          None ⇒ False
                        | Some (x, σ') ⇒ ¬ cond σ' ∧ P σ')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. ?P n"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P 0"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>gr_implies_not0</span><span> </span><span>if_SE_def</span><span>  </span><span>measure</span><span> </span><span>option.case_eq_if</span><span> 
</span><span>                     </span><span>option.sel</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ?P n ⟹ ?P (Suc n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>subst</span><span> </span><span>while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬cond σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"M σ = None"</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>measure</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span>σ'</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cond σ"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M σ = Some ((), σ')"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>3</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" P σ"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>4</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" f σ ≤ Suc n"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>hyp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?P n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ'"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>*</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>case_prodD</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>6</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(the(M σ)) = σ'"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>7</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cond σ' ⟹ f σ' ≤ n"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>6</span><span> </span><span>leD</span><span> </span><span>measure</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ' of None ⇒ False
                                                  | Some (xa, σ') ⇒ ¬ cond σ' ∧ P σ'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span> </span><span>6</span><span> </span><span>hyp</span><span> </span><span>measure</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ. P σ ⟹
         case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ of None ⇒ False
         | Some (x, σ') ⇒ ¬ cond σ' ∧ P σ'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_irpt</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. cond σ ∧ P σ⦄  M ⦃λ_. P⦄ ∨ ⦃λσ. cond σ ∧ P σ⦄  M  †"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>measure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. cond σ ∧ P σ ⟶ M σ = None ∨ f(snd(the(M σ))) &lt; ((f σ)::nat)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. P σ ⟶ cond σ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>        </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od †"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. ∀ σ. P σ ∧ f σ ≤ n ⟶  
                     (case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ of None ⇒ True | Some a ⇒ False)"</span></span></span><span> 
</span><span>            </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. ?P n "</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ. P σ ⟹ cond σ"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enabled</span><span> </span><span>*</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P 0 "</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>frule</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>gr_implies_not0</span><span> </span><span>if_SE_def</span><span> </span><span>option.case</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                           </span><span>option.case_eq_if</span><span>  </span><span>while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span>n</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?P n"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ. P σ ⟹ cond σ"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enabled</span><span> </span><span>*</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P (Suc n) "</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>frule</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_SE_unfold</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>if_SE_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>*</span><span class="delimiter">,</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"f σ ≤ Suc n"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"cond σ"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>**</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. cond σ ∧ P σ ⟶ (case M σ of None ⇒ False | Some (x, σ') ⇒ P σ')"</span></span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case M σ of None ⇒ False | Some (x, σ') ⇒ P σ')"</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"**"</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P σ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cond σ›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case (M ;- (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od)) σ of None ⇒ True | Some a ⇒ False"</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"M σ"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>σ'</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>               </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ'</span><span> 
</span><span>               </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ'"</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M σ = Some ((), σ')"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cond σ'"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P σ'›</span></span></span><span> </span><span>enabled</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f σ' ≤ n"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹M σ = Some ((), σ')›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P σ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cond σ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f σ ≤ Suc n›</span></span></span><span> </span><span>measure</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span>               </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ' of None ⇒ True | Some a ⇒ False"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P σ'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f σ' ≤ n›</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P σ"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"f σ ≤ Suc n"</span></span></span><span>
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"cond σ"</span></span></span><span>  
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. cond σ ∧ P σ ⟶ (case M σ of None ⇒ True | Some a ⇒ False)"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>**</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case M σ of None ⇒ True | Some a ⇒ False)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P σ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cond σ›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M σ = None"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"**"</span></span></span><span> </span><span>option.disc_eq_case</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case (M ;- (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od)) σ of None ⇒ True | Some a ⇒ False"</span></span></span><span>          
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹M σ = None›</span></span></span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ. P σ ⟹ case (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> cond do M od) σ of None ⇒ True | Some a ⇒ False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Experimental Alternative Definitions (Transformer-Style Rely-Guarantee)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>  </span><span>hoare<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('α ⇒ 'σ ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊢<span class="hidden">⇩</span><sub>1</sub> ({(1_)}/ (_)/ {(1_)})"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⊢<span class="hidden">⇩</span><sub>1</sub>{P} M {Q} ) = (∀σ. σ ⊨ (_  ← assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P ; x  ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (Q x)))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Problem: Severe Deviation for the case of an unsatisfyabke precondition *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>  </span><span>hoare<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ bool) ⇒ ('α, 'σ)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ⇒ ('α ⇒ 'σ ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊢<span class="hidden">⇩</span><sub>2</sub> ({(1_)}/ (_)/ {(1_)})"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⊢<span class="hidden">⇩</span><sub>2</sub>{P} M {Q} ) = (∀σ. P σ ⟶ (σ ⊨  (x ← M; assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (Q x))))"</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span></pre>
</div>
</div><div id="Hoare_Clean">
<div class="head"><h1>Theory Hoare_Clean</h1>
<span class="command">theory</span> <span class="name">Hoare_Clean</span><br/>
<span class="keyword">imports</span> <a href="Hoare_MonadSE.html"><span class="name">Hoare_MonadSE</span></a> <a href="Clean.html"><span class="name">Clean</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * A Hoare Calculus for Clean
 *
 * Authors : Burkhart Wolff
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hoare_Clean</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Hoare_MonadSE</span><span>
</span><span>          </span><span>Clean</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Control Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>break1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  P (σ ⦇ break_status := True ⦈) ⦄ break ⦃λr σ.  P σ ∧ break_status σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>break_def</span><span> </span><span>unit_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unset_break1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  P (σ ⦇ break_status := False ⦈) ⦄ unset_break_status ⦃λr σ. P σ ∧ ¬ break_status σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>unset_break_status_def</span><span> </span><span>unit_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_return1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  P (σ ⦇ return_status := True ⦈) ⦄ set_return_status ⦃λr σ. P σ ∧ return_status σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>set_return_status_def</span><span> </span><span>unit_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unset_return1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  P (σ ⦇ return_status := False ⦈) ⦄ unset_return_status ⦃λr σ. P σ ∧ ¬return_status σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>unset_return_status_def</span><span> </span><span>unit_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Skip Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_global_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ ⦄  assign_global upd rhs  ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assign_global_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_local_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ ⦄ assign_local upd rhs  ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assign_local_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  exec_stop σ ∧ P σ ⦄ return<span class="hidden">⇩</span><sub>C</sub> upd rhs ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>return<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>assign_local_def</span><span> </span><span>assign_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_clean_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ ⦄  assign tr  ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assign_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_clean_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ ⦄  if<span class="hidden">⇩</span><sub>C</sub> C then E else F fi ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_C_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_clean_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ ⦄  while<span class="hidden">⇩</span><sub>C</sub> cond do body od  ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>while_C_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_opcall_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   exec_stop σ ∧ P σ⦄ (call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>) ⦃λr σ. exec_stop σ ∧ P σ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_funcall_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ. exec_stop σ ∧ P σ⦄(p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub> ← call<span class="hidden">⇩</span><sub>C</sub> fun E ; assign_local upd (λσ. p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub>)) ⦃λr σ. exec_stop σ ∧ P σ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>assign_local_def</span><span> </span><span>assign_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_funcall_skip'</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⦃λσ. exec_stop σ ∧ P σ ⦄(p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub> ← call<span class="hidden">⇩</span><sub>C</sub> fun E ; assign_global upd (λσ. p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub>)) ⦃λr σ. exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>assign_global_def</span><span> </span><span>assign_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Assign Rules›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_global</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ upd"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬exec_stop σ ∧ P (upd (λ_. rhs σ) σ) ⦄ 
         assign_global upd rhs 
         ⦃λr σ. ¬exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>assign_global_def</span><span>  </span><span>assign_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_local</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ (upd ∘ map_hd)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.  ¬ exec_stop σ ∧ P ((upd ∘ map_hd) (λ_. rhs σ) σ) ⦄  
          assign_local upd rhs  
         ⦃λr σ. ¬ exec_stop σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>    </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>assign_local_def</span><span>  </span><span>assign_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>exec_stop_vs_control_independence</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_assign</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ (upd ∘ map_hd)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λ σ. ¬ exec_stop σ ∧ P ((upd ∘ map_hd) (λ_. rhs σ) (σ ⦇ return_status := True ⦈))⦄ 
          return<span class="hidden">⇩</span><sub>C</sub> upd rhs
         ⦃λr σ. P σ ∧ return_status σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>return<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>assign_local_def</span><span> </span><span>assign_def</span><span> 
</span><span>            </span><span>set_return_status_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b control_state_scheme"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (upd (map_hd (λ_. rhs σ)) (σ⦇return_status := True⦈))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (upd (map_hd (λ_. rhs σ)) σ⦇return_status := True⦈)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>assms</span><span> </span><span>exec_stop_vs_control_independence'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* do we need independence of rhs ? Not really. 'Normal' programs would never
     be control-state dependent, and 'artificial' ones would still be correct ...*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Construct Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_clean</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"    ⦃λσ. ¬ exec_stop σ ∧ P σ ∧ cond σ⦄ M ⦃Q⦄
   ⟹ ⦃λσ. ¬ exec_stop σ ∧ P σ ∧ ¬ cond σ⦄ M' ⦃Q⦄  
   ⟹ ⦃λσ. ¬ exec_stop σ ∧ P σ⦄ if<span class="hidden">⇩</span><sub>C</sub> cond then M else M' fi⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>if_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_C_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹There is a particular difficulty with a verification of (terminating) while rules
in a Hoare-logic for a language involving break. The first is, that break is not used
in the toplevel of a body of a loop (there might be breaks inside an inner loop, though).
This scheme is covered by the rule below, which is a generalisation of the classical 
while loop (as presented by @{thm while}.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_clean_no_break</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ break_status σ ∧ cond σ ∧ P σ⦄  M ⦃λ_. λσ.  ¬ break_status σ ∧ P σ ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>measure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. ¬ exec_stop σ ∧ cond σ ∧ P σ 
                    ⟶ M σ ≠ None ∧ f(snd(the(M σ))) &lt; ((f σ)::nat) "</span></span></span><span>
</span><span>               </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. _ ∧ cond σ ∧ P σ ⟶ ?decrease σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>        </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ exec_stop σ ∧ P σ⦄ 
                while<span class="hidden">⇩</span><sub>C</sub> cond do M od 
                ⦃λ_ σ. (return_status σ ∨ ¬ cond σ) ∧ ¬ break_status σ ∧ P σ⦄"</span></span></span><span>
</span><span>                </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃?pre⦄ while<span class="hidden">⇩</span><sub>C</sub> cond do M od ⦃λ_ σ. ?post1 σ ∧ ?post2 σ⦄"</span></span></span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_C_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span> </span><span>sequence'</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃?pre⦄ 
          while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. ¬ exec_stop σ ∧ cond σ) do M od
          ⦃λ_ σ. ¬ (¬ exec_stop σ ∧ cond σ) ∧ ¬ break_status σ ∧ P σ⦄"</span></span></span><span>
</span><span>          </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃?pre⦄ while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ?cond' do M od ⦃λ_ σ. ¬ ( ?cond' σ) ∧ ?post2 σ⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>consequence_unit</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ?pre σ ⟶ ?post2 σ"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exec_stop1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃?post2⦄while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ?cond' do M od⦃λx σ. ¬(?cond' σ) ∧ ?post2 σ⦄"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>while</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>consequence_unit</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?cond' σ ∧ ?post2 σ ⟶ ¬break_status σ ∧ cond σ ∧ P σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>         </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ break_status σ ∧ cond σ ∧ P σ⦄ M ⦃λx σ. ?post2 σ⦄"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>           </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?post2 σ ⟶ ?post2 σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>           </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ.?cond' σ ∧ ?post2 σ ⟶ ?decrease σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>measure</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬?cond' σ ∧ ?post2 σ ⟶ ¬?cond' σ ∧ ?post2 σ"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ (¬ exec_stop σ ∧ cond σ) ∧ ?post2 σ⦄ unset_break_status
          ⦃λ_ σ'. (return_status σ' ∨ ¬ cond σ') ∧ ?post2 σ'⦄"</span></span></span><span>
</span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ (?cond'' σ) ∧ ?post2 σ⦄ unset_break_status ⦃λ_ σ'. ?post3 σ' ∧ ?post2 σ' ⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>consequence_unit</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>  
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?cond'' σ ∧ ?post2 σ ⟶ (λσ. P σ ∧ ?post3 σ) (σ⦇break_status := False⦈)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>exec_stop_def</span><span> </span><span>surjective</span><span> </span><span>update_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. (λσ. P σ ∧ ?post3 σ) (σ⦇break_status := False⦈)⦄
              unset_break_status 
              ⦃λx σ. ?post3 σ ∧ ¬ break_status σ ∧ P σ⦄"</span></span></span><span>    
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conj_commute</span><span class="delimiter">,</span><span>subst</span><span> </span><span>conj_assoc</span><span class="delimiter">,</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conj_commute</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unset_break1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>         </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"?post3 σ ∧ ?post2 σ ⟶ ?post3 σ ∧ ?post2 σ"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the following we present a version allowing a break inside the body, which implies that the 
     invariant has been established at the break-point and the condition is irrelevant. 
     A return may occur, but the @{term "break_status"} is guaranteed to be true
     after leaving the loop.›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_clean'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span>M_inv</span><span>   </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ exec_stop σ ∧ cond σ ∧ P σ⦄  M ⦃λ_. P⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cond_idpc</span><span>    </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x σ.  (cond (σ⦇break_status := x⦈)) = cond σ "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv_idpc</span><span>     </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x σ.  (P (σ⦇break_status := x⦈)) = P σ "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f_is_measure</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ. ¬ exec_stop σ ∧ cond σ ∧ P σ ⟶ 
                       M σ ≠ None ∧ f(snd(the(M σ))) &lt; ((f σ)::nat) "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ exec_stop σ ∧ P σ⦄ 
          while<span class="hidden">⇩</span><sub>C</sub> cond do M od 
          ⦃λ_ σ.  ¬ break_status σ ∧ P σ⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_C_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hoare<span class="hidden">⇩</span><sub>3</sub>_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sequence'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. ¬ exec_stop σ ∧ P σ⦄ 
            while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. ¬ exec_stop σ ∧ cond σ) do M od
          ⦃λ_ σ. P (σ⦇break_status := False⦈)⦄"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>consequence_unit</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjunct2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>while</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_inv</span><span> </span><span>f_is_measure</span><span> </span><span>inv_idpc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λσ. P (σ⦇break_status := False⦈)⦄ unset_break_status 
          ⦃λx σ. ¬ break_status σ ∧ P σ⦄"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>conj_commute</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span>  </span><span>Hoare_Clean.unset_break1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Consequence and Sequence rules where inherited from the underlying Hoare-Monad theory.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="Clean_Symbex">
<div class="head"><h1>Theory Clean_Symbex</h1>
<span class="command">theory</span> <span class="name">Clean_Symbex</span><br/>
<span class="keyword">imports</span> <a href="Clean.html"><span class="name">Clean</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Clean_Symbex</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Clean</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Symbolic Execution Rules ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic NOP - Symbolic Execution Rules.  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹  As they are equalities, they can also
be used as program optimization rules. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign f; M)) = ((f σ) ⊨  M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (assign f;- M)) = ((f σ) ⊨  M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span> </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign f; M)) = (σ ⊨ M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>     
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (assign f;- M)) = (σ ⊨ M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span> </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>     
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Assign Execution Rules.  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign_global</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign_global upd rhs; M)) = ((upd (λ_. rhs σ) σ) ⊨  M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_global_def</span><span> </span><span>non_exec_assign</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign_global'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (assign_global upd rhs;- M)) = ((upd (λ_. rhs σ) σ) ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_assign_global</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign_global</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign_global upd rhs; M)) = ( σ ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_global_def</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign_global'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (assign_global upd rhs;- M)) = ( σ ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_global_def</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span> </span><span>bind_SE'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign_local</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign_local upd rhs; M)) = ((upd (map_hd (λ_. rhs σ)) σ) ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_local_def</span><span> </span><span>non_exec_assign</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign_local'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (assign_local upd rhs;- M)) = ((upd (map_hd (λ_. rhs σ)) σ) ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_assign_local</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>non_exec_assign_localD'</span><span class="delimiter">=</span><span> </span><span>non_exec_assign</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign_local</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← assign_local upd rhs; M)) = ( σ ⊨  M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assign_local_def</span><span> </span><span>assign_def</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_assign_local'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( assign_local upd rhs;- M)) = ( σ ⊨  M)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assign_local_def</span><span> </span><span>assign_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>exec_bind_SE_success2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assignD</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_assign</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>exec_assignD</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assignD'</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_assign'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>exec_assignD'</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assign_globalD</span><span> </span><span class="delimiter">=</span><span>  </span><span>exec_assign_global</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assign_globalD'</span><span> </span><span class="delimiter">=</span><span>  </span><span>exec_assign_global'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assign_localD</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_assign_local</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>exec_assign_localD</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_assign_localD'</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_assign_local'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Call Symbolic Execution Rules.  ›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_0</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← call_0<span class="hidden">⇩</span><sub>C</sub> M; M')) = (σ ⊨  M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>call_0<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_0'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (call_0<span class="hidden">⇩</span><sub>C</sub> M;- M')) = (σ ⊨  M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>exec_call_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_1</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( x ← call_1<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>; M' x)) = (σ ⊨  M' undefined)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_1'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (call_1<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>;- M')) = (σ ⊨  M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>exec_call_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( x ← call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>; M' x)) = (σ ⊨  M' undefined)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>;- M')) = (σ ⊨  M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>exec_call_1'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_2</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← call_2<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub>; M')) = (σ ⊨  M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>call_2<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>exec_bind_SE_success</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_call_2'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (call_2<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub>;- M')) = (σ ⊨ M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>exec_call_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Call Symbolic Execution Rules.  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_0</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← call_0<span class="hidden">⇩</span><sub>C</sub> M; M')) = (σ ⊨ M;- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>call_0<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_0'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ call_0<span class="hidden">⇩</span><sub>C</sub> M;- M') = (σ ⊨ M;- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_call_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_1</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( x ← (call_1<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>); M' x)) = (σ ⊨ (x ← M (A<span class="hidden">⇩</span><sub>1</sub> σ); M' x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>bind_SE_def</span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_1'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ call_1<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>;- M') = (σ ⊨  M (A<span class="hidden">⇩</span><sub>1</sub> σ);- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_call_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( x ← (call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>); M' x)) = (σ ⊨ (x ← M (A<span class="hidden">⇩</span><sub>1</sub> σ); M' x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>call<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>call_1<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ call<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub>;- M') = (σ ⊨  M (A<span class="hidden">⇩</span><sub>1</sub> σ);- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_call</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_2</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ( _ ← (call_2<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub>); M')) = (σ ⊨ M (A<span class="hidden">⇩</span><sub>1</sub> σ) (A<span class="hidden">⇩</span><sub>2</sub> σ);- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>call_2<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>valid_SE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_call_2'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ call_2<span class="hidden">⇩</span><sub>C</sub> M A<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>2</sub>;- M') = (σ ⊨  M (A<span class="hidden">⇩</span><sub>1</sub> σ) (A<span class="hidden">⇩</span><sub>2</sub> σ);- M')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE'_def</span><span> </span><span>non_exec_call_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Conditional.  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">" ((if<span class="hidden">⇩</span><sub>C</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi))σ = ((if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi)) σ "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_SE_def</span><span> </span><span>MonadSE.if_SE_def</span><span> </span><span>Symbex_MonadSE.valid_SE_def</span><span> </span><span>MonadSE.bind_SE'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bind_SE_def</span><span> </span><span>if_C_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_exec_If<span class="hidden">⇩</span><sub>C</sub></span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>C</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = (σ ⊨ (if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span> </span><span>valid_bind'_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_If<span class="hidden">⇩</span><sub>C</sub>'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (if<span class="hidden">⇩</span><sub>C</sub> P then B<span class="hidden">⇩</span><sub>1</sub> else B<span class="hidden">⇩</span><sub>2</sub> fi);-M) = (σ ⊨ M)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_SE_def</span><span> </span><span>MonadSE.if_SE_def</span><span> </span><span>Symbex_MonadSE.valid_SE_def</span><span> </span><span>MonadSE.bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>if_C_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_While<span class="hidden">⇩</span><sub>C</sub>'</span><span>  </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ (while<span class="hidden">⇩</span><sub>C</sub> P do B<span class="hidden">⇩</span><sub>1</sub> od);-M) = (σ ⊨ M)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_C_def</span><span> </span><span>MonadSE.if_SE_def</span><span> </span><span>Symbex_MonadSE.valid_SE_def</span><span> </span><span>MonadSE.bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>    
</span><span>
</span><span>
</span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if<span class="hidden">⇩</span><sub>C</sub>_cond_cong</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f σ = g σ ⟹ 
                           (if<span class="hidden">⇩</span><sub>C</sub> f then c else d fi) σ = 
                           (if<span class="hidden">⇩</span><sub>C</sub> g then c else d fi) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_C_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>   
</span><span> 
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Break - Rules.  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>break_assign_skip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"break ;- assign f = break"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>break_def</span><span> </span><span>assign_def</span><span> </span><span>exec_stop_def</span><span> </span><span>bind_SE'_def</span><span>   </span><span>bind_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>break_if_skip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"break ;- (if<span class="hidden">⇩</span><sub>C</sub> b then c else d fi) = break"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>break_def</span><span> </span><span>assign_def</span><span> </span><span>exec_stop_def</span><span> </span><span>if_C_def</span><span> </span><span>bind_SE'_def</span><span>   </span><span>bind_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>                       
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>break_while_skip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"break ;- (while<span class="hidden">⇩</span><sub>C</sub> b do c od) = break"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_C_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span>break_def</span><span> </span><span>exec_stop_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unset_break_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"( unset_break_status ;- unset_break_status ;- M) = (unset_break_status ;- M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unset_break_status_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_cancel1_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"( return<span class="hidden">⇩</span><sub>C</sub> X E ;- assign_global X E' ;- M) = ( return<span class="hidden">⇩</span><sub>C</sub> X E ;- M)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unset_break_status_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>            </span><span>assign_def</span><span> </span><span>return<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>assign_global_def</span><span> </span><span>assign_local_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_stop_def</span><span> </span><span>set_return_status_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_cancel2_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"( return<span class="hidden">⇩</span><sub>C</sub> X E ;- assign_local X E' ;- M) = ( return<span class="hidden">⇩</span><sub>C</sub> X E ;- M)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unset_break_status_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>            </span><span>assign_def</span><span> </span><span>return<span class="hidden">⇩</span><sub>C</sub>_def</span><span> </span><span>assign_global_def</span><span> </span><span>assign_local_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_stop_def</span><span> </span><span>set_return_status_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹While.  ›</span></span></span><span>     
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while<span class="hidden">⇩</span><sub>C</sub>_skip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(while<span class="hidden">⇩</span><sub>C</sub> (λ x. False) do c od) = skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_C_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exec_stop_def</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unset_break_status_def</span><span> </span><span>bind_SE'_def</span><span> </span><span>unit_SE_def</span><span> </span><span>bind_SE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Various tactics for various coverage criteria ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_k</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ (('σ_ext) control_state_ext ⇒ bool) 
                        ⇒ (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> 
                        ⇒ (unit, ('σ_ext) control_state_ext)MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"while_k _ ≡ while_C"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Somewhat amazingly, this unfolding lemma crucial for symbolic execution still holds ... 
     Even in the presence of break or return...›</span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_while<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ((while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- M)) = 
 (σ ⊨ ((if<span class="hidden">⇩</span><sub>C</sub> b then c ;- ((while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- unset_break_status) else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> fi)  ;- M))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>True</span><span> </span><span>exec_If<span class="hidden">⇩</span><sub>C</sub>'</span><span> </span><span>exec_While<span class="hidden">⇩</span><sub>C</sub>'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ b σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_bind'_cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ exec_stop σ›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>unit_SE_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_C_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind'_cong</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>MonadSE.while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. False"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>if<span class="hidden">⇩</span><sub>C</sub>_cond_cong</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. False"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_stop_def</span><span> </span><span>unset_break_status_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b σ"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_k_def</span><span> 
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>while_C_def</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>if_C_def</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span>valid_bind'_cong</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ exec_stop σ›</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span>  </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_bind'_cong</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ exec_stop σ›</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>MonadSE.while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_bind'_cong</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind'_cong</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. True"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ exec_stop σ›</span></span></span><span> </span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bind_assoc'</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>bind_assoc'</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ c;-((while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. ¬ exec_stop σ ∧ b σ) do c od);-unset_break_status);-M) =
                         (σ ⊨ c;-(while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- unset_break_status ;- M)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_SE'_def</span><span> </span><span>exec_bind_SE_failure</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ c ;- ((while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. ¬ exec_stop σ ∧ b σ) do c od);-unset_break_status);-M) =
                         (σ ⊨ c ;- (while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- unset_break_status ;- M)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c σ = Some a›</span></span></span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>exec_bind_SE_success2</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>exec_bind_SE_success2</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_stop (snd a)"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd a ⊨((while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> (λσ. ¬ exec_stop σ ∧ b σ) do c od);-unset_break_status);-M)=
                             (snd a ⊨ (while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- unset_break_status ;- M)"</span></span></span><span>
</span><span>                       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bind_assoc'</span><span> </span><span>exec_While<span class="hidden">⇩</span><sub>C</sub>'</span><span> </span><span>exec_skip</span><span> </span><span>if_SE_D2'</span><span> 
</span><span>                                                  </span><span>skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def</span><span> </span><span>while_SE_unfold</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd a ⊨ ((while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>(λσ. ¬exec_stop σ ∧ b σ) do c od);-unset_break_status);-M)=
                             (snd a ⊨ (while<span class="hidden">⇩</span><sub>C</sub> b do c od) ;- unset_break_status ;- M)"</span></span></span><span>
</span><span>                          </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>while_C_def</span><span>
</span><span>                          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_bind'_cong</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ... although it is, oh my god, amazingly complex to prove. *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_k_SE</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"while_C = while_k k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>while_k_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>exec_while_k</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(σ ⊨ ((while_k (Suc n) b c) ;- M)) = 
 (σ ⊨ ((if<span class="hidden">⇩</span><sub>C</sub> b then c ;- (while_k n b c) ;- unset_break_status else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> fi)  ;- M))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exec_while<span class="hidden">⇩</span><sub>C</sub></span><span> </span><span>while_k_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Necessary prerequisite: turning ematch and dmatch into a proper Isar Method. ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO : this code shoud go to TestGen Method setups *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
local
fun method_setup b tac =
  Method.setup b
    (Attrib.thms &gt;&gt; (fn rules =&gt; fn ctxt =&gt; METHOD (HEADGOAL o K (tac ctxt rules))))
in
val _ =
  Theory.setup (   method_setup @{binding ematch} ematch_tac "fast elimination matching"
                #&gt; method_setup @{binding dmatch} dmatch_tac "fast destruction matching"
                #&gt; method_setup @{binding match} match_tac "resolution based on fast matching")
end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>exec_while_kD</span><span> </span><span class="delimiter">=</span><span> </span><span>exec_while_k</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Test_Clean">
<div class="head"><h1>Theory Test_Clean</h1>
<span class="command">theory</span> <span class="name">Test_Clean</span><br/>
<span class="keyword">imports</span> <a href="Clean_Symbex.html"><span class="name">Clean_Symbex</span></a> <a href="Eisbach.html"><span class="name">Eisbach</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Test_Clean</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Clean_Symbex</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"HOL-Eisbach.Eisbach"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>memory_theory</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>memory_theory</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>memory_theory</span><span> </span><span>MonadSE.bind_assoc'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>norm</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>assert_D</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Clean_Main">
<div class="head"><h1>Theory Clean_Main</h1>
<span class="command">theory</span> <span class="name">Clean_Main</span><br/>
<span class="keyword">imports</span> <a href="Hoare_Clean.html"><span class="name">Hoare_Clean</span></a> <a href="Test_Clean.html"><span class="name">Test_Clean</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Clean --- a basic abstract ("shallow") programming language for test and proof.
 * Authors : Burkhart Wolff, Frédéric Tuong
 *           Contributions by Chantal Keller
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Clean_Main</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Clean</span><span> </span><span>Hoare_Clean</span><span> </span><span>Test_Clean</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Quicksort_concept">
<div class="head"><h1>Theory Quicksort_concept</h1>
<span class="command">theory</span> <span class="name">Quicksort_concept</span><br/>
<span class="keyword">imports</span> <a href="Clean.html"><span class="name">Clean</span></a> <a href="Hoare_MonadSE.html"><span class="name">Hoare_MonadSE</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Quicksort Concept
 *
 * Authors : Burkhart Wolff, Frédéric Tuong
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Clean Semantics : A Coding-Concept Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following show-case introduces subsequently a non-trivial example involving
local and global variable declarations, declarations of operations with pre-post conditions as
well as direct-recursive operations (i.e. C-like functions with side-effects on global and
local variables. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Quicksort_concept</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Clean</span><span>
</span><span>          </span><span>Hoare_MonadSE</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Quicksort Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ We present the following quicksort algorithm in some conceptual, high-level notation:

\begin{isar}
algorithm (A,i,j) =
    tmp := A[i];
    A[i]:=A[j];
    A[j]:=tmp

algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo
    for j := lo to hi - 1 do
        if A[j] &lt; pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i

algorithm quicksort(A, lo, hi) is
    if lo &lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

\end{isar}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we will present the Quicksort program alternatingly in Clean high-level
notation and simulate its effect by an alternative formalisation representing the semantic
effects of the high-level notation on a step-buy-step basis. Note that Clean does not posses
the concept of call-by-reference parameters; consequently, the algorithm must be specialized
to a variant where @{term A} is just a global variable.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Encoding of the Global State of Quicksort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We demonstrate the accumulating effect of some key Clean commands by highlighting the
changes of  Clean's state-management module state. At the beginning, the state-type of
the Clean state management is just the type of the @{typ "'a Clean.control_state.control_state_ext"},
while the table of global and local variables is empty.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ val Type(s,t) = StateMgt_core.get_state_type_global @{theory};
    StateMgt_core.get_state_field_tab_global @{theory}; ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The ‹global_vars› command, described and defined in ▩‹Clean.thy›,
declares the global variable ▩‹A›. This has the following effect:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">global_vars</span></span><span> </span><span>state</span><span>
</span><span>    </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹... which is reflected in Clean's state-management table:›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ val Type("Quicksort_concept.global_state_state_scheme",t)
        = StateMgt_core.get_state_type_global @{theory};
    StateMgt_core.get_state_field_tab_global @{theory}›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that the state-management uses long-names for complete disambiguation.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encoding swap in Clean›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹▩‹swap› in High-level Notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unfortunately, the name ‹result› is already used in the logical context; we use local binders
instead.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = ()"</span></span></span><span> </span><span class="comment">― ‹check that \&lt;^term&gt;‹i› can exist as a constant with an arbitrary type before treating ⬚‹function_spec››</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j = ()"</span></span></span><span> </span><span class="comment">― ‹check that \&lt;^term&gt;‹j› can exist as a constant with an arbitrary type before treating ⬚‹function_spec››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function_spec</span></span><span> </span><span>swap</span><span> </span><span class="delimiter">(</span><span>i</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">,</span><span>j</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹TODO: the hovering on parameters produces a number of report equal to the number of \&lt;^ML&gt;‹Proof_Context.add_fixes› called in \&lt;^ML&gt;‹Function_Specification_Parser.checkNsem_function_spec››</span><span>
</span><span class="keyword2"><span class="keyword">pre</span></span><span>          </span><span class="string"><span class="delete"><span class="delete">"‹i &lt; length A ∧ j &lt; length A›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">post</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">"‹λres. length A = length(old A) ∧ res = ()›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">local_vars</span></span><span>   </span><span>tmp</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">" ‹ tmp := A ! i›  ;-
               ‹ A := list_update A i (A ! j)› ;-
               ‹ A := list_update A j tmp› "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The body --- heavily using the ‹λ›-lifting cartouche --- corresponds to the low level
term: ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ @{cartouche [display=true]
‹‹defines " ((assign_local tmp_update (λσ. (A σ) ! i ))   ;-
            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ))))"››}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The effect of this statement is generation of the following definitions in the logical context:›</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i, j)"</span></span></span><span> </span><span class="comment">― ‹check that \&lt;^term&gt;‹i› and \&lt;^term&gt;‹j› are pointing to the constants defined before treating ⬚‹function_spec››</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>push_local_swap_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>pop_local_swap_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>swap_pre_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>swap_post_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>swap_core_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>swap_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The state-management is in the following configuration:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ val Type(s,t) = StateMgt_core.get_state_type_global @{theory};
    StateMgt_core.get_state_field_tab_global @{theory}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Similation of ▩‹swap› in elementary specification constructs:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that we prime identifiers in order to avoid confusion with the definitions of the
previous section. The pre- and postconditions are just definitions of the following form:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>swap'_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" nat × nat ⇒ 'a global_state_state_scheme ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"swap'_pre ≡ λ(i, j) σ. i &lt; length (A σ) ∧ j &lt; length (A σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>swap'_post</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a × 'b ⇒ 'c global_state_state_scheme ⇒ 'd global_state_state_scheme ⇒ unit ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"swap'_post ≡ λ(i, j) σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub> σ res. length (A σ) = length (A σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>) ∧ res = ()"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The somewhat vacuous parameter ‹res› for the result of the swap-computation is the conseqeuence
of the implicit definition of the return-type as @{typ "unit"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We simulate the effect of the local variable space declaration by the following command
     factoring out the functionality into the command ‹local_vars_test› ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
local_vars_test swap' "unit"
   tmp :: "int"

ML‹
val Type(s,t) = StateMgt_core.get_state_type_global @{theory};
val tab = StateMgt_core.get_state_field_tab_global @{theory};
@{term "A::('a local_swap_state_scheme⇒ int list)"}›

text‹This has already the effect of the definition:›
thm push_local_swap_state_def
thm pop_local_swap_state_def

text‹Again, we simulate the effect of this command by more elementary \HOL specification constructs:›
(* Thus, the internal functionality in ‹local_vars› is the construction of the two definitions *)
definition push_local_swap_state' :: "(unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "push_local_swap_state' σ =
                    Some((),σ⦇local_swap_state.tmp :=  undefined # local_swap_state.tmp σ ⦈)"

definition pop_local_swap_state' :: "(unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "pop_local_swap_state' σ =
                    Some(hd(local_swap_state.result_value σ),
                                ― ‹ recall : returns op value ›
                                ― ‹ which happens to be unit ›
                         σ⦇local_swap_state.tmp:= tl( local_swap_state.tmp σ) ⦈)"


definition swap'_core :: "nat × nat ⇒  (unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap'_core  ≡ (λ(i,j). ((assign_local tmp_update (λσ. A σ ! i ))   ;-
                            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
                            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ)))))"

text‹ a block manages the "dynamically" created fresh instances for the local variables of swap ›
definition swap' :: "nat × nat ⇒  (unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "swap' ≡ λ(i,j). block<span class="hidden">⇩</span><sub>C</sub> push_local_swap_state' (swap_core (i,j)) pop_local_swap_state'"


text‹NOTE: If local variables were only used in single-assignment style, it is possible
   to drastically simplify the encoding. These variables were not stored in the state,
   just kept as part of the monadic calculation. The simplifications refer both to
   calculation as well as well as symbolic execution and deduction.›

text‹The could be represented by the following alternative, optimized version :›
definition swap_opt :: "nat × nat ⇒  (unit,'a global_state_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap_opt ≡ λ(i,j). (tmp ←  yield<span class="hidden">⇩</span><sub>C</sub> (λσ. A σ ! i) ;
                          ((assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
                           (assign_global A_update (λσ. list_update (A σ) (j) (tmp)))))"
text‹In case that all local variables are single-assigned in swap, the entire local var definition
   could be ommitted.›
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encoding ▩‹partition› in Clean›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹▩‹partition› in High-level Notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function_spec</span></span><span> </span><span>partition</span><span> </span><span class="delimiter">(</span><span>lo</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">,</span><span> </span><span>hi</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">returns</span></span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">pre</span></span><span>          </span><span class="string"><span class="delete"><span class="delete">"‹lo &lt; length A ∧ hi &lt; length A›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">post</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">"‹λres::nat. length A = length(old A) ∧ res = 3›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">local_vars</span></span><span>   </span><span>pivot</span><span>  </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>             </span><span>i</span><span>      </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>             </span><span>j</span><span>      </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">" (‹pivot := A ! hi ›  ;- ‹i := lo › ;- ‹j := lo › ;-
               (while<span class="hidden">⇩</span><sub>C</sub> ‹j ≤ hi - 1 ›
                do (if<span class="hidden">⇩</span><sub>C</sub> ‹A ! j &lt; pivot›
                    then  call<span class="hidden">⇩</span><sub>C</sub> swap ‹(i , j) ›  ;-
                          ‹i := i + 1 ›
                    else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    fi) ;-
                    ‹j := j + 1 ›
                od) ;-
                call<span class="hidden">⇩</span><sub>C</sub> swap ‹(i, j)›  ;-
                return<span class="hidden">⇩</span><sub>C</sub> result_value_update ‹i›
               ) "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ The body is a fancy syntax for :

@{cartouche [display=true]
‹‹defines      " ((assign_local pivot_update (λσ. A σ ! hi ))   ;-
               (assign_local i_update (λσ. lo )) ;-

               (assign_local j_update (λσ. lo )) ;-
               (while<span class="hidden">⇩</span><sub>C</sub> (λσ. (hd o j) σ ≤ hi - 1 )
                do (if<span class="hidden">⇩</span><sub>C</sub> (λσ. A σ ! (hd o j) σ &lt; (hd o pivot)σ )
                    then  call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                          assign_local i_update (λσ. ((hd o i) σ) + 1)
                    else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    fi) ;-
                    (assign_local j_update (λσ. ((hd o j) σ) + 1))
                od) ;-
                call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                assign_local result_value_update (λσ. (hd o i) σ)
                ― ‹ the meaning of the return stmt ›
               ) "››}›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The effect of this statement is generation of the following definitions in the logical context:›</span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>partition_pre_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>partition_post_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>push_local_partition_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>pop_local_partition_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>partition_core_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>partition_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The state-management is in the following configuration:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ val Type(s,t) = StateMgt_core.get_state_type_global @{theory};
    StateMgt_core.get_state_field_tab_global @{theory}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Similation of ▩‹partition› in elementary specification constructs:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"partition'_pre ≡ λ(lo, hi) σ. lo &lt; length (A σ) ∧ hi &lt; length (A σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"partition'_post ≡ λ(lo, hi) σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub> σ res. length (A σ) = length (A σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>) ∧ res = 3"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Recall: list-lifting is automatic in ‹local_vars_test›:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">local_vars_test</span></span><span>  </span><span>partition'</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>    </span><span>pivot</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int"</span></span></span><span>
</span><span>    </span><span>i</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>    </span><span>j</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ ... which results in the internal definition of the respective push and pop operations
for the @{term "partition'"} local variable space: ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>push_local_partition'_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>pop_local_partition'_state_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* equivalent to *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>push_local_partition_state'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, 'a local_partition'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"push_local_partition_state' σ = Some((),
                        σ⦇local_partition_state.pivot := undefined # local_partition_state.pivot σ,
                          local_partition_state.i     := undefined # local_partition_state.i σ,
                          local_partition_state.j     := undefined # local_partition_state.j σ,
                          local_partition_state.result_value
                                           := undefined # local_partition_state.result_value σ ⦈)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pop_local_partition_state'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,'a local_partition_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"pop_local_partition_state' σ = Some(hd(local_partition_state.result_value σ),
                       σ⦇local_partition_state.pivot := tl(local_partition_state.pivot σ),
                         local_partition_state.i     := tl(local_partition_state.i σ),
                         local_partition_state.j     := tl(local_partition_state.j σ),
                         local_partition_state.result_value :=
                                                        tl(local_partition_state.result_value σ) ⦈)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition'_core</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat ⇒  (unit,'a local_partition'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"partition'_core  ≡ λ(lo,hi).
              ((assign_local pivot_update (λσ. A σ ! hi ))   ;-
               (assign_local i_update (λσ. lo )) ;-

               (assign_local j_update (λσ. lo )) ;-
               (while<span class="hidden">⇩</span><sub>C</sub> (λσ. (hd o j) σ ≤ hi - 1 )
                do (if<span class="hidden">⇩</span><sub>C</sub> (λσ. A σ ! (hd o j) σ &lt; (hd o pivot)σ )
                    then  call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                          assign_local i_update (λσ. ((hd o i) σ) + 1)
                    else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    fi)
                od) ;-
               (assign_local j_update (λσ. ((hd o j) σ) + 1)) ;-
                call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                assign_local result_value_update (λσ. (hd o i) σ)
                ― ‹ the meaning of the return stmt ›
               )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>partition_core_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* a block manages the "dynamically" created fresh instances for the local variables of swap *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat ⇒  (nat,'a local_partition'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"partition'  ≡ λ(lo,hi). block<span class="hidden">⇩</span><sub>C</sub> push_local_partition_state
                                   (partition_core (lo,hi))
                                   pop_local_partition_state"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encoding the toplevel : ▩‹quicksort› in Clean›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹▩‹quicksort› in High-level Notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">rec_function_spec</span></span><span> </span><span>quicksort</span><span> </span><span class="delimiter">(</span><span>lo</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">,</span><span> </span><span>hi</span><span class="delimiter">::</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">returns</span></span><span> </span><span>unit</span><span>
</span><span class="keyword2"><span class="keyword">pre</span></span><span>          </span><span class="string"><span class="delete"><span class="delete">"‹lo ≤ hi ∧ hi &lt; length A›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">post</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">"‹λres::unit. ∀i∈{lo .. hi}. ∀j∈{lo .. hi}. i ≤ j ⟶ A!i ≤ A!j›"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">variant</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"hi - lo"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">local_vars</span></span><span>   </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">" if<span class="hidden">⇩</span><sub>C</sub> ‹lo &lt; hi›
               then (p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub> ← call<span class="hidden">⇩</span><sub>C</sub> partition ‹(lo, hi)› ; assign_local p_update (λσ. p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub>)) ;-
                     call<span class="hidden">⇩</span><sub>C</sub> quicksort ‹(lo, p - 1)› ;-
                     call<span class="hidden">⇩</span><sub>C</sub> quicksort ‹(lo, p + 1)›
               else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
               fi"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>quicksort_core_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>quicksort_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>quicksort_pre_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>quicksort_post_def</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Similation of ▩‹quicksort› in elementary specification constructs:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This is the most complex form a Clean function may have: it may be directly
recursive. Two subcases are to be distinguished: either a measure is provided or not.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We start again with our simulation: First, we define the local variable ‹p›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">local_vars_test</span></span><span>  </span><span>quicksort'</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit"</span></span></span><span>
</span><span>    </span><span>p</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ val (x,y) = StateMgt_core.get_data_global @{theory}; ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>pop_local_quicksort'_state_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>push_local_quicksort'_state_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this implies the definitions : *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>push_local_quicksort_state'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, 'a local_quicksort'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"push_local_quicksort_state' σ =
                 Some((), σ⦇local_quicksort'_state.p := undefined # local_quicksort'_state.p σ,
                            local_quicksort'_state.result_value := undefined # local_quicksort'_state.result_value σ ⦈)"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pop_local_quicksort_state'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit,'a local_quicksort'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"pop_local_quicksort_state' σ = Some(hd(local_quicksort'_state.result_value σ),
                       σ⦇local_quicksort'_state.p   := tl(local_quicksort'_state.p σ),
                         local_quicksort'_state.result_value :=
                                                      tl(local_quicksort'_state.result_value σ) ⦈)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We recall the structure of the direct-recursive call in Clean syntax:
@{cartouche [display=true]
‹
funct quicksort(lo::int, hi::int) returns unit
     pre  "True"
     post "True"
     local_vars p :: int
     ‹if<span class="hidden">⇩</span><sub>C</sub><span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>E</sub><span class="hidden">⇩</span><sub>A</sub><span class="hidden">⇩</span><sub>N</sub> ‹lo &lt; hi› then
        p := partition(lo, hi) ;-
        quicksort(lo, p - 1) ;-
        quicksort(p + 1, hi)
      else Skip›
›}
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort'_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat ⇒ 'a local_quicksort'_state_scheme ⇒   bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"quicksort'_pre ≡ λ(i,j). λσ.  True "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort'_post</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat ⇒ unit ⇒ 'a local_quicksort'_state_scheme ⇒  bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"quicksort'_post ≡ λ(i,j). λ res. λσ.  True"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort'_core</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"   (nat × nat ⇒ (unit,'a local_quicksort'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>)
                              ⇒ (nat × nat ⇒ (unit,'a local_quicksort'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"quicksort'_core quicksort_rec ≡ λ(lo, hi).
                            ((if<span class="hidden">⇩</span><sub>C</sub> (λσ. lo &lt; hi )
                              then (p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub> ← call<span class="hidden">⇩</span><sub>C</sub> partition (λσ. (lo, hi)) ;
                                    assign_local p_update (λσ. p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub>)) ;-
                                    call<span class="hidden">⇩</span><sub>C</sub> quicksort_rec (λσ. (lo, (hd o p) σ - 1)) ;-
                                    call<span class="hidden">⇩</span><sub>C</sub> quicksort_rec (λσ. ((hd o p) σ + 1, hi))
                              else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                              fi))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ((quicksort'_core X) (lo,hi))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" ((nat × nat) × (nat × nat)) set ⇒
                            (nat × nat ⇒ (unit,'a local_quicksort'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"quicksort' order ≡ wfrec order (λX. λ(lo, hi). block<span class="hidden">⇩</span><sub>C</sub> push_local_quicksort'_state
                                                                 (quicksort'_core X (lo,hi))
                                                                 pop_local_quicksort'_state)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for Deductive Verification›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The coupling between the pre- and the post-condition state is done by the
     free variable (serving as a kind of ghost-variable) @{term "σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>"}. This coupling
     can also be used to express framing conditions; i.e. parts of the state which are
     independent and/or not affected by the computations to be verified. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_correct</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃λσ.   ¬exec_stop σ ∧ quicksort_pre (lo, hi)(σ) ∧ σ = σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub> ⦄
     quicksort (lo, hi)
   ⦃λr σ. ¬exec_stop σ ∧ quicksort_post(lo, hi)(σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>)(σ)(r) ⦄"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SquareRoot_concept">
<div class="head"><h1>Theory SquareRoot_concept</h1>
<span class="command">theory</span> <span class="name">SquareRoot_concept</span><br/>
<span class="keyword">imports</span> <a href="Test_Clean.html"><span class="name">Test_Clean</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * SquareRoot_concept --- Example of monadic symbolic execution for a WHILE program.
 * Burkhart Wolff and Chantal Keller, LRI, Univ. Paris-Sud, France
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The Squareroot Example for Symbolic Execution ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SquareRoot_concept</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Test_Clean</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ The Conceptual Algorithm in Clean Notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ In high-level notation, the algorithm we are investigating looks like this:

@{cartouche [display=true]
‹‹
function_spec sqrt (a::int) returns int
pre          "‹0 ≤ a›"
post         "‹λres::int.  (res + 1)<span class="hidden">⇧</span><sup>2</sup> &gt; a ∧ a ≥ (res)<span class="hidden">⇧</span><sup>2</sup>›"
defines      " (‹tm := 1› ;-
               ‹sqsum := 1› ;-
               ‹i := 0› ;-
               (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ‹sqsum &lt;= a› do
                  ‹i := i+1› ;-
                  ‹tm := tm + 2› ;-
                  ‹sqsum := tm + sqsum›
               od) ;-
               return<span class="hidden">⇩</span><sub>C</sub> result_value_update ‹i›
               )"
››}

›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Definition of the Global State ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The state is just a record; and the global variables correspond to fields in this
     record. This corresponds to typed, structured, non-aliasing states.
     Note that the types in the state can be arbitrary HOL-types - want to have
     sets of functions in a ghost-field ? No problem !
    ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ The state of the square-root program looks like this : ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typ</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Clean.control_state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
val Type(s,t) = StateMgt_core.get_state_type_global @{theory}
val Type(u,v) = @{typ unit}
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* could also be local variable, we flipped a coin and it became this way *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">global_vars</span></span><span> </span><span>state</span><span>
</span><span>   </span><span>tm</span><span>    </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>   </span><span>i</span><span>     </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>   </span><span>sqsum</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
val Type(s,t) = StateMgt_core.get_state_type_global @{theory}
val Type(u,v) = @{typ unit}
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* should be automatic *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tm_independent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ tm_update"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_independent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ i_update"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sqsum_independent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ sqsum_update"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_independence_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Setting for Symbolic Execution ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Some lemmas to reason about memory›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tm_simp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm (σ⦇tm := t⦈) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>simp_trace</span><span class="delimiter">]</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* from trace:
   [1]Procedure "record" produced rewrite rule:
   tm (?r⦇tm := ?k⦈) ≡ ?k

   Unfortunately, this lemma is not exported ... It looks as if it is computed on the fly ...
   This could explain why this is slow for our purposes ...
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tm_simp1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm (σ⦇sqsum := s⦈) = tm σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tm_simp2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm (σ⦇i := s⦈) = tm σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sqsum_simp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sqsum (σ⦇sqsum := s⦈) = s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sqsum_simp1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sqsum (σ⦇tm := t⦈) = sqsum σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sqsum_simp2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sqsum (σ⦇i := t⦈) = sqsum σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_simp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i (σ⦇i := i'⦈) = i'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_simp1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i (σ⦇tm := i'⦈) = i σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_simp2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i (σ⦇sqsum := i'⦈) = i σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>memory_theory</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>tm_simp</span><span> </span><span>tm_simp1</span><span> </span><span>tm_simp2</span><span>
</span><span>  </span><span>sqsum_simp</span><span> </span><span>sqsum_simp1</span><span> </span><span>sqsum_simp2</span><span>
</span><span>  </span><span>i_simp</span><span> </span><span>i_simp1</span><span> </span><span>i_simp2</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>memory_theory</span><span> </span><span class="delimiter">[</span><span>memory_theory</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exec_assign_globalD'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"♯ upd"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"σ ⊨ assign_global upd rhs ;- M ⟹¬ exec_stop σ ⟹  upd (λ_. rhs σ) σ ⊨ M"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>non_exec_assign_global'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>exec_stop_vs_control_independence</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>non_exec_assign_globalD'_tm</span><span> </span><span class="delimiter">=</span><span> </span><span>non_exec_assign_globalD'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tm_independent</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>non_exec_assign_globalD'_i</span><span> </span><span class="delimiter">=</span><span> </span><span>non_exec_assign_globalD'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_independent</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>non_exec_assign_globalD'_sqsum</span><span> </span><span class="delimiter">=</span><span> </span><span>non_exec_assign_globalD'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sqsum_independent</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Now we run a symbolic execution. We run match-tactics (rather than the Isabelle simplifier
  which would do the trick as well) in order to demonstrate a symbolic execution in Isabelle. ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ A Symbolic Execution Simulation ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>non_exec_stop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ exec_stop σ<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span>pos</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (a::int)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span>annotated_program</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"σ<span class="hidden">⇩</span><sub>0</sub> ⊨ ‹tm := 1› ;-
                ‹sqsum := 1› ;-
                ‹i := 0› ;-
                (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ‹sqsum &lt;= a› do
                   ‹i := i+1› ;-
                   ‹tm := tm + 2› ;-
                   ‹sqsum := tm + sqsum›
                od) ;-
                assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>(λσ. σ=σ<span class="hidden">⇩</span><sub>R</sub>)"</span></span></span><span>
</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ<span class="hidden">⇩</span><sub>R</sub> ⊨assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ‹i<span class="hidden">⇧</span><sup>2</sup>  ≤ a ∧ a &lt; (i + 1)<span class="hidden">⇧</span><sup>2</sup>› "</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>annotated_program</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_tm\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_sqsum\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_i\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"exec_whileD\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"ematch_tac @{context} [@{thm \"if_SE_execE''\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>memory_theory</span><span> </span><span>MonadSE.bind_assoc'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_i\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_tm\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_sqsum\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"exec_whileD\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"ematch_tac @{context} [@{thm \"if_SE_execE''\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>memory_theory</span><span> </span><span>MonadSE.bind_assoc'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_i\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_tm\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_sqsum\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"exec_whileD\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"ematch_tac @{context} [@{thm \"if_SE_execE''\"}] 1"</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>memory_theory</span><span> </span><span>MonadSE.bind_assoc'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_i\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_tm\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"dmatch_tac @{context} [@{thm \"non_exec_assign_globalD'_sqsum\"}] 1"</span></span></span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Here are all abstract test-cases explicit. Each subgoal correstponds to
       a path taken through the loop.›</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹push away the test-hyp: postcond is true for programs with more than
    three loop traversals (criterion: all-paths(k). This reveals explicitly
    the three test-cases for  @{term "k&lt;3"}. ›</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span> </span><span>1</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
txt‹Instead of testing, we @{emph ‹prove›} that the test cases satisfy the
    post-condition for all @{term "k&lt;3"} loop traversals and @{emph ‹all›}
    positive inputs @{term "a "}.›
   apply(auto  simp: assert_simp)
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹TODO: re-establish  automatic test-coverage tactics of @{cite "DBLP:conf/tap/Keller18"}.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>