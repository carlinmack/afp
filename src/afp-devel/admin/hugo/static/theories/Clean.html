<div id="MonadSE">
<div class="head">
<h1>Theory MonadSE</h1>
</div>
<pre class="source"><span class="comment1">(*****************************************************************************
 * Clean
 *                                                                            
 * HOL-TestGen --- theorem-prover based test case generation
 *                 http://www.brucker.ch/projects/hol-testgen/
 *                                                                            
 * Copyright (c) 2005-2007 ETH Zurich, Switzerland
 *               2009-2017 Univ. Paris-Sud, France 
 *               2009-2012 Achim D. Brucker, Germany
 *               2015-2017 University Sheffield, UK
 *               2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * Monads --- a base testing theory for sequential computations.
 * This file is part of HOL-TestGen.
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> MonadSE
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
        
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Definition : Standard State Exception Monads›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹State exception monads in our sense are a direct, pure formulation
of automata with a partial transition function.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Definition : Core Types and Operators›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'σ</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'o</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span>"</span></span> <span class="comment1">(* = 'σ ⇒ ('o × 'σ)option *)</span>       
      
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">bind_SE</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None 
                                        <span class="main">|</span> Some <span class="main">(</span><span class="bound">out</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">out</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> bind_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">bind<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">syntax</span></span>    <span class="main">(</span>xsymbols<span class="main">)</span>
          <span class="quoted">"_bind_SE"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span><span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span><span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
          <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span> _ <span class="keyword1">←</span> _<span class="keyword1">;</span> _<span class="keyword3">)</span>"</span> <span class="main">[</span>5<span class="main">,</span>8<span class="main">,</span>8<span class="main">]</span>8<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span> 
          <span class="quoted">"<span class="free">x</span> <span class="main">←</span> <span class="free">f</span><span class="main">;</span> <span class="free">g</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> bind_SE <span class="free">f</span> <span class="main">(</span><span class="main">%</span> <span class="free">x</span> <span class="main">.</span> <span class="free">g</span><span class="main">)</span>"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unit_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'o</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>   <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">result</span> _<span class="keyword3">)</span>"</span> 8<span class="main">)</span> 
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">unit_SE</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span>   unit_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the following, we prove the required Monad-laws›</span></span>

<span class="keyword1" id="MonadSE-bind_right_unit"><span class="command">lemma</span></span> bind_right_unit<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="keyword1">result</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  unit_SE_def bind_SE_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="improper">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="MonadSE-bind_left_unit"><span class="command">lemma</span></span> bind_left_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="keyword1">result</span> <span class="free">c</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_SE_def bind_SE_def<span class="main">)</span>
  
<span class="keyword1" id="MonadSE-bind_assoc"><span class="command">lemma</span></span> bind_assoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">y</span> <span class="main">←</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="free">k</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="free">h</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span> <span class="main">←</span> <span class="free">k</span> <span class="bound">x</span><span class="main">;</span> <span class="free">h</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_SE_def bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="improper">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">a</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Definition : More Operators and their Properties›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">fail_SE</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> None<span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">notation</span></span>   fail_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">assert_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">assert_SE</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span>True<span class="main">,</span><span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span>   assert_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">assume_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">assume_SE</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">∃</span><span class="bound">σ</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="keyword1">SOME</span> <span class="bound">σ</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span>   assume_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>


<span class="keyword1" id="MonadSE-bind_left_fail_SE"><span class="command">lemma</span></span> bind_left_fail_SE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_SE_def bind_SE_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We also provide a "Pipe-free" - variant of the bind operator.
Just a "standard" programming sequential operator without output frills.›</span></span>
<span class="comment1">(* TODO: Eliminate/Modify this. Is a consequence of the Monad-Instantiation. *)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_SE'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">;-</span>"</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">;-</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">;</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MonadSE-bind_assoc'"><span class="command">lemma</span></span> bind_assoc'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">m</span><span class="main">;-</span> <span class="free">k</span><span class="main">)</span><span class="main">;-</span> <span class="free">h</span> <span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span><span class="main">;-</span> <span class="main">(</span><span class="free">k</span><span class="main">;-</span> <span class="free">h</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>bind_SE'_def<span class="main">)</span>


<span class="keyword1" id="MonadSE-bind_left_unit'"><span class="command">lemma</span></span> bind_left_unit' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="keyword1">result</span> <span class="free">c</span><span class="main">)</span><span class="main">;-</span> <span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  bind_SE'_def<span class="main">)</span>
  

<span class="keyword1" id="MonadSE-bind_left_fail_SE'"><span class="command">lemma</span></span> bind_left_fail_SE'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">;-</span> <span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE'_def<span class="main">)</span>

<span class="keyword1" id="MonadSE-bind_right_unit'"><span class="command">lemma</span></span> bind_right_unit'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">;-</span> <span class="main">(</span><span class="keyword1">result</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  bind_SE'_def<span class="main">)</span>
          
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The bind-operator in the state-exception monad yields already
       a semantics for the concept of an input sequence on the meta-level:›</span></span>
<span class="keyword1" id="MonadSE-syntax_test"><span class="command">lemma</span></span>     syntax_test<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">o1</span> <span class="main">←</span> <span class="free">f1</span> <span class="main">;</span> <span class="bound">o2</span> <span class="main">←</span> <span class="free">f2</span><span class="main">;</span> <span class="keyword1">result</span> <span class="main">(</span><span class="free">post</span> <span class="bound">o1</span> <span class="bound">o2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">yield<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span>  <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span>  <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'a</span> <span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">yield<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">σ</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">try_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span> option<span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span></span> <span class="free"><span class="bound"><span class="entity">ioprog</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ioprog</span></span></span> <span class="bound">σ</span> <span class="keyword1">of</span>
                                      None <span class="main">⇒</span> Some<span class="main">(</span>None<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span>
                                    <span class="main">|</span> Some<span class="main">(</span><span class="bound">outs</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> Some<span class="main">(</span>Some <span class="bound">outs</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In contrast, mbind as a failure safe operator can roughly be seen 
       as a foldr on bind - try:
       m1 ; try m2 ; try m3; ... Note, that the rough equivalence only holds for
       certain predicates in the sequence - length equivalence modulo None,
       for example. However, if a conditional is added, the equivalence
       can be made precise:›</span></span>
  
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹On this basis, a symbolic evaluation scheme can be established
  that reduces mbind-code to try\_SE\_code and ite-cascades.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>   <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span> 10<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1"><span class="free">⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">σ</span>
                                      <span class="main">|</span> Some <span class="bound">H</span> <span class="main">⇒</span> Some <span class="bound">H</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">malt_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">malt_SE</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">=</span> foldr alt_SE <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span>   malt_SE <span class="main">(</span><span class="quoted">"<span class="keyword1">⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span>

<span class="keyword1" id="MonadSE-malt_SE_mt"><span class="command">lemma</span></span> malt_SE_mt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">[]</span> <span class="main">=</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> malt_SE_def<span class="main">)</span>

<span class="keyword1" id="MonadSE-malt_SE_cons"><span class="command">lemma</span></span> malt_SE_cons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="keyword1">⊓<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="keyword1">⨅<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">S</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> malt_SE_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Definition : Programming Operators and their Properties›</span></span>

<span class="keyword1"><span class="command">definition</span></span>  <span class="quoted"><span class="quoted">"<span class="free">skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">=</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">()</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">if_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">if_SE</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">σ</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="bound">σ</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="bound">σ</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">syntax</span></span>    <span class="main">(</span>xsymbols<span class="main">)</span>
          <span class="quoted">"_if_SE"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span><span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span><span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
          <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> _ <span class="keyword1">then</span> _ <span class="keyword1">else</span> _<span class="keyword1">fi</span><span class="keyword3">)</span>"</span> <span class="main">[</span>5<span class="main">,</span>8<span class="main">,</span>8<span class="main">]</span>8<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span> 
          <span class="quoted">"<span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">then</span> <span class="free">T1</span> <span class="keyword1">else</span> <span class="free">T2</span> <span class="keyword1">fi</span><span class="main">)</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> if_SE <span class="free">cond</span> <span class="free">T1</span> <span class="free">T2</span>"</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Theory of a Monadic While›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Prerequisites›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">replicator</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span> nat<span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">^^^</span>"</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^^^</span></span> <span class="main">0</span>      <span class="main">=</span> <span class="main">(</span><span class="keyword1">result</span> <span class="main">()</span><span class="main">)</span>"</span></span>
        <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^^^</span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">;-</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^^^</span></span>  <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">replicator2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span> nat<span class="main">,</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">^:^</span>"</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^:^</span></span> <span class="main">0</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span>      <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">)</span>"</span></span>
        <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^:^</span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">;-</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">^:^</span></span>  <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹First Step : Establishing an embedding between partial functions and relations›</span></span> 
<span class="comment1">(* plongement *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Mon2Rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'σ</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Mon2Rel</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">=</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="comment1">(* ressortir *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rel2Mon</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="tfree">'σ</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> "</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Rel2Mon</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="bound">σ</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">then</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="keyword1">SOME</span> <span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="bound">σ</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1" id="MonadSE-Mon2Rel_Rel2Mon_id"><span class="command">lemma</span></span> Mon2Rel_Rel2Mon_id<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> det<span class="main">:</span><span class="quoted"><span class="quoted">"single_valued <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Mon2Rel <span class="main">∘</span> Rel2Mon<span class="main">)</span> <span class="free">R</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def Mon2Rel_def Rel2Mon_def<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> some_eq_ex<span class="main">)</span> 
<span class="keyword1"><span class="command">using</span></span> det<span class="main">[</span><span class="operator">simplified</span> single_valued_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1" id="MonadSE-Rel2Mon_Id"><span class="command">lemma</span></span> Rel2Mon_Id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Rel2Mon <span class="main">∘</span> Mon2Rel<span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_def Mon2Rel_def Rel2Mon_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> contrapos_pp<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> HOL.not_sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="MonadSE-single_valued_Mon2Rel"><span class="command">lemma</span></span> single_valued_Mon2Rel<span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>Mon2Rel <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> single_valued_def Mon2Rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Second Step : Proving an induction principle allowing to establish that lfp remains
       deterministic›</span></span> 


<span class="comment1">(* A little complete partial order theory due to Tobias Nipkow *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">chain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">chain</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MonadSE-chain_total"><span class="command">lemma</span></span> chain_total<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span> <span class="main">==&gt;</span> <span class="free">S</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">S</span> <span class="free">j</span> <span class="main">∨</span> <span class="free">S</span> <span class="free">j</span> <span class="main">≤</span> <span class="free">S</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> chain_def le_cases lift_Suc_mono_le<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> set <span class="main">=&gt;</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">=&gt;</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">cont</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">S</span><span class="main">.</span> chain <span class="bound">S</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="bound">S</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span><span class="bound">S</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MonadSE-mono_if_cont"><span class="command">lemma</span></span> mono_if_cont<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">⊆</span> <span class="skolem">b</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> <span class="skolem">a</span> <span class="keyword1">else</span> <span class="skolem">b</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">⊆</span> <span class="skolem">b</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> chain_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?S</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="var">?S</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cont_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?S</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">⊆</span> <span class="skolem">b</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="var">?S</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">a</span> <span class="main">∪</span> <span class="free">f</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">a</span> <span class="main">⊆</span> <span class="free">f</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_upper1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MonadSE-chain_iterates"><span class="command">lemma</span></span> chain_iterates<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chain<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">^^</span><span class="bound">n</span><span class="main">)</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">{}</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> chain_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> lfp_if_cont<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp <span class="free">f</span> <span class="main">=</span>  <span class="main">(</span><span class="main">⋃</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?U</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfp <span class="free">f</span> <span class="main">⊆</span> <span class="var">?U</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> lfp_lowerbound<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="var">?U</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">^^</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">{}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> chain_iterates<span class="main">[</span><span class="operator">OF</span> mono_if_cont<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span> assms
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cont_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span><span class="main">^^</span><span class="main">0</span><span class="main">)</span><span class="main">{}</span> <span class="main">∪</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?U</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> funpow.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_iff funpow_0 old.nat.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="var">?U</span> <span class="main">⊆</span> <span class="var">?U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">p</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">p</span> <span class="main">⊆</span> <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">^^</span><span class="skolem">n</span><span class="main">)</span><span class="main">{}</span> <span class="main">⊆</span> <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> Suc
      <span class="keyword1"><span class="command">from</span></span> monoD<span class="main">[</span><span class="operator">OF</span> mono_if_cont<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> Suc<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">p</span> <span class="main">⊆</span> <span class="skolem">p</span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?U</span> <span class="main">⊆</span> lfp <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfp_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="MonadSE-single_valued_UN_chain"><span class="command">lemma</span></span> single_valued_UN_chain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">!!</span><span class="bound">n</span><span class="main">.</span> single_valued <span class="main">(</span><span class="free">S</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"single_valued<span class="main">(</span><span class="keyword1">UN</span> <span class="bound">n</span><span class="main">.</span> <span class="free">S</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> single_valued_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="skolem">n</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span> <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span> <span class="skolem">n</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> chain_total<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">]</span> assms<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> single_valued_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MonadSE-single_valued_lfp"><span class="command">lemma</span></span> single_valued_lfp<span class="main">:</span> 
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> single_valued <span class="bound">r</span> <span class="main">⟹</span> single_valued <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"single_valued<span class="main">(</span>lfp <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lfp_if_cont<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> single_valued_UN_chain<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain_iterates<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono_if_cont<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Third Step: Definition of the Monadic While <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span> ›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Γ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span><span class="main">(</span><span class="tfree">'σ</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> set<span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'σ</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'σ</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> set<span class="main">)</span>"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">Γ</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">cd</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">cw</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">cd</span></span></span> <span class="keyword1">O</span> <span class="bound">cw</span> <span class="keyword1">else</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">t</span><span class="main">}</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">while_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">while_SE</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="main">(</span>Rel2Mon<span class="main">(</span>lfp<span class="main">(</span>Γ <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>Mon2Rel <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">syntax</span></span>    <span class="main">(</span>xsymbols<span class="main">)</span>
          <span class="quoted">"_while_SE"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
          <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> _ <span class="keyword1">do</span> _ <span class="keyword1">od</span><span class="keyword3">)</span>"</span> <span class="main">[</span>8<span class="main">,</span>8<span class="main">]</span>8<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span> 
          <span class="quoted">"<span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">c</span> <span class="keyword1">do</span> <span class="free">b</span> <span class="keyword1">od</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> while_SE <span class="free">c</span> <span class="free">b</span>"</span>

<span class="keyword1" id="MonadSE-cont_Γ"><span class="command">lemma</span></span> cont_Γ<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span>Γ <span class="free">c</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cont_def Γ_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The fixpoint theory now allows us to establish that the lfp constructed over
       <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Mon2Rel</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> remains deterministic›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> single_valued_lfp_Mon2Rel<span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>lfp<span class="main">(</span>Γ <span class="free">c</span> <span class="main">(</span>Mon2Rel <span class="free">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> single_valued_lfp<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cont_Γ<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Γ_def single_valued_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> single_valued_Mon2Rel<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main"><span class="main">]</span></span> single_valued_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="MonadSE-Rel2Mon_if"><span class="command">lemma</span></span> Rel2Mon_if<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rel2Mon <span class="main">{</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">b</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> Mon2Rel <span class="free">c</span> <span class="keyword1">O</span> lfp <span class="main">(</span>Γ <span class="free">b</span> <span class="main">(</span>Mon2Rel <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">t</span><span class="main">}</span> <span class="free">σ</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="free">σ</span> <span class="keyword1">then</span> Rel2Mon <span class="main">(</span>Mon2Rel <span class="free">c</span> <span class="keyword1">O</span> lfp <span class="main">(</span>Γ <span class="free">b</span> <span class="main">(</span>Mon2Rel <span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span> <span class="keyword1">else</span> Some <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rel2Mon_def<span class="main">)</span>

<span class="keyword1" id="MonadSE-Rel2Mon_homomorphism"><span class="command">lemma</span></span> Rel2Mon_homomorphism<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> determ_X<span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> determ_Y<span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"Rel2Mon <span class="main">(</span><span class="free">X</span> <span class="keyword1">O</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Rel2Mon <span class="free">X</span><span class="main">)</span> <span class="main">;-</span> <span class="main">(</span>Rel2Mon <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
    <span class="keyword1"><span class="command">have</span></span> relational_partial_next_in_O<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">E</span> <span class="bound">F</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="bound">E</span> <span class="keyword1">O</span> <span class="bound">F</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">E</span><span class="main">)</span>"</span></span> 
                        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> some_eq_intro<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">X</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">.</span> single_valued <span class="bound">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">X</span><span class="main">)</span> <span class="main">=</span> <span class="bound">y</span>"</span></span>
                        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> single_valued_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rel2Mon_def bind_SE'_def bind_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">" <span class="main">∃</span> <span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="improper">σ</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> <span class="keyword1">O</span> <span class="free">Y</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> HOL.if_True<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> relational_partial_next_in_O<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> single_valued_relcomp some_eq_intro determ_X determ_Y relcomp.relcompI<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Putting everything together, the theory of embedding and the invariance of
       determinism of the while-body, gives us the usual unfold-theorem:›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> while_SE_unfold<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free">c</span> <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">result</span> <span class="main">()</span> <span class="keyword1">fi</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_SE_def bind_SE'_def while_SE_def unit_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lfp_unfold <span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono_if_cont<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> cont_Γ<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Γ_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Rel2Mon_if Rel2Mon_homomorphism bind_SE'_def Rel2Mon_Id <span class="main"><span class="main">[</span></span><span class="operator">simplified</span> comp_def<span class="main"><span class="main">]</span></span> 
                  single_valued_Mon2Rel single_valued_lfp_Mon2Rel <span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  

<span class="keyword1" id="MonadSE-bind_cong"><span class="command">lemma</span></span> bind_cong <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span>  <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">f</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="free">σ</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">g</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bind_SE'_def bind_SE_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="MonadSE-bind'_cong"><span class="command">lemma</span></span> bind'_cong <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span>  <span class="main">(</span><span class="free">f</span> <span class="main">;-</span> <span class="free">M</span> <span class="main">)</span><span class="free">σ</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="main">;-</span> <span class="free">M</span> <span class="main">)</span><span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bind_SE'_def bind_SE_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  
  
<span class="keyword1" id="MonadSE-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> True<span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MonadSE.if_SE_def<span class="main">)</span> 

<span class="keyword1" id="MonadSE-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_False <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> False<span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">=</span> <span class="free">d</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MonadSE.if_SE_def<span class="main">)</span> 
  
    
<span class="keyword1" id="MonadSE-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span> 
                           <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">f</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="free">σ</span> <span class="main">=</span> 
                           <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">g</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> if_SE_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
 
<span class="keyword1" id="MonadSE-while"><span class="command">lemma</span></span> while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_skip<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> False<span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">=</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span><span class="operator">subst</span> MonadSE.while_SE_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MonadSE.if_SE_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def<span class="main">)</span>
  
    
<span class="keyword2"><span class="keyword">end</span></span>
  </pre>
</div><div id="Seq_MonadSE">
<div class="head">
<h1>Theory Seq_MonadSE</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="keyword1"><span class="command">theory</span></span> Seq_MonadSE
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="MonadSE.html">MonadSE</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Chaining Monadic Computations : Definitions of Multi-bind Operators ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹  In order to express execution sequences inside \HOL --- rather
than arguing over a certain pattern of terms on the meta-level --- and
in order to make our theory amenable to formal reasoning over execution sequences, 
we represent them as lists of input and generalize the bind-operator
of the state-exception monad accordingly. The approach is straightforward,
but comes with a price: we have to encapsulate all input and output data
into one type, and restrict ourselves to  a uniform step function.
Assume that we have a typed interface to a module with
the operations $op_1$, $op_2$, \ldots, $op_n$ with the inputs 
$\iota_1$, $\iota_2$, \ldots, $\iota_n$ (outputs are treated analogously).
Then we can encode for this interface the general input - type:
\begin{displaymath}
\texttt{datatype}\ \texttt{in}\ =\ op_1\ ::\ \iota_1\ |\ ...\ |\ \iota_n
\end{displaymath}
Obviously, we loose some type-safety in this approach; we have to express
that in traces only \emph{corresponding} input and output belonging to the 
same operation will occur; this form of side-conditions have to be expressed
inside \HOL. From the user perspective, this will not make much difference,
since junk-data resulting from too weak typing can be ruled out by adopted
front-ends. 
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Note that the subsequent notion of a test-sequence allows the io stepping 
function (and the special case of a program under test) to stop execution 
\emph{within} the sequence; such premature terminations are characterized by an 
output list which is shorter than the input list. 

Intuitively, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind›</span></span></span></span> corresponds to a sequence of operation calls, separated by
";", in Java. The operation calls may fail (raising an exception), which means that
the state is maintained and the exception can still be caught at the end of the 
execution sequence.

›</span></span>

<span class="keyword1"><span class="command">fun</span></span>    <span class="entity">mbind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ι</span> list  <span class="main">⇒</span>  <span class="main">(</span><span class="tfree">'ι</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span> list<span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>  
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mbind</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mbind</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> 
                <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">of</span> 
                     None   <span class="main">⇒</span> Some<span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>
                  <span class="main">|</span>  Some <span class="main">(</span><span class="bound">out</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">mbind</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="bound">σ'</span> <span class="keyword1">of</span> 
                                          None    <span class="main">⇒</span> Some<span class="main">(</span><span class="main">[</span><span class="bound">out</span><span class="main">]</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> 
                                        <span class="main">|</span> Some<span class="main">(</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span> <span class="main">⇒</span> Some<span class="main">(</span><span class="bound">out</span><span class="main">#</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> mbind <span class="main">(</span><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span>"</span><span class="main">)</span> <span class="comment1">(* future name: mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub> *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This definition is fail-safe; in case of an exception, the current state is maintained,
       the computation as a whole is marked as success.
       Compare to the fail-strict variant <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind'›</span></span></span></span>:›</span></span>

<span class="keyword1" id="Seq_MonadSE-mbind_unit"><span class="command">lemma</span></span> mbind_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
     <span class="quoted"><span class="quoted">"mbind <span class="main">[]</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">result</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_SE_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The characteristic property of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mbind</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> --- which distinguishes it from 
       <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind›</span></span></span></span> defined in the sequel --- is that it never fails; it ``swallows'' internal
       errors occuring during the computation.›</span></span>    
<span class="keyword1" id="Seq_MonadSE-mbind_nofailure"><span class="command">lemma</span></span> mbind_nofailure <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"mbind <span class="free">S</span> <span class="free">f</span> <span class="free">σ</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">σ</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">S</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>unit_SE_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="improper">a</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">b</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> exE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> exE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In contrast, we define a fail-strict sequential execution operator.
He has more the characteristic to fail globally whenever one of its operation
steps fails.

Intuitively speaking, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind'›</span></span></span></span> corresponds to an execution of operations 
where a results in a System-Halt. Another interpretation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind'›</span></span></span></span> is to
view it as a kind of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">foldl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> foldl over lists via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="keyword1"><span class="quoted"><span class="keyword1">bind<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span> 
 
<span class="keyword1"><span class="command">fun</span></span>    <span class="entity">mbind'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ι</span> list  <span class="main">⇒</span>  <span class="main">(</span><span class="tfree">'ι</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span> list<span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mbind'</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
      <span class="quoted"><span class="quoted">"<span class="free">mbind'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> 
                <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">of</span> 
                     None   <span class="main">⇒</span> None
                  <span class="main">|</span>  Some <span class="main">(</span><span class="bound">out</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">mbind'</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="bound">σ'</span> <span class="keyword1">of</span> 
                                          None    <span class="main">⇒</span> None   <span class="comment1">― ‹fail-strict›</span> 
                                        <span class="main">|</span> Some<span class="main">(</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span> <span class="main">⇒</span> Some<span class="main">(</span><span class="bound">out</span><span class="main">#</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> mbind' <span class="main">(</span><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span>"</span><span class="main">)</span> <span class="comment1">(* future name: mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub> *)</span>

<span class="keyword1" id="Seq_MonadSE-mbind'_unit"><span class="command">lemma</span></span> mbind'_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
     <span class="quoted"><span class="quoted">"mbind' <span class="main">[]</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">result</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_SE_def<span class="main">)</span>

<span class="keyword1" id="Seq_MonadSE-mbind'_bind"><span class="command">lemma</span></span> mbind'_bind <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">x</span> <span class="main">←</span> mbind' <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">F</span><span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">←</span> <span class="main">(</span><span class="free">F</span> <span class="free">a</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> mbind' <span class="free">S</span> <span class="free">F</span><span class="main">;</span> <span class="free">M</span> <span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"z"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> mbind'.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="comment1">(* use only more abstract definitions *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The next <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mbind›</span></span></span></span> sequential execution operator is called 
Fail-Purge. He has more the characteristic to never fail, just "stuttering" 
above operation steps that fail. Another alternative in modeling.›</span></span> 

<span class="keyword1"><span class="command">fun</span></span>    <span class="entity">mbind''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ι</span> list  <span class="main">⇒</span>  <span class="main">(</span><span class="tfree">'ι</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span> list<span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mbind''</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
      <span class="quoted"><span class="quoted">"<span class="free">mbind''</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> 
                <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">of</span> 
                     None           <span class="main">⇒</span> <span class="free">mbind''</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span>
                  <span class="main">|</span>  Some <span class="main">(</span><span class="bound">out</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">mbind''</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">iostep</span></span></span> <span class="bound">σ'</span> <span class="keyword1">of</span> 
                                          None    <span class="main">⇒</span> None   <span class="comment1">― ‹does not occur›</span> 
                                        <span class="main">|</span> Some<span class="main">(</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span> <span class="main">⇒</span> Some<span class="main">(</span><span class="bound">out</span><span class="main">#</span><span class="bound">outs</span><span class="main">,</span><span class="bound">σ''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> mbind'' <span class="main">(</span><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span>"</span><span class="main">)</span> <span class="comment1">(* future name: mbind<span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub> *)</span>
<span class="keyword1"><span class="command">declare</span></span>  mbind''.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="comment1">(* use only more abstract definitions *)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹mbind' as failure strict operator can be seen as a foldr on bind -
       if the types would match \ldots›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Definition : Miscellaneous Operators and their Properties›</span></span>

<span class="keyword1" id="Seq_MonadSE-mbind_try"><span class="command">lemma</span></span> mbind_try<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">x</span> <span class="main">←</span> mbind <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">F</span><span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="bound">a'</span> <span class="main">←</span> <span class="keyword1">try<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">(</span><span class="free">F</span> <span class="free">a</span><span class="main">)</span><span class="main">;</span> 
      <span class="keyword1">if</span> <span class="bound">a'</span> <span class="main">=</span> None 
      <span class="keyword1">then</span> <span class="main">(</span><span class="free">M</span> <span class="main">[]</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> mbind <span class="free">S</span> <span class="free">F</span><span class="main">;</span> <span class="free">M</span> <span class="main">(</span>the <span class="bound">a'</span> <span class="main">#</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE_def try_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="free">a</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE_def try_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"mbind <span class="free">S</span> <span class="free">F</span> <span class="improper">b</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



  
<span class="keyword2"><span class="keyword">end</span></span>
  </pre>
</div><div id="Symbex_MonadSE">
<div class="head">
<h1>Theory Symbex_MonadSE</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="keyword1"><span class="command">theory</span></span> Symbex_MonadSE
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Seq_MonadSE.html">Seq_MonadSE</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Definition and Properties of Valid Execution Sequences›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A key-notion in our framework is the \emph{valid} execution
sequence, \ie{} a sequence that:
\begin{enumerate}
\item terminates (not obvious since while),
\item results in a final <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">True</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
\item does not fail globally (but recall the FailSave and FailPurge
      variants of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mbind</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-operators, that handle local exceptions in
      one or another way).
\end{enumerate}
Seen from an automata perspective (where the monad - operations correspond to
the step function), valid execution sequences can be used to model ``feasible paths''
across an automaton.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_SE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'σ</span> <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊨</span>"</span> 15<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">⊨</span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≠</span> None <span class="main">∧</span> fst<span class="main">(</span>the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This notation consideres failures as valid -- a definition
inspired by I/O conformance.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Valid Execution Sequences and their Symbolic Execution›</span></span>
<span class="keyword1" id="Symbex_MonadSE-exec_unit_SE"><span class="command">lemma</span></span> exec_unit_SE <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">result</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_unit_SE'"><span class="command">lemma</span></span> exec_unit_SE' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> Some <span class="main">(</span><span class="free">f</span> <span class="bound">σ</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="free">σ<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def <span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_fail_SE"><span class="command">lemma</span></span> exec_fail_SE <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_SE_def fail_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_fail_SE'"><span class="command">lemma</span></span> exec_fail_SE'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">σ<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def <span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The following the rules are in a sense the heart of the entire symbolic execution approach›</span></span>
<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_failure"><span class="command">lemma</span></span>  exec_bind_SE_failure<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="free">A</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_failure2"><span class="command">lemma</span></span>  exec_bind_SE_failure2<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def bind_SE'_def<span class="main">)</span>
  
  
<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success"><span class="command">lemma</span></span> exec_bind_SE_success<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="free">A</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def <span class="main">)</span>
    
<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success2"><span class="command">lemma</span></span> exec_bind_SE_success2<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ'</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def bind_SE'_def <span class="main">)</span>
    

<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success'"><span class="command">lemma</span></span> exec_bind_SE_success'<span class="main">:</span> <span class="comment1">(* atomic boolean Monad "Query Functions" *)</span> 
<span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">f</span> <span class="free">σ</span><span class="main">,</span><span class="free">σ</span><span class="main">)</span> <span class="main">⟹</span>  <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">σ</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def <span class="main">)</span>




<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success''"><span class="command">lemma</span></span> exec_bind_SE_success''<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="free">A</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>  <span class="main">∃</span> <span class="bound">v</span> <span class="bound">σ'</span><span class="main">.</span> the<span class="main">(</span><span class="free">A</span> <span class="free">σ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">the</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"snd <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success'''"><span class="command">lemma</span></span> exec_bind_SE_success'''<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="free">A</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>  <span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="free">A</span> <span class="free">σ</span><span class="main">)</span> <span class="main">=</span> Some <span class="bound">a</span> <span class="main">∧</span> <span class="main">(</span>snd <span class="bound">a</span><span class="main">)</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">the</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"snd <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Symbex_MonadSE-exec_bind_SE_success''''"><span class="command">lemma</span></span>  exec_bind_SE_success'''' <span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="free">A</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>  <span class="main">∃</span> <span class="bound">v</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">A</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">the</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fst <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"snd <span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Symbex_MonadSE-valid_bind_cong"><span class="command">lemma</span></span> valid_bind_cong <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">f</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">g</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bind_SE'_def bind_SE_def valid_SE_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
<span class="keyword1" id="Symbex_MonadSE-valid_bind'_cong"><span class="command">lemma</span></span> valid_bind'_cong <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">f</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">g</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bind_SE'_def bind_SE_def valid_SE_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Recall \verb+mbind_unit+ for the base case.›</span></span>

<span class="keyword1" id="Symbex_MonadSE-valid_mbind_mt"><span class="command">lemma</span></span> valid_mbind_mt <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span>  <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="main">[]</span> "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Symbex_MonadSE-valid_mbind_mtE"><span class="command">lemma</span></span> valid_mbind_mtE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_mbind_mt<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-valid_mbind'_mt"><span class="command">lemma</span></span> valid_mbind'_mt <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="main">[]</span> "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Symbex_MonadSE-valid_mbind'_mtE"><span class="command">lemma</span></span> valid_mbind'_mtE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_mbind'_mt<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-valid_mbind''_mt"><span class="command">lemma</span></span> valid_mbind''_mt <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="main">[]</span> "</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind''.simps valid_SE_def bind_SE_def unit_SE_def<span class="main">)</span>
<span class="keyword1" id="Symbex_MonadSE-valid_mbind''_mtE"><span class="command">lemma</span></span> valid_mbind''_mtE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">[]</span> <span class="free">f</span><span class="main">;</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_mbind''_mt<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-exec_mbindFSave_failure"><span class="command">lemma</span></span> exec_mbindFSave_failure<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_mbindFStop_failure"><span class="command">lemma</span></span> exec_mbindFStop_failure<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  <span class="main">(</span>False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_bind_SE_failure<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_mbindFPurge_failure"><span class="command">lemma</span></span> exec_mbindFPurge_failure<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def unit_SE_def bind_SE_def mbind''.simps<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-exec_mbindFSave_success"><span class="command">lemma</span></span> exec_mbindFSave_success <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span>  <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="free">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="main">(</span><span class="free">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_SE_def unit_SE_def bind_SE_def 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="free">σ'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_mbindFStop_success"><span class="command">lemma</span></span> exec_mbindFStop_success <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span>  <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="free">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="main">(</span><span class="free">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_SE_def unit_SE_def bind_SE_def 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="free">σ'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>  mbind'.simps<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_mbindFPurge_success"><span class="command">lemma</span></span> exec_mbindFPurge_success <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">⟹</span> 
   <span class="main">(</span><span class="free">σ</span>  <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="free">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">M</span> <span class="main">(</span><span class="free">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_SE_def unit_SE_def bind_SE_def 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span> <span class="free">σ'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>  mbind''.simps<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-exec_mbindFSave"><span class="command">lemma</span></span> exec_mbindFSave<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span>  <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">return</span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="keyword1">of</span>
       None <span class="main">⇒</span> <span class="main">(</span><span class="free">σ</span>  <span class="main">⊨</span> <span class="main">(</span><span class="free">return</span> <span class="main">(</span><span class="free">P</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">σ'</span>  <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span>  <span class="free">S</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="free">return</span> <span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> exec_mbindFSave_failure  exec_mbindFSave_success <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Symbex_MonadSE-mbind_eq_sexec"><span class="command">lemma</span></span> mbind_eq_sexec<span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">b</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">f</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⟹</span> 
             <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">f</span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">os</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">f</span><span class="main">;</span> <span class="free">P'</span> <span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">os</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>       <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">a</span><span class="main">;</span>  <span class="bound">x</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">f</span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span> <span class="main">=</span> 
             <span class="main">(</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">a</span><span class="main">;</span>  <span class="bound">x</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">f</span><span class="main">;</span> <span class="free">P'</span><span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Symbex_MonadSE-mbind_eq_sexec'"><span class="command">lemma</span></span> mbind_eq_sexec'<span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">b</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">f</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⟹</span> 
             <span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="bound">σ'</span> <span class="main">=</span> <span class="main">(</span><span class="free">P'</span> <span class="main">(</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="bound">σ'</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>       <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">a</span><span class="main">;</span>  <span class="free">P</span> <span class="main">(</span><span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span> <span class="main">=</span> 
             <span class="main">(</span> <span class="bound">a</span> <span class="main">←</span> <span class="free">f</span> <span class="free">a</span><span class="main">;</span>  <span class="free">P'</span><span class="main">(</span><span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_SE_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Symbex_MonadSE-mbind'_concat"><span class="command">lemma</span></span> mbind'_concat<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">(</span><span class="free">S</span><span class="main">@</span><span class="free">T</span><span class="main">)</span> <span class="free">f</span><span class="main">;</span> <span class="free">P</span> <span class="bound">os</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">f</span><span class="main">;</span> <span class="bound">os'</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">T</span> <span class="free">f</span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span><span class="bound">os</span> <span class="main">@</span> <span class="bound">os'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="free">S</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">σ</span></span> <span class="quoted"><span class="free">P</span></span><span class="main">)</span> 
   <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">S</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> Cons.hyps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mbind_eq_sexec'<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Symbex_MonadSE-assert_suffix_inv"><span class="command">lemma</span></span> assert_suffix_inv <span class="main">:</span> 
              <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">xs</span> <span class="free">istep</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">⟹</span> <span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="free">istep</span> <span class="free">x</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="free">istep</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> mbind'_concat<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_SE_def assert_SE_def valid_SE_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">aa</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="improper">bb</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">aa</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="improper">bb</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>



<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Universal splitting and symbolic execution rule›</span></span>
<span class="keyword1" id="Symbex_MonadSE-exec_mbindFSave_E"><span class="command">lemma</span></span> exec_mbindFSave_E<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> seq <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span>  <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   none<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">P</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   some<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">b</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span><span class="main">;</span><span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span> "</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> seq
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span>"</span></span><span class="main">)</span>  
   <span class="keyword3"><span class="command">case</span></span> None  <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> none<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ass<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> ioprog1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFSave_failure<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">aa</span><span class="main">)</span> <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some <span class="skolem">aa</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">aa</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"out"</span> <span class="quoted">"σ'"</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> some<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> ioprog1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFSave_success<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The next rule reveals the particular interest in deduction;
       as an elimination rule, it allows for a linear conversion of a validity judgement
       <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> over an input list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">S</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into a constraint system; without any 
       branching ... Symbolic execution can even be stopped tactically whenever 
       <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">ioprog</span></span> <span class="free"><span class="free">a</span></span> <span class="free"><span class="free">σ</span></span> <span class="main"><span class="main">=</span></span> Some<span class="main"><span class="main">(</span></span><span class="free"><span class="free">b</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">σ'</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> comes to a contradiction.›</span></span>
<span class="keyword1" id="Symbex_MonadSE-exec_mbindFStop_E"><span class="command">lemma</span></span> exec_mbindFStop_E<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> seq <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span> <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   some<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">b</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">σ'</span><span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">S</span> <span class="free">ioprog</span><span class="main">;</span><span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> seq
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span>"</span></span><span class="main">)</span>  
   <span class="keyword3"><span class="command">case</span></span> None  <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> σ<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">σ</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> S<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">S</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> M<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">P</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFStop_failure<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">aa</span><span class="main">)</span> <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some <span class="skolem">aa</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">aa</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"out"</span> <span class="quoted">"σ'"</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> some<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> ioprog1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFStop_success<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Symbex_MonadSE-exec_mbindFPurge_E"><span class="command">lemma</span></span> exec_mbindFPurge_E<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> seq <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">S</span><span class="main">)</span> <span class="free">ioprog</span> <span class="main">;</span>  <span class="main">(</span><span class="free">P</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   none<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span><span class="main">;</span><span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   some<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">b</span> <span class="bound">σ'</span><span class="main">.</span> <span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some<span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">σ'</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">s</span> <span class="main">←</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>P</sub><span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>g</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">S</span> <span class="free">ioprog</span><span class="main">;</span><span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">b</span><span class="main">#</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span> "</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> seq
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span>"</span></span><span class="main">)</span>  
   <span class="keyword3"><span class="command">case</span></span> None  <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> none<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ass<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> ioprog1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFPurge_failure<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">aa</span><span class="main">)</span> <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="free">a</span> <span class="free">σ</span> <span class="main">=</span> Some <span class="skolem">aa</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">aa</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"out"</span> <span class="quoted">"σ'"</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> some<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> ass<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> ioprog1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exec_mbindFPurge_success<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Symbex_MonadSE-assert_disch1"><span class="command">lemma</span></span> assert_disch1 <span class="main">:</span><span class="quoted"><span class="quoted">" <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> True<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assert_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-assert_disch2"><span class="command">lemma</span></span> assert_disch2 <span class="main">:</span><span class="quoted"><span class="quoted">" <span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;</span> <span class="free">M</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assert_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-assert_disch3"><span class="command">lemma</span></span> assert_disch3 <span class="main">:</span><span class="quoted"><span class="quoted">" <span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assert_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-assert_disch4"><span class="command">lemma</span></span> assert_disch4 <span class="main">:</span><span class="quoted"><span class="quoted">" <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span>  <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assert_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-assert_simp"><span class="command">lemma</span></span> assert_simp <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">σ</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assert_disch3 assert_disch4<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> assert_D <span class="main">=</span> assert_simp<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>  <span class="comment1">(* legacy *)</span>

<span class="keyword1" id="Symbex_MonadSE-assert_bind_simp"><span class="command">lemma</span></span> assert_bind_simp <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">;</span> <span class="free">M</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">M</span> True<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assert_SE_def valid_SE_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> HOL.if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> assert_bindD <span class="main">=</span> assert_bind_simp<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>  <span class="comment1">(* legacy *)</span>


<span class="keyword1" id="Symbex_MonadSE-assume_D"><span class="command">lemma</span></span> assume_D <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span> <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE_def assume_SE_def valid_SE_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> HOL.if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Eps <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Hilbert_Choice.someI<span class="main"><span class="keyword3">,</span></span><span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Symbex_MonadSE-assume_E"><span class="command">lemma</span></span> assume_E <span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> *  <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span> "</span></span>
<span class="keyword2"><span class="keyword">and</span></span>     ** <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="bound">σ</span> <span class="main">⊨</span> <span class="free">M</span>  <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> *<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">insert</span> *<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> assume_D<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> **<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-assume_E'"><span class="command">lemma</span></span> assume_E' <span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> *  <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;-</span> <span class="free">M</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span>     ** <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="bound">σ</span> <span class="main">⊨</span> <span class="free">M</span>  <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">insert</span> *<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> <span class="quoted">"bind_SE'_def"</span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> assume_D<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> **<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These two rule prove that the SE Monad in connection with the notion of valid sequence
is actually sufficient for a representation of a Boogie-like language. The SBE monad with explicit
sets of states --- to be shown below --- is strictly speaking not necessary (and will therefore
be discontinued in the development).›</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span>"</span></span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_D1"><span class="command">lemma</span></span> if_SE_D1 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_D1'"><span class="command">lemma</span></span> if_SE_D1' <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_def valid_SE_def bind_SE'_def bind_SE_def<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-if_SE_D2"><span class="command">lemma</span></span> if_SE_D2 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_D2'"><span class="command">lemma</span></span> if_SE_D2' <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_def valid_SE_def bind_SE'_def bind_SE_def<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-if_SE_split_asm"><span class="command">lemma</span></span> if_SE_split_asm <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_D1 if_SE_D2<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_split_asm'"><span class="command">lemma</span></span> if_SE_split_asm'<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_D1' if_SE_D2'<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-if_SE_split"><span class="command">lemma</span></span> if_SE_split<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_D1 if_SE_D2<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-if_SE_split'"><span class="command">lemma</span></span> if_SE_split'<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_D1' if_SE_D2'<span class="main">)</span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_execE"><span class="command">lemma</span></span> if_SE_execE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>   B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>  <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>   C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span><span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">insert</span> A <span class="main"><span class="main">[</span></span><span class="operator">simplified</span> if_SE_split<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span>  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> B C<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-if_SE_execE'"><span class="command">lemma</span></span> if_SE_execE'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>   B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>  <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">B<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>   C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span><span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">B<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">insert</span> A <span class="main"><span class="main">[</span></span><span class="operator">simplified</span> if_SE_split'<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span>  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> B C<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-exec_while"><span class="command">lemma</span></span> exec_while <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
 <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">()</span><span class="keyword1">fi</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> while_SE_unfold<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE'_def <span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_whileD <span class="main">=</span> exec_while<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>

<span class="keyword1" id="Symbex_MonadSE-if_SE_execE''"><span class="command">lemma</span></span> if_SE_execE''<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span> 
<span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">;-</span> <span class="free">M</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> 
<span class="main">⟹</span> <span class="main">(</span><span class="main">¬</span> <span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">;-</span> <span class="free">M</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> 
<span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> if_SE_execE'<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">opaque</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>bool<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword1" id="Symbex_MonadSE-if_SE_execE''_pos"><span class="command">lemma</span></span> if_SE_execE''_pos<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span> 
<span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">;-</span> <span class="free">M</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> 
<span class="main">⟹</span> <span class="main">(</span>opaque <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> 
<span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> opaque_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">m</span> <span class="free">σ</span><span class="main">)</span> <span class="keyword1">of</span> None  <span class="main">⇒</span> False <span class="main">|</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>  <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_SE_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="free">σ</span> <span class="main">=</span> None"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> not_None_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    
<span class="comment1">(* for the moment no good idea to state the case where the body eventually crashes. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>  <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="main">(</span><span class="bound">x</span><span class="main">=</span><span class="free">X</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">X</span><span class="main">.</span> <span class="bound">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="bound">x</span><span class="main">=</span><span class="bound">X</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>


<span class="keyword1" id="Symbex_MonadSE-monadic_sequence_rule"><span class="command">lemma</span></span> monadic_sequence_rule<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">X</span> <span class="bound">σ<span class="hidden">⇩</span><sub>1</sub></span><span class="main">.</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="free">σ</span><span class="main">=</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">∧</span>  <span class="free">P</span> <span class="free">σ</span><span class="main">)</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="main">(</span><span class="bound">x</span><span class="main">=</span><span class="bound">X</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">σ</span><span class="main">=</span><span class="bound">σ<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               <span class="main">∧</span> 
               <span class="main">(</span><span class="bound">σ<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="main">(</span><span class="bound">σ</span><span class="main">=</span><span class="bound">σ<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span> <span class="free">x</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">;</span> <span class="bound">y</span>  <span class="main">←</span> <span class="free">M'</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="free">R</span> <span class="free">x</span> <span class="bound">y</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="main">⟹</span>
               <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span><span class="free">σ</span><span class="main">=</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">∧</span>  <span class="free">P</span> <span class="free">σ</span><span class="main">)</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="bound">y</span>  <span class="main">←</span> <span class="free">M'</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> exE impE conjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> assume_D<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> exE impE conjE<span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_SE_def assume_SE_def assert_SE_def bind_SE_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split HOL.if_split_asm Option.option.split Option.option.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> someI_ex<span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>


  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">X</span><span class="main">.</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="bound">x</span><span class="main">=</span><span class="bound">X</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>
       <span class="main">⟹</span> 
            <span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_SE_def assume_SE_def assert_SE_def bind_SE_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split HOL.if_split_asm Option.option.split Option.option.split_asm<span class="main">)</span>


<span class="keyword1" id="Symbex_MonadSE-exec_skip"><span class="command">lemma</span></span> exec_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_skipD <span class="main">=</span> exec_skip<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Test-Refinements will be stated in terms of the failsave <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mbind</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, opting 
       more generality. The following lemma allows for an  optimization both in 
       test execution as well as in symbolic execution for an important special case of
       the post-codition: Whenever the latter has the constraint that the length of input and 
       output sequence equal each other (that is to say: no failure occured), failsave mbind
       can be reduced to failstop mbind ...›</span></span>
<span class="keyword1" id="Symbex_MonadSE-mbindFSave_vs_mbindFStop"><span class="command">lemma</span></span> mbindFSave_vs_mbindFStop <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">ιs</span> <span class="free">ioprog</span><span class="main">)</span><span class="main">;</span> <span class="keyword1">result</span><span class="main">(</span>length <span class="free">ιs</span> <span class="main">=</span> length <span class="bound">os</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">ιs</span> <span class="bound">os</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">ιs</span> <span class="free">ioprog</span><span class="main">)</span><span class="main">;</span> <span class="keyword1">result</span><span class="main">(</span><span class="free">P</span> <span class="free">ιs</span> <span class="bound">os</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">P</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">σ</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">ιs</span>"</span></span><span class="main">)</span> 
     <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_try try_SE_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Seq_MonadSE.mbind.simps<span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">ιs</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"P"</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> Cons.hyps<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">ioprog</span> <span class="skolem">a</span> <span class="improper">σ</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> exec_mbindFSave_failure exec_mbindFStop_failure<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  split_paired_all <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Seq_MonadSE.mbind.simps <span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> <span class="quoted">"σ'"</span><span class="main">)</span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> exec_mbindFSave_success<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> exec_bind_SE_success<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">ιs</span> <span class="bound">s</span><span class="main">.</span> <span class="improper">P</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="bound">ιs</span><span class="main">)</span> <span class="main">(</span><span class="improper">aa</span> <span class="main">#</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span> <span class="comment1">(* heureka ! *)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Symbex_MonadSE-mbind"><span class="command">lemma</span></span> mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub>_vs_mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">ι</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">ioprog</span> <span class="bound">ι</span> <span class="bound">σ</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="free">ιs</span> <span class="free">ioprog</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">os</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
            <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">os</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="free">ιs</span> <span class="free">ioprog</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">os</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">ιs</span>"</span></span><span class="main">)</span> 
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span> 
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">ιs</span><span class="main">)</span> 
       <span class="keyword1"><span class="command">from</span></span> Cons.hyps                           
       <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">S</span> <span class="bound">f</span> <span class="bound">σ</span><span class="main">.</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="bound">S</span> <span class="bound">f</span> <span class="bound">σ</span> <span class="main">≠</span> None "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
       <span class="keyword1"><span class="command">have</span></span> C<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="skolem">ιs</span> <span class="free">ioprog</span> <span class="bound">σ</span> <span class="main">=</span> <span class="keyword1">mbind<span class="hidden">⇩</span><sub>F</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>v</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">ιs</span> <span class="free">ioprog</span> <span class="bound">σ</span>"</span></span> 
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ιs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span><span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Seq_MonadSE.mbind'.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> A<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span> <span class="main">.</span> <span class="free">ioprog</span> <span class="improper">a</span> <span class="bound">σ</span> <span class="main">≠</span> None"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>option.split<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
       <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> A<span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> exE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span>  <span class="quoted">"out"</span> <span class="quoted">"σ'"</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> B<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">ιs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">ioprog</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">σ'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> not_None_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> exE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  exec_bind_SE_success<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span>   <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">a</span> <span class="main">#</span> <span class="main">(</span>fst <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="improper">out</span> <span class="improper">σ'</span> <span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> refl<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span>snd <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="improper">out</span> <span class="improper">σ'</span> <span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> refl<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  exec_bind_SE_success<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  exec_bind_SE_success<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Some <span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span>  trans<span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>C<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span>  exec_bind_SE_success<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span>  exec_bind_SE_success<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Some <span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span>  trans<span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>C<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Miscellaneous›</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> unit_SE <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">result</span> _<span class="keyword3">)</span>"</span> 8<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
  </pre>
</div><div id="Clean">
<div class="head">
<h1>Theory Clean</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * Clean --- a basic abstract ("shallow") programming language for test and proof.
 * Burkhart Wolff, Frédéric Tuong and Chantal Keller, LRI, Univ. Paris-Saclay, France
 *)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹The Clean Language›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Clean
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Symbex_MonadSE.html">Symbex_MonadSE</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"global_vars"</span> <span class="quoted">"local_vars_test"</span> <span class="main">::</span> thy_decl 
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"returns"</span> <span class="quoted">"pre"</span> <span class="quoted">"post"</span> <span class="quoted">"local_vars"</span> <span class="quoted">"variant"</span> 
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"function_spec"</span> <span class="main">::</span> thy_decl
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"rec_function_spec"</span>   <span class="main">::</span> thy_decl

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Clean (pronounced as: ``C lean'' or ``Céline'' [selin]) is a minimalistic imperative language 
with C-like control-flow operators based on a shallow embedding into the ``State Exception Monads'' theory 
formalized in <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🗏</span></span>‹MonadSE.thy›</span></span>. It strives for a type-safe notation of program-variables, an
incremental construction of the typed state-space in order to facilitate incremental verification
and open-world extensibility to new type definitions intertwined with the program
definition.

It comprises:
\begin{itemize}
\item C-like control flow with <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">break</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span>,
\item global variables,
\item function calls (seen as monadic executions) with side-effects, recursion
      and local variables,
\item parameters are modeled via functional abstractions 
      (functions are monads); a passing of parameters to local variables
      might be added later,
\item direct recursive function calls,
\item cartouche syntax for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>λ›</span></span></span></span>-lifted update operations supporting global and local variables.
\end{itemize}

Note that Clean in its current version is restricted to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹monomorphic›</span></span> global and local variables
as well as function parameters. This limitation will be overcome at a later stage. The construction
in itself, however, is deeply based on parametric polymorphism (enabling structured proofs over
extensible records as used in languages of the ML family
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf›</span></span>
and Haskell <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://www.schoolofhaskell.com/user/fumieval/extensible-records›</span></span>).
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">footnote</span> ‹sdf›<span class="antiquote">}</span></span>, <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">file</span> "$ISABELLE_HOME/src/Pure/ROOT.ML"<span class="antiquote">}</span></span>›</span></span> 
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹A High-level Description of the Clean Memory Model›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹A Simple Typed Memory Model of Clean: An Introduction ›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Clean is based on a ``no-frills'' state-exception monad 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">type_synonym</span></span></span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'o</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'σ</span></span><span class="main"><span class="main">)</span></span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">‹'σ ⇀ ('o × 'σ)›</span></span>›</span></span></span></span> with the 
usual definitions of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">bind</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">unit</span></span>›</span></span></span></span>.
In this language, sequence operators, conditionals and loops can be integrated. ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹From a concrete program, the underlying state <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="tfree"><span class="tfree">'σ</span></span>›</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹incrementally›</span></span> constructed by a
sequence of extensible record definitions:
<span class="antiquoted"><span class="antiquoted">▸</span></span> Initially, an internal control state is defined to give semantics to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">break</span></span>›</span></span></span></span> and
 <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span> statements:
  \begin{isar}
        record control_state =  break_val  :: bool   return_val :: bool
  \end{isar}
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹control_state›</span></span></span></span> represents the $\sigma_0$ state.
<span class="antiquoted"><span class="antiquoted">▸</span></span> Any global variable definition block with definitions $a_1 : \tau_1$ $\dots$ $a_n : \tau_n$  
  is translated into a record extension:
  \begin{isar}
        record σ$_{n+1}$ = σ$_n$    +    a$_1$ :: $\tau_1$; ...; $a_n$ :: $\tau_n$
  \end{isar}
<span class="antiquoted"><span class="antiquoted">▸</span></span> Any local variable definition block (as part of a procedure declaration) 
  with definitions $a_1 : \tau_1$ $\dots$ $a_n : \tau_n$ is translated into the record extension:
  \begin{isar}
        record σ$_{n+1}$ = σ$_n$    +    a$_1$ :: $\tau_1$ list; ...; $a_n$ :: $\tau_n$ list; result :: $\tau_{result-type}$ list; 
  \end{isar}
  where the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">_</span></span> list›</span></span></span></span>-lifting is used to model a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹stack›</span></span> of local variable instances
  in case of direct recursions and the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">result_value</span></span>›</span></span></span></span> used for the value of the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span>
  statement.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">record</span></span></span></span>›</span></span></span></span> package creates an <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="tfree"><span class="tfree">'σ</span></span>›</span></span></span></span> extensible record type 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="tfree"><span class="tfree">'σ</span></span> control_state_ext›</span></span></span></span> where the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="tfree"><span class="tfree">'σ</span></span>›</span></span></span></span> stands for extensions that are subsequently ``stuffed'' in
them. Furthermore, it generates definitions for the constructor, accessor and update functions and
automatically derives a number of theorems over them (e.g., ``updates on different fields commute'',
``accessors on a record are surjective'', ``accessors yield the value of the last update''). The
collection of these theorems constitutes the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹memory model›</span></span> of Clean, providing an incrementally 
extensible state-space for global and local program variables. In contrast to axiomatizations
of memory models, our generated state-spaces might be ``wrong'' in the sense that they do not 
reflect the operational behaviour of a particular compiler or a sufficiently large portion of the 
C language; however, it is by construction <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹logically consistent›</span></span> since it is
impossible to derive falsity from the entire set of conservative extension schemes used in their
construction. A particular advantage of the incremental state-space construction is that it
supports incremental verification and interleaving of program definitions with theory development.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Formally Modeling Control-States  ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The control state is the ``root'' of all extensions for local and global variable
spaces in Clean. It contains just the information of the current control-flow: a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">break</span></span>›</span></span></span></span> occurred
(meaning all commands till the end of the control block will be skipped) or a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span> occurred
(meaning all commands till the end of the current function body will be skipped).›</span></span>
  
<span class="keyword1"><span class="command">record</span></span>  control_state <span class="main">=</span> 
            break_status  <span class="main">::</span> <span class="quoted">bool</span>
            return_status <span class="main">::</span> <span class="quoted">bool</span>

<span class="comment1">(* break quits innermost while or for, return quits an entire execution sequence. *)</span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">break</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">break</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span> <span class="main">⦇</span> break_status <span class="main">:=</span> True <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unset_break_status</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">unset_break_status</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span> <span class="main">⦇</span> break_status <span class="main">:=</span> False <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_return_status</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">set_return_status</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> True <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unset_return_status</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">unset_return_status</span>  <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> False <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">exec_stop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">exec_stop</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> break_status <span class="bound">σ</span> <span class="main">∨</span> return_status <span class="bound">σ</span> <span class="main">)</span>"</span></span>

<span class="keyword1" id="Clean-exec_stop1"><span class="command">lemma</span></span> exec_stop1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"break_status <span class="free">σ</span> <span class="main">⟹</span> exec_stop <span class="free">σ</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> exec_stop_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Clean-exec_stop2"><span class="command">lemma</span></span> exec_stop2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"return_status <span class="free">σ</span> <span class="main">⟹</span> exec_stop <span class="free">σ</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> exec_stop_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ On the basis of the control-state, assignments, conditionals and loops are reformulated
  into <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹break›</span></span></span></span>-aware and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span>-aware versions as shown in the definitions of
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">assign</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">if_C</span></span>›</span></span></span></span> (in this theory file, see below). ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For Reasoning over Clean programs, we need the notion of independance of an
     update from the control-block: ›</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">control_independence</span> <span class="main">::</span>
                 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'b</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⇒</span><span class="tfree">'a</span> control_state_scheme <span class="main">⇒</span> <span class="tfree">'a</span> control_state_scheme<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>    <span class="main">(</span><span class="quoted">"<span class="keyword1">♯</span>"</span><span class="main">)</span>
           <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">♯</span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span> <span class="bound">T</span> <span class="bound">b</span><span class="main">.</span> break_status <span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">=</span> break_status <span class="bound">σ</span> 
                                 <span class="main">∧</span> return_status <span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">=</span> return_status <span class="bound">σ</span>
                                 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span> return_status <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="bound">σ</span><span class="main">)</span><span class="main">⦇</span> return_status <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span>
                                 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span> break_status <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="bound">T</span> <span class="bound">σ</span><span class="main">)</span><span class="main">⦇</span> break_status <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span><span class="main">)</span> "</span></span>



<span class="keyword1" id="Clean-exec_stop_vs_control_independence"><span class="command">lemma</span></span> exec_stop_vs_control_independence <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="free">upd</span> <span class="main">⟹</span> exec_stop <span class="main">(</span><span class="free">upd</span> <span class="free">f</span> <span class="free">σ</span><span class="main">)</span> <span class="main">=</span> exec_stop <span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def exec_stop_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1" id="Clean-exec_stop_vs_control_independence'"><span class="command">lemma</span></span> exec_stop_vs_control_independence' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="free">upd</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">upd</span> <span class="free">f</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> <span class="free">b</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">upd</span> <span class="free">f</span> <span class="free">σ</span><span class="main">)</span><span class="main">⦇</span> return_status <span class="main">:=</span> <span class="free">b</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def exec_stop_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Clean-exec_stop_vs_control_independence''"><span class="command">lemma</span></span> exec_stop_vs_control_independence'' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="free">upd</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">upd</span> <span class="free">f</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⦇</span> break_status <span class="main">:=</span> <span class="free">b</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">upd</span> <span class="free">f</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⦇</span> break_status <span class="main">:=</span> <span class="free">b</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def exec_stop_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>




<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹An Example for Global Variable Declarations.›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We present the above definition of the incremental construction of the state-space in more
detail via an example construction.

Consider a global variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> representing an array of integer. This 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹global variable declaration›</span></span> corresponds to the effect of the following
record declaration:

<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">record</span></span></span></span> state0 <span class="main"><span class="main">=</span></span> control_state <span class="main"><span class="main">+</span></span> A <span class="main"><span class="main">::</span></span> <span class="quoted"><span class="quoted">"int list"</span></span>›</span></span></span></span>

which is later extended by another global variable, say, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>B›</span></span></span></span> representing a real
described in the Cauchy Sequence form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span>int <span class="main"><span class="main">×</span></span> int<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as follows:

<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">record</span></span></span></span> state1 <span class="main"><span class="main">=</span></span> state0 <span class="main"><span class="main">+</span></span> B <span class="main"><span class="main">::</span></span> <span class="quoted"><span class="quoted">"nat ⇒ (int × int)"</span></span>›</span></span></span></span>.

A further extension would be needed if a (potentially recursive) function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> with some local
variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tmp›</span></span></span></span> is defined:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">record</span></span></span></span> state2 <span class="main"><span class="main">=</span></span> state1 <span class="main"><span class="main">+</span></span> tmp <span class="main"><span class="main">::</span></span> <span class="quoted"><span class="quoted">"nat stack"</span></span> result_value <span class="main"><span class="main">::</span></span> <span class="quoted"><span class="quoted">"nat stack"</span></span> ›</span></span></span></span>, where the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>stack›</span></span></span></span>
needed for modeling recursive instances is just a synonym for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>list›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The Assignment Operations (embedded in State-Exception Monad) ›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Based on the global variable states, we define   <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹break›</span></span></span></span>-aware and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span>-aware 
version of the assignment. The trick to do this in a generic <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹and›</span></span> type-safe way is to provide
the generated accessor and update functions (the ``lens'' representing this global variable,
cf. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> "Foster2009BidirectionalPL" <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> "DBLP:journals/toplas/FosterGMPS07" <span class="quasi_keyword"><span class="quasi_keyword">and</span></span>
"DBLP:conf/ictac/FosterZW16"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) to the generic assign operators. This pair of accessor and update
carries all relevant semantic and type information of this particular variable and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹characterizes›</span></span>
this variable semantically. Specific syntactic support~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⁋</span></span>‹via the Isabelle concept of
cartouche: <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://isabelle.in.tum.de/doc/isar-ref.pdf›</span></span>›</span></span> will hide away the syntactic overhead and permit a human-readable
form of assignments or expressions accessing the underlying state. ›</span></span>


<span class="keyword1"><span class="command">consts</span></span> syntax_assign <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'α</span>  <span class="main">⇒</span> int<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">:=</span>"</span> 60<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">assign</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_scheme  <span class="main">⇒</span> 
                       <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_scheme<span class="main">)</span> <span class="main">⇒</span> 
                       <span class="main">(</span>unit<span class="main">,</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_scheme<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">assign</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span>  <span class="entity">assign_global</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span>  <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span>
                              <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span>  <span class="tfree">'a</span><span class="main">)</span>
                              <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>    <span class="quoted"><span class="quoted">"<span class="free">assign_global</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="main">=</span> assign<span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹An update of the variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> based on the state of the previous example is done 
by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source = true] <span class="quoted"><span class="quoted">‹assign_global <span class="free"><span class="free">A_upd</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> list_update <span class="main"><span class="main">(</span></span><span class="free"><span class="free">A</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">i</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">A</span></span> <span class="bound"><span class="bound">σ</span></span> <span class="main"><span class="main">!</span></span> <span class="free"><span class="free">j</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
representing <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A[i] = A[j]›</span></span></span></span>; arbitrary nested updates can be constructed accordingly.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Local variable spaces work analogously; except that they are represented by a stack
in order to support individual instances in case of function recursion. This requires
automated generation of specific push- and pop operations used to model the effect of
entering or leaving a function block (to be discussed later).›</span></span>


<span class="keyword1"><span class="command">fun</span></span>      <span class="entity">map_hd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_hd</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">map_hd</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span>"</span></span>

<span class="keyword1" id="Clean-tl_map_hd"><span class="command">lemma</span></span> tl_map_hd <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span><span class="quoted"><span class="quoted">"tl <span class="main">(</span>map_hd <span class="free">f</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> tl <span class="free">S</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> map_hd.elims<span class="main">)</span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_nth</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">f</span> <span class="bound">l</span><span class="main">.</span> list_update <span class="bound">l</span> <span class="bound">i</span> <span class="main">(</span><span class="bound">f</span> <span class="main">(</span><span class="bound">l</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>  <span class="entity">assign_local</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span> 
                                 <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span>
                             <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span>  <span class="tfree">'a</span><span class="main">)</span>
                             <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>    <span class="quoted"><span class="quoted">"<span class="free">assign_local</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="main">=</span> assign<span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="keyword1">o</span> map_hd<span class="main">)</span> <span class="main">(</span><span class="main">%</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Semantically, the difference between <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹global›</span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹local›</span></span> is rather unimpressive as the 
     following lemma shows. However, the distinction matters for the pretty-printing setup of Clean.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"assign_local <span class="free">upd</span> <span class="free">rhs</span> <span class="main">=</span> assign_global <span class="main">(</span><span class="free">upd</span> <span class="keyword1">o</span> map_hd<span class="main">)</span> <span class="free">rhs</span> "</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> assign_local_def assign_global_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span> command in C-like languages is represented basically by an assignment to a local
variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>result_value›</span></span></span></span> (see below in the Clean-package generation), plus some setup of 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹return_status›</span></span></span></span>. Note that a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span> may appear after a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹break›</span></span></span></span> and should have no effect
in this case.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span> <span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span>
                      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'σ_ext</span> control_state_scheme <span class="main">⇒</span>  <span class="tfree">'a</span><span class="main">)</span>
                      <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'σ_ext</span> control_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">return<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="main">=</span><span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> 
                                                <span class="keyword1">else</span> <span class="main">(</span>assign_local <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="free"><span class="bound"><span class="entity">rhs</span></span></span> <span class="main">;-</span> set_return_status<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Example for a Local Variable Space›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Consider the usual operation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>swap›</span></span></span></span> defined in some free-style syntax as follows:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display] <span class="raw_text"><span class="raw_text">‹
  function_spec swap (i::nat,j::nat)
  local_vars   tmp :: int 
  defines      " ‹ tmp  := A ! i› ;-
                 ‹ A[i] := A ! j› ;- 
                 ‹ A[j] := tmp› "›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ 
For the fantasy syntax  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tmp := A ! i›</span></span></span></span>, we can construct the following semantic code:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source = true] <span class="quoted"><span class="quoted">‹assign_local <span class="free"><span class="free">tmp_update</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">A</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">!</span></span> <span class="free"><span class="free">i</span></span> <span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tmp_update›</span></span></span></span> is the
update operation generated by the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">record</span></span></span></span>›</span></span></span></span>-package, which is generated while treating local variables
of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>swap›</span></span></span></span>. By the way, a stack for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span>-values is also generated in order to give semantics
to a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span> operation: it is syntactically equivalent to the assignment of 
the result variable  in the local state (stack). It sets the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return_val</span></span>›</span></span></span></span> flag.

The management of the local state space requires function-specific <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>push›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pop›</span></span></span></span> operations,
for which suitable definitions are generated as well:

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display]
<span class="raw_text"><span class="raw_text">‹definition push_local_swap_state :: "(unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
   where   "push_local_swap_state σ = 
                     Some((),σ⦇local_swap_state.tmp := undefined # local_swap_state.tmp σ,
                               local_swap_state.result_value := undefined # 
                                                                  local_swap_state.result_value σ  ⦈)"

 definition pop_local_swap_state :: "(unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
   where   "pop_local_swap_state σ = 
                    Some(hd(local_swap_state.result_value σ), 
                         σ⦇local_swap_state.tmp:= tl( local_swap_state.tmp σ) ⦈)"›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>result_value›</span></span></span></span> is the stack for potential result values (not needed in the concrete
example <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>swap›</span></span></span></span>).
›</span></span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Global and Local State Management via Extensible Records ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the sequel, we present the automation of the state-management as schematically discussed
in the previous section; the declarations of global and local variable blocks are constructed by 
subsequent extensions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> control_state_scheme"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, defined above.›</span></span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">StateMgt_core</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">control_stateT</span> <span class="main">=</span> Syntax.parse_typ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"control_state"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">control_stateS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>control_state_scheme"</span><span class="antiquote">}</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">optionT</span> <span class="entity">t</span> <span class="main">=</span> Type<span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> "Option.option"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">MON_SE_T</span> <span class="entity">res</span> <span class="entity">state</span> <span class="main">=</span> <span class="entity">state</span> --&gt; <span class="entity">optionT</span><span class="main">(</span><span class="entity">HOLogic.mk_prodT</span><span class="main">(</span><span class="entity">res</span><span class="main">,</span><span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_control_stateS</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>control_state_scheme"</span><span class="antiquote">}</span></span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
   <span class="main">|</span><span class="entity">merge_control_stateS</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>control_state_scheme"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
   <span class="main">|</span><span class="entity">merge_control_stateS</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">(</span><span class="entity">t</span> <span class="main">=</span> <span class="entity">t'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> error<span class="inner_quoted">"can not merge Clean state"</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">var_kind</span> <span class="main">=</span> <span class="entity">global_var</span> <span class="keyword2"><span class="keyword">of</span></span> typ <span class="main">|</span> <span class="entity">local_var</span> <span class="keyword2"><span class="keyword">of</span></span> typ

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">type_of</span><span class="main">(</span><span class="entity">global_var</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span> <span class="main">|</span> <span class="entity">type_of</span><span class="main">(</span><span class="entity">local_var</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">state_field_tab</span> <span class="main">=</span> <span class="entity">var_kind</span> Symtab.table

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span>                      <span class="main">=</span> <span class="main">(</span><span class="entity">state_field_tab</span> * typ <span class="comment1">(* current extensible record *)</span><span class="main">)</span> 
  <span class="keyword1"><span class="keyword">val</span></span>  <span class="entity">empty</span>                  <span class="main">=</span> <span class="main">(</span>Symtab.empty<span class="main">,</span><span class="entity">control_stateS</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span>  <span class="entity">extend</span>                 <span class="main">=</span> I
  <span class="keyword1"><span class="keyword">fun</span></span>  <span class="entity">merge</span><span class="main">(</span><span class="main">(</span><span class="entity">s1</span><span class="main">,</span><span class="entity">t1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="entity">s2</span><span class="main">,</span><span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">(</span><span class="entity">s1</span><span class="main">,</span><span class="entity">s2</span><span class="main">)</span><span class="main">,</span><span class="entity">merge_control_stateS</span><span class="main">(</span><span class="entity">t1</span><span class="main">,</span><span class="entity">t2</span><span class="main">)</span><span class="main">)</span>
<span class="main">)</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_data</span>                   <span class="main">=</span> Data.get o Context.Proof<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_data</span>                   <span class="main">=</span> Data.map<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_data_global</span>            <span class="main">=</span> Data.get o Context.Theory<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_data_global</span>            <span class="main">=</span> Context.theory_map o <span class="entity">map_data</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_state_type</span>             <span class="main">=</span> snd o <span class="entity">get_data</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_state_type_global</span>      <span class="main">=</span> snd o <span class="entity">get_data_global</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_state_field_tab</span>        <span class="main">=</span> fst o <span class="entity">get_data</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_state_field_tab_global</span> <span class="main">=</span> fst o <span class="entity">get_data_global</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd_state_type</span> <span class="entity">f</span>           <span class="main">=</span> <span class="entity">map_data</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tab</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">tab</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd_state_type_global</span> <span class="entity">f</span>    <span class="main">=</span> <span class="entity">map_data_global</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tab</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">tab</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fetch_state_field</span> <span class="main">(</span><span class="entity">ln</span><span class="main">,</span><span class="entity">X</span><span class="main">)</span>   <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">a</span>::<span class="entity">b</span>:: <span class="main">_</span>  <span class="main">=</span> rev <span class="main">(</span>Long_Name.explode <span class="entity">ln</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span><span class="entity">a</span><span class="main">)</span><span class="main">,</span><span class="entity">X</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filter_name</span> <span class="entity">name</span> <span class="entity">ln</span>        <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span><span class="main">,</span><span class="entity">X</span><span class="main">)</span> <span class="main">=</span> <span class="entity">fetch_state_field</span> <span class="entity">ln</span>
                                 <span class="keyword2"><span class="keyword">in</span></span>  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">a</span> <span class="main">=</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME<span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span><span class="main">,</span><span class="entity">X</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filter_attr_of</span> <span class="entity">name</span> <span class="entity">thy</span>    <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tabs</span> <span class="main">=</span> <span class="entity">get_state_field_tab_global</span> <span class="entity">thy</span>
                                 <span class="keyword2"><span class="keyword">in</span></span>  map_filter <span class="main">(</span><span class="entity">filter_name</span> <span class="entity">name</span><span class="main">)</span> <span class="main">(</span>Symtab.dest <span class="entity">tabs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_program_variable</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> Symtab.defined<span class="main">(</span><span class="main">(</span>fst o <span class="entity">get_data_global</span><span class="main">)</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">name</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_global_program_variable</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup<span class="main">(</span><span class="main">(</span>fst o <span class="entity">get_data_global</span><span class="main">)</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
                                             SOME<span class="main">(</span><span class="entity">global_var</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
                                           <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_local_program_variable</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup<span class="main">(</span><span class="main">(</span>fst o <span class="entity">get_data_global</span><span class="main">)</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
                                             SOME<span class="main">(</span><span class="entity">local_var</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
                                           <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_state_variable_global</span> <span class="entity">f</span> <span class="entity">field</span> <span class="entity">thy</span>  <span class="main">=</span>  
             <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> Const<span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> Syntax.read_term_global <span class="entity">thy</span> <span class="entity">field</span>
             <span class="keyword2"><span class="keyword">in</span></span>  <span class="main">(</span><span class="entity">map_data_global</span> <span class="main">(</span>apfst <span class="main">(</span>Symtab.update_new<span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">f</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">thy</span><span class="main">)</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> Symtab.DUP <span class="main">_</span> <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"multiple declaration of global var"</span><span class="main">)</span><span class="main">)</span>
             <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_state_variable_local</span> <span class="entity">f</span> <span class="entity">field</span> <span class="entity">ctxt</span>  <span class="main">=</span> 
             <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> Const<span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> Syntax.read_term_global  <span class="main">(</span>Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">field</span>
             <span class="keyword2"><span class="keyword">in</span></span>  <span class="main">(</span><span class="entity">map_data</span> <span class="main">(</span>apfst <span class="main">(</span>Symtab.update_new<span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">f</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="entity">ctxt</span><span class="main">)</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> Symtab.DUP <span class="main">_</span> <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"multiple declaration of global var"</span><span class="main">)</span><span class="main">)</span>
             <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Block-Structures›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ On the managed local state-spaces, it is now straight-forward to define the semantics for 
a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>block›</span></span></span></span> representing the necessary management of local variable instances:
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">block<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"  <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                     <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>  
                     <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                     <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">block<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">push</span></span></span> <span class="free"><span class="bound"><span class="entity">core</span></span></span> <span class="free"><span class="bound"><span class="entity">pop</span></span></span> <span class="main">≡</span> <span class="main">(</span>          <span class="comment1">― ‹assumes break and return unset ›</span> 
                                   <span class="free"><span class="bound"><span class="entity">push</span></span></span> <span class="main">;-</span>   <span class="comment1">― ‹create new instances of local variables ›</span> 
                                   <span class="free"><span class="bound"><span class="entity">core</span></span></span> <span class="main">;-</span>   <span class="comment1">― ‹execute the body ›</span>
                                   unset_break_status <span class="main">;-</span>    <span class="comment1">― ‹unset a potential break ›</span>
                                   unset_return_status<span class="main">;-</span>    <span class="comment1">― ‹unset a potential return break ›</span>
                                   <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">pop</span></span></span><span class="main">;</span>           <span class="comment1">― ‹restore previous local var instances ›</span>
                                    <span class="keyword1">unit<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>        <span class="comment1">― ‹yield the return value ›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Based on this definition, the running <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>swap›</span></span></span></span> example is represented as follows:

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display]
<span class="raw_text"><span class="raw_text">‹definition swap_core :: "nat × nat ⇒  (unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap_core  ≡ (λ(i,j). ((assign_local tmp_update (λσ. A σ ! i ))   ;-
                            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;- 
                            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ)))))" 

definition swap :: "nat × nat ⇒  (unit,'a local_swap_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "swap ≡ λ(i,j). block<span class="hidden">⇩</span><sub>C</sub> push_local_swap_state (swap_core (i,j)) pop_local_swap_state"
›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Call Semantics›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹It is now straight-forward to define the semantics of a generic call --- 
which is simply a monad execution that is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹break›</span></span></span></span>-aware and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">return</span></span>›</span></span></span></span>-aware.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span>
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'α</span><span class="main">)</span> <span class="main">⇒</span>                        
                      <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">call<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span>undefined<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note that this presentation assumes a uncurried format of the arguments. The 
question arises if this is the right approach to handle calls of operation with multiple arguments.
Is it better to go for an some appropriate currying principle? Here are 
 some more experimental variants for curried operations...
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call_0<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">call_0<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span>undefined<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="bound">σ</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The generic version using tuples is identical with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">call_1<span class="hidden">⇩</span><sub>C</sub></span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call_1<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span>
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'α</span><span class="main">)</span> <span class="main">⇒</span>                        
                      <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>                                                      
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">call_1<span class="hidden">⇩</span><sub>C</sub></span>  <span class="main">=</span> call<span class="hidden">⇩</span><sub>C</sub>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call_2<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span>
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'α</span><span class="main">)</span> <span class="main">⇒</span>                        
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'β</span><span class="main">)</span> <span class="main">⇒</span>      
                      <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">call_2<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span>undefined<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call_3<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'β</span> <span class="main">⇒</span>  <span class="tfree">'γ</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span> <span class="main">⇒</span>
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'α</span><span class="main">)</span> <span class="main">⇒</span>                        
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'β</span><span class="main">)</span> <span class="main">⇒</span>      
                       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'γ</span><span class="main">)</span> <span class="main">⇒</span>      
                      <span class="main">(</span><span class="tfree">'ρ</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">call_3<span class="hidden">⇩</span><sub>C</sub></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>3</sub></span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span>undefined<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> 
                                                   <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A<span class="hidden">⇩</span><sub>3</sub></span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>

<span class="comment1">(* and 4 and 5 and ... *)</span>                        
  

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Some Term-Coding Functions ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the following, we add a number of advanced HOL-term constructors in the style of 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">ML_structure</span></span> "HOLogic"<span class="antiquote"><span class="antiquote">}</span></span></span></span> from the Isabelle/HOL libraries. They incorporate the construction
of types during term construction in a bottom-up manner. Consequently, the leafs of such
terms should always be typed, and anonymous loose-<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">ML</span></span> "Bound"<span class="antiquote"><span class="antiquote">}</span></span></span></span> variables avoided.›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="comment1">(* HOLogic extended *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_None</span> <span class="entity">ty</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">none</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Option.option.None›</span>
                     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">none_ty</span> <span class="main">=</span> <span class="entity">ty</span> --&gt; Type<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹option›</span><span class="main">,</span><span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>  Const<span class="main">(</span><span class="entity">none</span><span class="main">,</span> <span class="entity">none_ty</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Some</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Option.option.Some›</span> 
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">t</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some_ty</span> <span class="main">=</span> <span class="entity">ty</span> --&gt; Type<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹option›</span><span class="main">,</span><span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>  Const<span class="main">(</span><span class="entity">some</span><span class="main">,</span> <span class="entity">some_ty</span><span class="main">)</span> $ <span class="entity">t</span>
                <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_listTy</span> <span class="main">(</span>Type<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹List.list›</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">T</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_hdT</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">t</span> 
               <span class="keyword2"><span class="keyword">in</span></span>  Const<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹List.hd›</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="main">(</span><span class="entity">dest_listTy</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tlT</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">t</span> 
               <span class="keyword2"><span class="keyword">in</span></span>  Const<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹List.tl›</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span><span class="main">)</span> $ <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span>  <span class="entity">mk_undefined</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"unit"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Product_Type.Unity›</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹unit›</span></span><span class="main">)</span>
    <span class="main">|</span><span class="entity">mk_undefined</span> <span class="entity">t</span>               <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹HOL.undefined›</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">meta_eq_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Pure.eq›</span><span class="main">,</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; propT<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_meta_eq</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">meta_eq_const</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> $ <span class="entity">t</span> $ <span class="entity">u</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span>   <span class="entity">mk_pat_tupleabs</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>
    <span class="main">|</span> <span class="entity">mk_pat_tupleabs</span> <span class="main">[</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span><span class="main">]</span> <span class="entity">t</span> <span class="main">=</span> absfree<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span><span class="main">(</span><span class="entity">t</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">mk_pat_tupleabs</span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span>::<span class="entity">R</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">HOLogic.mk_case_prod</span><span class="main">(</span>absfree<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span><span class="main">(</span><span class="entity">mk_pat_tupleabs</span> <span class="entity">R</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="entity">n</span> <span class="main">=</span> fst<span class="main">(</span>dest_Const<span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">wfrecT</span> <span class="entity">order</span> <span class="entity">recs</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">funT</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">recs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aTy</span>  <span class="main">=</span> domain_type <span class="entity">funT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ordTy</span> <span class="main">=</span> <span class="entity">HOLogic.mk_setT</span><span class="main">(</span><span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">aTy</span><span class="main">,</span><span class="entity">aTy</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> Const<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Wfrec.wfrec›</span><span class="main">,</span> <span class="entity">ordTy</span> --&gt; <span class="main">(</span><span class="entity">funT</span> --&gt; <span class="entity">funT</span><span class="main">)</span> --&gt; <span class="entity">funT</span><span class="main">)</span> $ <span class="entity">order</span> $ <span class="entity">recs</span> <span class="keyword2"><span class="keyword">end</span></span>


›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹And here comes the core of the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹Clean›</span></span></span></span>-State-Management: the module that provides the 
functionality for the commands keywords <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">global_vars</span></span></span></span>›</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">local_vars</span></span></span></span>›</span></span></span></span>  and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">local_vars_test</span></span></span></span>›</span></span></span></span>.
Note that the difference between <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">local_vars</span></span></span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">local_vars_test</span></span></span></span>›</span></span></span></span> is just a technical one:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">local_vars</span></span></span></span>›</span></span></span></span> can only be used inside a Clean function specification, made with the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">function_spec</span></span></span></span>›</span></span></span></span>
command. On the other hand, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">local_vars_test</span></span></span></span>›</span></span></span></span> is defined as a global Isar command for test purposes. 

A particular feature of the local-variable management is the provision of definitions for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">push</span></span>›</span></span></span></span>
and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">pop</span></span>›</span></span></span></span> operations --- encoded as <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'o</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'σ</span></span><span class="main"><span class="main">)</span></span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>›</span></span></span></span> operations --- which are vital for
the function specifications defined below.
›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">StateMgt</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> StateMgt_core

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result_name</span> <span class="main">=</span> <span class="inner_quoted">"result_value"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_result_value_conf</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> 
        <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span>  <span class="entity">S</span> <span class="main">=</span> <span class="entity">filter_attr_of</span> <span class="entity">name</span> <span class="entity">thy</span>
        <span class="keyword2"><span class="keyword">in</span></span>  hd<span class="main">(</span>filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">b</span> <span class="main">=</span> <span class="entity">result_name</span><span class="main">)</span> <span class="entity">S</span><span class="main">)</span> 
            <span class="keyword3"><span class="keyword">handle</span></span> Empty <span class="main">=&gt;</span> error <span class="inner_quoted">"internal error: get_result_value_conf "</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span> 


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_lookup_result_value_term</span> <span class="entity">name</span> <span class="entity">sty</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">prefix</span><span class="main">,</span><span class="entity">name</span><span class="main">)</span><span class="main">,</span><span class="entity">local_var</span><span class="main">(</span>Type<span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_result_value_conf</span> <span class="entity">name</span> <span class="entity">thy</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">long_name</span> <span class="main">=</span> Sign.intern_const <span class="entity">thy</span> <span class="main">(</span><span class="entity">prefix</span>^<span class="inner_quoted">"."</span>^<span class="entity">name</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> Const<span class="main">(</span><span class="entity">long_name</span><span class="main">,</span> <span class="entity">sty</span> --&gt; <span class="entity">ty</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">mk_hdT</span> <span class="main">(</span><span class="entity">term</span> $ Free<span class="main">(</span><span class="inner_quoted">"σ"</span><span class="main">,</span><span class="entity">sty</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span>  <span class="entity">map_to_update</span> <span class="entity">sty</span> <span class="entity">is_pop</span> <span class="entity">thy</span> <span class="main">(</span><span class="main">(</span><span class="entity">struct_name</span><span class="main">,</span> <span class="entity">attr_name</span><span class="main">)</span><span class="main">,</span> <span class="entity">local_var</span> <span class="main">(</span>Type<span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span><span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">term</span> <span class="main">=</span> 
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tlT</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_pop</span> <span class="keyword2"><span class="keyword">then</span></span> Const<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹List.tl›</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span><span class="main">)</span>
                     <span class="keyword2"><span class="keyword">else</span></span> Const<span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹List.Cons›</span><span class="main">,</span> <span class="entity">dest_listTy</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span> --&gt; <span class="entity">ty</span><span class="main">)</span>
                          $ <span class="entity">mk_undefined</span> <span class="main">(</span><span class="entity">dest_listTy</span> <span class="entity">ty</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">update_name</span> <span class="main">=</span> Sign.intern_const  <span class="entity">thy</span> <span class="main">(</span><span class="entity">struct_name</span>^<span class="inner_quoted">"."</span>^<span class="entity">attr_name</span>^<span class="inner_quoted">"_update"</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Const<span class="main">(</span><span class="entity">update_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">ty</span> --&gt; <span class="entity">ty</span><span class="main">)</span> --&gt; <span class="entity">sty</span> --&gt; <span class="entity">sty</span><span class="main">)</span> $ <span class="entity">tlT</span><span class="main">)</span> $ <span class="entity">term</span> <span class="keyword2"><span class="keyword">end</span></span>
   <span class="main">|</span> <span class="entity">map_to_update</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">_</span> <span class="main">=</span> error<span class="main">(</span><span class="inner_quoted">"internal error map_to_update"</span><span class="main">)</span>     

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_local_state_name</span> <span class="entity">binding</span> <span class="main">=</span> 
       Binding.prefix_name <span class="inner_quoted">"local_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_state"</span> <span class="entity">binding</span><span class="main">)</span>  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_global_state_name</span> <span class="entity">binding</span> <span class="main">=</span> 
       Binding.prefix_name <span class="inner_quoted">"global_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_state"</span> <span class="entity">binding</span><span class="main">)</span>  

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">construct_update</span> <span class="entity">is_pop</span> <span class="entity">binding</span> <span class="entity">sty</span> <span class="entity">thy</span> <span class="main">=</span> 
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">long_name</span> <span class="main">=</span> Binding.name_of<span class="main">(</span> <span class="entity">binding</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attrS</span> <span class="main">=</span> <span class="entity">StateMgt_core.filter_attr_of</span> <span class="entity">long_name</span> <span class="entity">thy</span>
       <span class="keyword2"><span class="keyword">in</span></span>  fold <span class="main">(</span><span class="entity">map_to_update</span> <span class="entity">sty</span> <span class="entity">is_pop</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">attrS</span><span class="main">)</span> <span class="main">(</span>Free<span class="main">(</span><span class="inner_quoted">"σ"</span><span class="main">,</span><span class="entity">sty</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cmd</span> <span class="main">(</span><span class="entity">decl</span><span class="main">,</span> <span class="entity">spec</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> oo <span class="entity">Specification.definition'</span> <span class="entity">decl</span> <span class="entity">params</span> <span class="entity">prems</span> <span class="entity">spec</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_push_name</span> <span class="entity">binding</span> <span class="main">=</span> Binding.prefix_name <span class="inner_quoted">"push_"</span> <span class="entity">binding</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">push_eq</span> <span class="entity">binding</span>  <span class="entity">name_op</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">lthy</span> <span class="main">=</span> 
         <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mty</span> <span class="main">=</span> <span class="entity">MON_SE_T</span> <span class="entity">rty</span> <span class="entity">sty</span> 
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> <span class="entity">construct_update</span> false <span class="entity">binding</span> <span class="entity">sty</span> <span class="entity">thy</span>
         <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">mk_meta_eq</span><span class="main">(</span><span class="main">(</span>Free<span class="main">(</span><span class="entity">name_op</span><span class="main">,</span> <span class="entity">mty</span><span class="main">)</span> $ Free<span class="main">(</span><span class="inner_quoted">"σ"</span><span class="main">,</span><span class="entity">sty</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                         <span class="entity">mk_Some</span> <span class="main">(</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">mk_undefined</span> <span class="entity">rty</span><span class="main">,</span><span class="entity">term</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                          
         <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_push_def</span> <span class="entity">binding</span> <span class="entity">sty</span> <span class="entity">lthy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name_pushop</span> <span class="main">=</span>  <span class="entity">mk_push_name</span> <span class="entity">binding</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rty</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹unit›</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">push_eq</span> <span class="entity">binding</span>  <span class="main">(</span>Binding.name_of <span class="entity">name_pushop</span><span class="main">)</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mty</span> <span class="main">=</span> <span class="entity">StateMgt_core.MON_SE_T</span> <span class="entity">rty</span> <span class="entity">sty</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span>SOME<span class="main">(</span><span class="entity">name_pushop</span><span class="main">,</span> SOME <span class="entity">mty</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span><span class="entity">eq</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">cmd</span> <span class="entity">args</span> true <span class="entity">lthy</span>  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pop_name</span> <span class="entity">binding</span> <span class="main">=</span> Binding.prefix_name <span class="inner_quoted">"pop_"</span>  <span class="entity">binding</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pop_eq</span>  <span class="entity">binding</span> <span class="entity">name_op</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">lthy</span> <span class="main">=</span> 
         <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mty</span> <span class="main">=</span> <span class="entity">MON_SE_T</span> <span class="entity">rty</span> <span class="entity">sty</span> 
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_access</span> <span class="main">=</span> <span class="entity">mk_lookup_result_value_term</span> <span class="main">(</span>Binding.name_of <span class="entity">binding</span><span class="main">)</span> <span class="entity">sty</span> <span class="entity">thy</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> <span class="entity">construct_update</span> true <span class="entity">binding</span>  <span class="entity">sty</span> <span class="entity">thy</span>                 
         <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">mk_meta_eq</span><span class="main">(</span><span class="main">(</span>Free<span class="main">(</span><span class="entity">name_op</span><span class="main">,</span> <span class="entity">mty</span><span class="main">)</span> $ Free<span class="main">(</span><span class="inner_quoted">"σ"</span><span class="main">,</span><span class="entity">sty</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                         <span class="entity">mk_Some</span> <span class="main">(</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">res_access</span><span class="main">,</span><span class="entity">term</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>                          
         <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pop_def</span> <span class="entity">binding</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">lthy</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mty</span> <span class="main">=</span> <span class="entity">StateMgt_core.MON_SE_T</span> <span class="entity">rty</span> <span class="entity">sty</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name_op</span> <span class="main">=</span>  <span class="entity">mk_pop_name</span> <span class="entity">binding</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">pop_eq</span> <span class="entity">binding</span> <span class="main">(</span>Binding.name_of <span class="entity">name_op</span><span class="main">)</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span>SOME<span class="main">(</span><span class="entity">name_op</span><span class="main">,</span> SOME <span class="entity">mty</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span><span class="entity">eq</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">cmd</span> <span class="entity">args</span> true <span class="entity">lthy</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_parent</span> NONE <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">read_parent</span> <span class="main">(</span>SOME <span class="entity">raw_T</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Proof_Context.read_typ_abbrev <span class="entity">ctxt</span> <span class="entity">raw_T</span> <span class="keyword2"><span class="keyword">of</span></span>
        Type <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>SOME <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">name</span><span class="main">)</span><span class="main">,</span> fold Variable.declare_typ <span class="entity">Ts</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">T</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Bad parent record specification: "</span> ^ Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_fields</span> <span class="entity">raw_fields</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> Syntax.read_typs <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">raw_T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">raw_T</span><span class="main">)</span> <span class="entity">raw_fields</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fields</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_fields</span> <span class="entity">Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold Variable.declare_typ <span class="entity">Ts</span> <span class="entity">ctxt</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">fields</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_typ_'a</span> <span class="entity">ctxt</span> <span class="entity">binding</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_bind</span> <span class="main">=</span>  Binding.prefix_name <span class="inner_quoted">"'a "</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_scheme"</span> <span class="entity">binding</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">case</span></span> Syntax.parse_typ <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">ty_bind</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
       Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>type"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>
     <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Unexpected type"</span> ^ Position.here <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_record_cmd0</span> <span class="entity">read_fields</span> <span class="entity">overloaded</span> <span class="entity">is_global_kind</span> <span class="entity">raw_params</span> <span class="entity">binding</span> <span class="entity">raw_parent</span> <span class="entity">raw_fields</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">Typedecl.read_constraint</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_params</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt1</span> <span class="main">=</span> fold <span class="main">(</span>Variable.declare_typ o TFree<span class="main">)</span> <span class="entity">params</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">parent</span><span class="main">,</span> <span class="entity">ctxt2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_parent</span> <span class="entity">raw_parent</span> <span class="entity">ctxt1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fields</span><span class="main">,</span> <span class="entity">ctxt3</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_fields</span> <span class="entity">raw_fields</span> <span class="entity">ctxt2</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> <span class="main">=</span>  <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">HOLogic.listT</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fields'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_global_kind</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">fields</span> <span class="keyword2"><span class="keyword">else</span></span> map <span class="entity">lift</span> <span class="entity">fields</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params'</span> <span class="main">=</span> map <span class="main">(</span>Proof_Context.check_tfree <span class="entity">ctxt3</span><span class="main">)</span> <span class="entity">params</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">declare</span> <span class="main">=</span> <span class="entity">StateMgt_core.declare_state_variable_global</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd_state_typ</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
                                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Syntax.parse_typ <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">binding</span><span class="main">)</span>
                            <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">StateMgt_core.upd_state_type_global</span><span class="main">(</span>K <span class="entity">ty</span><span class="main">)</span><span class="main">(</span><span class="entity">thy</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">insert_var</span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>           
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_global_kind</span>   
            <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">declare</span> <span class="entity">StateMgt_core.global_var</span> <span class="main">(</span>Binding.name_of <span class="entity">f</span><span class="main">)</span> <span class="entity">thy</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">declare</span> <span class="entity">StateMgt_core.local_var</span>  <span class="main">(</span>Binding.name_of <span class="entity">f</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_push_pop</span> <span class="entity">thy</span> <span class="main">=</span> 
            <span class="keyword2"><span class="keyword">if</span></span> not <span class="entity">is_global_kind</span> 
            <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sty</span> <span class="main">=</span> <span class="entity">parse_typ_'a</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">binding</span><span class="main">;</span>
                     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rty</span> <span class="main">=</span> <span class="entity">dest_listTy</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span><span class="main">(</span>hd<span class="main">(</span>rev <span class="entity">fields'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                 <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy</span>

                    |&gt; <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">mk_push_def</span> <span class="entity">binding</span> <span class="entity">sty</span><span class="main">)</span> 
                    |&gt; <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">mk_pop_def</span>  <span class="entity">binding</span> <span class="entity">rty</span> <span class="entity">sty</span><span class="main">)</span> 
                                                            
                 <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy</span> |&gt; <span class="entity">Record.add_record</span> <span class="entity">overloaded</span> <span class="main">(</span><span class="entity">params'</span><span class="main">,</span> <span class="entity">binding</span><span class="main">)</span> <span class="entity">parent</span> <span class="entity">fields'</span> 
         |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thy</span> <span class="main">=&gt;</span>  List.foldr <span class="entity">insert_var</span> <span class="main">(</span><span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">fields'</span><span class="main">)</span><span class="main">)</span>
         |&gt; <span class="entity">upd_state_typ</span>
         |&gt; <span class="entity">define_push_pop</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_2_string_raw</span> <span class="main">(</span>Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">[</span>TFree <span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> String.isSuffix <span class="inner_quoted">"_scheme"</span> <span class="entity">s</span>
                                            <span class="keyword2"><span class="keyword">then</span></span> Long_Name.base_name<span class="main">(</span>unsuffix <span class="inner_quoted">"_scheme"</span> <span class="entity">s</span><span class="main">)</span>
                                            <span class="keyword2"><span class="keyword">else</span></span> Long_Name.base_name<span class="main">(</span>unsuffix <span class="inner_quoted">"_ext"</span> <span class="entity">s</span><span class="main">)</span>
                                          
   <span class="main">|</span><span class="entity">typ_2_string_raw</span> <span class="main">(</span>Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
                         error <span class="main">(</span><span class="inner_quoted">"Illegal parameterized state type - not allowed in Clean:"</span>  ^ <span class="entity">s</span><span class="main">)</span> 
   <span class="main">|</span><span class="entity">typ_2_string_raw</span> <span class="main">_</span> <span class="main">=</span> error  <span class="inner_quoted">"Illegal state type - not allowed in Clean."</span> 
                                  
             
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">new_state_record0</span> <span class="entity">add_record_cmd</span> <span class="entity">is_global_kind</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">raw_params</span><span class="main">,</span> <span class="entity">binding</span><span class="main">)</span><span class="main">,</span> <span class="entity">res_ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_fields</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binding</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_global_kind</span> 
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_global_state_name</span> <span class="entity">binding</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_local_state_name</span> <span class="entity">binding</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_parent</span> <span class="main">=</span> SOME<span class="main">(</span><span class="entity">typ_2_string_raw</span> <span class="main">(</span><span class="entity">StateMgt_core.get_state_type_global</span> <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pos</span> <span class="main">=</span> Binding.pos_of <span class="entity">binding</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd_state_typ</span> <span class="entity">thy</span> <span class="main">=</span>
          <span class="entity">StateMgt_core.upd_state_type_global</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">parse_typ_'a</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">binding</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result_binding</span> <span class="main">=</span> Binding.make<span class="main">(</span><span class="entity">result_name</span><span class="main">,</span><span class="entity">pos</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_fields'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">res_ty</span> <span class="keyword2"><span class="keyword">of</span></span> 
                            NONE <span class="main">=&gt;</span> <span class="entity">raw_fields</span>
                          <span class="main">|</span> SOME <span class="entity">res_ty</span> <span class="main">=&gt;</span> <span class="entity">raw_fields</span> @ <span class="main">[</span><span class="main">(</span><span class="entity">result_binding</span><span class="main">,</span><span class="entity">res_ty</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">thy</span> |&gt; <span class="entity">add_record_cmd</span> <span class="main">{</span>overloaded <span class="main">=</span> false<span class="main">}</span> <span class="entity">is_global_kind</span> 
                              <span class="entity">raw_params</span> <span class="entity">binding</span> <span class="entity">raw_parent</span> <span class="entity">raw_fields'</span> 
            |&gt; <span class="entity">upd_state_typ</span> 

    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_record_cmd</span>    <span class="main">=</span> <span class="entity">add_record_cmd0</span> <span class="entity">read_fields</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_record_cmd'</span>   <span class="main">=</span> <span class="entity">add_record_cmd0</span> pair<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_state_record</span>  <span class="main">=</span> <span class="entity">new_state_record0</span> <span class="entity">add_record_cmd</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_state_record'</span> <span class="main">=</span> <span class="entity">new_state_record0</span> <span class="entity">add_record_cmd'</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> 
      <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">global_vars</span>›</span></span>   
      <span class="inner_quoted">"define global state record"</span>
      <span class="main">(</span><span class="main">(</span>Parse.type_args_constrained -- Parse.binding<span class="main">)</span>
    -- Scan.succeed NONE
    -- Scan.repeat1 Parse.const_binding
    &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">new_state_record</span> true<span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> 
      <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">local_vars_test</span>›</span></span>  
      <span class="inner_quoted">"define local state record"</span>
      <span class="main">(</span><span class="main">(</span>Parse.type_args_constrained -- Parse.binding<span class="main">)</span> 
    -- <span class="main">(</span>Parse.typ &gt;&gt; SOME<span class="main">)</span>
    -- Scan.repeat1 Parse.const_binding
    &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">new_state_record</span> false<span class="main">)</span><span class="main">)</span>
<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Syntactic Sugar supporting <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>λ›</span></span></span></span>-lifting for Global and Local Variables ›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Clean_Syntax_Lift</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword2"><span class="keyword">local</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_local_access</span> <span class="entity">X</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Fun.comp"<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> 
                            $ Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "List.list.hd"<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">X</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">app_sigma</span> <span class="entity">db</span> <span class="entity">tm</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const<span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">StateMgt_core.is_global_program_variable</span> <span class="entity">name</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> 
                          <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tm</span> $ <span class="main">(</span>Bound <span class="entity">db</span><span class="main">)</span> <span class="comment1">(* lambda lifting *)</span>
                          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">StateMgt_core.is_local_program_variable</span> <span class="entity">name</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> 
                               <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">mk_local_access</span> <span class="entity">tm</span><span class="main">)</span> $ <span class="main">(</span>Bound <span class="entity">db</span><span class="main">)</span> <span class="comment1">(* lambda lifting local *)</span>
                               <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tm</span>              <span class="comment1">(* no lifting *)</span>
      <span class="main">|</span> Free <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">tm</span>
      <span class="main">|</span> Var <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">tm</span>
      <span class="main">|</span> Bound <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &gt; <span class="entity">db</span> <span class="keyword2"><span class="keyword">then</span></span> Bound<span class="main">(</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> Bound <span class="entity">n</span> 
      <span class="main">|</span> Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">tm'</span><span class="main">)</span> <span class="main">=&gt;</span> Abs<span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">app_sigma</span> <span class="main">(</span><span class="entity">db</span>+<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">tm'</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">t1</span> $ <span class="entity">t2</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">app_sigma</span> <span class="entity">db</span> <span class="entity">t1</span> <span class="entity">ctxt</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">app_sigma</span> <span class="entity">db</span> <span class="entity">t2</span> <span class="entity">ctxt</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">scope_var</span> <span class="entity">name</span> <span class="main">=</span>
      Proof_Context.theory_of
      #&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thy</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">StateMgt_core.is_global_program_variable</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">then</span></span> SOME true
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">StateMgt_core.is_local_program_variable</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">then</span></span> SOME false
            <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assign_update</span> <span class="entity">var</span> <span class="main">=</span> <span class="entity">var</span> ^ <span class="entity">Record.updateN</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_term0</span> <span class="entity">abs</span> <span class="entity">scope_var</span> <span class="entity">tm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
         Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Clean.syntax_assign"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>
         $ <span class="main">(</span><span class="entity">t1</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="inner_quoted">"_type_constraint_"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span>
         $ <span class="entity">t2</span> <span class="main">=&gt;</span>
            Const <span class="main">(</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">scope_var</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
                      SOME true <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "assign_global"<span class="antiquote">}</span></span>
                    <span class="main">|</span> SOME false <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "assign_local"<span class="antiquote">}</span></span>
                    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"mk_assign"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t1</span><span class="main">]</span><span class="main">)</span>
                  <span class="main">,</span> dummyT<span class="main">)</span>
            $ Const<span class="main">(</span><span class="entity">assign_update</span> <span class="entity">name</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span>
            $ <span class="entity">abs</span> <span class="entity">t2</span>
       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">abs</span> <span class="entity">tm</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_term</span> <span class="entity">ctxt</span> <span class="entity">sty</span> <span class="main">=</span>
      <span class="entity">transform_term0</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tm</span> <span class="main">=&gt;</span> Abs <span class="main">(</span><span class="inner_quoted">"σ"</span><span class="main">,</span> <span class="entity">sty</span><span class="main">,</span> <span class="entity">app_sigma</span> <span class="inner_numeral">0</span> <span class="entity">tm</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span> <span class="main">=&gt;</span> <span class="entity">scope_var</span> <span class="entity">name</span> <span class="entity">ctxt</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_term'</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">transform_term</span> <span class="entity">ctxt</span> dummyT

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_tr</span> <span class="entity">ctxt</span> <span class="entity">content</span> <span class="entity">args</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">err</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"string_tr"</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">args</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="main">(</span>Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">p</span><span class="main">]</span> <span class="main">=&gt;</span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Term_Position.decode_position <span class="entity">p</span> <span class="keyword2"><span class="keyword">of</span></span>
              SOME <span class="main">(</span><span class="entity">pos</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Symbol_Pos.implode <span class="main">(</span><span class="entity">content</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">pos</span><span class="main">)</span><span class="main">)</span>
                            |&gt; Syntax.parse_term <span class="entity">ctxt</span>
                            |&gt; <span class="entity">transform_term</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">StateMgt_core.get_state_type</span> <span class="entity">ctxt</span><span class="main">)</span>
                            |&gt; Syntax.check_term <span class="entity">ctxt</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">err</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">err</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_cartouche_string"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cartouche_position <span class="main">⇒</span> string"</span></span>  <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
  <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_cartouche_string"<span class="antiquote">}</span></span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Clean_Syntax_Lift.string_tr</span> <span class="entity">ctxt</span> <span class="main">(</span>Symbol_Pos.cartouche_content o Symbol_Pos.explode<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
›</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Support for (direct recursive) Clean Function Specifications ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Based on the machinery for the State-Management and  implicitly cooperating with the 
cartouches for assignment syntax, the function-specification <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">function_spec</span></span></span></span>›</span></span></span></span>-package coordinates:
<span class="antiquoted"><span class="antiquoted">▸</span></span> the parsing and type-checking of parameters,
<span class="antiquoted"><span class="antiquoted">▸</span></span> the parsing and type-checking of pre and post conditions in MOAL notation
  (using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>λ›</span></span></span></span>-lifting cartouches and implicit reference to parameters, pre and post states),
<span class="antiquoted"><span class="antiquoted">▸</span></span> the parsing local variable section with the local-variable space generation,
<span class="antiquoted"><span class="antiquoted">▸</span></span> the parsing of the body in this extended variable space,
<span class="antiquoted"><span class="antiquoted">▸</span></span> and optionally the support of measures for recursion proofs.

The reader interested in details is referred to the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🗏</span></span>‹../examples/Quicksort_concept.thy›</span></span>-example,
accompanying this distribution.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">old</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">old</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>


<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ 
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹ 
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Function_Specification_Parser</span>  <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">struct</span></span>

    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">funct_spec_src</span> <span class="main">=</span> <span class="main">{</span>    
        binding<span class="main">:</span>  binding<span class="main">,</span>                         <span class="comment1">(* name *)</span>
        params<span class="main">:</span> <span class="main">(</span>binding*string<span class="main">)</span> list<span class="main">,</span>             <span class="comment1">(* parameters and their type*)</span>
        ret_type<span class="main">:</span> string<span class="main">,</span>                          <span class="comment1">(* return type; default unit *)</span>
        locals<span class="main">:</span> <span class="main">(</span>binding*string*mixfix<span class="main">)</span>list<span class="main">,</span>       <span class="comment1">(* local variables *)</span>
        pre_src<span class="main">:</span> string<span class="main">,</span>                           <span class="comment1">(* precondition src *)</span>
        post_src<span class="main">:</span> string<span class="main">,</span>                          <span class="comment1">(* postcondition src *)</span>
        variant_src<span class="main">:</span> string option<span class="main">,</span>                       <span class="comment1">(* variant src *)</span>
        body_src<span class="main">:</span> string * Position.T              <span class="comment1">(* body src *)</span>
      <span class="main">}</span>

    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">funct_spec_sem</span> <span class="main">=</span> <span class="main">{</span>    
        params<span class="main">:</span> <span class="main">(</span>binding*typ<span class="main">)</span> list<span class="main">,</span>                <span class="comment1">(* parameters and their type*)</span>
        ret_ty<span class="main">:</span> typ<span class="main">,</span>                               <span class="comment1">(* return type *)</span>
        pre<span class="main">:</span> term<span class="main">,</span>                                 <span class="comment1">(* precondition  *)</span>
        post<span class="main">:</span> term<span class="main">,</span>                                <span class="comment1">(* postcondition  *)</span>
        variant<span class="main">:</span> term option                       <span class="comment1">(* variant  *)</span>
      <span class="main">}</span>


    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_arg_decl</span> <span class="main">=</span> Parse.binding -- <span class="main">(</span>Parse.$$$ <span class="inner_quoted">"::"</span> |-- Parse.typ<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_param_decls</span> <span class="main">=</span> Args.parens <span class="main">(</span>Parse.enum <span class="inner_quoted">","</span> <span class="entity">parse_arg_decl</span><span class="main">)</span>
      
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_returns_clause</span> <span class="main">=</span> Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">returns</span>›</span></span> |--  Parse.typ<span class="main">)</span> <span class="inner_quoted">"unit"</span>
 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">locals_clause</span> <span class="main">=</span> <span class="main">(</span>Scan.optional <span class="main">(</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">local_vars</span>›</span></span> 
                                        -- <span class="main">(</span>Scan.repeat1 Parse.const_binding<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_proc_spec</span> <span class="main">=</span> <span class="main">(</span>
          Parse.binding 
       -- <span class="entity">parse_param_decls</span>
       -- <span class="entity">parse_returns_clause</span>
       --| <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">pre</span>›</span></span>             -- Parse.term 
       --| <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">post</span>›</span></span>            -- Parse.term 
       -- <span class="main">(</span>Scan.option  <span class="main">(</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">variant</span>›</span></span> |-- Parse.term<span class="main">)</span><span class="main">)</span>
       -- <span class="main">(</span>Scan.optional<span class="main">(</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">local_vars</span>›</span></span> |-- <span class="main">(</span>Scan.repeat1 Parse.const_binding<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       --| <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">defines</span>›</span></span>         -- <span class="main">(</span>Parse.position <span class="main">(</span>Parse.term<span class="main">)</span><span class="main">)</span> 
      <span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span><span class="entity">params</span><span class="main">)</span><span class="main">,</span><span class="entity">ret_ty</span><span class="main">)</span><span class="main">,</span><span class="entity">pre_src</span><span class="main">)</span><span class="main">,</span><span class="entity">post_src</span><span class="main">)</span><span class="main">,</span><span class="entity">variant_src</span><span class="main">)</span><span class="main">,</span><span class="entity">locals</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">body_src</span><span class="main">)</span> <span class="main">=&gt;</span> 
        <span class="main">{</span>
          binding <span class="main">=</span> <span class="entity">binding</span><span class="main">,</span> 
          params<span class="main">=</span><span class="entity">params</span><span class="main">,</span> 
          ret_type<span class="main">=</span><span class="entity">ret_ty</span><span class="main">,</span> 
          pre_src<span class="main">=</span><span class="entity">pre_src</span><span class="main">,</span> 
          post_src<span class="main">=</span><span class="entity">post_src</span><span class="main">,</span> 
          variant_src<span class="main">=</span><span class="entity">variant_src</span><span class="main">,</span>
          locals<span class="main">=</span><span class="entity">locals</span><span class="main">,</span>
          body_src<span class="main">=</span><span class="entity">body_src</span><span class="main">}</span> <span class="main">:</span> <span class="entity">funct_spec_src</span>
        <span class="main">)</span>

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_params</span> <span class="entity">params</span> <span class="entity">ctxt</span> <span class="main">=</span>
     <span class="keyword2"><span class="keyword">let</span></span>
       <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> Syntax.read_typs <span class="entity">ctxt</span> <span class="main">(</span>map snd <span class="entity">params</span><span class="main">)</span><span class="main">;</span>
     <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> fold Variable.declare_typ <span class="entity">Ts</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
   
   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_result</span> <span class="entity">ret_ty</span> <span class="entity">ctxt</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span> Syntax.read_typs <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">ret_ty</span><span class="main">]</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Variable.declare_typ <span class="entity">ty</span> <span class="entity">ctxt</span>           
          <span class="keyword2"><span class="keyword">in</span></span>  <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_function_spec</span> <span class="main">(</span><span class="main">{</span> <span class="entity">params</span><span class="main">,</span> <span class="entity">ret_type</span><span class="main">,</span> <span class="entity">variant_src</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">:</span> <span class="entity">funct_spec_src</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">params_Ts</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_params</span> <span class="entity">params</span> <span class="entity">ctxt</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rty</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_result</span> <span class="entity">ret_type</span> <span class="entity">ctxt'</span> 
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">variant</span> <span class="main">=</span> Option.map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt''</span><span class="main">)</span>  <span class="entity">variant_src</span>
       <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">{</span>params <span class="main">=</span> <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">params_Ts</span><span class="main">)</span><span class="main">,</span> ret_ty <span class="main">=</span> <span class="entity">rty</span><span class="main">,</span>variant <span class="main">=</span> <span class="entity">variant</span><span class="main">}</span><span class="main">,</span><span class="entity">ctxt''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span> 


   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_absence_old</span> <span class="entity">term</span> <span class="main">=</span> 
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "old"<span class="antiquote">}</span></span> <span class="keyword1"><span class="keyword">andalso</span></span> fst <span class="main">(</span>dest_Type <span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"fun"</span>
                                  <span class="keyword2"><span class="keyword">then</span></span> error<span class="main">(</span><span class="inner_quoted">"the old notation is not allowed here!"</span><span class="main">)</span>  
                                  <span class="keyword2"><span class="keyword">else</span></span> false
            <span class="keyword2"><span class="keyword">in</span></span>  exists_Const <span class="entity">test</span> <span class="entity">term</span> <span class="keyword2"><span class="keyword">end</span></span>
   
   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_old</span> <span class="entity">sty</span> <span class="entity">term</span> <span class="main">=</span> 
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span>  <span class="entity">transform_old0</span> <span class="main">(</span>Const<span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "old"<span class="antiquote">}</span></span><span class="main">,</span> Type <span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">term</span> <span class="main">)</span> 
                              <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term</span> <span class="keyword2"><span class="keyword">of</span></span>
                                  <span class="main">(</span>Const<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> $ Bound <span class="entity">x</span><span class="main">)</span> <span class="main">=&gt;</span>  <span class="main">(</span>Const<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> $ Bound <span class="main">(</span><span class="entity">x</span>+<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
                                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"illegal application of the old notation."</span><span class="main">)</span><span class="main">)</span>
               <span class="main">|</span><span class="entity">transform_old0</span> <span class="main">(</span><span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">transform_old0</span> <span class="entity">t1</span> $ <span class="entity">transform_old0</span> <span class="entity">t2</span>
               <span class="main">|</span><span class="entity">transform_old0</span> <span class="main">(</span>Abs<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">,</span><span class="entity">term</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ty</span><span class="main">,</span><span class="entity">transform_old0</span> <span class="entity">term</span><span class="main">)</span> 
               <span class="main">|</span><span class="entity">transform_old0</span> <span class="entity">term</span> <span class="main">=</span> <span class="entity">term</span>
       <span class="keyword2"><span class="keyword">in</span></span>  Abs<span class="main">(</span><span class="inner_quoted">"σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub>"</span><span class="main">,</span> <span class="entity">sty</span><span class="main">,</span> <span class="entity">transform_old0</span> <span class="entity">term</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
   
   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_cond</span> <span class="entity">binding</span> <span class="entity">f_sty</span> <span class="entity">transform_old</span> <span class="entity">src_suff</span> <span class="entity">check_absence_old</span> <span class="entity">params</span> <span class="entity">src</span> <span class="entity">ctxt</span> <span class="main">=</span> 
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">src'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">transform_old</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">src</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> 
                        Abs<span class="main">(</span><span class="entity">nn</span><span class="main">,</span> <span class="entity">sty_pre</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_pat_tupleabs</span> <span class="main">(</span>map <span class="main">(</span>apsnd <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">params</span><span class="main">)</span> <span class="main">(</span>Abs<span class="main">(</span><span class="entity">nn</span><span class="main">,</span><span class="entity">sty_pre</span><span class="comment1">(* sty root ! !*)</span><span class="main">,</span><span class="entity">term</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"define abstraction for result"</span> ^ Position.here <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg</span> <span class="main">=</span> Binding.suffix_name <span class="entity">src_suff</span> <span class="entity">binding</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">check_absence_old</span> <span class="entity">src'</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span>  <span class="entity">mk_meta_eq</span><span class="main">(</span>Free<span class="main">(</span>Binding.name_of <span class="entity">bdg</span><span class="main">,</span> <span class="entity">HOLogic.mk_tupleT</span><span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">params</span><span class="main">)</span> --&gt; <span class="entity">f_sty</span> <span class="entity">HOLogic.boolT</span><span class="main">)</span><span class="main">,</span><span class="entity">src'</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span>SOME<span class="main">(</span><span class="entity">bdg</span><span class="main">,</span>NONE<span class="main">,</span>NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span><span class="entity">eq</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> 
       <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">StateMgt.cmd</span> <span class="entity">args</span> true <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span>

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_precond</span> <span class="entity">binding</span> <span class="entity">sty</span> <span class="main">=</span>
     <span class="entity">define_cond</span> <span class="entity">binding</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">boolT</span> <span class="main">=&gt;</span> <span class="entity">sty</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> I <span class="inner_quoted">"_pre"</span> <span class="entity">check_absence_old</span>

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_postcond</span> <span class="entity">binding</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="main">=</span>
     <span class="entity">define_cond</span> <span class="entity">binding</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">boolT</span> <span class="main">=&gt;</span> <span class="entity">sty</span> --&gt; <span class="entity">sty</span> --&gt; <span class="entity">rty</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> <span class="main">(</span><span class="entity">transform_old</span> <span class="entity">sty</span><span class="main">)</span> <span class="inner_quoted">"_post"</span> I

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_body_core</span> <span class="entity">binding</span> <span class="entity">args_ty</span> <span class="entity">sty</span> <span class="entity">params</span> <span class="entity">body</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_core</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_core"</span> <span class="entity">binding</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_core_name</span> <span class="main">=</span> Binding.name_of <span class="entity">bdg_core</span>

           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">umty</span> <span class="main">=</span> <span class="entity">args_ty</span> --&gt; <span class="entity">StateMgt.MON_SE_T</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"unit"</span><span class="antiquote">}</span></span> <span class="entity">sty</span>

           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span><span class="main">(</span>Free <span class="main">(</span><span class="entity">bdg_core_name</span><span class="main">,</span> <span class="entity">umty</span><span class="main">)</span><span class="main">,</span><span class="entity">mk_pat_tupleabs</span><span class="main">(</span>map<span class="main">(</span>apsnd <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="entity">params</span><span class="main">)</span> <span class="entity">body</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_core</span> <span class="main">=</span><span class="main">(</span>SOME <span class="main">(</span><span class="entity">bdg_core</span><span class="main">,</span> SOME <span class="entity">umty</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

       <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">StateMgt.cmd</span> <span class="entity">args_core</span> true
       <span class="keyword2"><span class="keyword">end</span></span> 
 
   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_body_main</span> <span class="main">{</span>recursive <span class="main">=</span> <span class="entity">x</span><span class="main">:</span>bool<span class="main">}</span> <span class="entity">binding</span> <span class="entity">rty</span> <span class="entity">sty</span> <span class="entity">params</span> <span class="entity">variant_src</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">=</span> 
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">push_name</span> <span class="main">=</span> <span class="entity">StateMgt.mk_push_name</span> <span class="main">(</span><span class="entity">StateMgt.mk_local_state_name</span> <span class="entity">binding</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pop_name</span> <span class="main">=</span> <span class="entity">StateMgt.mk_pop_name</span> <span class="main">(</span><span class="entity">StateMgt.mk_local_state_name</span> <span class="entity">binding</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_core</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_core"</span> <span class="entity">binding</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_core_name</span> <span class="main">=</span> Binding.name_of <span class="entity">bdg_core</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_rec_name</span> <span class="main">=</span> Binding.name_of<span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_rec"</span> <span class="entity">binding</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bdg_ord_name</span> <span class="main">=</span> Binding.name_of<span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_order"</span> <span class="entity">binding</span><span class="main">)</span>

           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_ty</span> <span class="main">=</span> <span class="entity">HOLogic.mk_tupleT</span> <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">params</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params'</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">params</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rmty</span> <span class="main">=</span> <span class="entity">StateMgt_core.MON_SE_T</span> <span class="entity">rty</span> <span class="entity">sty</span> 

           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">umty</span> <span class="main">=</span> <span class="entity">StateMgt.MON_SE_T</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"unit"</span><span class="antiquote">}</span></span> <span class="entity">sty</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argsProdT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span><span class="main">(</span><span class="entity">args_ty</span><span class="main">,</span><span class="entity">args_ty</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argsRelSet</span> <span class="main">=</span> <span class="entity">HOLogic.mk_setT</span> <span class="entity">argsProdT</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">measure_term</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">variant_src</span> <span class="keyword2"><span class="keyword">of</span></span>
                                 NONE <span class="main">=&gt;</span> Free<span class="main">(</span><span class="entity">bdg_ord_name</span><span class="main">,</span><span class="entity">args_ty</span> --&gt; <span class="entity">HOLogic.natT</span><span class="main">)</span>
                               <span class="main">|</span> SOME <span class="entity">str</span> <span class="main">=&gt;</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span> |&gt; <span class="entity">mk_pat_tupleabs</span> <span class="entity">params'</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">measure</span> <span class="main">=</span>  Const<span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Wellfounded.measure"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">args_ty</span> --&gt; <span class="entity">HOLogic.natT</span><span class="main">)</span>
                                                                     --&gt; <span class="entity">argsRelSet</span> <span class="main">)</span>
                          $ <span class="entity">measure_term</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_main</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_none <span class="entity">variant_src</span>
                          <span class="keyword2"><span class="keyword">then</span></span> Free<span class="main">(</span>Binding.name_of <span class="entity">binding</span><span class="main">,</span> <span class="main">(</span><span class="entity">args_ty</span> --&gt; <span class="entity">HOLogic.natT</span><span class="main">)</span>
                                                                       --&gt; <span class="entity">args_ty</span> --&gt; <span class="entity">rmty</span><span class="main">)</span> $
                                         Free<span class="main">(</span><span class="entity">bdg_ord_name</span><span class="main">,</span> <span class="entity">args_ty</span> --&gt; <span class="entity">HOLogic.natT</span><span class="main">)</span>
                          <span class="keyword2"><span class="keyword">else</span></span> Free<span class="main">(</span>Binding.name_of <span class="entity">binding</span><span class="main">,</span> <span class="entity">args_ty</span> --&gt; <span class="entity">rmty</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_main</span> <span class="main">=</span> <span class="entity">mk_pat_tupleabs</span> <span class="entity">params'</span>
                          <span class="main">(</span>Const<span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Clean.block<span class="hidden">⇩</span><sub>C</sub>"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">umty</span> --&gt; <span class="entity">umty</span>  --&gt; <span class="entity">rmty</span> --&gt; <span class="entity">rmty</span><span class="main">)</span>
                          $ Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">push_name</span><span class="main">)</span><span class="main">,</span><span class="entity">umty</span><span class="main">)</span>
                          $ <span class="main">(</span>Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="entity">bdg_core_name</span><span class="main">,</span> <span class="entity">args_ty</span> --&gt; <span class="entity">umty</span><span class="main">)</span>  
                             $ <span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span>map Free <span class="entity">params'</span><span class="main">)</span><span class="main">)</span>
                          $ Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">pop_name</span><span class="main">)</span><span class="main">,</span><span class="entity">rmty</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_main_rec</span> <span class="main">=</span> <span class="entity">wfrecT</span> 
                              <span class="entity">measure</span> 
                              <span class="main">(</span>Abs<span class="main">(</span><span class="entity">bdg_rec_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">args_ty</span> --&gt; <span class="entity">umty</span><span class="main">)</span> <span class="main">,</span> 
                                   <span class="entity">mk_pat_tupleabs</span> <span class="entity">params'</span>
                                   <span class="main">(</span>Const<span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Clean.block<span class="hidden">⇩</span><sub>C</sub>"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">umty</span>--&gt;<span class="entity">umty</span>--&gt;<span class="entity">rmty</span>--&gt;<span class="entity">rmty</span><span class="main">)</span>
                                   $ Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">push_name</span><span class="main">)</span><span class="main">,</span><span class="entity">umty</span><span class="main">)</span>
                                   $ <span class="main">(</span>Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="entity">bdg_core_name</span><span class="main">,</span>
                                            <span class="main">(</span><span class="entity">args_ty</span> --&gt; <span class="entity">umty</span><span class="main">)</span> --&gt; <span class="entity">args_ty</span> --&gt; <span class="entity">umty</span><span class="main">)</span>  
                                      $ <span class="main">(</span>Bound <span class="main">(</span>length <span class="entity">params</span><span class="main">)</span><span class="main">)</span>
                                      $ <span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span>map Free <span class="entity">params'</span><span class="main">)</span><span class="main">)</span>
                                   $ Const<span class="main">(</span><span class="entity">read_constname</span> <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">pop_name</span><span class="main">)</span><span class="main">,</span><span class="entity">rmty</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_main</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span><span class="main">(</span><span class="entity">lhs_main</span><span class="main">,</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">rhs_main_rec</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">rhs_main</span> <span class="main">)</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_main</span> <span class="main">=</span> <span class="main">(</span>SOME<span class="main">(</span><span class="entity">binding</span><span class="main">,</span>NONE<span class="main">,</span>NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span><span class="entity">eq_main</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> 
       <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">ctxt</span> |&gt; <span class="entity">StateMgt.cmd</span> <span class="entity">args_main</span> true 
       <span class="keyword2"><span class="keyword">end</span></span> 


   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkNsem_function_spec</span> <span class="main">{</span>recursive <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span><span class="main">{</span>variant_src<span class="main">=</span>SOME <span class="main">_</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">_</span> <span class="main">=</span> 
                               error <span class="inner_quoted">"No measure required in non-recursive call"</span>
      <span class="main">|</span><span class="entity">checkNsem_function_spec</span> <span class="main">(</span><span class="entity">isrec</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span>recursive <span class="main">=</span> <span class="main">_</span><span class="main">:</span>bool<span class="main">}</span><span class="main">)</span> 
                               <span class="main">(</span><span class="entity">args</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">ret_type</span><span class="main">,</span> <span class="entity">variant_src</span><span class="main">,</span> <span class="entity">locals</span><span class="main">,</span> <span class="entity">body_src</span><span class="main">,</span> <span class="entity">pre_src</span><span class="main">,</span> <span class="entity">post_src</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">:</span> <span class="entity">funct_spec_src</span><span class="main">)</span>
                               <span class="entity">thy</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">theory_map</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="main">=</span>
             <span class="entity">Named_Target.theory_map_result</span>
               <span class="main">(</span>K <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">Named_Target.theory_map</span> o <span class="entity">f</span><span class="main">)</span><span class="main">)</span>
               <span class="main">(</span><span class="entity">read_function_spec</span> <span class="entity">args</span>
               #&gt; uncurry <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>params<span class="main">=</span><span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">,</span><span class="entity">ret_ty</span><span class="main">,</span>variant <span class="main">=</span> <span class="main">_</span><span class="main">}</span> <span class="main">=&gt;</span>
                            pair <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span>
                                  Proof_Context.add_fixes <span class="main">(</span>map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> SOME <span class="entity">T</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">params</span> <span class="entity">Ts</span><span class="main">)</span>
                                    <span class="comment1">(* this declares the parameters of a function specification
                                       as Free variables (overrides a possible constant declaration)
                                       and assigns the declared type to them *)</span>
                                  #&gt; uncurry <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">params'</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 3<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">b'</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">b'</span><span class="main">,</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">params'</span> <span class="entity">params</span> <span class="entity">Ts</span><span class="main">)</span> <span class="entity">ret_ty</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                <span class="entity">thy</span>
       <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">thy'</span> |&gt; <span class="entity">theory_map</span>
                     <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sty_old</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="entity">thy'</span>
                     <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">params</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ret_ty</span> <span class="main">=&gt;</span>
                         <span class="entity">define_precond</span> <span class="entity">binding</span> <span class="entity">sty_old</span> <span class="entity">params</span> <span class="entity">pre_src</span>
                      #&gt; <span class="entity">define_postcond</span> <span class="entity">binding</span> <span class="entity">ret_ty</span> <span class="entity">sty_old</span> <span class="entity">params</span> <span class="entity">post_src</span> <span class="keyword2"><span class="keyword">end</span></span>
                |&gt; <span class="entity">StateMgt.new_state_record</span> false <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="entity">binding</span><span class="main">)</span><span class="main">,</span> SOME <span class="entity">ret_type</span><span class="main">)</span><span class="main">,</span><span class="entity">locals</span><span class="main">)</span>
                |&gt; <span class="entity">theory_map</span>
                         <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">params</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ret_ty</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
                          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sty</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type</span> <span class="entity">ctxt</span>
                              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_ty</span> <span class="main">=</span> <span class="entity">HOLogic.mk_tupleT</span> <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">params</span><span class="main">)</span>
                              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mon_se_ty</span> <span class="main">=</span> <span class="entity">StateMgt_core.MON_SE_T</span> <span class="entity">ret_ty</span> <span class="entity">sty</span>
                              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span>
                                <span class="keyword2"><span class="keyword">if</span></span> <span class="main">#</span>recursive <span class="entity">isrec</span> <span class="keyword2"><span class="keyword">then</span></span>
                                  Proof_Context.add_fixes 
                                    <span class="main">[</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">args_ty</span> --&gt; <span class="entity">mon_se_ty</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span> <span class="entity">ctxt</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
                                <span class="keyword2"><span class="keyword">else</span></span>
                                  <span class="entity">ctxt</span>
                              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt'</span> <span class="main">(</span>fst <span class="entity">body_src</span><span class="main">)</span>
                          <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">ctxt'</span> |&gt; <span class="entity">define_body_core</span> <span class="entity">binding</span> <span class="entity">args_ty</span> <span class="entity">sty</span> <span class="entity">params</span> <span class="entity">body</span>
                          <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
                |&gt; <span class="entity">theory_map</span>
                         <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">params</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ret_ty</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
                          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sty</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type</span> <span class="entity">ctxt</span>
                              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="main">(</span>fst <span class="entity">body_src</span><span class="main">)</span>
                          <span class="keyword2"><span class="keyword">in</span></span>  <span class="entity">ctxt</span> |&gt; <span class="entity">define_body_main</span> <span class="entity">isrec</span> <span class="entity">binding</span> <span class="entity">ret_ty</span> <span class="entity">sty</span> <span class="entity">params</span> <span class="entity">variant_src</span> <span class="entity">body</span>
                          <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

  
   <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
     <span class="entity">Outer_Syntax.command</span> 
         <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">function_spec</span>›</span></span>   
         <span class="inner_quoted">"define Clean function specification"</span>
         <span class="main">(</span><span class="entity">parse_proc_spec</span> &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">checkNsem_function_spec</span> <span class="main">{</span>recursive <span class="main">=</span> false<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
   
   <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
     <span class="entity">Outer_Syntax.command</span> 
         <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">rec_function_spec</span>›</span></span>   
         <span class="inner_quoted">"define recursive Clean function specification"</span>
         <span class="main">(</span><span class="entity">parse_proc_spec</span> &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">checkNsem_function_spec</span> <span class="main">{</span>recursive <span class="main">=</span> true<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The Rest of Clean: Break/Return aware Version of If, While, etc.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">if_C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext <span class="main">⇒</span> bool<span class="main">,</span> 
                      <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span> 
                      <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">if_C</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> 
                              <span class="keyword1">then</span> Some<span class="main">(</span>undefined<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span>  <span class="comment1">― ‹state unchanged, return arbitrary›</span>
                              <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">σ</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="bound">σ</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="bound">σ</span><span class="main">)</span>"</span></span>     

<span class="keyword1"><span class="command">syntax</span></span>    <span class="main">(</span>xsymbols<span class="main">)</span>
          <span class="quoted">"_if_SECLEAN"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span><span class="main">(</span><span class="tfree">'o</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">,</span><span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o'</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
          <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> _ <span class="keyword1">then</span> _ <span class="keyword1">else</span> _<span class="keyword1">fi</span><span class="keyword3">)</span>"</span> <span class="main">[</span>5<span class="main">,</span>8<span class="main">,</span>8<span class="main">]</span>8<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span> 
          <span class="quoted">"<span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">then</span> <span class="free">T1</span> <span class="keyword1">else</span> <span class="free">T2</span> <span class="keyword1">fi</span><span class="main">)</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> Clean.if_C <span class="free">cond</span> <span class="free">T1</span> <span class="free">T2</span>"</span>

          
          
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">while_C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext <span class="main">⇒</span> bool<span class="main">)</span> 
                        <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> 
                        <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">while_C</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">if</span> exec_stop <span class="bound">σ</span> <span class="keyword1">then</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span>
                               <span class="keyword1">else</span> <span class="main">(</span><span class="main">(</span>MonadSE.while_SE <span class="main">(</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">σ</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">;-</span> 
                                     unset_break_status<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">syntax</span></span>    <span class="main">(</span>xsymbols<span class="main">)</span>
          <span class="quoted">"_while_C"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">,</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span> 
          <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> _ <span class="keyword1">do</span> _ <span class="keyword1">od</span><span class="keyword3">)</span>"</span> <span class="main">[</span>8<span class="main">,</span>8<span class="main">]</span>8<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span> 
          <span class="quoted">"<span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">c</span> <span class="keyword1">do</span> <span class="free">b</span> <span class="keyword1">od</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> Clean.while_C <span class="free">c</span> <span class="free">b</span>"</span>

  

<span class="keyword2"><span class="keyword">end</span></span>

  
  </pre>
</div><div id="Hoare_MonadSE">
<div class="head">
<h1>Theory Hoare_MonadSE</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * Basic Hoare Calculus for the State Exception Monad 
 *
 * Authors : Burkhart Wolff
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Hoare_MonadSE
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Symbex_MonadSE.html">Symbex_MonadSE</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Hoare›</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hoare<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">⦃</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">⦄</span><span class="keyword3">/ </span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">/ </span><span class="keyword1">⦃</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">⦄</span><span class="keyword3">)</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">=&gt;</span> False <span class="main">|</span> Some<span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">x</span> <span class="bound">σ'</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hoare<span class="hidden">⇩</span><sub>3</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">⦃</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">⦄</span><span class="keyword3">/ </span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">/</span><span class="keyword1">†</span><span class="keyword3">)</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main"><span class="free">†</span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">=&gt;</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">=&gt;</span> False<span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic rules›</span></span> 
  
<span class="keyword1" id="Hoare_MonadSE-skip"><span class="command">lemma</span></span> skip<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1" id="Hoare_MonadSE-fail"><span class="command">lemma</span></span> fail<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="keyword1">fail<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">†</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>'_def fail_SE_def unit_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_MonadSE-assert"><span class="command">lemma</span></span> assert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="main">⦃</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">⦄</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def assert_SE_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_MonadSE-assert_conseq"><span class="command">lemma</span></span> assert_conseq<span class="main">:</span> <span class="quoted"><span class="quoted">"Collect <span class="free">P</span> <span class="main">⊆</span> Collect <span class="free">Q</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">Q</span> <span class="main">⦃</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">⦄</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def assert_SE_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_MonadSE-assume_conseq"><span class="command">lemma</span></span> assume_conseq<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">Q</span> <span class="main">⦃</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="free">Q</span><span class="main">⦄</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def assume_SE_def unit_SE_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="main"><span class="main">:</span></span> someI2<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹assignment missing in the calculus because this is viewed as a state specific  
       operation, definable for concrete instances of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'σ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generalized and special sequence rules›</span></span> 
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The decisive idea is to factor out the post-condition on the results of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">M</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> :›</span></span>
<span class="keyword1" id="Hoare_MonadSE-sequence"><span class="command">lemma</span></span> sequence <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">A</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">⦄</span>
   <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">⦃</span><span class="free">Q</span> <span class="bound">x</span><span class="main">⦄</span> <span class="free">M'</span> <span class="bound">x</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span> 
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def bind_SE_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>

<span class="keyword1" id="Hoare_MonadSE-sequence_irpt_l"><span class="command">lemma</span></span> sequence_irpt_l <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">†</span>  <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span> <span class="main">†</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>

<span class="keyword1" id="Hoare_MonadSE-sequence_irpt_r"><span class="command">lemma</span></span> sequence_irpt_r <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">A</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">⦃</span><span class="free">Q</span> <span class="bound">x</span><span class="main">⦄</span> <span class="free">M'</span> <span class="bound">x</span> <span class="main">†</span>  <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">M</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span> <span class="main">†</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>'_def hoare<span class="hidden">⇩</span><sub>3</sub>_def bind_SE_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>
        
<span class="keyword1" id="Hoare_MonadSE-sequence'"><span class="command">lemma</span></span> sequence' <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">Q</span> <span class="main">⦄</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span> <span class="free">M'</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span>"</span></span>     
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>_def bind_SE_def bind_SE'_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>

<span class="keyword1" id="Hoare_MonadSE-sequence_irpt_l'"><span class="command">lemma</span></span> sequence_irpt_l' <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">†</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span> <span class="main">†</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def bind_SE'_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>
    
<span class="keyword1" id="Hoare_MonadSE-sequence_irpt_r'"><span class="command">lemma</span></span> sequence_irpt_r' <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">Q</span> <span class="main">⦄</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span> <span class="free">M'</span> <span class="main">†</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span> <span class="main">†</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>'_def hoare<span class="hidden">⇩</span><sub>3</sub>_def bind_SE_def bind_SE'_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Generalized and special consequence rules›</span></span>  
<span class="keyword1" id="Hoare_MonadSE-consequence"><span class="command">lemma</span></span> consequence <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    Collect <span class="free">P</span> <span class="main">⊆</span> Collect <span class="free">P'</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">A</span> <span class="main">∧</span> <span class="free">Q'</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">⦄</span> 
   <span class="main">⟹</span> <span class="main">∀</span> <span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> Collect<span class="main">(</span><span class="free">Q'</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⊆</span> Collect <span class="main">(</span><span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">A</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def bind_SE_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">σ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.option.split_asm Option.option.split<span class="main">)</span>

<span class="keyword1" id="Hoare_MonadSE-consequence_unit"><span class="command">lemma</span></span> consequence_unit <span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">P'</span> <span class="bound">σ</span><span class="main">)</span>"</span></span> 
   <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span>unit<span class="main">.</span> <span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span>  <span class="free">Q'</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span> 
   <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="main">⋀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">Q'</span>  <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">Q</span>  <span class="bound">σ</span><span class="main">)</span>"</span></span> 
   <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">Q</span>  <span class="bound">σ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span>unit<span class="main">.</span> <span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>UNIV <span class="main">∧</span> <span class="free">Q</span>  <span class="bound">σ</span><span class="main">)</span> "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> *<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span>  P' <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">P'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Q' <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">%</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">Q'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> consequence<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_mono assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_mono assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Hoare_MonadSE-consequence_irpt"><span class="command">lemma</span></span> consequence_irpt <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    Collect <span class="free">P</span> <span class="main">⊆</span> Collect <span class="free">P'</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">†</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span>  <span class="free">M</span> <span class="main">†</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def  
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Hoare_MonadSE-consequence_mt_swap"><span class="command">lemma</span></span> consequence_mt_swap <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">⦄</span> <span class="free">M</span> <span class="main">†</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Condition rules›</span></span> 
  
<span class="keyword1" id="Hoare_MonadSE-cond"><span class="command">lemma</span></span> cond <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M'</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>  
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">then</span> <span class="free">M</span> <span class="keyword1">else</span> <span class="free">M'</span> <span class="keyword1">fi</span><span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def if_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Hoare_MonadSE-cond_irpt"><span class="command">lemma</span></span> cond_irpt <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">†</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M'</span> <span class="main">†</span>  
   <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">then</span> <span class="free">M</span> <span class="keyword1">else</span> <span class="free">M'</span> <span class="keyword1">fi</span> <span class="main">†</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def if_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Note that the other four combinations can be directly derived via
       the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> consequence_mt_swap<span class="antiquote"><span class="antiquote">}</span></span></span></span> rule.›</span></span>
  
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹While rules›</span></span> 
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The only non-trivial proof is, of course, the while loop rule. Note
that non-terminating loops were mapped to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">None</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> following the principle
that our monadic state-transformers represent partial functions in the mathematical 
sense.›</span></span>
  
<span class="keyword1" id="Hoare_MonadSE-while"><span class="command">lemma</span></span> while <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>  <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> measure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">M</span> <span class="bound">σ</span> <span class="main">≠</span> None <span class="main">∧</span> <span class="free">f</span><span class="main">(</span>snd<span class="main">(</span>the<span class="main">(</span><span class="free">M</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="bound">σ</span><span class="main">)</span><span class="main">::</span>nat<span class="main">)</span> "</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>        <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span><span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>

<span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def if_SE_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">σ</span> <span class="main">≤</span> <span class="bound">n</span> <span class="main">⟶</span>  
                     <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="bound">σ</span> <span class="keyword1">of</span> 
                          None <span class="main">⇒</span> False
                        <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span>"</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> n<span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">n</span></span></span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span>"</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> while_SE_unfold<span class="main">)</span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> gr_implies_not0 if_SE_def  measure option.case_eq_if 
                     option.sel option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> prod.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> split_def unit_SE_def<span class="main">)</span>
     <span class="keyword1"><span class="command">next</span></span>
       <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">" <span class="var">?P</span> <span class="skolem">n</span> <span class="main">⟹</span> <span class="var">?P</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">subst</span> while_SE_unfold<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">cond</span> <span class="improper">σ</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_SE_def unit_SE_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_SE_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="improper">σ</span> <span class="main">=</span> None"</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command">using</span></span> measure <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_SE'_def bind_SE_def<span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
          <span class="keyword3"><span class="command">assume</span></span> 1 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="skolem">σ</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span>  2 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="skolem">σ</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">σ'</span><span class="main">)</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span>  3 <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">P</span> <span class="skolem">σ</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span>  4 <span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="skolem">σ</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span>  hyp <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">n</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> 5 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">σ'</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> * 1 2 3 case_prodD hoare<span class="hidden">⇩</span><sub>3</sub>_def option.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">have</span></span> 6 <span class="main">:</span> <span class="quoted"><span class="quoted">"snd<span class="main">(</span>the<span class="main">(</span><span class="free">M</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">σ'</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 2<span class="main">)</span>
          <span class="keyword1"><span class="command">have</span></span> 7 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="skolem">σ'</span> <span class="main">⟹</span> <span class="free">f</span> <span class="skolem">σ'</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> 1 3 4 6 leD measure <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span>   <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="skolem">σ'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False
                                                  <span class="main">|</span> Some <span class="main">(</span><span class="bound">xa</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ'</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> 1 3 4 5 6 hyp measure <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span>
         <span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False
         <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"*"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
  

<span class="keyword1" id="Hoare_MonadSE-while_irpt"><span class="command">lemma</span></span> while_irpt <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>  <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span> <span class="main">∨</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>  <span class="free">M</span>  <span class="main">†</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> measure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">M</span> <span class="bound">σ</span> <span class="main">=</span> None <span class="main">∨</span> <span class="free">f</span><span class="main">(</span>snd<span class="main">(</span>the<span class="main">(</span><span class="free">M</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="bound">σ</span><span class="main">)</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> enabled<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">cond</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>        <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> <span class="main">†</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def if_SE_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">σ</span> <span class="main">≤</span> <span class="bound">n</span> <span class="main">⟶</span>  
                     <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span> 
            <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">n</span> "</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> n<span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">n</span></span></span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> 
         <span class="keyword1"><span class="command">have</span></span> 1 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="free">cond</span> <span class="bound">σ</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enabled * <span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">0</span> "</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span><span class="operator">frule</span> 1<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> bind_SE'_def bind_SE_def gr_implies_not0 if_SE_def option.case<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> 
                           option.case_eq_if  while_SE_unfold<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="skolem">n</span> 
      <span class="keyword3"><span class="command">assume</span></span> hyp <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">n</span>"</span></span>
         <span class="keyword1"><span class="command">have</span></span> 1 <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="free">cond</span> <span class="bound">σ</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enabled * <span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> "</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">frule</span> 1<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> while_SE_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_SE_def<span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">insert</span> *<span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> disjE<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">σ</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">σ</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="skolem">σ</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span>   ** <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">M</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span>
         <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="free">M</span> <span class="skolem">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span> 
               <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted">"**"</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">σ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">cond</span> <span class="skolem">σ</span>›</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> 
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="main">(</span><span class="free">M</span> <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">)</span> <span class="skolem">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False"</span></span>
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="skolem">σ</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> σ'<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE'_def bind_SE_def<span class="main">)</span>
             <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
               <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ'</span> 
               <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">σ'</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="skolem">σ</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">σ'</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="skolem">σ'</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">σ'</span>›</span></span> enabled<span class="main">)</span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">σ'</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">M</span> <span class="skolem">σ</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">σ'</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">σ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">cond</span> <span class="skolem">σ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">σ</span> <span class="main">≤</span> Suc <span class="skolem">n</span>›</span></span> measure <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>   
               <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="skolem">σ'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> hyp  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">σ'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">σ'</span> <span class="main">≤</span> <span class="skolem">n</span>›</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">σ</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">σ</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="skolem">σ</span>"</span></span>  
         <span class="keyword2"><span class="keyword">and</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">M</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>
        <span class="keyword3"><span class="command">obtain</span></span> ** <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="free">M</span> <span class="skolem">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted">"*"</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">σ</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">cond</span> <span class="skolem">σ</span>›</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="skolem">σ</span> <span class="main">=</span> None"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted">"**"</span> option.disc_eq_case<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="main">(</span><span class="free">M</span> <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">)</span> <span class="skolem">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False"</span></span>          
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">M</span> <span class="skolem">σ</span> <span class="main">=</span> None›</span></span> bind_SE'_def bind_SE_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>      
    <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">)</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> False"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
  

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Experimental Alternative Definitions (Transformer-Style Rely-Guarantee)›</span></span>

<span class="keyword1"><span class="command">definition</span></span>  <span class="entity">hoare<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⊢<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword3">(</span><span class="keyword1">{</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">}</span><span class="keyword3">/ </span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">/ </span><span class="keyword1">{</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">}</span><span class="keyword3">)</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main"><span class="free">⊢<span class="hidden">⇩</span><sub>1</sub></span></span><span class="main"><span class="free">{</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">}</span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main"><span class="free">{</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">}</span></span> <span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span>  <span class="main">←</span> <span class="keyword1">assume<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">;</span> <span class="bound">x</span>  <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Problem: Severe Deviation for the case of an unsatisfyabke precondition *)</span>

<span class="keyword1"><span class="command">definition</span></span>  <span class="entity">hoare<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'σ</span><span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'σ</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⊢<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword3">(</span><span class="keyword1">{</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">}</span><span class="keyword3">/ </span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">/ </span><span class="keyword1">{</span><span class="keyword3">(1</span>_<span class="keyword3">)</span><span class="keyword1">}</span><span class="keyword3">)</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main"><span class="free">⊢<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main"><span class="free">{</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">}</span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main"><span class="free">{</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">}</span></span> <span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⊨</span>  <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">;</span> <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  
<span class="keyword2"><span class="keyword">end</span></span>
  </pre>
</div><div id="Hoare_Clean">
<div class="head">
<h1>Theory Hoare_Clean</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * A Hoare Calculus for Clean
 *
 * Authors : Burkhart Wolff
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Hoare_Clean
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Hoare_MonadSE.html">Hoare_MonadSE</a>
          <a href="Clean.html">Clean</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Clean Control Rules›</span></span>

<span class="keyword1" id="Hoare_Clean-break1"><span class="command">lemma</span></span> break1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⦇</span> break_status <span class="main">:=</span> True <span class="main">⦈</span><span class="main">)</span> <span class="main">⦄</span> break <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span>  <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> break_status <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def break_def unit_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_Clean-unset_break1"><span class="command">lemma</span></span> unset_break1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⦇</span> break_status <span class="main">:=</span> False <span class="main">⦈</span><span class="main">)</span> <span class="main">⦄</span> unset_break_status <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def unset_break_status_def unit_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_Clean-set_return1"><span class="command">lemma</span></span> set_return1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> True <span class="main">⦈</span><span class="main">)</span> <span class="main">⦄</span> set_return_status <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> return_status <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def set_return_status_def unit_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_Clean-unset_return1"><span class="command">lemma</span></span> unset_return1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> False <span class="main">⦈</span><span class="main">)</span> <span class="main">⦄</span> unset_return_status <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span>return_status <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def unset_return_status_def unit_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Clean Skip Rules›</span></span>

<span class="keyword1" id="Hoare_Clean-assign_global_skip"><span class="command">lemma</span></span> assign_global_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>  assign_global <span class="free">upd</span> <span class="free">rhs</span>  <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assign_global_def<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-assign_local_skip"><span class="command">lemma</span></span> assign_local_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span> assign_local <span class="free">upd</span> <span class="free">rhs</span>  <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assign_local_def<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-return_skip"><span class="command">lemma</span></span> return_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span> return<span class="hidden">⇩</span><sub>C</sub> <span class="free">upd</span> <span class="free">rhs</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def return<span class="hidden">⇩</span><sub>C</sub>_def unit_SE_def assign_local_def assign_def bind_SE'_def bind_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_Clean-assign_clean_skip"><span class="command">lemma</span></span> assign_clean_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>  assign <span class="free">tr</span>  <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assign_def<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-if_clean_skip"><span class="command">lemma</span></span> if_clean_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>  <span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">C</span> <span class="keyword1">then</span> <span class="free">E</span> <span class="keyword1">else</span> <span class="free">F</span> <span class="keyword1">fi</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def if_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_C_def<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-while_clean_skip"><span class="command">lemma</span></span> while_clean_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>  <span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">body</span> <span class="keyword1">od</span>  <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def while_C_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare_Clean-if_opcall_skip"><span class="command">lemma</span></span> if_opcall_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="main">(</span>call<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def call<span class="hidden">⇩</span><sub>C</sub>_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Hoare_Clean-if_funcall_skip"><span class="command">lemma</span></span> if_funcall_skip<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span><span class="main">(</span><span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">←</span> call<span class="hidden">⇩</span><sub>C</sub> <span class="free">fun</span> <span class="free">E</span> <span class="main">;</span> assign_local <span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def call<span class="hidden">⇩</span><sub>C</sub>_def assign_local_def assign_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE_def<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-if_funcall_skip'"><span class="command">lemma</span></span> if_funcall_skip'<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span><span class="main">(</span><span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">←</span> call<span class="hidden">⇩</span><sub>C</sub> <span class="free">fun</span> <span class="free">E</span> <span class="main">;</span> assign_global <span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def call<span class="hidden">⇩</span><sub>C</sub>_def assign_global_def assign_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE_def<span class="main">)</span>




<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Clean Assign Rules›</span></span>


<span class="keyword1" id="Hoare_Clean-assign_global"><span class="command">lemma</span></span> assign_global<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="free">upd</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span><span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">⦄</span> 
         assign_global <span class="free">upd</span> <span class="free">rhs</span> 
         <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def assign_global_def  assign_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Hoare_Clean-assign_local"><span class="command">lemma</span></span> assign_local<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="main">(</span><span class="free">upd</span> <span class="main">∘</span> map_hd<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">∘</span> map_hd<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">⦄</span>  
          assign_local <span class="free">upd</span> <span class="free">rhs</span>  
         <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>    hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def assign_local_def  assign_def
  <span class="keyword1"><span class="command">using</span></span> assms exec_stop_vs_control_independence <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Hoare_Clean-return_assign"><span class="command">lemma</span></span> return_assign<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="main">(</span><span class="free">upd</span> <span class="main">∘</span> map_hd<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">∘</span> map_hd<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">σ</span> <span class="main">⦇</span> return_status <span class="main">:=</span> True <span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">⦄</span> 
          return<span class="hidden">⇩</span><sub>C</sub> <span class="free">upd</span> <span class="free">rhs</span>
         <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> return_status <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> return<span class="hidden">⇩</span><sub>C</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def assign_local_def assign_def 
            set_return_status_def bind_SE'_def bind_SE_def 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> control_state_scheme"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>map_hd <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">σ</span><span class="main">⦇</span>return_status <span class="main">:=</span> True<span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="skolem">σ</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">upd</span> <span class="main">(</span>map_hd <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="skolem">σ</span><span class="main">⦇</span>return_status <span class="main">:=</span> True<span class="main">⦈</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> a1 assms exec_stop_vs_control_independence' <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="comment1">(* do we need independence of rhs ? Not really. 'Normal' programs would never
     be control-state dependent, and 'artificial' ones would still be correct ...*)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Clean Construct Rules›</span></span>

<span class="keyword1" id="Hoare_Clean-cond_clean"><span class="command">lemma</span></span> cond_clean <span class="main">:</span> 
  <span class="quoted"><span class="quoted">"    <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>
   <span class="main">⟹</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M'</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>  
   <span class="main">⟹</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">then</span> <span class="free">M</span> <span class="keyword1">else</span> <span class="free">M'</span> <span class="keyword1">fi</span><span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def bind_SE_def if_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_C_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹There is a particular difficulty with a verification of (terminating) while rules
in a Hoare-logic for a language involving break. The first is, that break is not used
in the toplevel of a body of a loop (there might be breaks inside an inner loop, though).
This scheme is covered by the rule below, which is a generalisation of the classical 
while loop (as presented by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> while<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>


<span class="keyword1" id="Hoare_Clean-while_clean_no_break"><span class="command">lemma</span></span> while_clean_no_break <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>  <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> measure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> 
                    <span class="main">⟶</span> <span class="free">M</span> <span class="bound">σ</span> <span class="main">≠</span> None <span class="main">∧</span> <span class="free">f</span><span class="main">(</span>snd<span class="main">(</span>the<span class="main">(</span><span class="free">M</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="bound">σ</span><span class="main">)</span><span class="main">::</span>nat<span class="main">)</span> "</span></span>
               <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">_</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="var">?decrease</span> <span class="bound">σ</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">shows</span></span>        <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> 
                <span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> 
                <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="main">(</span>return_status <span class="bound">σ</span> <span class="main">∨</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="var">?pre</span><span class="main">⦄</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="var">?post1</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command">unfolding</span></span> while_C_def hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> sequence'<span class="main">)</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="var">?pre</span><span class="main">⦄</span> 
          <span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span>
          <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span><span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="var">?pre</span><span class="main">⦄</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="var">?cond'</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span> <span class="var">?cond'</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> consequence_unit<span class="main">)</span> 
         <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">" <span class="var">?pre</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="var">?post2</span> <span class="skolem">σ</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> exec_stop1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
         <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="var">?post2</span><span class="main">⦄</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="var">?cond'</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span><span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="var">?cond'</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
         <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule_tac</span> f <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> while<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> consequence_unit<span class="main">)</span>
           <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cond'</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="main">¬</span>break_status <span class="skolem">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="skolem">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
         <span class="keyword1"><span class="command">next</span></span>
           <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"*"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
         <span class="keyword1"><span class="command">next</span></span> 
           <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span>  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?post2</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="var">?post2</span> <span class="skolem">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
         <span class="keyword1"><span class="command">next</span></span> 
           <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span><span class="var">?cond'</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="var">?decrease</span> <span class="bound">σ</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> measure <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
         <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
         <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">" <span class="main">¬</span><span class="var">?cond'</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="main">¬</span><span class="var">?cond'</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span><span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span> unset_break_status
          <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ'</span><span class="main">.</span> <span class="main">(</span>return_status <span class="bound">σ'</span> <span class="main">∨</span> <span class="main">¬</span> <span class="free">cond</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ'</span><span class="main">⦄</span>"</span></span>
         <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span><span class="var">?cond''</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ</span><span class="main">⦄</span> unset_break_status <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ'</span><span class="main">.</span> <span class="var">?post3</span> <span class="bound">σ'</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="bound">σ'</span> <span class="main">⦄</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> consequence_unit<span class="main">)</span> 
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span>  
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?cond''</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="var">?post3</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> False<span class="main">⦈</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> exec_stop_def surjective update_convs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="var">?post3</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> False<span class="main">⦈</span><span class="main">)</span><span class="main">⦄</span>
              unset_break_status 
              <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="var">?post3</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>    
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> conj_commute<span class="main"><span class="keyword3">,</span></span><span class="operator">subst</span> conj_assoc<span class="main"><span class="keyword3">,</span></span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> conj_commute<span class="main">)</span>
             <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> unset_break1<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span> 
         <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"<span class="var">?post3</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span> <span class="main">⟶</span> <span class="var">?post3</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="var">?post2</span> <span class="skolem">σ</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> 


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the following we present a version allowing a break inside the body, which implies that the 
     invariant has been established at the break-point and the condition is irrelevant. 
     A return may occur, but the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"break_status"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is guaranteed to be true
     after leaving the loop.›</span></span>



<span class="keyword1" id="Hoare_Clean-while_clean'"><span class="command">lemma</span></span> while_clean'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  M_inv   <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>  <span class="free">M</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> cond_idpc    <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span>  <span class="main">(</span><span class="free">cond</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">cond</span> <span class="bound">σ</span> "</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> inv_idpc     <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span>  <span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="bound">σ</span> "</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> f_is_measure <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span> <span class="main">⟶</span> 
                       <span class="free">M</span> <span class="bound">σ</span> <span class="main">≠</span> None <span class="main">∧</span> <span class="free">f</span><span class="main">(</span>snd<span class="main">(</span>the<span class="main">(</span><span class="free">M</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="bound">σ</span><span class="main">)</span><span class="main">::</span>nat<span class="main">)</span> "</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>    <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> 
          <span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">cond</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span> 
          <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span>  <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> while_C_def hoare<span class="hidden">⇩</span><sub>3</sub>_def hoare<span class="hidden">⇩</span><sub>3</sub>'_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare<span class="hidden">⇩</span><sub>3</sub>_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> sequence'<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span> 
            <span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">cond</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">M</span> <span class="keyword1">od</span>
          <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> False<span class="main">⦈</span><span class="main">)</span><span class="main">⦄</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> consequence_unit<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> conjunct2<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> f <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> while<span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> M_inv f_is_measure inv_idpc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">σ</span><span class="main">⦇</span>break_status <span class="main">:=</span> False<span class="main">⦈</span><span class="main">)</span><span class="main">⦄</span> unset_break_status 
          <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> break_status <span class="bound">σ</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">σ</span><span class="main">⦄</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> conj_commute<span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span>  Hoare_Clean.unset_break1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Consequence and Sequence rules where inherited from the underlying Hoare-Monad theory.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span>





</pre>
</div><div id="Clean_Symbex">
<div class="head">
<h1>Theory Clean_Symbex</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="keyword1"><span class="command">theory</span></span> Clean_Symbex
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Clean.html">Clean</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Clean Symbolic Execution Rules ›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic NOP - Symbolic Execution Rules.  ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹  As they are equalities, they can also
be used as program optimization rules. ›</span></span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign"><span class="command">lemma</span></span> non_exec_assign  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign <span class="free">f</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assms exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign'"><span class="command">lemma</span></span> non_exec_assign'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>assign <span class="free">f</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assms exec_bind_SE_success bind_SE'_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_assign"><span class="command">lemma</span></span> exec_assign  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign <span class="free">f</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assms exec_bind_SE_success<span class="main">)</span>     

<span class="keyword1" id="Clean_Symbex-exec_assign'"><span class="command">lemma</span></span> exec_assign'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>assign <span class="free">f</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_def assms exec_bind_SE_success bind_SE'_def<span class="main">)</span>     

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Assign Execution Rules.  ›</span></span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign_global"><span class="command">lemma</span></span> non_exec_assign_global  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign_global <span class="free">upd</span> <span class="free">rhs</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="free">σ</span><span class="main">)</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_global_def non_exec_assign assms<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign_global'"><span class="command">lemma</span></span> non_exec_assign_global'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>assign_global <span class="free">upd</span> <span class="free">rhs</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="free">σ</span><span class="main">)</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> assms bind_SE'_def non_exec_assign_global<span class="main">)</span>


<span class="keyword1" id="Clean_Symbex-exec_assign_global"><span class="command">lemma</span></span> exec_assign_global  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign_global <span class="free">upd</span> <span class="free">rhs</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> <span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_global_def assign_def assms exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_assign_global'"><span class="command">lemma</span></span> exec_assign_global'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>assign_global <span class="free">upd</span> <span class="free">rhs</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> <span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_global_def assign_def assms exec_bind_SE_success bind_SE'_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign_local"><span class="command">lemma</span></span> non_exec_assign_local  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign_local <span class="free">upd</span> <span class="free">rhs</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">(</span>map_hd <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="free">σ</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_local_def non_exec_assign assms<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_assign_local'"><span class="command">lemma</span></span> non_exec_assign_local'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>assign_local <span class="free">upd</span> <span class="free">rhs</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">upd</span> <span class="main">(</span>map_hd <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="free">σ</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span><span class="main">)</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms bind_SE'_def non_exec_assign_local<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> non_exec_assign_localD'<span class="main">=</span> non_exec_assign<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>

<span class="keyword1" id="Clean_Symbex-exec_assign_local"><span class="command">lemma</span></span> exec_assign_local  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> assign_local <span class="free">upd</span> <span class="free">rhs</span><span class="main">;</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> <span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assign_local_def assign_def assms exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_assign_local'"><span class="command">lemma</span></span> exec_assign_local'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> assign_local <span class="free">upd</span> <span class="free">rhs</span><span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> <span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> assign_local_def assign_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms exec_bind_SE_success2<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_assignD <span class="main">=</span> exec_assign<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>
<span class="keyword1"><span class="command">thm</span></span> exec_assignD

<span class="keyword1"><span class="command">lemmas</span></span> exec_assignD' <span class="main">=</span> exec_assign'<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>
<span class="keyword1"><span class="command">thm</span></span> exec_assignD'

<span class="keyword1"><span class="command">lemmas</span></span> exec_assign_globalD <span class="main">=</span>  exec_assign_global<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_assign_globalD' <span class="main">=</span>  exec_assign_global'<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_assign_localD <span class="main">=</span> exec_assign_local<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>
<span class="keyword1"><span class="command">thm</span></span> exec_assign_localD

<span class="keyword1"><span class="command">lemmas</span></span> exec_assign_localD' <span class="main">=</span> exec_assign_local'<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic Call Symbolic Execution Rules.  ›</span></span>



<span class="keyword1" id="Clean_Symbex-exec_call_0"><span class="command">lemma</span></span> exec_call_0  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> call_0<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span><span class="main">;</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms call_0<span class="hidden">⇩</span><sub>C</sub>_def exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call_0'"><span class="command">lemma</span></span> exec_call_0'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>call_0<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def exec_call_0<span class="main">)</span>



<span class="keyword1" id="Clean_Symbex-exec_call_1"><span class="command">lemma</span></span> exec_call_1  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">x</span> <span class="main">←</span> call_1<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span> undefined<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms call_1<span class="hidden">⇩</span><sub>C</sub>_def call<span class="hidden">⇩</span><sub>C</sub>_def exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call_1'"><span class="command">lemma</span></span> exec_call_1'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>call_1<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def exec_call_1<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call"><span class="command">lemma</span></span> exec_call  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">x</span> <span class="main">←</span> call<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span> undefined<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms call<span class="hidden">⇩</span><sub>C</sub>_def call_1<span class="hidden">⇩</span><sub>C</sub>_def exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call'"><span class="command">lemma</span></span> exec_call'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>call<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms call_1<span class="hidden">⇩</span><sub>C</sub>_def exec_call_1'<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call_2"><span class="command">lemma</span></span> exec_call_2  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> call_2<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">A<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms call_2<span class="hidden">⇩</span><sub>C</sub>_def exec_bind_SE_success<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-exec_call_2'"><span class="command">lemma</span></span> exec_call_2'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span>call_2<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">A<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def exec_call_2<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic Call Symbolic Execution Rules.  ›</span></span>

<span class="keyword1" id="Clean_Symbex-non_exec_call_0"><span class="command">lemma</span></span> non_exec_call_0  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> call_0<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span><span class="main">;</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def bind_SE_def call_0<span class="hidden">⇩</span><sub>C</sub>_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_call_0'"><span class="command">lemma</span></span> non_exec_call_0'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> call_0<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def non_exec_call_0<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_call_1"><span class="command">lemma</span></span> non_exec_call_1  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">x</span> <span class="main">←</span> <span class="main">(</span>call_1<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def call<span class="hidden">⇩</span><sub>C</sub>_def bind_SE_def call_1<span class="hidden">⇩</span><sub>C</sub>_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_call_1'"><span class="command">lemma</span></span> non_exec_call_1'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> call_1<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def non_exec_call_1<span class="main">)</span>


<span class="keyword1" id="Clean_Symbex-non_exec_call"><span class="command">lemma</span></span> non_exec_call  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="bound">x</span> <span class="main">←</span> <span class="main">(</span>call<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">←</span> <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;</span> <span class="free">M'</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms call<span class="hidden">⇩</span><sub>C</sub>_def bind_SE'_def bind_SE_def call_1<span class="hidden">⇩</span><sub>C</sub>_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_call'"><span class="command">lemma</span></span> non_exec_call'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> call<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def non_exec_call<span class="main">)</span>


<span class="keyword1" id="Clean_Symbex-non_exec_call_2"><span class="command">lemma</span></span> non_exec_call_2  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span> <span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span>call_2<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">A<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span> <span class="free">M'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def bind_SE_def call_2<span class="hidden">⇩</span><sub>C</sub>_def valid_SE_def<span class="main">)</span>

<span class="keyword1" id="Clean_Symbex-non_exec_call_2'"><span class="command">lemma</span></span> non_exec_call_2'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> call_2<span class="hidden">⇩</span><sub>C</sub> <span class="free">M</span> <span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">A<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span>  <span class="free">M</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span><span class="free">A<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">σ</span><span class="main">)</span><span class="main">;-</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE'_def non_exec_call_2<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Conditional.  ›</span></span>

<span class="keyword1" id="Clean_Symbex-exec_If"><span class="command">lemma</span></span> exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span><span class="free">σ</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span> <span class="free">σ</span> "</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> if_SE_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_SE_def if_C_def<span class="main">)</span>
    
    
<span class="keyword1" id="Clean_Symbex-valid_exec_If"><span class="command">lemma</span></span> valid_exec_If<span class="hidden">⇩</span><sub>C</sub>  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> valid_bind'_cong<span class="main">)</span>


      
<span class="keyword1" id="Clean_Symbex-exec_If"><span class="command">lemma</span></span> exec_If<span class="hidden">⇩</span><sub>C</sub>'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">P</span> <span class="keyword1">then</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="free">B<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">fi</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> if_SE_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def bind_SE_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms if_C_def<span class="main">)</span>
    
<span class="keyword1" id="Clean_Symbex-exec_While"><span class="command">lemma</span></span> exec_While<span class="hidden">⇩</span><sub>C</sub>'  <span class="main">:</span> 
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">P</span> <span class="keyword1">do</span> <span class="free">B<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">od</span><span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> while_C_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def bind_SE_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>    


    
    
<span class="keyword1" id="Clean_Symbex-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>C</sub>_cond_cong <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">σ</span> <span class="main">=</span> <span class="free">g</span> <span class="free">σ</span> <span class="main">⟹</span> 
                           <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">f</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="free">σ</span> <span class="main">=</span> 
                           <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">g</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> if_C_def
   <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
   
 
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Break - Rules.  ›</span></span>

<span class="keyword1" id="Clean_Symbex-break_assign_skip"><span class="command">lemma</span></span> break_assign_skip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"break <span class="main">;-</span> assign <span class="free">f</span> <span class="main">=</span> break"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> break_def assign_def exec_stop_def bind_SE'_def   bind_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>



<span class="keyword1" id="Clean_Symbex-break_if_skip"><span class="command">lemma</span></span> break_if_skip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"break <span class="main">;-</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span> <span class="keyword1">fi</span><span class="main">)</span> <span class="main">=</span> break"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> break_def assign_def exec_stop_def if_C_def bind_SE'_def   bind_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
                       
<span class="keyword1" id="Clean_Symbex-break_while_skip"><span class="command">lemma</span></span> break_while_skip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"break <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">=</span> break"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> while_C_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def bind_SE'_def bind_SE_def break_def exec_stop_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    
<span class="keyword1" id="Clean_Symbex-unset_break_idem"><span class="command">lemma</span></span> unset_break_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> 
 <span class="quoted"><span class="quoted">"<span class="main">(</span> unset_break_status <span class="main">;-</span> unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>  <span class="keyword1"><span class="command">unfolding</span></span> unset_break_status_def bind_SE'_def bind_SE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Clean_Symbex-return_cancel1_idem"><span class="command">lemma</span></span> return_cancel1_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> 
 <span class="quoted"><span class="quoted">"<span class="main">(</span> return<span class="hidden">⇩</span><sub>C</sub> <span class="free">X</span> <span class="free">E</span> <span class="main">;-</span> assign_global <span class="free">X</span> <span class="free">E'</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> return<span class="hidden">⇩</span><sub>C</sub> <span class="free">X</span> <span class="free">E</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">unfolding</span></span> unset_break_status_def bind_SE'_def bind_SE_def
            assign_def return<span class="hidden">⇩</span><sub>C</sub>_def assign_global_def assign_local_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"exec_stop <span class="improper">σ</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_stop_def set_return_status_def<span class="main">)</span>
    
<span class="keyword1" id="Clean_Symbex-return_cancel2_idem"><span class="command">lemma</span></span> return_cancel2_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> 
 <span class="quoted"><span class="quoted">"<span class="main">(</span> return<span class="hidden">⇩</span><sub>C</sub> <span class="free">X</span> <span class="free">E</span> <span class="main">;-</span> assign_local <span class="free">X</span> <span class="free">E'</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> return<span class="hidden">⇩</span><sub>C</sub> <span class="free">X</span> <span class="free">E</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> <span class="quoted">"σ"</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">unfolding</span></span> unset_break_status_def bind_SE'_def bind_SE_def
            assign_def return<span class="hidden">⇩</span><sub>C</sub>_def assign_global_def assign_local_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"exec_stop <span class="improper">σ</span>"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_stop_def set_return_status_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹While.  ›</span></span>     

<span class="keyword1" id="Clean_Symbex-while"><span class="command">lemma</span></span> while<span class="hidden">⇩</span><sub>C</sub>_skip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> False<span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">=</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> while_C_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">unfolding</span></span> exec_stop_def skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unset_break_status_def bind_SE'_def unit_SE_def bind_SE_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
 

<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹ Various tactics for various coverage criteria ›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">while_k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext <span class="main">⇒</span> bool<span class="main">)</span> 
                        <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> 
                        <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="main">(</span><span class="tfree">'σ_ext</span><span class="main">)</span> control_state_ext<span class="main">)</span>MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>     <span class="quoted"><span class="quoted">"<span class="free">while_k</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">≡</span> while_C"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Somewhat amazingly, this unfolding lemma crucial for symbolic execution still holds ... 
     Even in the presence of break or return...›</span></span> 
<span class="keyword1" id="Clean_Symbex-exec_while"><span class="command">lemma</span></span> exec_while<span class="hidden">⇩</span><sub>C</sub> <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
 <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">;-</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> unset_break_status<span class="main">)</span> <span class="keyword1">else</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="keyword1">fi</span><span class="main">)</span>  <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"exec_stop <span class="free">σ</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True exec_If<span class="hidden">⇩</span><sub>C</sub>' exec_While<span class="hidden">⇩</span><sub>C</sub>'<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">b</span> <span class="free">σ</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> valid_bind'_cong<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> exec_stop <span class="free">σ</span>›</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def unit_SE_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> while_C_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind'_cong<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> MonadSE.while_SE_unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">.</span></span> False"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> if<span class="hidden">⇩</span><sub>C</sub>_cond_cong <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">.</span></span> False"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> exec_If<span class="hidden">⇩</span><sub>C</sub>_If<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_stop_def unset_break_status_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">have</span></span> * <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="free">σ</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
           <span class="keyword1"><span class="command">unfolding</span></span> while_k_def 
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  while_C_def<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  if_C_def<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  valid_bind'_cong<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> exec_stop <span class="free">σ</span>›</span></span><span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span>  <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_bind'_cong<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> exec_stop <span class="free">σ</span>›</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> MonadSE.while_SE_unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> valid_bind'_cong<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind'_cong<span class="main">)</span>
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> if<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_cond_cong <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">.</span></span> True"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>   <span class="quoted"><span class="quoted">‹<span class="main">¬</span> exec_stop <span class="free">σ</span>›</span></span> <span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_assoc'<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> bind_assoc'<span class="main">)</span>
            <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="free">σ</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> None
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">c</span><span class="main">;-</span><span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">b</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">;-</span>unset_break_status<span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span>
                         <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">c</span><span class="main">;-</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_SE'_def exec_bind_SE_failure<span class="main">)</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">a</span><span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">c</span> <span class="main">;-</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">b</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">;-</span>unset_break_status<span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span> <span class="main">=</span>
                         <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="free">c</span> <span class="main">;-</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> <span class="quoted"><span class="quoted">‹<span class="free">c</span> <span class="free">σ</span> <span class="main">=</span> Some <span class="skolem">a</span>›</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> surjective_pairing<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">a</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> exec_bind_SE_success2<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> exec_bind_SE_success2<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
                <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"exec_stop <span class="main">(</span>snd <span class="skolem">a</span><span class="main">)</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd <span class="skolem">a</span> <span class="main">⊨</span><span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">b</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">;-</span>unset_break_status<span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">=</span>
                             <span class="main">(</span>snd <span class="skolem">a</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
                       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> bind_assoc' exec_While<span class="hidden">⇩</span><sub>C</sub>' exec_skip if_SE_D2' 
                                                  skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>_def while_SE_unfold<span class="main">)</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd <span class="skolem">a</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> <span class="free">b</span> <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span><span class="main">;-</span>unset_break_status<span class="main">)</span><span class="main">;-</span><span class="free">M</span><span class="main">)</span><span class="main">=</span>
                             <span class="main">(</span>snd <span class="skolem">a</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">do</span> <span class="free">c</span> <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span> unset_break_status <span class="main">;-</span> <span class="free">M</span><span class="main">)</span>"</span></span>
                          <span class="keyword1"><span class="command">unfolding</span></span>  while_C_def
                          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_bind'_cong<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
                <span class="keyword1"><span class="command">qed</span></span>       
            <span class="keyword1"><span class="command">qed</span></span>  
    <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(* ... although it is, oh my god, amazingly complex to prove. *)</span>


<span class="keyword1" id="Clean_Symbex-while_k_SE"><span class="command">lemma</span></span> while_k_SE <span class="main">:</span> <span class="quoted"><span class="quoted">"while_C <span class="main">=</span> while_k <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> while_k_def<span class="main">)</span>


<span class="keyword1"><span class="command">corollary</span></span> exec_while_k <span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span>while_k <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
 <span class="main">(</span><span class="free">σ</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">;-</span> <span class="main">(</span>while_k <span class="free">n</span> <span class="free">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">;-</span> unset_break_status <span class="keyword1">else</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> <span class="keyword1">fi</span><span class="main">)</span>  <span class="main">;-</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_while<span class="hidden">⇩</span><sub>C</sub> while_k_def<span class="main">)</span>
    

<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹ Necessary prerequisite: turning ematch and dmatch into a proper Isar Method. ›</span></span>
<span class="comment1">(* TODO : this code shoud go to TestGen Method setups *)</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword2"><span class="keyword">local</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">method_setup</span> <span class="entity">b</span> <span class="entity">tac</span> <span class="main">=</span>
  <span class="entity">Method.setup</span> <span class="entity">b</span>
    <span class="main">(</span><span class="entity">Attrib.thms</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">rules</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">METHOD</span> <span class="main">(</span>HEADGOAL o K <span class="main">(</span><span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">rules</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span>   <span class="entity">method_setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> ematch<span class="antiquote">}</span></span></span> ematch_tac <span class="inner_quoted">"fast elimination matching"</span>
                #&gt; <span class="entity">method_setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> dmatch<span class="antiquote">}</span></span></span> dmatch_tac <span class="inner_quoted">"fast destruction matching"</span>
                #&gt; <span class="entity">method_setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> match<span class="antiquote">}</span></span></span> match_tac <span class="inner_quoted">"resolution based on fast matching"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">lemmas</span></span> exec_while_kD <span class="main">=</span> exec_while_k<span class="main">[</span><span class="operator">THEN</span> iffD1<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Test_Clean">
<div class="head">
<h1>Theory Test_Clean</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="keyword1"><span class="command">theory</span></span> Test_Clean
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Clean_Symbex.html">Clean_Symbex</a>
          <span class="quoted">"<a href="../../HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> memory_theory

<span class="keyword1"><span class="command">method</span></span> memory_theory <span class="main">=</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">memory_theory</span></span> MonadSE.bind_assoc'<span class="main">)</span>
<span class="keyword1"><span class="command">method</span></span> norm <span class="main">=</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> assert_D<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Clean_Main">
<div class="head">
<h1>Theory Clean_Main</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * Clean --- a basic abstract ("shallow") programming language for test and proof.
 * Authors : Burkhart Wolff, Frédéric Tuong
 *           Contributions by Chantal Keller
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Clean_Main
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Clean.html">Clean</a> <a href="Hoare_Clean.html">Hoare_Clean</a> <a href="Test_Clean.html">Test_Clean</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Quicksort_concept">
<div class="head">
<h1>Theory Quicksort_concept</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * Quicksort Concept
 *
 * Authors : Burkhart Wolff, Frédéric Tuong
 *)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹ Clean Semantics : A Coding-Concept Example›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The following show-case introduces subsequently a non-trivial example involving
local and global variable declarations, declarations of operations with pre-post conditions as
well as direct-recursive operations (i.e. C-like functions with side-effects on global and
local variables. ›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Quicksort_concept
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Clean.html">Clean</a>
          <a href="Hoare_MonadSE.html">Hoare_MonadSE</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The Quicksort Example›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ We present the following quicksort algorithm in some conceptual, high-level notation:

\begin{isar}
algorithm (A,i,j) =
    tmp := A[i];
    A[i]:=A[j];
    A[j]:=tmp

algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo
    for j := lo to hi - 1 do
        if A[j] &lt; pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i

algorithm quicksort(A, lo, hi) is
    if lo &lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

\end{isar}
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the following, we will present the Quicksort program alternatingly in Clean high-level
notation and simulate its effect by an alternative formalisation representing the semantic
effects of the high-level notation on a step-buy-step basis. Note that Clean does not posses
the concept of call-by-reference parameters; consequently, the algorithm must be specialized
to a variant where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is just a global variable.›</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Clean Encoding of the Global State of Quicksort›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We demonstrate the accumulating effect of some key Clean commands by highlighting the
changes of  Clean's state-management module state. At the beginning, the state-type of
the Clean state management is just the type of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> Clean.control_state.control_state_ext"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
while the table of global and local variables is empty.›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ <span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span>
    <span class="entity">StateMgt_core.get_state_field_tab_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span> ›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>global_vars›</span></span></span></span> command, described and defined in <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹Clean.thy›</span></span></span></span>,
declares the global variable <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹A›</span></span></span></span>. This has the following effect:›</span></span>

<span class="keyword1"><span class="command">global_vars</span></span> state
    A <span class="main">::</span> <span class="quoted"><span class="quoted">"int list"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹... which is reflected in Clean's state-management table:›</span></span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ <span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="inner_quoted">"Quicksort_concept.global_state_state_scheme"</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span>
        <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span>
    <span class="entity">StateMgt_core.get_state_field_tab_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note that the state-management uses long-names for complete disambiguation.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Encoding swap in Clean›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹swap›</span></span></span></span> in High-level Notation›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Unfortunately, the name <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>result›</span></span></span></span> is already used in the logical context; we use local binders
instead.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> <span class="main">()</span>"</span></span> <span class="comment1">― ‹check that <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span><span class="quoted">‹<span class="free">i</span>›</span></span> can exist as a constant with an arbitrary type before treating <span class="antiquoted"><span class="operator">⬚</span><span class="raw_text">‹<span class="keyword1"><span class="command">function_spec</span></span>›</span></span>›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">=</span> <span class="main">()</span>"</span></span> <span class="comment1">― ‹check that <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span><span class="quoted">‹<span class="free">j</span>›</span></span> can exist as a constant with an arbitrary type before treating <span class="antiquoted"><span class="operator">⬚</span><span class="raw_text">‹<span class="keyword1"><span class="command">function_spec</span></span>›</span></span>›</span>

<span class="keyword1"><span class="command">function_spec</span></span> <span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity">swap</span></span></span></span></span></span> <span class="main">(</span><span class="free"><span class="free"><span class="free">i</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">,</span><span class="free"><span class="free"><span class="free">j</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">)</span> <span class="comment1">― ‹TODO: the hovering on parameters produces a number of report equal to the number of <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">ML</span><span class="hidden">&gt;</span></span>‹Proof_Context.add_fixes›</span> called in <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">ML</span><span class="hidden">&gt;</span></span>‹<span class="entity">Function_Specification_Parser.checkNsem_function_spec</span>›</span>›</span>
<span class="keyword2"><span class="keyword">pre</span></span>          <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹i &lt; length A ∧ j &lt; length A›</span>"</span></span>
<span class="keyword2"><span class="keyword">post</span></span>         <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹λres. length A = length(old A) ∧ res = ()›</span>"</span></span>
<span class="keyword2"><span class="keyword">local_vars</span></span>   tmp <span class="main">::</span> <span class="quoted">int</span>
<span class="keyword2"><span class="keyword">defines</span></span>      <span class="quoted"><span class="quoted"><span class="quoted">" <span class="inner_cartouche"><span class="inner_cartouche">‹ tmp := A ! i›</span></span>  <span class="main"><span class="main">;-</span></span>
               <span class="inner_cartouche"><span class="inner_cartouche">‹ A := list_update A i (A ! j)›</span></span> <span class="main"><span class="main">;-</span></span>
               <span class="inner_cartouche"><span class="inner_cartouche">‹ A := list_update A j tmp›</span></span> "</span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The body --- heavily using the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>λ›</span></span></span></span>-lifting cartouche --- corresponds to the low level
term: ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display=true]
<span class="raw_text"><span class="raw_text">‹‹defines " ((assign_local tmp_update (λσ. (A σ) ! i ))   ;-
            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ))))"››</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The effect of this statement is generation of the following definitions in the logical context:›</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>i<span class="main">,</span> j<span class="main">)</span>"</span></span> <span class="comment1">― ‹check that <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span><span class="quoted">‹i›</span></span> and <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span><span class="quoted">‹j›</span></span> are pointing to the constants defined before treating <span class="antiquoted"><span class="operator">⬚</span><span class="raw_text">‹<span class="keyword1"><span class="command">function_spec</span></span>›</span></span>›</span>
<span class="keyword1"><span class="command">thm</span></span> push_local_swap_state_def
<span class="keyword1"><span class="command">thm</span></span> pop_local_swap_state_def
<span class="keyword1"><span class="command">thm</span></span> swap_pre_def
<span class="keyword1"><span class="command">thm</span></span> swap_post_def
<span class="keyword1"><span class="command">thm</span></span> swap_core_def
<span class="keyword1"><span class="command">thm</span></span> swap_def

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The state-management is in the following configuration:›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ <span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span>
    <span class="entity">StateMgt_core.get_state_field_tab_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Similation of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹swap›</span></span></span></span> in elementary specification constructs:›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note that we prime identifiers in order to avoid confusion with the definitions of the
previous section. The pre- and postconditions are just definitions of the following form:›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">swap'_pre</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" nat <span class="main">×</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> global_state_state_scheme <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">swap'_pre</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">&lt;</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">swap'_post</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> global_state_state_scheme <span class="main">⇒</span> <span class="tfree">'d</span> global_state_state_scheme <span class="main">⇒</span> unit <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">swap'_post</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="bound">σ</span> <span class="bound">res</span><span class="main">.</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>A <span class="bound">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span><span class="main">)</span> <span class="main">∧</span> <span class="bound">res</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The somewhat vacuous parameter <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>res›</span></span></span></span> for the result of the swap-computation is the conseqeuence
of the implicit definition of the return-type as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"unit"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We simulate the effect of the local variable space declaration by the following command
     factoring out the functionality into the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_vars_test›</span></span></span></span> ›</span></span>
<span class="comment1">(*
local_vars_test swap' "unit"
   tmp :: "int"

ML‹
val Type(s,t) = StateMgt_core.get_state_type_global @{theory};
val tab = StateMgt_core.get_state_field_tab_global @{theory};
@{term "A::('a local_swap_state_scheme⇒ int list)"}›

text‹This has already the effect of the definition:›
thm push_local_swap_state_def
thm pop_local_swap_state_def

text‹Again, we simulate the effect of this command by more elementary \HOL specification constructs:›
(* Thus, the internal functionality in ‹local_vars› is the construction of the two definitions *)
definition push_local_swap_state' :: "(unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "push_local_swap_state' σ =
                    Some((),σ⦇local_swap_state.tmp :=  undefined # local_swap_state.tmp σ ⦈)"

definition pop_local_swap_state' :: "(unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "pop_local_swap_state' σ =
                    Some(hd(local_swap_state.result_value σ),
                                ― ‹ recall : returns op value ›
                                ― ‹ which happens to be unit ›
                         σ⦇local_swap_state.tmp:= tl( local_swap_state.tmp σ) ⦈)"


definition swap'_core :: "nat × nat ⇒  (unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap'_core  ≡ (λ(i,j). ((assign_local tmp_update (λσ. A σ ! i ))   ;-
                            (assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
                            (assign_global A_update (λσ. list_update (A σ) (j) ((hd o tmp) σ)))))"

text‹ a block manages the "dynamically" created fresh instances for the local variables of swap ›
definition swap' :: "nat × nat ⇒  (unit,'a local_swap'_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
  where   "swap' ≡ λ(i,j). block<span class="hidden">⇩</span><sub>C</sub> push_local_swap_state' (swap_core (i,j)) pop_local_swap_state'"


text‹NOTE: If local variables were only used in single-assignment style, it is possible
   to drastically simplify the encoding. These variables were not stored in the state,
   just kept as part of the monadic calculation. The simplifications refer both to
   calculation as well as well as symbolic execution and deduction.›

text‹The could be represented by the following alternative, optimized version :›
definition swap_opt :: "nat × nat ⇒  (unit,'a global_state_state_scheme) MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"
    where "swap_opt ≡ λ(i,j). (tmp ←  yield<span class="hidden">⇩</span><sub>C</sub> (λσ. A σ ! i) ;
                          ((assign_global A_update (λσ. list_update (A σ) (i) (A σ ! j))) ;-
                           (assign_global A_update (λσ. list_update (A σ) (j) (tmp)))))"
text‹In case that all local variables are single-assigned in swap, the entire local var definition
   could be ommitted.›
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Encoding <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹partition›</span></span></span></span> in Clean›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹partition›</span></span></span></span> in High-level Notation›</span></span>

<span class="keyword1"><span class="command">function_spec</span></span> <span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity">partition</span></span></span></span></span></span> <span class="main">(</span><span class="free"><span class="free"><span class="free">lo</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">,</span> <span class="free"><span class="free"><span class="free">hi</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> <span class="quoted"><span class="quoted">nat</span></span>
<span class="keyword2"><span class="keyword">pre</span></span>          <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹lo &lt; length A ∧ hi &lt; length A›</span>"</span></span>
<span class="keyword2"><span class="keyword">post</span></span>         <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹λres::nat. length A = length(old A) ∧ res = 3›</span>"</span></span>
<span class="keyword2"><span class="keyword">local_vars</span></span>   pivot  <span class="main">::</span> <span class="quoted">int</span>
             i      <span class="main">::</span> <span class="quoted">nat</span>
             j      <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">defines</span></span>      <span class="quoted"><span class="quoted"><span class="quoted">" <span class="main"><span class="main">(</span></span><span class="inner_cartouche"><span class="inner_cartouche">‹pivot := A ! hi ›</span></span>  <span class="main"><span class="main">;-</span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹i := lo ›</span></span> <span class="main"><span class="main">;-</span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹j := lo ›</span></span> <span class="main"><span class="main">;-</span></span>
               <span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹j ≤ hi - 1 ›</span></span>
                <span class="keyword1"><span class="keyword1">do</span></span> <span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹A ! j &lt; pivot›</span></span>
                    <span class="keyword1"><span class="keyword1">then</span></span>  call<span class="hidden">⇩</span><sub>C</sub> swap <span class="inner_cartouche"><span class="inner_cartouche">‹(i , j) ›</span></span>  <span class="main"><span class="main">;-</span></span>
                          <span class="inner_cartouche"><span class="inner_cartouche">‹i := i + 1 ›</span></span>
                    <span class="keyword1"><span class="keyword1">else</span></span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    <span class="keyword1"><span class="keyword1">fi</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">;-</span></span>
                    <span class="inner_cartouche"><span class="inner_cartouche">‹j := j + 1 ›</span></span>
                <span class="keyword1"><span class="keyword1">od</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">;-</span></span>
                call<span class="hidden">⇩</span><sub>C</sub> swap <span class="inner_cartouche"><span class="inner_cartouche">‹(i, j)›</span></span>  <span class="main"><span class="main">;-</span></span>
                return<span class="hidden">⇩</span><sub>C</sub> result_value_update <span class="inner_cartouche"><span class="inner_cartouche">‹i›</span></span>
               <span class="main"><span class="main">)</span></span> "</span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ The body is a fancy syntax for :

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display=true]
<span class="raw_text"><span class="raw_text">‹‹defines      " ((assign_local pivot_update (λσ. A σ ! hi ))   ;-
               (assign_local i_update (λσ. lo )) ;-

               (assign_local j_update (λσ. lo )) ;-
               (while<span class="hidden">⇩</span><sub>C</sub> (λσ. (hd o j) σ ≤ hi - 1 )
                do (if<span class="hidden">⇩</span><sub>C</sub> (λσ. A σ ! (hd o j) σ &lt; (hd o pivot)σ )
                    then  call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                          assign_local i_update (λσ. ((hd o i) σ) + 1)
                    else skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    fi) ;-
                    (assign_local j_update (λσ. ((hd o j) σ) + 1))
                od) ;-
                call<span class="hidden">⇩</span><sub>C</sub> (swap) (λσ. ((hd o i) σ,  (hd o j) σ))  ;-
                assign_local result_value_update (λσ. (hd o i) σ)
                ― ‹ the meaning of the return stmt ›
               ) "››</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The effect of this statement is generation of the following definitions in the logical context:›</span></span>
<span class="keyword1"><span class="command">thm</span></span> partition_pre_def
<span class="keyword1"><span class="command">thm</span></span> partition_post_def
<span class="keyword1"><span class="command">thm</span></span> push_local_partition_state_def
<span class="keyword1"><span class="command">thm</span></span> pop_local_partition_state_def
<span class="keyword1"><span class="command">thm</span></span> partition_core_def
<span class="keyword1"><span class="command">thm</span></span> partition_def

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The state-management is in the following configuration:›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ <span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span>
    <span class="entity">StateMgt_core.get_state_field_tab_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Similation of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹partition›</span></span></span></span> in elementary specification constructs:›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">partition'_pre</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">lo</span> <span class="main">&lt;</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">hi</span> <span class="main">&lt;</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">partition'_post</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span> <span class="bound">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="bound">σ</span> <span class="bound">res</span><span class="main">.</span> length <span class="main">(</span>A <span class="bound">σ</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>A <span class="bound">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span><span class="main">)</span> <span class="main">∧</span> <span class="bound">res</span> <span class="main">=</span> <span class="numeral">3</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Recall: list-lifting is automatic in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_vars_test›</span></span></span></span>:›</span></span>

<span class="keyword1"><span class="command">local_vars_test</span></span>  <span class="entity"><span class="entity">partition'</span></span> <span class="quoted"><span class="quoted">"nat"</span></span>
    pivot  <span class="main">::</span> <span class="quoted"><span class="quoted">"int"</span></span>
    i      <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
    j      <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ ... which results in the internal definition of the respective push and pop operations
for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">partition'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> local variable space: ›</span></span>

<span class="keyword1"><span class="command">thm</span></span> push_local_partition'_state_def
<span class="keyword1"><span class="command">thm</span></span> pop_local_partition'_state_def

<span class="comment1">(* equivalent to *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">push_local_partition_state'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'a</span> local_partition'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">push_local_partition_state'</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span><span class="main">()</span><span class="main">,</span>
                        <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">⦇</span>local_partition_state.pivot <span class="main">:=</span> undefined <span class="main">#</span> local_partition_state.pivot <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">,</span>
                          local_partition_state.i     <span class="main">:=</span> undefined <span class="main">#</span> local_partition_state.i <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">,</span>
                          local_partition_state.j     <span class="main">:=</span> undefined <span class="main">#</span> local_partition_state.j <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">,</span>
                          local_partition_state.result_value
                                           <span class="main">:=</span> undefined <span class="main">#</span> local_partition_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⦈</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pop_local_partition_state'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'a</span> local_partition_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">pop_local_partition_state'</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span>hd<span class="main">(</span>local_partition_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                       <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">⦇</span>local_partition_state.pivot <span class="main">:=</span> tl<span class="main">(</span>local_partition_state.pivot <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                         local_partition_state.i     <span class="main">:=</span> tl<span class="main">(</span>local_partition_state.i <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                         local_partition_state.j     <span class="main">:=</span> tl<span class="main">(</span>local_partition_state.j <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                         local_partition_state.result_value <span class="main">:=</span>
                                                        tl<span class="main">(</span>local_partition_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">partition'_core</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span>  <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'a</span> local_partition'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">partition'_core</span>  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span><span class="bound">hi</span><span class="main">)</span><span class="main">.</span>
              <span class="main">(</span><span class="main">(</span>assign_local pivot_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> A <span class="bound">σ</span> <span class="main">!</span> <span class="bound">hi</span> <span class="main">)</span><span class="main">)</span>   <span class="main">;-</span>
               <span class="main">(</span>assign_local i_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">lo</span> <span class="main">)</span><span class="main">)</span> <span class="main">;-</span>

               <span class="main">(</span>assign_local j_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">lo</span> <span class="main">)</span><span class="main">)</span> <span class="main">;-</span>
               <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span>hd <span class="keyword1">o</span> j<span class="main">)</span> <span class="bound">σ</span> <span class="main">≤</span> <span class="bound">hi</span> <span class="main">-</span> <span class="main">1</span> <span class="main">)</span>
                <span class="keyword1">do</span> <span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> A <span class="bound">σ</span> <span class="main">!</span> <span class="main">(</span>hd <span class="keyword1">o</span> j<span class="main">)</span> <span class="bound">σ</span> <span class="main">&lt;</span> <span class="main">(</span>hd <span class="keyword1">o</span> pivot<span class="main">)</span><span class="bound">σ</span> <span class="main">)</span>
                    <span class="keyword1">then</span>  call<span class="hidden">⇩</span><sub>C</sub> <span class="main">(</span>swap<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>hd <span class="keyword1">o</span> i<span class="main">)</span> <span class="bound">σ</span><span class="main">,</span>  <span class="main">(</span>hd <span class="keyword1">o</span> j<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>  <span class="main">;-</span>
                          assign_local i_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>hd <span class="keyword1">o</span> i<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
                    <span class="keyword1">else</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                    <span class="keyword1">fi</span><span class="main">)</span>
                <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span>
               <span class="main">(</span>assign_local j_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>hd <span class="keyword1">o</span> j<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">;-</span>
                call<span class="hidden">⇩</span><sub>C</sub> <span class="main">(</span>swap<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>hd <span class="keyword1">o</span> i<span class="main">)</span> <span class="bound">σ</span><span class="main">,</span>  <span class="main">(</span>hd <span class="keyword1">o</span> j<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>  <span class="main">;-</span>
                assign_local result_value_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span>hd <span class="keyword1">o</span> i<span class="main">)</span> <span class="bound">σ</span><span class="main">)</span>
                <span class="comment1">― ‹ the meaning of the return stmt ›</span>
               <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">thm</span></span> partition_core_def

<span class="comment1">(* a block manages the "dynamically" created fresh instances for the local variables of swap *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">partition'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span>  <span class="main">(</span>nat<span class="main">,</span><span class="tfree">'a</span> local_partition'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">partition'</span>  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span><span class="bound">hi</span><span class="main">)</span><span class="main">.</span> block<span class="hidden">⇩</span><sub>C</sub> push_local_partition_state
                                   <span class="main">(</span>partition_core <span class="main">(</span><span class="bound">lo</span><span class="main">,</span><span class="bound">hi</span><span class="main">)</span><span class="main">)</span>
                                   pop_local_partition_state"</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Encoding the toplevel : <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹quicksort›</span></span></span></span> in Clean›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹quicksort›</span></span></span></span> in High-level Notation›</span></span>

<span class="keyword1"><span class="command">rec_function_spec</span></span> <span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="free"><span class="entity"><span class="entity">quicksort</span></span></span></span></span></span></span> <span class="main">(</span><span class="free"><span class="free"><span class="free">lo</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">,</span> <span class="free"><span class="free"><span class="free">hi</span></span></span><span class="main">::</span><span class="quoted">nat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> <span class="quoted"><span class="quoted">unit</span></span>
<span class="keyword2"><span class="keyword">pre</span></span>          <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹lo ≤ hi ∧ hi &lt; length A›</span>"</span></span>
<span class="keyword2"><span class="keyword">post</span></span>         <span class="quoted"><span class="quoted">"<span class="inner_cartouche">‹λres::unit. ∀i∈{lo .. hi}. ∀j∈{lo .. hi}. i ≤ j ⟶ A!i ≤ A!j›</span>"</span></span>
<span class="keyword2"><span class="keyword">variant</span></span>      <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">hi</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">lo</span></span>"</span></span></span>
<span class="keyword2"><span class="keyword">local_vars</span></span>   p <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword2"><span class="keyword">defines</span></span>      <span class="quoted"><span class="quoted"><span class="quoted">" <span class="keyword1"><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹lo &lt; hi›</span></span>
               <span class="keyword1"><span class="keyword1">then</span></span> <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span></span> <span class="main"><span class="main">←</span></span> call<span class="hidden">⇩</span><sub>C</sub> partition <span class="inner_cartouche"><span class="inner_cartouche">‹(lo, hi)›</span></span> <span class="main"><span class="main">;</span></span> assign_local p_update <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">;-</span></span>
                     call<span class="hidden">⇩</span><sub>C</sub> <span class="free"><span class="free">quicksort</span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹(lo, p - 1)›</span></span> <span class="main"><span class="main">;-</span></span>
                     call<span class="hidden">⇩</span><sub>C</sub> <span class="free"><span class="free">quicksort</span></span> <span class="inner_cartouche"><span class="inner_cartouche">‹(lo, p + 1)›</span></span>
               <span class="keyword1"><span class="keyword1">else</span></span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
               <span class="keyword1"><span class="keyword1">fi</span></span>"</span></span></span>


<span class="keyword1"><span class="command">thm</span></span> quicksort_core_def
<span class="keyword1"><span class="command">thm</span></span> quicksort_def
<span class="keyword1"><span class="command">thm</span></span> quicksort_pre_def
<span class="keyword1"><span class="command">thm</span></span> quicksort_post_def




<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Similation of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">▩</span></span><span class="raw_text"><span class="raw_text">‹quicksort›</span></span></span></span> in elementary specification constructs:›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This is the most complex form a Clean function may have: it may be directly
recursive. Two subcases are to be distinguished: either a measure is provided or not.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We start again with our simulation: First, we define the local variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">local_vars_test</span></span>  <span class="entity"><span class="entity">quicksort'</span></span> <span class="quoted"><span class="quoted">"unit"</span></span>
    p  <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹ <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_data_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span><span class="main">;</span> ›</span>

<span class="keyword1"><span class="command">thm</span></span> pop_local_quicksort'_state_def
<span class="keyword1"><span class="command">thm</span></span> push_local_quicksort'_state_def

<span class="comment1">(* this implies the definitions : *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">push_local_quicksort_state'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'a</span> local_quicksort'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">push_local_quicksort_state'</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span>
                 Some<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">⦇</span>local_quicksort'_state.p <span class="main">:=</span> undefined <span class="main">#</span> local_quicksort'_state.p <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">,</span>
                            local_quicksort'_state.result_value <span class="main">:=</span> undefined <span class="main">#</span> local_quicksort'_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⦈</span><span class="main">)</span>"</span></span>




<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pop_local_quicksort_state'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span><span class="tfree">'a</span> local_quicksort'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">pop_local_quicksort_state'</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> Some<span class="main">(</span>hd<span class="main">(</span>local_quicksort'_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                       <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">⦇</span>local_quicksort'_state.p   <span class="main">:=</span> tl<span class="main">(</span>local_quicksort'_state.p <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">,</span>
                         local_quicksort'_state.result_value <span class="main">:=</span>
                                                      tl<span class="main">(</span>local_quicksort'_state.result_value <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We recall the structure of the direct-recursive call in Clean syntax:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display=true]
<span class="raw_text"><span class="raw_text">‹
funct quicksort(lo::int, hi::int) returns unit
     pre  "True"
     post "True"
     local_vars p :: int
     ‹if<span class="hidden">⇩</span><sub>C</sub><span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>E</sub><span class="hidden">⇩</span><sub>A</sub><span class="hidden">⇩</span><sub>N</sub> ‹lo &lt; hi› then
        p := partition(lo, hi) ;-
        quicksort(lo, p - 1) ;-
        quicksort(p + 1, hi)
      else Skip›
›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">quicksort'_pre</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> local_quicksort'_state_scheme <span class="main">⇒</span>   bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">quicksort'_pre</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  True "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">quicksort'_post</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="tfree">'a</span> local_quicksort'_state_scheme <span class="main">⇒</span>  bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">quicksort'_post</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="main">λ</span> <span class="bound">res</span><span class="main">.</span> <span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>  True"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">quicksort'_core</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"   <span class="main">(</span>nat <span class="main">×</span> nat <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'a</span> local_quicksort'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span>
                              <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'a</span> local_quicksort'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">quicksort'_core</span> <span class="free"><span class="bound"><span class="entity">quicksort_rec</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span><span class="main">.</span>
                            <span class="main">(</span><span class="main">(</span><span class="keyword1">if<span class="hidden">⇩</span><sub>C</sub></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">lo</span> <span class="main">&lt;</span> <span class="bound">hi</span> <span class="main">)</span>
                              <span class="keyword1">then</span> <span class="main">(</span><span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span> <span class="main">←</span> call<span class="hidden">⇩</span><sub>C</sub> partition <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span><span class="main">)</span> <span class="main">;</span>
                                    assign_local p_update <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">p<span class="hidden">⇩</span><sub>t</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>p</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">;-</span>
                                    call<span class="hidden">⇩</span><sub>C</sub> <span class="free"><span class="bound"><span class="entity">quicksort_rec</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="main">(</span>hd <span class="keyword1">o</span> p<span class="main">)</span> <span class="bound">σ</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">;-</span>
                                    call<span class="hidden">⇩</span><sub>C</sub> <span class="free"><span class="bound"><span class="entity">quicksort_rec</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>hd <span class="keyword1">o</span> p<span class="main">)</span> <span class="bound">σ</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span><span class="main">)</span>
                              <span class="keyword1">else</span> skip<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub>
                              <span class="keyword1">fi</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="main">(</span>quicksort'_core <span class="free">X</span><span class="main">)</span> <span class="main">(</span><span class="free">lo</span><span class="main">,</span><span class="free">hi</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">quicksort'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> <span class="main">×</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span><span class="main">)</span> set <span class="main">⇒</span>
                            <span class="main">(</span>nat <span class="main">×</span> nat <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span><span class="tfree">'a</span> local_quicksort'_state_scheme<span class="main">)</span> MON<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>   <span class="quoted"><span class="quoted">"<span class="free">quicksort'</span> <span class="free"><span class="bound"><span class="entity">order</span></span></span> <span class="main">≡</span> wfrec <span class="free"><span class="bound"><span class="entity">order</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">X</span><span class="main">.</span> <span class="main">λ</span><span class="main">(</span><span class="bound">lo</span><span class="main">,</span> <span class="bound">hi</span><span class="main">)</span><span class="main">.</span> block<span class="hidden">⇩</span><sub>C</sub> push_local_quicksort'_state
                                                                 <span class="main">(</span>quicksort'_core <span class="bound">X</span> <span class="main">(</span><span class="bound">lo</span><span class="main">,</span><span class="bound">hi</span><span class="main">)</span><span class="main">)</span>
                                                                 pop_local_quicksort'_state<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Setup for Deductive Verification›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The coupling between the pre- and the post-condition state is done by the
     free variable (serving as a kind of ghost-variable) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. This coupling
     can also be used to express framing conditions; i.e. parts of the state which are
     independent and/or not affected by the computations to be verified. ›</span></span>
<span class="keyword1" id="Quicksort_concept-quicksort_correct"><span class="command">lemma</span></span> quicksort_correct <span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span>   <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> quicksort_pre <span class="main">(</span><span class="free">lo</span><span class="main">,</span> <span class="free">hi</span><span class="main">)</span><span class="main">(</span><span class="bound">σ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">σ</span> <span class="main">=</span> <span class="free">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span> <span class="main">⦄</span>
     quicksort <span class="main">(</span><span class="free">lo</span><span class="main">,</span> <span class="free">hi</span><span class="main">)</span>
   <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span>exec_stop <span class="bound">σ</span> <span class="main">∧</span> quicksort_post<span class="main">(</span><span class="free">lo</span><span class="main">,</span> <span class="free">hi</span><span class="main">)</span><span class="main">(</span><span class="free">σ<span class="hidden">⇩</span><sub>p</sub><span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>e</sub></span><span class="main">)</span><span class="main">(</span><span class="bound">σ</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span><span class="main">)</span> <span class="main">⦄</span>"</span></span>
   <span class="keyword1"><span class="command">oops</span></span>



<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="SquareRoot_concept">
<div class="head">
<h1>Theory SquareRoot_concept</h1>
</div>
<pre class="source"><span class="comment1">(******************************************************************************
 * Clean
 *
 * Copyright (c) 2018-2019 Université Paris-Saclay, Univ. Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)</span>

<span class="comment1">(*
 * SquareRoot_concept --- Example of monadic symbolic execution for a WHILE program.
 * Burkhart Wolff and Chantal Keller, LRI, Univ. Paris-Sud, France
 *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹ The Squareroot Example for Symbolic Execution ›</span></span>

<span class="keyword1"><span class="command">theory</span></span> SquareRoot_concept
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Test_Clean.html">Test_Clean</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The Conceptual Algorithm in Clean Notation›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ In high-level notation, the algorithm we are investigating looks like this:

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cartouche</span></span> [display=true]
<span class="raw_text"><span class="raw_text">‹‹
function_spec sqrt (a::int) returns int
pre          "‹0 ≤ a›"
post         "‹λres::int.  (res + 1)<span class="hidden">⇧</span><sup>2</sup> &gt; a ∧ a ≥ (res)<span class="hidden">⇧</span><sup>2</sup>›"
defines      " (‹tm := 1› ;-
               ‹sqsum := 1› ;-
               ‹i := 0› ;-
               (while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub> ‹sqsum &lt;= a› do
                  ‹i := i+1› ;-
                  ‹tm := tm + 2› ;-
                  ‹sqsum := tm + sqsum›
               od) ;-
               return<span class="hidden">⇩</span><sub>C</sub> result_value_update ‹i›
               )"
››</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Definition of the Global State ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The state is just a record; and the global variables correspond to fields in this
     record. This corresponds to typed, structured, non-aliasing states.
     Note that the types in the state can be arbitrary HOL-types - want to have
     sets of functions in a ghost-field ? No problem !
    ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ The state of the square-root program looks like this : ›</span></span>

<span class="keyword1"><span class="command">typ</span></span> <span class="quoted"><span class="quoted">"Clean.control_state"</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">u</span><span class="main">,</span><span class="entity">v</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">unit</span><span class="antiquote">}</span></span>
›</span>

<span class="comment1">(* could also be local variable, we flipped a coin and it became this way *)</span>
<span class="keyword1"><span class="command">global_vars</span></span> state
   tm    <span class="main">::</span> <span class="quoted">int</span>
   i     <span class="main">::</span> <span class="quoted">int</span>
   sqsum <span class="main">::</span> <span class="quoted">int</span>


<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">StateMgt_core.get_state_type_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> Type<span class="main">(</span><span class="entity">u</span><span class="main">,</span><span class="entity">v</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">unit</span><span class="antiquote">}</span></span>
›</span>


<span class="comment1">(* should be automatic *)</span>
<span class="keyword1" id="SquareRoot_concept-tm_independent"><span class="command">lemma</span></span> tm_independent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> tm_update"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="SquareRoot_concept-i_independent"><span class="command">lemma</span></span> i_independent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> i_update"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="SquareRoot_concept-sqsum_independent"><span class="command">lemma</span></span> sqsum_independent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> sqsum_update"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> control_independence_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>





<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Setting for Symbolic Execution ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Some lemmas to reason about memory›</span></span>

<span class="keyword1" id="SquareRoot_concept-tm_simp"><span class="command">lemma</span></span> tm_simp <span class="main">:</span> <span class="quoted"><span class="quoted">"tm <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>tm <span class="main">:=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simp_trace</span><span class="main">]</span><span class="main">]</span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="comment1">(* from trace:
   [1]Procedure "record" produced rewrite rule:
   tm (?r⦇tm := ?k⦈) ≡ ?k

   Unfortunately, this lemma is not exported ... It looks as if it is computed on the fly ...
   This could explain why this is slow for our purposes ...
*)</span>
<span class="keyword1" id="SquareRoot_concept-tm_simp1"><span class="command">lemma</span></span> tm_simp1 <span class="main">:</span> <span class="quoted"><span class="quoted">"tm <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>sqsum <span class="main">:=</span> <span class="free">s</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> tm <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-tm_simp2"><span class="command">lemma</span></span> tm_simp2 <span class="main">:</span> <span class="quoted"><span class="quoted">"tm <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>i <span class="main">:=</span> <span class="free">s</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> tm <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-sqsum_simp"><span class="command">lemma</span></span> sqsum_simp <span class="main">:</span> <span class="quoted"><span class="quoted">"sqsum <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>sqsum <span class="main">:=</span> <span class="free">s</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-sqsum_simp1"><span class="command">lemma</span></span> sqsum_simp1 <span class="main">:</span> <span class="quoted"><span class="quoted">"sqsum <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>tm <span class="main">:=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> sqsum <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-sqsum_simp2"><span class="command">lemma</span></span> sqsum_simp2 <span class="main">:</span> <span class="quoted"><span class="quoted">"sqsum <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>i <span class="main">:=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> sqsum <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-i_simp"><span class="command">lemma</span></span> i_simp <span class="main">:</span> <span class="quoted"><span class="quoted">"i <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>i <span class="main">:=</span> <span class="free">i'</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">i'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-i_simp1"><span class="command">lemma</span></span> i_simp1 <span class="main">:</span> <span class="quoted"><span class="quoted">"i <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>tm <span class="main">:=</span> <span class="free">i'</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> i <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="SquareRoot_concept-i_simp2"><span class="command">lemma</span></span> i_simp2 <span class="main">:</span> <span class="quoted"><span class="quoted">"i <span class="main">(</span><span class="free">σ</span><span class="main">⦇</span>sqsum <span class="main">:=</span> <span class="free">i'</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> i <span class="free">σ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> memory_theory <span class="main">=</span>
  tm_simp tm_simp1 tm_simp2
  sqsum_simp sqsum_simp1 sqsum_simp2
  i_simp i_simp1 i_simp2


<span class="keyword1"><span class="command">declare</span></span> memory_theory <span class="main">[</span><span class="operator">memory_theory</span><span class="main">]</span>


<span class="keyword1" id="SquareRoot_concept-non_exec_assign_globalD'"><span class="command">lemma</span></span> non_exec_assign_globalD'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">♯</span> <span class="free">upd</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">⊨</span> assign_global <span class="free">upd</span> <span class="free">rhs</span> <span class="main">;-</span> <span class="free">M</span> <span class="main">⟹</span><span class="main">¬</span> exec_stop <span class="free">σ</span> <span class="main">⟹</span>  <span class="free">upd</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">rhs</span> <span class="free">σ</span><span class="main">)</span> <span class="free">σ</span> <span class="main">⊨</span> <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> non_exec_assign_global'<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms exec_stop_vs_control_independence <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> non_exec_assign_globalD'_tm <span class="main">=</span> non_exec_assign_globalD'<span class="main">[</span><span class="operator">OF</span> tm_independent<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> non_exec_assign_globalD'_i <span class="main">=</span> non_exec_assign_globalD'<span class="main">[</span><span class="operator">OF</span> i_independent<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> non_exec_assign_globalD'_sqsum <span class="main">=</span> non_exec_assign_globalD'<span class="main">[</span><span class="operator">OF</span> sqsum_independent<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ Now we run a symbolic execution. We run match-tactics (rather than the Isabelle simplifier
  which would do the trick as well) in order to demonstrate a symbolic execution in Isabelle. ›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ A Symbolic Execution Simulation ›</span></span>


<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> non_exec_stop<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exec_stop <span class="free">σ<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>    pos <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>int<span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>    annotated_program<span class="main">:</span>
          <span class="quoted"><span class="quoted">"<span class="free">σ<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> <span class="inner_cartouche">‹tm := 1›</span> <span class="main">;-</span>
                <span class="inner_cartouche">‹sqsum := 1›</span> <span class="main">;-</span>
                <span class="inner_cartouche">‹i := 0›</span> <span class="main">;-</span>
                <span class="main">(</span><span class="keyword1">while<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="inner_cartouche">‹sqsum &lt;= a›</span> <span class="keyword1">do</span>
                   <span class="inner_cartouche">‹i := i+1›</span> <span class="main">;-</span>
                   <span class="inner_cartouche">‹tm := tm + 2›</span> <span class="main">;-</span>
                   <span class="inner_cartouche">‹sqsum := tm + sqsum›</span>
                <span class="keyword1">od</span><span class="main">)</span> <span class="main">;-</span>
                <span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span><span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="bound">σ</span><span class="main">=</span><span class="free">σ<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span>"</span></span>

       <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ<span class="hidden">⇩</span><sub>R</sub></span> <span class="main">⊨</span><span class="keyword1">assert<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>E</sub></span> <span class="inner_cartouche">‹i<span class="hidden">⇧</span><sup>2</sup>  ≤ a ∧ a &lt; (i + 1)<span class="hidden">⇧</span><sup>2</sup>›</span> "</span></span>


  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">insert</span> annotated_program<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_tm\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_sqsum\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_i\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"exec_whileD\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"ematch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"if_SE_execE''\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> memory_theory MonadSE.bind_assoc'<span class="main">)</span>

   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_i\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_tm\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_sqsum\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>

   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"exec_whileD\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"ematch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"if_SE_execE''\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> memory_theory MonadSE.bind_assoc'<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_i\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_tm\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_sqsum\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"exec_whileD\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"ematch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"if_SE_execE''\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> memory_theory MonadSE.bind_assoc'<span class="main">)</span>


    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_i\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_tm\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">"dmatch_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> \"non_exec_assign_globalD'_sqsum\"<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>"</span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Here are all abstract test-cases explicit. Each subgoal correstponds to
       a path taken through the loop.›</span></span>


  <span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹push away the test-hyp: postcond is true for programs with more than
    three loop traversals (criterion: all-paths(k). This reveals explicitly
    the three test-cases for  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">k</span></span><span class="main"><span class="main">&lt;</span></span><span class="numeral"><span class="numeral">3</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. ›</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> 1


<span class="comment1">(*
txt‹Instead of testing, we @{emph ‹prove›} that the test cases satisfy the
    post-condition for all @{term "k&lt;3"} loop traversals and @{emph ‹all›}
    positive inputs @{term "a "}.›
   apply(auto  simp: assert_simp)
 *)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹TODO: re-establish  automatic test-coverage tactics of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> "DBLP:conf/tap/Keller18"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>